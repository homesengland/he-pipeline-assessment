import { r as registerInstance, a as createEvent, h, j as Host, e as getElement } from './index-CL6j2ec2.js';
import { a as requireDagre, v as v4 } from './index-CElHzHu_.js';
import { f as getInboundConnections, i as getOutboundConnections, r as removeActivity, j as findActivity, k as addConnection } from './utils-C0M_5Llz.js';
import { a as WorkflowPersistenceBehavior, A as ActivityTraits } from './index-D7wXd6HU.js';
import './index-fZDMH_YE.js';
import { a as state } from './store-B_H_ZDGs.js';
import { A as ActivityIcon } from './activity-icon-nWEHGFat.js';
import { W as WorkflowDesignerMode, L as LayoutDirection } from './models-0-8LsKgc.js';
import { g as getDefaultExportFromCjs, a as getAugmentedNamespace } from './_commonjsHelpers-Cf5sKic0.js';
import { e as eventBus } from './event-bus-axQqcjdg.js';
import { E as EventTypes } from './events-CpKc8CLe.js';
import './collection-B4sYCr2r.js';
import './_baseSet-SXJectIy.js';
import './elsa-client-q6ob5JPZ.js';
import './fetch-client-1OcjQcrw.js';
import './cronstrue-BvVNjwUa.js';

var jquery$1 = {exports: {}};

/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
var jquery = jquery$1.exports;

var hasRequiredJquery;

function requireJquery () {
	if (hasRequiredJquery) return jquery$1.exports;
	hasRequiredJquery = 1;
	(function (module) {
		( function( global, factory ) {

			"use strict";

			if ( 'object' === "object" && 'object' === "object" ) {

				// For CommonJS and CommonJS-like environments where a proper `window`
				// is present, execute the factory and get jQuery.
				// For environments that do not have a `window` with a `document`
				// (such as Node.js), expose a factory as module.exports.
				// This accentuates the need for the creation of a real `window`.
				// e.g. var jQuery = require("jquery")(window);
				// See ticket trac-14549 for more info.
				module.exports = global.document ?
					factory( global, true ) :
					function( w ) {
						if ( !w.document ) {
							throw new Error( "jQuery requires a window with a document" );
						}
						return factory( w );
					};
			} else {
				factory( global );
			}

		// Pass this if window is not defined yet
		} )( typeof window !== "undefined" ? window : jquery, function( window, noGlobal ) {

		// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
		// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
		// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
		// enough that all such attempts are guarded in a try block.
		"use strict";

		var arr = [];

		var getProto = Object.getPrototypeOf;

		var slice = arr.slice;

		var flat = arr.flat ? function( array ) {
			return arr.flat.call( array );
		} : function( array ) {
			return arr.concat.apply( [], array );
		};


		var push = arr.push;

		var indexOf = arr.indexOf;

		var class2type = {};

		var toString = class2type.toString;

		var hasOwn = class2type.hasOwnProperty;

		var fnToString = hasOwn.toString;

		var ObjectFunctionString = fnToString.call( Object );

		var support = {};

		var isFunction = function isFunction( obj ) {

				// Support: Chrome <=57, Firefox <=52
				// In some browsers, typeof returns "function" for HTML <object> elements
				// (i.e., `typeof document.createElement( "object" ) === "function"`).
				// We don't want to classify *any* DOM node as a function.
				// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
				// Plus for old WebKit, typeof returns "function" for HTML collections
				// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
				return typeof obj === "function" && typeof obj.nodeType !== "number" &&
					typeof obj.item !== "function";
			};


		var isWindow = function isWindow( obj ) {
				return obj != null && obj === obj.window;
			};


		var document = window.document;



			var preservedScriptAttributes = {
				type: true,
				src: true,
				nonce: true,
				noModule: true
			};

			function DOMEval( code, node, doc ) {
				doc = doc || document;

				var i, val,
					script = doc.createElement( "script" );

				script.text = code;
				if ( node ) {
					for ( i in preservedScriptAttributes ) {

						// Support: Firefox 64+, Edge 18+
						// Some browsers don't support the "nonce" property on scripts.
						// On the other hand, just using `getAttribute` is not enough as
						// the `nonce` attribute is reset to an empty string whenever it
						// becomes browsing-context connected.
						// See https://github.com/whatwg/html/issues/2369
						// See https://html.spec.whatwg.org/#nonce-attributes
						// The `node.getAttribute` check was added for the sake of
						// `jQuery.globalEval` so that it can fake a nonce-containing node
						// via an object.
						val = node[ i ] || node.getAttribute && node.getAttribute( i );
						if ( val ) {
							script.setAttribute( i, val );
						}
					}
				}
				doc.head.appendChild( script ).parentNode.removeChild( script );
			}


		function toType( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		}
		/* global Symbol */
		// Defining this global in .eslintrc.json would create a danger of using the global
		// unguarded in another place, it seems safer to define global only for this module



		var version = "3.7.1",

			rhtmlSuffix = /HTML$/i,

			// Define a local copy of jQuery
			jQuery = function( selector, context ) {

				// The jQuery object is actually just the init constructor 'enhanced'
				// Need init if jQuery is called (just allow error to be thrown if not included)
				return new jQuery.fn.init( selector, context );
			};

		jQuery.fn = jQuery.prototype = {

			// The current version of jQuery being used
			jquery: version,

			constructor: jQuery,

			// The default length of a jQuery object is 0
			length: 0,

			toArray: function() {
				return slice.call( this );
			},

			// Get the Nth element in the matched element set OR
			// Get the whole matched element set as a clean array
			get: function( num ) {

				// Return all the elements in a clean array
				if ( num == null ) {
					return slice.call( this );
				}

				// Return just the one element from the set
				return num < 0 ? this[ num + this.length ] : this[ num ];
			},

			// Take an array of elements and push it onto the stack
			// (returning the new matched element set)
			pushStack: function( elems ) {

				// Build a new jQuery matched element set
				var ret = jQuery.merge( this.constructor(), elems );

				// Add the old object onto the stack (as a reference)
				ret.prevObject = this;

				// Return the newly-formed element set
				return ret;
			},

			// Execute a callback for every element in the matched set.
			each: function( callback ) {
				return jQuery.each( this, callback );
			},

			map: function( callback ) {
				return this.pushStack( jQuery.map( this, function( elem, i ) {
					return callback.call( elem, i, elem );
				} ) );
			},

			slice: function() {
				return this.pushStack( slice.apply( this, arguments ) );
			},

			first: function() {
				return this.eq( 0 );
			},

			last: function() {
				return this.eq( -1 );
			},

			even: function() {
				return this.pushStack( jQuery.grep( this, function( _elem, i ) {
					return ( i + 1 ) % 2;
				} ) );
			},

			odd: function() {
				return this.pushStack( jQuery.grep( this, function( _elem, i ) {
					return i % 2;
				} ) );
			},

			eq: function( i ) {
				var len = this.length,
					j = +i + ( i < 0 ? len : 0 );
				return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
			},

			end: function() {
				return this.prevObject || this.constructor();
			},

			// For internal use only.
			// Behaves like an Array's method, not like a jQuery method.
			push: push,
			sort: arr.sort,
			splice: arr.splice
		};

		jQuery.extend = jQuery.fn.extend = function() {
			var options, name, src, copy, copyIsArray, clone,
				target = arguments[ 0 ] || {},
				i = 1,
				length = arguments.length,
				deep = false;

			// Handle a deep copy situation
			if ( typeof target === "boolean" ) {
				deep = target;

				// Skip the boolean and the target
				target = arguments[ i ] || {};
				i++;
			}

			// Handle case when target is a string or something (possible in deep copy)
			if ( typeof target !== "object" && !isFunction( target ) ) {
				target = {};
			}

			// Extend jQuery itself if only one argument is passed
			if ( i === length ) {
				target = this;
				i--;
			}

			for ( ; i < length; i++ ) {

				// Only deal with non-null/undefined values
				if ( ( options = arguments[ i ] ) != null ) {

					// Extend the base object
					for ( name in options ) {
						copy = options[ name ];

						// Prevent Object.prototype pollution
						// Prevent never-ending loop
						if ( name === "__proto__" || target === copy ) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
							( copyIsArray = Array.isArray( copy ) ) ) ) {
							src = target[ name ];

							// Ensure proper type for the source value
							if ( copyIsArray && !Array.isArray( src ) ) {
								clone = [];
							} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
								clone = {};
							} else {
								clone = src;
							}
							copyIsArray = false;

							// Never move original objects, clone them
							target[ name ] = jQuery.extend( deep, clone, copy );

						// Don't bring in undefined values
						} else if ( copy !== undefined ) {
							target[ name ] = copy;
						}
					}
				}
			}

			// Return the modified object
			return target;
		};

		jQuery.extend( {

			// Unique for each copy of jQuery on the page
			expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

			// Assume jQuery is ready without the ready module
			isReady: true,

			error: function( msg ) {
				throw new Error( msg );
			},

			noop: function() {},

			isPlainObject: function( obj ) {
				var proto, Ctor;

				// Detect obvious negatives
				// Use toString instead of jQuery.type to catch host objects
				if ( !obj || toString.call( obj ) !== "[object Object]" ) {
					return false;
				}

				proto = getProto( obj );

				// Objects with no prototype (e.g., `Object.create( null )`) are plain
				if ( !proto ) {
					return true;
				}

				// Objects with prototype are plain iff they were constructed by a global Object function
				Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
				return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
			},

			isEmptyObject: function( obj ) {
				var name;

				for ( name in obj ) {
					return false;
				}
				return true;
			},

			// Evaluates a script in a provided context; falls back to the global one
			// if not specified.
			globalEval: function( code, options, doc ) {
				DOMEval( code, { nonce: options && options.nonce }, doc );
			},

			each: function( obj, callback ) {
				var length, i = 0;

				if ( isArrayLike( obj ) ) {
					length = obj.length;
					for ( ; i < length; i++ ) {
						if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
							break;
						}
					}
				}

				return obj;
			},


			// Retrieve the text value of an array of DOM nodes
			text: function( elem ) {
				var node,
					ret = "",
					i = 0,
					nodeType = elem.nodeType;

				if ( !nodeType ) {

					// If no nodeType, this is expected to be an array
					while ( ( node = elem[ i++ ] ) ) {

						// Do not traverse comment nodes
						ret += jQuery.text( node );
					}
				}
				if ( nodeType === 1 || nodeType === 11 ) {
					return elem.textContent;
				}
				if ( nodeType === 9 ) {
					return elem.documentElement.textContent;
				}
				if ( nodeType === 3 || nodeType === 4 ) {
					return elem.nodeValue;
				}

				// Do not include comment or processing instruction nodes

				return ret;
			},

			// results is for internal usage only
			makeArray: function( arr, results ) {
				var ret = results || [];

				if ( arr != null ) {
					if ( isArrayLike( Object( arr ) ) ) {
						jQuery.merge( ret,
							typeof arr === "string" ?
								[ arr ] : arr
						);
					} else {
						push.call( ret, arr );
					}
				}

				return ret;
			},

			inArray: function( elem, arr, i ) {
				return arr == null ? -1 : indexOf.call( arr, elem, i );
			},

			isXMLDoc: function( elem ) {
				var namespace = elem && elem.namespaceURI,
					docElem = elem && ( elem.ownerDocument || elem ).documentElement;

				// Assume HTML when documentElement doesn't yet exist, such as inside
				// document fragments.
				return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
			},

			// Support: Android <=4.0 only, PhantomJS 1 only
			// push.apply(_, arraylike) throws on ancient WebKit
			merge: function( first, second ) {
				var len = +second.length,
					j = 0,
					i = first.length;

				for ( ; j < len; j++ ) {
					first[ i++ ] = second[ j ];
				}

				first.length = i;

				return first;
			},

			grep: function( elems, callback, invert ) {
				var callbackInverse,
					matches = [],
					i = 0,
					length = elems.length,
					callbackExpect = !invert;

				// Go through the array, only saving the items
				// that pass the validator function
				for ( ; i < length; i++ ) {
					callbackInverse = !callback( elems[ i ], i );
					if ( callbackInverse !== callbackExpect ) {
						matches.push( elems[ i ] );
					}
				}

				return matches;
			},

			// arg is for internal usage only
			map: function( elems, callback, arg ) {
				var length, value,
					i = 0,
					ret = [];

				// Go through the array, translating each of the items to their new values
				if ( isArrayLike( elems ) ) {
					length = elems.length;
					for ( ; i < length; i++ ) {
						value = callback( elems[ i ], i, arg );

						if ( value != null ) {
							ret.push( value );
						}
					}

				// Go through every key on the object,
				} else {
					for ( i in elems ) {
						value = callback( elems[ i ], i, arg );

						if ( value != null ) {
							ret.push( value );
						}
					}
				}

				// Flatten any nested arrays
				return flat( ret );
			},

			// A global GUID counter for objects
			guid: 1,

			// jQuery.support is not used in Core but other projects attach their
			// properties to it so it needs to exist.
			support: support
		} );

		if ( typeof Symbol === "function" ) {
			jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
		}

		// Populate the class2type map
		jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
			function( _i, name ) {
				class2type[ "[object " + name + "]" ] = name.toLowerCase();
			} );

		function isArrayLike( obj ) {

			// Support: real iOS 8.2 only (not reproducible in simulator)
			// `in` check used to prevent JIT error (gh-2145)
			// hasOwn isn't used here due to false negatives
			// regarding Nodelist length in IE
			var length = !!obj && "length" in obj && obj.length,
				type = toType( obj );

			if ( isFunction( obj ) || isWindow( obj ) ) {
				return false;
			}

			return type === "array" || length === 0 ||
				typeof length === "number" && length > 0 && ( length - 1 ) in obj;
		}


		function nodeName( elem, name ) {

			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

		}
		var pop = arr.pop;


		var sort = arr.sort;


		var splice = arr.splice;


		var whitespace = "[\\x20\\t\\r\\n\\f]";


		var rtrimCSS = new RegExp(
			"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
			"g"
		);




		// Note: an element does not contain itself
		jQuery.contains = function( a, b ) {
			var bup = b && b.parentNode;

			return a === bup || !!( bup && bup.nodeType === 1 && (

				// Support: IE 9 - 11+
				// IE doesn't have `contains` on SVG.
				a.contains ?
					a.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		};




		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

		function fcssescape( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		}

		jQuery.escapeSelector = function( sel ) {
			return ( sel + "" ).replace( rcssescape, fcssescape );
		};




		var preferredDoc = document,
			pushNative = push;

		( function() {

		var i,
			Expr,
			outermostContext,
			sortInput,
			hasDuplicate,
			push = pushNative,

			// Local document vars
			document,
			documentElement,
			documentIsHTML,
			rbuggyQSA,
			matches,

			// Instance-specific data
			expando = jQuery.expando,
			dirruns = 0,
			done = 0,
			classCache = createCache(),
			tokenCache = createCache(),
			compilerCache = createCache(),
			nonnativeSelectorCache = createCache(),
			sortOrder = function( a, b ) {
				if ( a === b ) {
					hasDuplicate = true;
				}
				return 0;
			},

			booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
				"loop|multiple|open|readonly|required|scoped",

			// Regular expressions

			// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
			identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
				"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

			// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
			attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

				// Operator (capture 2)
				"*([*^$|!~]?=)" + whitespace +

				// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
				"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
				whitespace + "*\\]",

			pseudos = ":(" + identifier + ")(?:\\((" +

				// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
				// 1. quoted (capture 3; capture 4 or capture 5)
				"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

				// 2. simple (capture 6)
				"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

				// 3. anything else (capture 2)
				".*" +
				")\\)|)",

			// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
			rwhitespace = new RegExp( whitespace + "+", "g" ),

			rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
			rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
				whitespace + "*" ),
			rdescend = new RegExp( whitespace + "|>" ),

			rpseudo = new RegExp( pseudos ),
			ridentifier = new RegExp( "^" + identifier + "$" ),

			matchExpr = {
				ID: new RegExp( "^#(" + identifier + ")" ),
				CLASS: new RegExp( "^\\.(" + identifier + ")" ),
				TAG: new RegExp( "^(" + identifier + "|[*])" ),
				ATTR: new RegExp( "^" + attributes ),
				PSEUDO: new RegExp( "^" + pseudos ),
				CHILD: new RegExp(
					"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
						whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
						whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
				bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

				// For use in libraries implementing .is()
				// We use this for POS matching in `select`
				needsContext: new RegExp( "^" + whitespace +
					"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
					"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
			},

			rinputs = /^(?:input|select|textarea|button)$/i,
			rheader = /^h\d$/i,

			// Easily-parseable/retrievable ID or TAG or CLASS selectors
			rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

			rsibling = /[+~]/,

			// CSS escapes
			// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
			runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
				"?|\\\\([^\\r\\n\\f])", "g" ),
			funescape = function( escape, nonHex ) {
				var high = "0x" + escape.slice( 1 ) - 0x10000;

				if ( nonHex ) {

					// Strip the backslash prefix from a non-hex escape sequence
					return nonHex;
				}

				// Replace a hexadecimal escape sequence with the encoded Unicode code point
				// Support: IE <=11+
				// For values outside the Basic Multilingual Plane (BMP), manually construct a
				// surrogate pair
				return high < 0 ?
					String.fromCharCode( high + 0x10000 ) :
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
			},

			// Used for iframes; see `setDocument`.
			// Support: IE 9 - 11+, Edge 12 - 18+
			// Removing the function wrapper causes a "Permission Denied"
			// error in IE/Edge.
			unloadHandler = function() {
				setDocument();
			},

			inDisabledFieldset = addCombinator(
				function( elem ) {
					return elem.disabled === true && nodeName( elem, "fieldset" );
				},
				{ dir: "parentNode", next: "legend" }
			);

		// Support: IE <=9 only
		// Accessing document.activeElement can throw unexpectedly
		// https://bugs.jquery.com/ticket/13393
		function safeActiveElement() {
			try {
				return document.activeElement;
			} catch ( err ) { }
		}

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(
				( arr = slice.call( preferredDoc.childNodes ) ),
				preferredDoc.childNodes
			);

			// Support: Android <=4.0
			// Detect silently failing push.apply
			// eslint-disable-next-line no-unused-expressions
			arr[ preferredDoc.childNodes.length ].nodeType;
		} catch ( e ) {
			push = {
				apply: function( target, els ) {
					pushNative.apply( target, slice.call( els ) );
				},
				call: function( target ) {
					pushNative.apply( target, slice.call( arguments, 1 ) );
				}
			};
		}

		function find( selector, context, results, seed ) {
			var m, i, elem, nid, match, groups, newSelector,
				newContext = context && context.ownerDocument,

				// nodeType defaults to 9, since context defaults to document
				nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if ( typeof selector !== "string" || !selector ||
				nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if ( !seed ) {
				setDocument( context );
				context = context || document;

				if ( documentIsHTML ) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

						// ID selector
						if ( ( m = match[ 1 ] ) ) {

							// Document context
							if ( nodeType === 9 ) {
								if ( ( elem = context.getElementById( m ) ) ) {

									// Support: IE 9 only
									// getElementById can match elements by name instead of ID
									if ( elem.id === m ) {
										push.call( results, elem );
										return results;
									}
								} else {
									return results;
								}

							// Element context
							} else {

								// Support: IE 9 only
								// getElementById can match elements by name instead of ID
								if ( newContext && ( elem = newContext.getElementById( m ) ) &&
									find.contains( context, elem ) &&
									elem.id === m ) {

									push.call( results, elem );
									return results;
								}
							}

						// Type selector
						} else if ( match[ 2 ] ) {
							push.apply( results, context.getElementsByTagName( selector ) );
							return results;

						// Class selector
						} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
							push.apply( results, context.getElementsByClassName( m ) );
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if ( !nonnativeSelectorCache[ selector + " " ] &&
						( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

						newSelector = selector;
						newContext = context;

						// qSA considers elements outside a scoping root when evaluating child or
						// descendant combinators, which is not what we want.
						// In such cases, we work around the behavior by prefixing every selector in the
						// list with an ID selector referencing the scope context.
						// The technique has to be used as well when a leading combinator is used
						// as such selectors are not recognized by querySelectorAll.
						// Thanks to Andrew Dupont for this technique.
						if ( nodeType === 1 &&
							( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

							// Expand context for sibling selectors
							newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
								context;

							// We can use :scope instead of the ID hack if the browser
							// supports it & if we're not changing the context.
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when
							// strict-comparing two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq
							if ( newContext != context || !support.scope ) {

								// Capture the context ID, setting it first if necessary
								if ( ( nid = context.getAttribute( "id" ) ) ) {
									nid = jQuery.escapeSelector( nid );
								} else {
									context.setAttribute( "id", ( nid = expando ) );
								}
							}

							// Prefix every selector in the list
							groups = tokenize( selector );
							i = groups.length;
							while ( i-- ) {
								groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
									toSelector( groups[ i ] );
							}
							newSelector = groups.join( "," );
						}

						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
							nonnativeSelectorCache( selector, true );
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}

			// All others
			return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
		}

		/**
		 * Create key-value caches of limited size
		 * @returns {function(string, object)} Returns the Object data after storing it on itself with
		 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
		 *	deleting the oldest entry
		 */
		function createCache() {
			var keys = [];

			function cache( key, value ) {

				// Use (key + " ") to avoid collision with native prototype properties
				// (see https://github.com/jquery/sizzle/issues/157)
				if ( keys.push( key + " " ) > Expr.cacheLength ) {

					// Only keep the most recent entries
					delete cache[ keys.shift() ];
				}
				return ( cache[ key + " " ] = value );
			}
			return cache;
		}

		/**
		 * Mark a function for special use by jQuery selector module
		 * @param {Function} fn The function to mark
		 */
		function markFunction( fn ) {
			fn[ expando ] = true;
			return fn;
		}

		/**
		 * Support testing using an element
		 * @param {Function} fn Passed the created element and returns a boolean result
		 */
		function assert( fn ) {
			var el = document.createElement( "fieldset" );

			try {
				return !!fn( el );
			} catch ( e ) {
				return false;
			} finally {

				// Remove from its parent by default
				if ( el.parentNode ) {
					el.parentNode.removeChild( el );
				}

				// release memory in IE
				el = null;
			}
		}

		/**
		 * Returns a function to use in pseudos for input types
		 * @param {String} type
		 */
		function createInputPseudo( type ) {
			return function( elem ) {
				return nodeName( elem, "input" ) && elem.type === type;
			};
		}

		/**
		 * Returns a function to use in pseudos for buttons
		 * @param {String} type
		 */
		function createButtonPseudo( type ) {
			return function( elem ) {
				return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
					elem.type === type;
			};
		}

		/**
		 * Returns a function to use in pseudos for :enabled/:disabled
		 * @param {Boolean} disabled true for :disabled; false for :enabled
		 */
		function createDisabledPseudo( disabled ) {

			// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
			return function( elem ) {

				// Only certain elements can match :enabled or :disabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
				if ( "form" in elem ) {

					// Check for inherited disabledness on relevant non-disabled elements:
					// * listed form-associated elements in a disabled fieldset
					//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
					// * option elements in a disabled optgroup
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
					// All such elements have a "form" property.
					if ( elem.parentNode && elem.disabled === false ) {

						// Option elements defer to a parent optgroup if present
						if ( "label" in elem ) {
							if ( "label" in elem.parentNode ) {
								return elem.parentNode.disabled === disabled;
							} else {
								return elem.disabled === disabled;
							}
						}

						// Support: IE 6 - 11+
						// Use the isDisabled shortcut property to check for disabled fieldset ancestors
						return elem.isDisabled === disabled ||

							// Where there is no isDisabled, check manually
							elem.isDisabled !== !disabled &&
								inDisabledFieldset( elem ) === disabled;
					}

					return elem.disabled === disabled;

				// Try to winnow out elements that can't be disabled before trusting the disabled property.
				// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
				// even exist on them, let alone have a boolean value.
				} else if ( "label" in elem ) {
					return elem.disabled === disabled;
				}

				// Remaining elements are neither :enabled nor :disabled
				return false;
			};
		}

		/**
		 * Returns a function to use in pseudos for positionals
		 * @param {Function} fn
		 */
		function createPositionalPseudo( fn ) {
			return markFunction( function( argument ) {
				argument = +argument;
				return markFunction( function( seed, matches ) {
					var j,
						matchIndexes = fn( [], seed.length, argument ),
						i = matchIndexes.length;

					// Match elements found at the specified indexes
					while ( i-- ) {
						if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
							seed[ j ] = !( matches[ j ] = seed[ j ] );
						}
					}
				} );
			} );
		}

		/**
		 * Checks a node for validity as a jQuery selector context
		 * @param {Element|Object=} context
		 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
		 */
		function testContext( context ) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		/**
		 * Sets document-related variables once based on the current document
		 * @param {Element|Object} [node] An element or document object to use to set the document
		 * @returns {Object} Returns the current document
		 */
		function setDocument( node ) {
			var subWindow,
				doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
				return document;
			}

			// Update global variables
			document = doc;
			documentElement = document.documentElement;
			documentIsHTML = !jQuery.isXMLDoc( document );

			// Support: iOS 7 only, IE 9 - 11+
			// Older browsers didn't support unprefixed `matches`.
			matches = documentElement.matches ||
				documentElement.webkitMatchesSelector ||
				documentElement.msMatchesSelector;

			// Support: IE 9 - 11+, Edge 12 - 18+
			// Accessing iframe documents after unload throws "permission denied" errors
			// (see trac-13936).
			// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
			// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
			if ( documentElement.msMatchesSelector &&

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				preferredDoc != document &&
				( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

				// Support: IE 9 - 11+, Edge 12 - 18+
				subWindow.addEventListener( "unload", unloadHandler );
			}

			// Support: IE <10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programmatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert( function( el ) {
				documentElement.appendChild( el ).id = jQuery.expando;
				return !document.getElementsByName ||
					!document.getElementsByName( jQuery.expando ).length;
			} );

			// Support: IE 9 only
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node.
			support.disconnectedMatch = assert( function( el ) {
				return matches.call( el, "*" );
			} );

			// Support: IE 9 - 11+, Edge 12 - 18+
			// IE/Edge don't support the :scope pseudo-class.
			support.scope = assert( function() {
				return document.querySelectorAll( ":scope" );
			} );

			// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
			// Make sure the `:has()` argument is parsed unforgivingly.
			// We include `*` in the test to detect buggy implementations that are
			// _selectively_ forgiving (specifically when the list includes at least
			// one valid selector).
			// Note that we treat complete lack of support for `:has()` as if it were
			// spec-compliant support, which is fine because use of `:has()` in such
			// environments will fail in the qSA path and fall back to jQuery traversal
			// anyway.
			support.cssHas = assert( function() {
				try {
					document.querySelector( ":has(*,:jqfake)" );
					return false;
				} catch ( e ) {
					return true;
				}
			} );

			// ID filter and find
			if ( support.getById ) {
				Expr.filter.ID = function( id ) {
					var attrId = id.replace( runescape, funescape );
					return function( elem ) {
						return elem.getAttribute( "id" ) === attrId;
					};
				};
				Expr.find.ID = function( id, context ) {
					if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
						var elem = context.getElementById( id );
						return elem ? [ elem ] : [];
					}
				};
			} else {
				Expr.filter.ID =  function( id ) {
					var attrId = id.replace( runescape, funescape );
					return function( elem ) {
						var node = typeof elem.getAttributeNode !== "undefined" &&
							elem.getAttributeNode( "id" );
						return node && node.value === attrId;
					};
				};

				// Support: IE 6 - 7 only
				// getElementById is not reliable as a find shortcut
				Expr.find.ID = function( id, context ) {
					if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
						var node, i, elems,
							elem = context.getElementById( id );

						if ( elem ) {

							// Verify the id attribute
							node = elem.getAttributeNode( "id" );
							if ( node && node.value === id ) {
								return [ elem ];
							}

							// Fall back on getElementsByName
							elems = context.getElementsByName( id );
							i = 0;
							while ( ( elem = elems[ i++ ] ) ) {
								node = elem.getAttributeNode( "id" );
								if ( node && node.value === id ) {
									return [ elem ];
								}
							}
						}

						return [];
					}
				};
			}

			// Tag
			Expr.find.TAG = function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else {
					return context.querySelectorAll( tag );
				}
			};

			// Class
			Expr.find.CLASS = function( className, context ) {
				if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
					return context.getElementsByClassName( className );
				}
			};

			/* QSA/matchesSelector
			---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			rbuggyQSA = [];

			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert( function( el ) {

				var input;

				documentElement.appendChild( el ).innerHTML =
					"<a id='" + expando + "' href='' disabled='disabled'></a>" +
					"<select id='" + expando + "-\r\\' disabled='disabled'>" +
					"<option selected=''></option></select>";

				// Support: iOS <=7 - 8 only
				// Boolean attributes and "value" are not treated correctly in some XML documents
				if ( !el.querySelectorAll( "[selected]" ).length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: iOS <=7 - 8 only
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push( "~=" );
				}

				// Support: iOS 8 only
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push( ".#.+[+~]" );
				}

				// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
				// In some of the document kinds, these selectors wouldn't work natively.
				// This is probably OK but for backwards compatibility we want to maintain
				// handling them through jQuery traversal in jQuery 3.x.
				if ( !el.querySelectorAll( ":checked" ).length ) {
					rbuggyQSA.push( ":checked" );
				}

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				input = document.createElement( "input" );
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE 9 - 11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
				// In some of the document kinds, these selectors wouldn't work natively.
				// This is probably OK but for backwards compatibility we want to maintain
				// handling them through jQuery traversal in jQuery 3.x.
				documentElement.appendChild( el ).disabled = true;
				if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE 11+, Edge 15 - 18+
				// IE 11/Edge don't find elements on a `[name='']` query in some cases.
				// Adding a temporary attribute to the document before the selection works
				// around the issue.
				// Interestingly, IE 10 & older don't seem to have the issue.
				input = document.createElement( "input" );
				input.setAttribute( "name", "" );
				el.appendChild( input );
				if ( !el.querySelectorAll( "[name='']" ).length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
						whitespace + "*(?:''|\"\")" );
				}
			} );

			if ( !support.cssHas ) {

				// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
				// Our regular `try-catch` mechanism fails to detect natively-unsupported
				// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
				// in browsers that parse the `:has()` argument as a forgiving selector list.
				// https://drafts.csswg.org/selectors/#relational now requires the argument
				// to be parsed unforgivingly, but browsers have not yet fully adjusted.
				rbuggyQSA.push( ":has" );
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

			/* Sorting
			---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = function( a, b ) {

				// Flag for duplicate removal
				if ( a === b ) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if ( compare ) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
					a.compareDocumentPosition( b ) :

					// Otherwise we know they are disconnected
					1;

				// Disconnected nodes
				if ( compare & 1 ||
					( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

					// Choose the first element that is related to our preferred document
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( a === document || a.ownerDocument == preferredDoc &&
						find.contains( preferredDoc, a ) ) {
						return -1;
					}

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( b === document || b.ownerDocument == preferredDoc &&
						find.contains( preferredDoc, b ) ) {
						return 1;
					}

					// Maintain original order
					return sortInput ?
						( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
						0;
				}

				return compare & 4 ? -1 : 1;
			};

			return document;
		}

		find.matches = function( expr, elements ) {
			return find( expr, null, null, elements );
		};

		find.matchesSelector = function( elem, expr ) {
			setDocument( elem );

			if ( documentIsHTML &&
				!nonnativeSelectorCache[ expr + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

				try {
					var ret = matches.call( elem, expr );

					// IE 9's matchesSelector returns false on disconnected nodes
					if ( ret || support.disconnectedMatch ||

							// As well, disconnected nodes are said to be in a document
							// fragment in IE 9
							elem.document && elem.document.nodeType !== 11 ) {
						return ret;
					}
				} catch ( e ) {
					nonnativeSelectorCache( expr, true );
				}
			}

			return find( expr, document, null, [ elem ] ).length > 0;
		};

		find.contains = function( context, elem ) {

			// Set document vars if needed
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( ( context.ownerDocument || context ) != document ) {
				setDocument( context );
			}
			return jQuery.contains( context, elem );
		};


		find.attr = function( elem, name ) {

			// Set document vars if needed
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( ( elem.ownerDocument || elem ) != document ) {
				setDocument( elem );
			}

			var fn = Expr.attrHandle[ name.toLowerCase() ],

				// Don't get fooled by Object.prototype properties (see trac-13807)
				val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
					fn( elem, name, !documentIsHTML ) :
					undefined;

			if ( val !== undefined ) {
				return val;
			}

			return elem.getAttribute( name );
		};

		find.error = function( msg ) {
			throw new Error( "Syntax error, unrecognized expression: " + msg );
		};

		/**
		 * Document sorting and removing duplicates
		 * @param {ArrayLike} results
		 */
		jQuery.uniqueSort = function( results ) {
			var elem,
				duplicates = [],
				j = 0,
				i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			//
			// Support: Android <=4.0+
			// Testing for detecting duplicates is unpredictable so instead assume we can't
			// depend on duplicate detection in all browsers without a stable sort.
			hasDuplicate = !support.sortStable;
			sortInput = !support.sortStable && slice.call( results, 0 );
			sort.call( results, sortOrder );

			if ( hasDuplicate ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem === results[ i ] ) {
						j = duplicates.push( i );
					}
				}
				while ( j-- ) {
					splice.call( results, duplicates[ j ], 1 );
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		jQuery.fn.uniqueSort = function() {
			return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
		};

		Expr = jQuery.expr = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				ATTR: function( match ) {
					match[ 1 ] = match[ 1 ].replace( runescape, funescape );

					// Move the given value to match[3] whether quoted or unquoted
					match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
						.replace( runescape, funescape );

					if ( match[ 2 ] === "~=" ) {
						match[ 3 ] = " " + match[ 3 ] + " ";
					}

					return match.slice( 0, 4 );
				},

				CHILD: function( match ) {

					/* matches from matchExpr["CHILD"]
						1 type (only|nth|...)
						2 what (child|of-type)
						3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
						4 xn-component of xn+y argument ([+-]?\d*n|)
						5 sign of xn-component
						6 x of xn-component
						7 sign of y-component
						8 y of y-component
					*/
					match[ 1 ] = match[ 1 ].toLowerCase();

					if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

						// nth-* requires argument
						if ( !match[ 3 ] ) {
							find.error( match[ 0 ] );
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[ 4 ] = +( match[ 4 ] ?
							match[ 5 ] + ( match[ 6 ] || 1 ) :
							2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
						);
						match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

					// other types prohibit arguments
					} else if ( match[ 3 ] ) {
						find.error( match[ 0 ] );
					}

					return match;
				},

				PSEUDO: function( match ) {
					var excess,
						unquoted = !match[ 6 ] && match[ 2 ];

					if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
						return null;
					}

					// Accept quoted arguments as-is
					if ( match[ 3 ] ) {
						match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

					// Strip excess characters from unquoted arguments
					} else if ( unquoted && rpseudo.test( unquoted ) &&

						// Get excess from tokenize (recursively)
						( excess = tokenize( unquoted, true ) ) &&

						// advance to the next closing parenthesis
						( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

						// excess is a negative index
						match[ 0 ] = match[ 0 ].slice( 0, excess );
						match[ 2 ] = unquoted.slice( 0, excess );
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice( 0, 3 );
				}
			},

			filter: {

				TAG: function( nodeNameSelector ) {
					var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
					return nodeNameSelector === "*" ?
						function() {
							return true;
						} :
						function( elem ) {
							return nodeName( elem, expectedNodeName );
						};
				},

				CLASS: function( className ) {
					var pattern = classCache[ className + " " ];

					return pattern ||
						( pattern = new RegExp( "(^|" + whitespace + ")" + className +
							"(" + whitespace + "|$)" ) ) &&
						classCache( className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
									typeof elem.getAttribute !== "undefined" &&
										elem.getAttribute( "class" ) ||
									""
							);
						} );
				},

				ATTR: function( name, operator, check ) {
					return function( elem ) {
						var result = find.attr( elem, name );

						if ( result == null ) {
							return operator === "!=";
						}
						if ( !operator ) {
							return true;
						}

						result += "";

						if ( operator === "=" ) {
							return result === check;
						}
						if ( operator === "!=" ) {
							return result !== check;
						}
						if ( operator === "^=" ) {
							return check && result.indexOf( check ) === 0;
						}
						if ( operator === "*=" ) {
							return check && result.indexOf( check ) > -1;
						}
						if ( operator === "$=" ) {
							return check && result.slice( -check.length ) === check;
						}
						if ( operator === "~=" ) {
							return ( " " + result.replace( rwhitespace, " " ) + " " )
								.indexOf( check ) > -1;
						}
						if ( operator === "|=" ) {
							return result === check || result.slice( 0, check.length + 1 ) === check + "-";
						}

						return false;
					};
				},

				CHILD: function( type, what, _argument, first, last ) {
					var simple = type.slice( 0, 3 ) !== "nth",
						forward = type.slice( -4 ) !== "last",
						ofType = what === "of-type";

					return first === 1 && last === 0 ?

						// Shortcut for :nth-*(n)
						function( elem ) {
							return !!elem.parentNode;
						} :

						function( elem, _context, xml ) {
							var cache, outerCache, node, nodeIndex, start,
								dir = simple !== forward ? "nextSibling" : "previousSibling",
								parent = elem.parentNode,
								name = ofType && elem.nodeName.toLowerCase(),
								useCache = !xml && !ofType,
								diff = false;

							if ( parent ) {

								// :(first|last|only)-(child|of-type)
								if ( simple ) {
									while ( dir ) {
										node = elem;
										while ( ( node = node[ dir ] ) ) {
											if ( ofType ?
												nodeName( node, name ) :
												node.nodeType === 1 ) {

												return false;
											}
										}

										// Reverse direction for :only-* (if we haven't yet done so)
										start = dir = type === "only" && !start && "nextSibling";
									}
									return true;
								}

								start = [ forward ? parent.firstChild : parent.lastChild ];

								// non-xml :nth-child(...) stores cache data on `parent`
								if ( forward && useCache ) {

									// Seek `elem` from a previously-cached index
									outerCache = parent[ expando ] || ( parent[ expando ] = {} );
									cache = outerCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex && cache[ 2 ];
									node = nodeIndex && parent.childNodes[ nodeIndex ];

									while ( ( node = ++nodeIndex && node && node[ dir ] ||

										// Fallback to seeking `elem` from the start
										( diff = nodeIndex = 0 ) || start.pop() ) ) {

										// When found, cache indexes on `parent` and break
										if ( node.nodeType === 1 && ++diff && node === elem ) {
											outerCache[ type ] = [ dirruns, nodeIndex, diff ];
											break;
										}
									}

								} else {

									// Use previously-cached element index if available
									if ( useCache ) {
										outerCache = elem[ expando ] || ( elem[ expando ] = {} );
										cache = outerCache[ type ] || [];
										nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
										diff = nodeIndex;
									}

									// xml :nth-child(...)
									// or :nth-last-child(...) or :nth(-last)?-of-type(...)
									if ( diff === false ) {

										// Use the same loop as above to seek `elem` from the start
										while ( ( node = ++nodeIndex && node && node[ dir ] ||
											( diff = nodeIndex = 0 ) || start.pop() ) ) {

											if ( ( ofType ?
												nodeName( node, name ) :
												node.nodeType === 1 ) &&
												++diff ) {

												// Cache the index of each encountered element
												if ( useCache ) {
													outerCache = node[ expando ] ||
														( node[ expando ] = {} );
													outerCache[ type ] = [ dirruns, diff ];
												}

												if ( node === elem ) {
													break;
												}
											}
										}
									}
								}

								// Incorporate the offset, then check against cycle size
								diff -= last;
								return diff === first || ( diff % first === 0 && diff / first >= 0 );
							}
						};
				},

				PSEUDO: function( pseudo, argument ) {

					// pseudo-class names are case-insensitive
					// https://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
						fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
							find.error( "unsupported pseudo: " + pseudo );

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as jQuery does
					if ( fn[ expando ] ) {
						return fn( argument );
					}

					// But maintain support for old signatures
					if ( fn.length > 1 ) {
						args = [ pseudo, pseudo, "", argument ];
						return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
							markFunction( function( seed, matches ) {
								var idx,
									matched = fn( seed, argument ),
									i = matched.length;
								while ( i-- ) {
									idx = indexOf.call( seed, matched[ i ] );
									seed[ idx ] = !( matches[ idx ] = matched[ i ] );
								}
							} ) :
							function( elem ) {
								return fn( elem, 0, args );
							};
					}

					return fn;
				}
			},

			pseudos: {

				// Potentially complex pseudos
				not: markFunction( function( selector ) {

					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
						results = [],
						matcher = compile( selector.replace( rtrimCSS, "$1" ) );

					return matcher[ expando ] ?
						markFunction( function( seed, matches, _context, xml ) {
							var elem,
								unmatched = matcher( seed, null, xml, [] ),
								i = seed.length;

							// Match elements unmatched by `matcher`
							while ( i-- ) {
								if ( ( elem = unmatched[ i ] ) ) {
									seed[ i ] = !( matches[ i ] = elem );
								}
							}
						} ) :
						function( elem, _context, xml ) {
							input[ 0 ] = elem;
							matcher( input, null, xml, results );

							// Don't keep the element
							// (see https://github.com/jquery/sizzle/issues/299)
							input[ 0 ] = null;
							return !results.pop();
						};
				} ),

				has: markFunction( function( selector ) {
					return function( elem ) {
						return find( selector, elem ).length > 0;
					};
				} ),

				contains: markFunction( function( text ) {
					text = text.replace( runescape, funescape );
					return function( elem ) {
						return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
					};
				} ),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// https://www.w3.org/TR/selectors/#lang-pseudo
				lang: markFunction( function( lang ) {

					// lang value must be a valid identifier
					if ( !ridentifier.test( lang || "" ) ) {
						find.error( "unsupported lang: " + lang );
					}
					lang = lang.replace( runescape, funescape ).toLowerCase();
					return function( elem ) {
						var elemLang;
						do {
							if ( ( elemLang = documentIsHTML ?
								elem.lang :
								elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
							}
						} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
						return false;
					};
				} ),

				// Miscellaneous
				target: function( elem ) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice( 1 ) === elem.id;
				},

				root: function( elem ) {
					return elem === documentElement;
				},

				focus: function( elem ) {
					return elem === safeActiveElement() &&
						document.hasFocus() &&
						!!( elem.type || elem.href || ~elem.tabIndex );
				},

				// Boolean properties
				enabled: createDisabledPseudo( false ),
				disabled: createDisabledPseudo( true ),

				checked: function( elem ) {

					// In CSS3, :checked should return both checked and selected elements
					// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					return ( nodeName( elem, "input" ) && !!elem.checked ) ||
						( nodeName( elem, "option" ) && !!elem.selected );
				},

				selected: function( elem ) {

					// Support: IE <=11+
					// Accessing the selectedIndex property
					// forces the browser to treat the default option as
					// selected when in an optgroup.
					if ( elem.parentNode ) {
						// eslint-disable-next-line no-unused-expressions
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				empty: function( elem ) {

					// https://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
						if ( elem.nodeType < 6 ) {
							return false;
						}
					}
					return true;
				},

				parent: function( elem ) {
					return !Expr.pseudos.empty( elem );
				},

				// Element/input types
				header: function( elem ) {
					return rheader.test( elem.nodeName );
				},

				input: function( elem ) {
					return rinputs.test( elem.nodeName );
				},

				button: function( elem ) {
					return nodeName( elem, "input" ) && elem.type === "button" ||
						nodeName( elem, "button" );
				},

				text: function( elem ) {
					var attr;
					return nodeName( elem, "input" ) && elem.type === "text" &&

						// Support: IE <10 only
						// New HTML5 attribute values (e.g., "search") appear
						// with elem.type === "text"
						( ( attr = elem.getAttribute( "type" ) ) == null ||
							attr.toLowerCase() === "text" );
				},

				// Position-in-collection
				first: createPositionalPseudo( function() {
					return [ 0 ];
				} ),

				last: createPositionalPseudo( function( _matchIndexes, length ) {
					return [ length - 1 ];
				} ),

				eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
					return [ argument < 0 ? argument + length : argument ];
				} ),

				even: createPositionalPseudo( function( matchIndexes, length ) {
					var i = 0;
					for ( ; i < length; i += 2 ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				} ),

				odd: createPositionalPseudo( function( matchIndexes, length ) {
					var i = 1;
					for ( ; i < length; i += 2 ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				} ),

				lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
					var i;

					if ( argument < 0 ) {
						i = argument + length;
					} else if ( argument > length ) {
						i = length;
					} else {
						i = argument;
					}

					for ( ; --i >= 0; ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				} ),

				gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
					var i = argument < 0 ? argument + length : argument;
					for ( ; ++i < length; ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				} )
			}
		};

		Expr.pseudos.nth = Expr.pseudos.eq;

		// Add button/input type pseudos
		for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
			Expr.pseudos[ i ] = createInputPseudo( i );
		}
		for ( i in { submit: true, reset: true } ) {
			Expr.pseudos[ i ] = createButtonPseudo( i );
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		function tokenize( selector, parseOnly ) {
			var matched, match, tokens, type,
				soFar, groups, preFilters,
				cached = tokenCache[ selector + " " ];

			if ( cached ) {
				return parseOnly ? 0 : cached.slice( 0 );
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while ( soFar ) {

				// Comma and first run
				if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
					if ( match ) {

						// Don't consume trailing commas as valid
						soFar = soFar.slice( match[ 0 ].length ) || soFar;
					}
					groups.push( ( tokens = [] ) );
				}

				matched = false;

				// Combinators
				if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
					matched = match.shift();
					tokens.push( {
						value: matched,

						// Cast descendant combinators to space
						type: match[ 0 ].replace( rtrimCSS, " " )
					} );
					soFar = soFar.slice( matched.length );
				}

				// Filters
				for ( type in Expr.filter ) {
					if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
						( match = preFilters[ type ]( match ) ) ) ) {
						matched = match.shift();
						tokens.push( {
							value: matched,
							type: type,
							matches: match
						} );
						soFar = soFar.slice( matched.length );
					}
				}

				if ( !matched ) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			if ( parseOnly ) {
				return soFar.length;
			}

			return soFar ?
				find.error( selector ) :

				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
		}

		function toSelector( tokens ) {
			var i = 0,
				len = tokens.length,
				selector = "";
			for ( ; i < len; i++ ) {
				selector += tokens[ i ].value;
			}
			return selector;
		}

		function addCombinator( matcher, combinator, base ) {
			var dir = combinator.dir,
				skip = combinator.next,
				key = skip || dir,
				checkNonElements = base && key === "parentNode",
				doneName = done++;

			return combinator.first ?

				// Check against closest ancestor/preceding element
				function( elem, context, xml ) {
					while ( ( elem = elem[ dir ] ) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							return matcher( elem, context, xml );
						}
					}
					return false;
				} :

				// Check against all ancestor/preceding elements
				function( elem, context, xml ) {
					var oldCache, outerCache,
						newCache = [ dirruns, doneName ];

					// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
					if ( xml ) {
						while ( ( elem = elem[ dir ] ) ) {
							if ( elem.nodeType === 1 || checkNonElements ) {
								if ( matcher( elem, context, xml ) ) {
									return true;
								}
							}
						}
					} else {
						while ( ( elem = elem[ dir ] ) ) {
							if ( elem.nodeType === 1 || checkNonElements ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );

								if ( skip && nodeName( elem, skip ) ) {
									elem = elem[ dir ] || elem;
								} else if ( ( oldCache = outerCache[ key ] ) &&
									oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

									// Assign to newCache so results back-propagate to previous elements
									return ( newCache[ 2 ] = oldCache[ 2 ] );
								} else {

									// Reuse newcache so results back-propagate to previous elements
									outerCache[ key ] = newCache;

									// A match means we're done; a fail means we have to keep checking
									if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
										return true;
									}
								}
							}
						}
					}
					return false;
				};
		}

		function elementMatcher( matchers ) {
			return matchers.length > 1 ?
				function( elem, context, xml ) {
					var i = matchers.length;
					while ( i-- ) {
						if ( !matchers[ i ]( elem, context, xml ) ) {
							return false;
						}
					}
					return true;
				} :
				matchers[ 0 ];
		}

		function multipleContexts( selector, contexts, results ) {
			var i = 0,
				len = contexts.length;
			for ( ; i < len; i++ ) {
				find( selector, contexts[ i ], results );
			}
			return results;
		}

		function condense( unmatched, map, filter, context, xml ) {
			var elem,
				newUnmatched = [],
				i = 0,
				len = unmatched.length,
				mapped = map != null;

			for ( ; i < len; i++ ) {
				if ( ( elem = unmatched[ i ] ) ) {
					if ( !filter || filter( elem, context, xml ) ) {
						newUnmatched.push( elem );
						if ( mapped ) {
							map.push( i );
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
			if ( postFilter && !postFilter[ expando ] ) {
				postFilter = setMatcher( postFilter );
			}
			if ( postFinder && !postFinder[ expando ] ) {
				postFinder = setMatcher( postFinder, postSelector );
			}
			return markFunction( function( seed, results, context, xml ) {
				var temp, i, elem, matcherOut,
					preMap = [],
					postMap = [],
					preexisting = results.length,

					// Get initial elements from seed or context
					elems = seed ||
						multipleContexts( selector || "*",
							context.nodeType ? [ context ] : context, [] ),

					// Prefilter to get matcher input, preserving a map for seed-results synchronization
					matcherIn = preFilter && ( seed || !selector ) ?
						condense( elems, preMap, preFilter, context, xml ) :
						elems;

				if ( matcher ) {

					// If we have a postFinder, or filtered seed, or non-seed postFilter
					// or preexisting results,
					matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results;

					// Find primary matches
					matcher( matcherIn, matcherOut, context, xml );
				} else {
					matcherOut = matcherIn;
				}

				// Apply postFilter
				if ( postFilter ) {
					temp = condense( matcherOut, postMap );
					postFilter( temp, [], context, xml );

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while ( i-- ) {
						if ( ( elem = temp[ i ] ) ) {
							matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
						}
					}
				}

				if ( seed ) {
					if ( postFinder || preFilter ) {
						if ( postFinder ) {

							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while ( i-- ) {
								if ( ( elem = matcherOut[ i ] ) ) {

									// Restore matcherIn since elem is not yet a final match
									temp.push( ( matcherIn[ i ] = elem ) );
								}
							}
							postFinder( null, ( matcherOut = [] ), temp, xml );
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while ( i-- ) {
							if ( ( elem = matcherOut[ i ] ) &&
								( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

								seed[ temp ] = !( results[ temp ] = elem );
							}
						}
					}

				// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(
						matcherOut === results ?
							matcherOut.splice( preexisting, matcherOut.length ) :
							matcherOut
					);
					if ( postFinder ) {
						postFinder( null, results, matcherOut, xml );
					} else {
						push.apply( results, matcherOut );
					}
				}
			} );
		}

		function matcherFromTokens( tokens ) {
			var checkContext, matcher, j,
				len = tokens.length,
				leadingRelative = Expr.relative[ tokens[ 0 ].type ],
				implicitRelative = leadingRelative || Expr.relative[ " " ],
				i = leadingRelative ? 1 : 0,

				// The foundational matcher ensures that elements are reachable from top-level context(s)
				matchContext = addCombinator( function( elem ) {
					return elem === checkContext;
				}, implicitRelative, true ),
				matchAnyContext = addCombinator( function( elem ) {
					return indexOf.call( checkContext, elem ) > -1;
				}, implicitRelative, true ),
				matchers = [ function( elem, context, xml ) {

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
						( checkContext = context ).nodeType ?
							matchContext( elem, context, xml ) :
							matchAnyContext( elem, context, xml ) );

					// Avoid hanging onto element
					// (see https://github.com/jquery/sizzle/issues/299)
					checkContext = null;
					return ret;
				} ];

			for ( ; i < len; i++ ) {
				if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
					matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
				} else {
					matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

					// Return special upon seeing a positional matcher
					if ( matcher[ expando ] ) {

						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for ( ; j < len; j++ ) {
							if ( Expr.relative[ tokens[ j ].type ] ) {
								break;
							}
						}
						return setMatcher(
							i > 1 && elementMatcher( matchers ),
							i > 1 && toSelector(

								// If the preceding token was a descendant combinator, insert an implicit any-element `*`
								tokens.slice( 0, i - 1 )
									.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
							).replace( rtrimCSS, "$1" ),
							matcher,
							i < j && matcherFromTokens( tokens.slice( i, j ) ),
							j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
							j < len && toSelector( tokens )
						);
					}
					matchers.push( matcher );
				}
			}

			return elementMatcher( matchers );
		}

		function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
			var bySet = setMatchers.length > 0,
				byElement = elementMatchers.length > 0,
				superMatcher = function( seed, context, xml, results, outermost ) {
					var elem, j, matcher,
						matchedCount = 0,
						i = "0",
						unmatched = seed && [],
						setMatched = [],
						contextBackup = outermostContext,

						// We must always have either seed elements or outermost context
						elems = seed || byElement && Expr.find.TAG( "*", outermost ),

						// Use integer dirruns iff this is the outermost matcher
						dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
						len = elems.length;

					if ( outermost ) {

						// Support: IE 11+, Edge 17 - 18+
						// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
						// two documents; shallow comparisons work.
						// eslint-disable-next-line eqeqeq
						outermostContext = context == document || context || outermost;
					}

					// Add elements passing elementMatchers directly to results
					// Support: iOS <=7 - 9 only
					// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
					// elements by id. (see trac-14142)
					for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
						if ( byElement && elem ) {
							j = 0;

							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq
							if ( !context && elem.ownerDocument != document ) {
								setDocument( elem );
								xml = !documentIsHTML;
							}
							while ( ( matcher = elementMatchers[ j++ ] ) ) {
								if ( matcher( elem, context || document, xml ) ) {
									push.call( results, elem );
									break;
								}
							}
							if ( outermost ) {
								dirruns = dirrunsUnique;
							}
						}

						// Track unmatched elements for set filters
						if ( bySet ) {

							// They will have gone through all possible matchers
							if ( ( elem = !matcher && elem ) ) {
								matchedCount--;
							}

							// Lengthen the array for every element, matched or not
							if ( seed ) {
								unmatched.push( elem );
							}
						}
					}

					// `i` is now the count of elements visited above, and adding it to `matchedCount`
					// makes the latter nonnegative.
					matchedCount += i;

					// Apply set filters to unmatched elements
					// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
					// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
					// no element matchers and no seed.
					// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
					// case, which will result in a "00" `matchedCount` that differs from `i` but is also
					// numerically zero.
					if ( bySet && i !== matchedCount ) {
						j = 0;
						while ( ( matcher = setMatchers[ j++ ] ) ) {
							matcher( unmatched, setMatched, context, xml );
						}

						if ( seed ) {

							// Reintegrate element matches to eliminate the need for sorting
							if ( matchedCount > 0 ) {
								while ( i-- ) {
									if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
										setMatched[ i ] = pop.call( results );
									}
								}
							}

							// Discard index placeholder values to get only actual matches
							setMatched = condense( setMatched );
						}

						// Add matches to results
						push.apply( results, setMatched );

						// Seedless set matches succeeding multiple successful matchers stipulate sorting
						if ( outermost && !seed && setMatched.length > 0 &&
							( matchedCount + setMatchers.length ) > 1 ) {

							jQuery.uniqueSort( results );
						}
					}

					// Override manipulation of globals by nested matchers
					if ( outermost ) {
						dirruns = dirrunsUnique;
						outermostContext = contextBackup;
					}

					return unmatched;
				};

			return bySet ?
				markFunction( superMatcher ) :
				superMatcher;
		}

		function compile( selector, match /* Internal Use Only */ ) {
			var i,
				setMatchers = [],
				elementMatchers = [],
				cached = compilerCache[ selector + " " ];

			if ( !cached ) {

				// Generate a function of recursive functions that can be used to check each element
				if ( !match ) {
					match = tokenize( selector );
				}
				i = match.length;
				while ( i-- ) {
					cached = matcherFromTokens( match[ i ] );
					if ( cached[ expando ] ) {
						setMatchers.push( cached );
					} else {
						elementMatchers.push( cached );
					}
				}

				// Cache the compiled function
				cached = compilerCache( selector,
					matcherFromGroupMatchers( elementMatchers, setMatchers ) );

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		}

		/**
		 * A low-level selection function that works with jQuery's compiled
		 *  selector functions
		 * @param {String|Function} selector A selector or a pre-compiled
		 *  selector function built with jQuery selector compile
		 * @param {Element} context
		 * @param {Array} [results]
		 * @param {Array} [seed] A set of elements to match against
		 */
		function select( selector, context, results, seed ) {
			var i, tokens, token, type, find,
				compiled = typeof selector === "function" && selector,
				match = !seed && tokenize( ( selector = compiled.selector || selector ) );

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if ( match.length === 1 ) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[ 0 ] = match[ 0 ].slice( 0 );
				if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
						context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

					context = ( Expr.find.ID(
						token.matches[ 0 ].replace( runescape, funescape ),
						context
					) || [] )[ 0 ];
					if ( !context ) {
						return results;

					// Precompiled matchers will still verify ancestry, so step up a level
					} else if ( compiled ) {
						context = context.parentNode;
					}

					selector = selector.slice( tokens.shift().value.length );
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
				while ( i-- ) {
					token = tokens[ i ];

					// Abort if we hit a combinator
					if ( Expr.relative[ ( type = token.type ) ] ) {
						break;
					}
					if ( ( find = Expr.find[ type ] ) ) {

						// Search, expanding context for leading sibling combinators
						if ( ( seed = find(
							token.matches[ 0 ].replace( runescape, funescape ),
							rsibling.test( tokens[ 0 ].type ) &&
								testContext( context.parentNode ) || context
						) ) ) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice( i, 1 );
							selector = seed.length && toSelector( tokens );
							if ( !selector ) {
								push.apply( results, seed );
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			( compiled || compile( selector, match ) )(
				seed,
				context,
				!documentIsHTML,
				results,
				!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
			);
			return results;
		}

		// One-time assignments

		// Support: Android <=4.0 - 4.1+
		// Sort stability
		support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

		// Initialize against the default document
		setDocument();

		// Support: Android <=4.0 - 4.1+
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert( function( el ) {

			// Should return 1, but returns 4 (following)
			return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
		} );

		jQuery.find = find;

		// Deprecated
		jQuery.expr[ ":" ] = jQuery.expr.pseudos;
		jQuery.unique = jQuery.uniqueSort;

		// These have always been private, but they used to be documented as part of
		// Sizzle so let's maintain them for now for backwards compatibility purposes.
		find.compile = compile;
		find.select = select;
		find.setDocument = setDocument;
		find.tokenize = tokenize;

		find.escape = jQuery.escapeSelector;
		find.getText = jQuery.text;
		find.isXML = jQuery.isXMLDoc;
		find.selectors = jQuery.expr;
		find.support = jQuery.support;
		find.uniqueSort = jQuery.uniqueSort;

			/* eslint-enable */

		} )();


		var dir = function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;

			while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		};


		var siblings = function( n, elem ) {
			var matched = [];

			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}

			return matched;
		};


		var rneedsContext = jQuery.expr.match.needsContext;

		var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



		// Implement the identical functionality for filter and not
		function winnow( elements, qualifier, not ) {
			if ( isFunction( qualifier ) ) {
				return jQuery.grep( elements, function( elem, i ) {
					return !!qualifier.call( elem, i, elem ) !== not;
				} );
			}

			// Single element
			if ( qualifier.nodeType ) {
				return jQuery.grep( elements, function( elem ) {
					return ( elem === qualifier ) !== not;
				} );
			}

			// Arraylike of elements (jQuery, arguments, Array)
			if ( typeof qualifier !== "string" ) {
				return jQuery.grep( elements, function( elem ) {
					return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
				} );
			}

			// Filtered directly for both simple and complex selectors
			return jQuery.filter( qualifier, elements, not );
		}

		jQuery.filter = function( expr, elems, not ) {
			var elem = elems[ 0 ];

			if ( not ) {
				expr = ":not(" + expr + ")";
			}

			if ( elems.length === 1 && elem.nodeType === 1 ) {
				return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
			}

			return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
		};

		jQuery.fn.extend( {
			find: function( selector ) {
				var i, ret,
					len = this.length,
					self = this;

				if ( typeof selector !== "string" ) {
					return this.pushStack( jQuery( selector ).filter( function() {
						for ( i = 0; i < len; i++ ) {
							if ( jQuery.contains( self[ i ], this ) ) {
								return true;
							}
						}
					} ) );
				}

				ret = this.pushStack( [] );

				for ( i = 0; i < len; i++ ) {
					jQuery.find( selector, self[ i ], ret );
				}

				return len > 1 ? jQuery.uniqueSort( ret ) : ret;
			},
			filter: function( selector ) {
				return this.pushStack( winnow( this, selector || [], false ) );
			},
			not: function( selector ) {
				return this.pushStack( winnow( this, selector || [], true ) );
			},
			is: function( selector ) {
				return !!winnow(
					this,

					// If this is a positional/relative selector, check membership in the returned set
					// so $("p:first").is("p:last") won't return true for a doc with two "p".
					typeof selector === "string" && rneedsContext.test( selector ) ?
						jQuery( selector ) :
						selector || [],
					false
				).length;
			}
		} );


		// Initialize a jQuery object


		// A central reference to the root jQuery(document)
		var rootjQuery,

			// A simple way to check for HTML strings
			// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
			// Strict HTML recognition (trac-11290: must start with <)
			// Shortcut simple #id case for speed
			rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

			init = jQuery.fn.init = function( selector, context, root ) {
				var match, elem;

				// HANDLE: $(""), $(null), $(undefined), $(false)
				if ( !selector ) {
					return this;
				}

				// Method init() accepts an alternate rootjQuery
				// so migrate can support jQuery.sub (gh-2101)
				root = root || rootjQuery;

				// Handle HTML strings
				if ( typeof selector === "string" ) {
					if ( selector[ 0 ] === "<" &&
						selector[ selector.length - 1 ] === ">" &&
						selector.length >= 3 ) {

						// Assume that strings that start and end with <> are HTML and skip the regex check
						match = [ null, selector, null ];

					} else {
						match = rquickExpr.exec( selector );
					}

					// Match html or make sure no context is specified for #id
					if ( match && ( match[ 1 ] || !context ) ) {

						// HANDLE: $(html) -> $(array)
						if ( match[ 1 ] ) {
							context = context instanceof jQuery ? context[ 0 ] : context;

							// Option to run scripts is true for back-compat
							// Intentionally let the error be thrown if parseHTML is not present
							jQuery.merge( this, jQuery.parseHTML(
								match[ 1 ],
								context && context.nodeType ? context.ownerDocument || context : document,
								true
							) );

							// HANDLE: $(html, props)
							if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
								for ( match in context ) {

									// Properties of context are called as methods if possible
									if ( isFunction( this[ match ] ) ) {
										this[ match ]( context[ match ] );

									// ...and otherwise set as attributes
									} else {
										this.attr( match, context[ match ] );
									}
								}
							}

							return this;

						// HANDLE: $(#id)
						} else {
							elem = document.getElementById( match[ 2 ] );

							if ( elem ) {

								// Inject the element directly into the jQuery object
								this[ 0 ] = elem;
								this.length = 1;
							}
							return this;
						}

					// HANDLE: $(expr, $(...))
					} else if ( !context || context.jquery ) {
						return ( context || root ).find( selector );

					// HANDLE: $(expr, context)
					// (which is just equivalent to: $(context).find(expr)
					} else {
						return this.constructor( context ).find( selector );
					}

				// HANDLE: $(DOMElement)
				} else if ( selector.nodeType ) {
					this[ 0 ] = selector;
					this.length = 1;
					return this;

				// HANDLE: $(function)
				// Shortcut for document ready
				} else if ( isFunction( selector ) ) {
					return root.ready !== undefined ?
						root.ready( selector ) :

						// Execute immediately if ready is not present
						selector( jQuery );
				}

				return jQuery.makeArray( selector, this );
			};

		// Give the init function the jQuery prototype for later instantiation
		init.prototype = jQuery.fn;

		// Initialize central reference
		rootjQuery = jQuery( document );


		var rparentsprev = /^(?:parents|prev(?:Until|All))/,

			// Methods guaranteed to produce a unique set when starting from a unique set
			guaranteedUnique = {
				children: true,
				contents: true,
				next: true,
				prev: true
			};

		jQuery.fn.extend( {
			has: function( target ) {
				var targets = jQuery( target, this ),
					l = targets.length;

				return this.filter( function() {
					var i = 0;
					for ( ; i < l; i++ ) {
						if ( jQuery.contains( this, targets[ i ] ) ) {
							return true;
						}
					}
				} );
			},

			closest: function( selectors, context ) {
				var cur,
					i = 0,
					l = this.length,
					matched = [],
					targets = typeof selectors !== "string" && jQuery( selectors );

				// Positional selectors never match, since there's no _selection_ context
				if ( !rneedsContext.test( selectors ) ) {
					for ( ; i < l; i++ ) {
						for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

							// Always skip document fragments
							if ( cur.nodeType < 11 && ( targets ?
								targets.index( cur ) > -1 :

								// Don't pass non-elements to jQuery#find
								cur.nodeType === 1 &&
									jQuery.find.matchesSelector( cur, selectors ) ) ) {

								matched.push( cur );
								break;
							}
						}
					}
				}

				return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
			},

			// Determine the position of an element within the set
			index: function( elem ) {

				// No argument, return index in parent
				if ( !elem ) {
					return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
				}

				// Index in selector
				if ( typeof elem === "string" ) {
					return indexOf.call( jQuery( elem ), this[ 0 ] );
				}

				// Locate the position of the desired element
				return indexOf.call( this,

					// If it receives a jQuery object, the first element is used
					elem.jquery ? elem[ 0 ] : elem
				);
			},

			add: function( selector, context ) {
				return this.pushStack(
					jQuery.uniqueSort(
						jQuery.merge( this.get(), jQuery( selector, context ) )
					)
				);
			},

			addBack: function( selector ) {
				return this.add( selector == null ?
					this.prevObject : this.prevObject.filter( selector )
				);
			}
		} );

		function sibling( cur, dir ) {
			while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
			return cur;
		}

		jQuery.each( {
			parent: function( elem ) {
				var parent = elem.parentNode;
				return parent && parent.nodeType !== 11 ? parent : null;
			},
			parents: function( elem ) {
				return dir( elem, "parentNode" );
			},
			parentsUntil: function( elem, _i, until ) {
				return dir( elem, "parentNode", until );
			},
			next: function( elem ) {
				return sibling( elem, "nextSibling" );
			},
			prev: function( elem ) {
				return sibling( elem, "previousSibling" );
			},
			nextAll: function( elem ) {
				return dir( elem, "nextSibling" );
			},
			prevAll: function( elem ) {
				return dir( elem, "previousSibling" );
			},
			nextUntil: function( elem, _i, until ) {
				return dir( elem, "nextSibling", until );
			},
			prevUntil: function( elem, _i, until ) {
				return dir( elem, "previousSibling", until );
			},
			siblings: function( elem ) {
				return siblings( ( elem.parentNode || {} ).firstChild, elem );
			},
			children: function( elem ) {
				return siblings( elem.firstChild );
			},
			contents: function( elem ) {
				if ( elem.contentDocument != null &&

					// Support: IE 11+
					// <object> elements with no `data` attribute has an object
					// `contentDocument` with a `null` prototype.
					getProto( elem.contentDocument ) ) {

					return elem.contentDocument;
				}

				// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
				// Treat the template element as a regular one in browsers that
				// don't support it.
				if ( nodeName( elem, "template" ) ) {
					elem = elem.content || elem;
				}

				return jQuery.merge( [], elem.childNodes );
			}
		}, function( name, fn ) {
			jQuery.fn[ name ] = function( until, selector ) {
				var matched = jQuery.map( this, fn, until );

				if ( name.slice( -5 ) !== "Until" ) {
					selector = until;
				}

				if ( selector && typeof selector === "string" ) {
					matched = jQuery.filter( selector, matched );
				}

				if ( this.length > 1 ) {

					// Remove duplicates
					if ( !guaranteedUnique[ name ] ) {
						jQuery.uniqueSort( matched );
					}

					// Reverse order for parents* and prev-derivatives
					if ( rparentsprev.test( name ) ) {
						matched.reverse();
					}
				}

				return this.pushStack( matched );
			};
		} );
		var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



		// Convert String-formatted options into Object-formatted ones
		function createOptions( options ) {
			var object = {};
			jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
				object[ flag ] = true;
			} );
			return object;
		}

		/*
		 * Create a callback list using the following parameters:
		 *
		 *	options: an optional list of space-separated options that will change how
		 *			the callback list behaves or a more traditional option object
		 *
		 * By default a callback list will act like an event callback list and can be
		 * "fired" multiple times.
		 *
		 * Possible options:
		 *
		 *	once:			will ensure the callback list can only be fired once (like a Deferred)
		 *
		 *	memory:			will keep track of previous values and will call any callback added
		 *					after the list has been fired right away with the latest "memorized"
		 *					values (like a Deferred)
		 *
		 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
		 *
		 *	stopOnFalse:	interrupt callings when a callback returns false
		 *
		 */
		jQuery.Callbacks = function( options ) {

			// Convert options from String-formatted to Object-formatted if needed
			// (we check in cache first)
			options = typeof options === "string" ?
				createOptions( options ) :
				jQuery.extend( {}, options );

			var // Flag to know if list is currently firing
				firing,

				// Last fire value for non-forgettable lists
				memory,

				// Flag to know if list was already fired
				fired,

				// Flag to prevent firing
				locked,

				// Actual callback list
				list = [],

				// Queue of execution data for repeatable lists
				queue = [],

				// Index of currently firing callback (modified by add/remove as needed)
				firingIndex = -1,

				// Fire callbacks
				fire = function() {

					// Enforce single-firing
					locked = locked || options.once;

					// Execute callbacks for all pending executions,
					// respecting firingIndex overrides and runtime changes
					fired = firing = true;
					for ( ; queue.length; firingIndex = -1 ) {
						memory = queue.shift();
						while ( ++firingIndex < list.length ) {

							// Run callback and check for early termination
							if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
								options.stopOnFalse ) {

								// Jump to end and forget the data so .add doesn't re-fire
								firingIndex = list.length;
								memory = false;
							}
						}
					}

					// Forget the data if we're done with it
					if ( !options.memory ) {
						memory = false;
					}

					firing = false;

					// Clean up if we're done firing for good
					if ( locked ) {

						// Keep an empty list if we have data for future add calls
						if ( memory ) {
							list = [];

						// Otherwise, this object is spent
						} else {
							list = "";
						}
					}
				},

				// Actual Callbacks object
				self = {

					// Add a callback or a collection of callbacks to the list
					add: function() {
						if ( list ) {

							// If we have memory from a past run, we should fire after adding
							if ( memory && !firing ) {
								firingIndex = list.length - 1;
								queue.push( memory );
							}

							( function add( args ) {
								jQuery.each( args, function( _, arg ) {
									if ( isFunction( arg ) ) {
										if ( !options.unique || !self.has( arg ) ) {
											list.push( arg );
										}
									} else if ( arg && arg.length && toType( arg ) !== "string" ) {

										// Inspect recursively
										add( arg );
									}
								} );
							} )( arguments );

							if ( memory && !firing ) {
								fire();
							}
						}
						return this;
					},

					// Remove a callback from the list
					remove: function() {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );

								// Handle firing indexes
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						} );
						return this;
					},

					// Check if a given callback is in the list.
					// If no argument is given, return whether or not list has callbacks attached.
					has: function( fn ) {
						return fn ?
							jQuery.inArray( fn, list ) > -1 :
							list.length > 0;
					},

					// Remove all callbacks from the list
					empty: function() {
						if ( list ) {
							list = [];
						}
						return this;
					},

					// Disable .fire and .add
					// Abort any current/pending executions
					// Clear all callbacks and values
					disable: function() {
						locked = queue = [];
						list = memory = "";
						return this;
					},
					disabled: function() {
						return !list;
					},

					// Disable .fire
					// Also disable .add unless we have memory (since it would have no effect)
					// Abort any pending executions
					lock: function() {
						locked = queue = [];
						if ( !memory && !firing ) {
							list = memory = "";
						}
						return this;
					},
					locked: function() {
						return !!locked;
					},

					// Call all callbacks with the given context and arguments
					fireWith: function( context, args ) {
						if ( !locked ) {
							args = args || [];
							args = [ context, args.slice ? args.slice() : args ];
							queue.push( args );
							if ( !firing ) {
								fire();
							}
						}
						return this;
					},

					// Call all the callbacks with the given arguments
					fire: function() {
						self.fireWith( this, arguments );
						return this;
					},

					// To know if the callbacks have already been called at least once
					fired: function() {
						return !!fired;
					}
				};

			return self;
		};


		function Identity( v ) {
			return v;
		}
		function Thrower( ex ) {
			throw ex;
		}

		function adoptValue( value, resolve, reject, noValue ) {
			var method;

			try {

				// Check for promise aspect first to privilege synchronous behavior
				if ( value && isFunction( ( method = value.promise ) ) ) {
					method.call( value ).done( resolve ).fail( reject );

				// Other thenables
				} else if ( value && isFunction( ( method = value.then ) ) ) {
					method.call( value, resolve, reject );

				// Other non-thenables
				} else {

					// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
					// * false: [ value ].slice( 0 ) => resolve( value )
					// * true: [ value ].slice( 1 ) => resolve()
					resolve.apply( undefined, [ value ].slice( noValue ) );
				}

			// For Promises/A+, convert exceptions into rejections
			// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
			// Deferred#then to conditionally suppress rejection.
			} catch ( value ) {

				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				reject.apply( undefined, [ value ] );
			}
		}

		jQuery.extend( {

			Deferred: function( func ) {
				var tuples = [

						// action, add listener, callbacks,
						// ... .then handlers, argument index, [final state]
						[ "notify", "progress", jQuery.Callbacks( "memory" ),
							jQuery.Callbacks( "memory" ), 2 ],
						[ "resolve", "done", jQuery.Callbacks( "once memory" ),
							jQuery.Callbacks( "once memory" ), 0, "resolved" ],
						[ "reject", "fail", jQuery.Callbacks( "once memory" ),
							jQuery.Callbacks( "once memory" ), 1, "rejected" ]
					],
					state = "pending",
					promise = {
						state: function() {
							return state;
						},
						always: function() {
							deferred.done( arguments ).fail( arguments );
							return this;
						},
						"catch": function( fn ) {
							return promise.then( null, fn );
						},

						// Keep pipe for back-compat
						pipe: function( /* fnDone, fnFail, fnProgress */ ) {
							var fns = arguments;

							return jQuery.Deferred( function( newDefer ) {
								jQuery.each( tuples, function( _i, tuple ) {

									// Map tuples (progress, done, fail) to arguments (done, fail, progress)
									var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

									// deferred.progress(function() { bind to newDefer or newDefer.notify })
									// deferred.done(function() { bind to newDefer or newDefer.resolve })
									// deferred.fail(function() { bind to newDefer or newDefer.reject })
									deferred[ tuple[ 1 ] ]( function() {
										var returned = fn && fn.apply( this, arguments );
										if ( returned && isFunction( returned.promise ) ) {
											returned.promise()
												.progress( newDefer.notify )
												.done( newDefer.resolve )
												.fail( newDefer.reject );
										} else {
											newDefer[ tuple[ 0 ] + "With" ](
												this,
												fn ? [ returned ] : arguments
											);
										}
									} );
								} );
								fns = null;
							} ).promise();
						},
						then: function( onFulfilled, onRejected, onProgress ) {
							var maxDepth = 0;
							function resolve( depth, deferred, handler, special ) {
								return function() {
									var that = this,
										args = arguments,
										mightThrow = function() {
											var returned, then;

											// Support: Promises/A+ section 2.3.3.3.3
											// https://promisesaplus.com/#point-59
											// Ignore double-resolution attempts
											if ( depth < maxDepth ) {
												return;
											}

											returned = handler.apply( that, args );

											// Support: Promises/A+ section 2.3.1
											// https://promisesaplus.com/#point-48
											if ( returned === deferred.promise() ) {
												throw new TypeError( "Thenable self-resolution" );
											}

											// Support: Promises/A+ sections 2.3.3.1, 3.5
											// https://promisesaplus.com/#point-54
											// https://promisesaplus.com/#point-75
											// Retrieve `then` only once
											then = returned &&

												// Support: Promises/A+ section 2.3.4
												// https://promisesaplus.com/#point-64
												// Only check objects and functions for thenability
												( typeof returned === "object" ||
													typeof returned === "function" ) &&
												returned.then;

											// Handle a returned thenable
											if ( isFunction( then ) ) {

												// Special processors (notify) just wait for resolution
												if ( special ) {
													then.call(
														returned,
														resolve( maxDepth, deferred, Identity, special ),
														resolve( maxDepth, deferred, Thrower, special )
													);

												// Normal processors (resolve) also hook into progress
												} else {

													// ...and disregard older resolution values
													maxDepth++;

													then.call(
														returned,
														resolve( maxDepth, deferred, Identity, special ),
														resolve( maxDepth, deferred, Thrower, special ),
														resolve( maxDepth, deferred, Identity,
															deferred.notifyWith )
													);
												}

											// Handle all other returned values
											} else {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Identity ) {
													that = undefined;
													args = [ returned ];
												}

												// Process the value(s)
												// Default process is resolve
												( special || deferred.resolveWith )( that, args );
											}
										},

										// Only normal processors (resolve) catch and reject exceptions
										process = special ?
											mightThrow :
											function() {
												try {
													mightThrow();
												} catch ( e ) {

													if ( jQuery.Deferred.exceptionHook ) {
														jQuery.Deferred.exceptionHook( e,
															process.error );
													}

													// Support: Promises/A+ section 2.3.3.3.4.1
													// https://promisesaplus.com/#point-61
													// Ignore post-resolution exceptions
													if ( depth + 1 >= maxDepth ) {

														// Only substitute handlers pass on context
														// and multiple values (non-spec behavior)
														if ( handler !== Thrower ) {
															that = undefined;
															args = [ e ];
														}

														deferred.rejectWith( that, args );
													}
												}
											};

									// Support: Promises/A+ section 2.3.3.3.1
									// https://promisesaplus.com/#point-57
									// Re-resolve promises immediately to dodge false rejection from
									// subsequent errors
									if ( depth ) {
										process();
									} else {

										// Call an optional hook to record the error, in case of exception
										// since it's otherwise lost when execution goes async
										if ( jQuery.Deferred.getErrorHook ) {
											process.error = jQuery.Deferred.getErrorHook();

										// The deprecated alias of the above. While the name suggests
										// returning the stack, not an error instance, jQuery just passes
										// it directly to `console.warn` so both will work; an instance
										// just better cooperates with source maps.
										} else if ( jQuery.Deferred.getStackHook ) {
											process.error = jQuery.Deferred.getStackHook();
										}
										window.setTimeout( process );
									}
								};
							}

							return jQuery.Deferred( function( newDefer ) {

								// progress_handlers.add( ... )
								tuples[ 0 ][ 3 ].add(
									resolve(
										0,
										newDefer,
										isFunction( onProgress ) ?
											onProgress :
											Identity,
										newDefer.notifyWith
									)
								);

								// fulfilled_handlers.add( ... )
								tuples[ 1 ][ 3 ].add(
									resolve(
										0,
										newDefer,
										isFunction( onFulfilled ) ?
											onFulfilled :
											Identity
									)
								);

								// rejected_handlers.add( ... )
								tuples[ 2 ][ 3 ].add(
									resolve(
										0,
										newDefer,
										isFunction( onRejected ) ?
											onRejected :
											Thrower
									)
								);
							} ).promise();
						},

						// Get a promise for this deferred
						// If obj is provided, the promise aspect is added to the object
						promise: function( obj ) {
							return obj != null ? jQuery.extend( obj, promise ) : promise;
						}
					},
					deferred = {};

				// Add list-specific methods
				jQuery.each( tuples, function( i, tuple ) {
					var list = tuple[ 2 ],
						stateString = tuple[ 5 ];

					// promise.progress = list.add
					// promise.done = list.add
					// promise.fail = list.add
					promise[ tuple[ 1 ] ] = list.add;

					// Handle state
					if ( stateString ) {
						list.add(
							function() {

								// state = "resolved" (i.e., fulfilled)
								// state = "rejected"
								state = stateString;
							},

							// rejected_callbacks.disable
							// fulfilled_callbacks.disable
							tuples[ 3 - i ][ 2 ].disable,

							// rejected_handlers.disable
							// fulfilled_handlers.disable
							tuples[ 3 - i ][ 3 ].disable,

							// progress_callbacks.lock
							tuples[ 0 ][ 2 ].lock,

							// progress_handlers.lock
							tuples[ 0 ][ 3 ].lock
						);
					}

					// progress_handlers.fire
					// fulfilled_handlers.fire
					// rejected_handlers.fire
					list.add( tuple[ 3 ].fire );

					// deferred.notify = function() { deferred.notifyWith(...) }
					// deferred.resolve = function() { deferred.resolveWith(...) }
					// deferred.reject = function() { deferred.rejectWith(...) }
					deferred[ tuple[ 0 ] ] = function() {
						deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
						return this;
					};

					// deferred.notifyWith = list.fireWith
					// deferred.resolveWith = list.fireWith
					// deferred.rejectWith = list.fireWith
					deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
				} );

				// Make the deferred a promise
				promise.promise( deferred );

				// Call given func if any
				if ( func ) {
					func.call( deferred, deferred );
				}

				// All done!
				return deferred;
			},

			// Deferred helper
			when: function( singleValue ) {
				var

					// count of uncompleted subordinates
					remaining = arguments.length,

					// count of unprocessed arguments
					i = remaining,

					// subordinate fulfillment data
					resolveContexts = Array( i ),
					resolveValues = slice.call( arguments ),

					// the primary Deferred
					primary = jQuery.Deferred(),

					// subordinate callback factory
					updateFunc = function( i ) {
						return function( value ) {
							resolveContexts[ i ] = this;
							resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
							if ( !( --remaining ) ) {
								primary.resolveWith( resolveContexts, resolveValues );
							}
						};
					};

				// Single- and empty arguments are adopted like Promise.resolve
				if ( remaining <= 1 ) {
					adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
						!remaining );

					// Use .then() to unwrap secondary thenables (cf. gh-3000)
					if ( primary.state() === "pending" ||
						isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

						return primary.then();
					}
				}

				// Multiple arguments are aggregated like Promise.all array elements
				while ( i-- ) {
					adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
				}

				return primary.promise();
			}
		} );


		// These usually indicate a programmer mistake during development,
		// warn about them ASAP rather than swallowing them by default.
		var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

		// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
		// captured before the async barrier to get the original error cause
		// which may otherwise be hidden.
		jQuery.Deferred.exceptionHook = function( error, asyncError ) {

			// Support: IE 8 - 9 only
			// Console exists when dev tools are open, which can happen at any time
			if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
				window.console.warn( "jQuery.Deferred exception: " + error.message,
					error.stack, asyncError );
			}
		};




		jQuery.readyException = function( error ) {
			window.setTimeout( function() {
				throw error;
			} );
		};




		// The deferred used on DOM ready
		var readyList = jQuery.Deferred();

		jQuery.fn.ready = function( fn ) {

			readyList
				.then( fn )

				// Wrap jQuery.readyException in a function so that the lookup
				// happens at the time of error handling instead of callback
				// registration.
				.catch( function( error ) {
					jQuery.readyException( error );
				} );

			return this;
		};

		jQuery.extend( {

			// Is the DOM ready to be used? Set to true once it occurs.
			isReady: false,

			// A counter to track how many items to wait for before
			// the ready event fires. See trac-6781
			readyWait: 1,

			// Handle when the DOM is ready
			ready: function( wait ) {

				// Abort if there are pending holds or we're already ready
				if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
					return;
				}

				// Remember that the DOM is ready
				jQuery.isReady = true;

				// If a normal DOM Ready event fired, decrement, and wait if need be
				if ( wait !== true && --jQuery.readyWait > 0 ) {
					return;
				}

				// If there are functions bound, to execute
				readyList.resolveWith( document, [ jQuery ] );
			}
		} );

		jQuery.ready.then = readyList.then;

		// The ready event handler and self cleanup method
		function completed() {
			document.removeEventListener( "DOMContentLoaded", completed );
			window.removeEventListener( "load", completed );
			jQuery.ready();
		}

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE <=9 - 10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}




		// Multifunctional method to get and set values of a collection
		// The value/s can optionally be executed if it's a function
		var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
			var i = 0,
				len = elems.length,
				bulk = key == null;

			// Sets many values
			if ( toType( key ) === "object" ) {
				chainable = true;
				for ( i in key ) {
					access( elems, fn, i, key[ i ], true, emptyGet, raw );
				}

			// Sets one value
			} else if ( value !== undefined ) {
				chainable = true;

				if ( !isFunction( value ) ) {
					raw = true;
				}

				if ( bulk ) {

					// Bulk operations run against the entire set
					if ( raw ) {
						fn.call( elems, value );
						fn = null;

					// ...except when executing function values
					} else {
						bulk = fn;
						fn = function( elem, _key, value ) {
							return bulk.call( jQuery( elem ), value );
						};
					}
				}

				if ( fn ) {
					for ( ; i < len; i++ ) {
						fn(
							elems[ i ], key, raw ?
								value :
								value.call( elems[ i ], i, fn( elems[ i ], key ) )
						);
					}
				}
			}

			if ( chainable ) {
				return elems;
			}

			// Gets
			if ( bulk ) {
				return fn.call( elems );
			}

			return len ? fn( elems[ 0 ], key ) : emptyGet;
		};


		// Matches dashed string for camelizing
		var rmsPrefix = /^-ms-/,
			rdashAlpha = /-([a-z])/g;

		// Used by camelCase as callback to replace()
		function fcamelCase( _all, letter ) {
			return letter.toUpperCase();
		}

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 15
		// Microsoft forgot to hump their vendor prefix (trac-9572)
		function camelCase( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		}
		var acceptData = function( owner ) {

			// Accepts only:
			//  - Node
			//    - Node.ELEMENT_NODE
			//    - Node.DOCUMENT_NODE
			//  - Object
			//    - Any
			return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
		};




		function Data() {
			this.expando = jQuery.expando + Data.uid++;
		}

		Data.uid = 1;

		Data.prototype = {

			cache: function( owner ) {

				// Check if the owner object already has a cache
				var value = owner[ this.expando ];

				// If not, create one
				if ( !value ) {
					value = {};

					// We can accept data for non-element nodes in modern browsers,
					// but we should not, see trac-8335.
					// Always return an empty object.
					if ( acceptData( owner ) ) {

						// If it is a node unlikely to be stringify-ed or looped over
						// use plain assignment
						if ( owner.nodeType ) {
							owner[ this.expando ] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
						} else {
							Object.defineProperty( owner, this.expando, {
								value: value,
								configurable: true
							} );
						}
					}
				}

				return value;
			},
			set: function( owner, data, value ) {
				var prop,
					cache = this.cache( owner );

				// Handle: [ owner, key, value ] args
				// Always use camelCase key (gh-2257)
				if ( typeof data === "string" ) {
					cache[ camelCase( data ) ] = value;

				// Handle: [ owner, { properties } ] args
				} else {

					// Copy the properties one-by-one to the cache object
					for ( prop in data ) {
						cache[ camelCase( prop ) ] = data[ prop ];
					}
				}
				return cache;
			},
			get: function( owner, key ) {
				return key === undefined ?
					this.cache( owner ) :

					// Always use camelCase key (gh-2257)
					owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
			},
			access: function( owner, key, value ) {

				// In cases where either:
				//
				//   1. No key was specified
				//   2. A string key was specified, but no value provided
				//
				// Take the "read" path and allow the get method to determine
				// which value to return, respectively either:
				//
				//   1. The entire cache object
				//   2. The data stored at the key
				//
				if ( key === undefined ||
						( ( key && typeof key === "string" ) && value === undefined ) ) {

					return this.get( owner, key );
				}

				// When the key is not a string, or both a key and value
				// are specified, set or extend (existing objects) with either:
				//
				//   1. An object of properties
				//   2. A key and value
				//
				this.set( owner, key, value );

				// Since the "set" path can have two possible entry points
				// return the expected data based on which path was taken[*]
				return value !== undefined ? value : key;
			},
			remove: function( owner, key ) {
				var i,
					cache = owner[ this.expando ];

				if ( cache === undefined ) {
					return;
				}

				if ( key !== undefined ) {

					// Support array or space separated string of keys
					if ( Array.isArray( key ) ) {

						// If key is an array of keys...
						// We always set camelCase keys, so remove that.
						key = key.map( camelCase );
					} else {
						key = camelCase( key );

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						key = key in cache ?
							[ key ] :
							( key.match( rnothtmlwhite ) || [] );
					}

					i = key.length;

					while ( i-- ) {
						delete cache[ key[ i ] ];
					}
				}

				// Remove the expando if there's no more data
				if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

					// Support: Chrome <=35 - 45
					// Webkit & Blink performance suffers when deleting properties
					// from DOM nodes, so set to undefined instead
					// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
					if ( owner.nodeType ) {
						owner[ this.expando ] = undefined;
					} else {
						delete owner[ this.expando ];
					}
				}
			},
			hasData: function( owner ) {
				var cache = owner[ this.expando ];
				return cache !== undefined && !jQuery.isEmptyObject( cache );
			}
		};
		var dataPriv = new Data();

		var dataUser = new Data();



		//	Implementation Summary
		//
		//	1. Enforce API surface and semantic compatibility with 1.9.x branch
		//	2. Improve the module's maintainability by reducing the storage
		//		paths to a single mechanism.
		//	3. Use the same single mechanism to support "private" and "user" data.
		//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
		//	5. Avoid exposing implementation details on user objects (eg. expando properties)
		//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

		var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
			rmultiDash = /[A-Z]/g;

		function getData( data ) {
			if ( data === "true" ) {
				return true;
			}

			if ( data === "false" ) {
				return false;
			}

			if ( data === "null" ) {
				return null;
			}

			// Only convert to a number if it doesn't change the string
			if ( data === +data + "" ) {
				return +data;
			}

			if ( rbrace.test( data ) ) {
				return JSON.parse( data );
			}

			return data;
		}

		function dataAttr( elem, key, data ) {
			var name;

			// If nothing was found internally, try to fetch any
			// data from the HTML5 data-* attribute
			if ( data === undefined && elem.nodeType === 1 ) {
				name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
				data = elem.getAttribute( name );

				if ( typeof data === "string" ) {
					try {
						data = getData( data );
					} catch ( e ) {}

					// Make sure we set the data so it isn't changed later
					dataUser.set( elem, key, data );
				} else {
					data = undefined;
				}
			}
			return data;
		}

		jQuery.extend( {
			hasData: function( elem ) {
				return dataUser.hasData( elem ) || dataPriv.hasData( elem );
			},

			data: function( elem, name, data ) {
				return dataUser.access( elem, name, data );
			},

			removeData: function( elem, name ) {
				dataUser.remove( elem, name );
			},

			// TODO: Now that all calls to _data and _removeData have been replaced
			// with direct calls to dataPriv methods, these can be deprecated.
			_data: function( elem, name, data ) {
				return dataPriv.access( elem, name, data );
			},

			_removeData: function( elem, name ) {
				dataPriv.remove( elem, name );
			}
		} );

		jQuery.fn.extend( {
			data: function( key, value ) {
				var i, name, data,
					elem = this[ 0 ],
					attrs = elem && elem.attributes;

				// Gets all values
				if ( key === undefined ) {
					if ( this.length ) {
						data = dataUser.get( elem );

						if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
							i = attrs.length;
							while ( i-- ) {

								// Support: IE 11 only
								// The attrs elements can be null (trac-14894)
								if ( attrs[ i ] ) {
									name = attrs[ i ].name;
									if ( name.indexOf( "data-" ) === 0 ) {
										name = camelCase( name.slice( 5 ) );
										dataAttr( elem, name, data[ name ] );
									}
								}
							}
							dataPriv.set( elem, "hasDataAttrs", true );
						}
					}

					return data;
				}

				// Sets multiple values
				if ( typeof key === "object" ) {
					return this.each( function() {
						dataUser.set( this, key );
					} );
				}

				return access( this, function( value ) {
					var data;

					// The calling jQuery object (element matches) is not empty
					// (and therefore has an element appears at this[ 0 ]) and the
					// `value` parameter was not undefined. An empty jQuery object
					// will result in `undefined` for elem = this[ 0 ] which will
					// throw an exception if an attempt to read a data cache is made.
					if ( elem && value === undefined ) {

						// Attempt to get data from the cache
						// The key will always be camelCased in Data
						data = dataUser.get( elem, key );
						if ( data !== undefined ) {
							return data;
						}

						// Attempt to "discover" the data in
						// HTML5 custom data-* attrs
						data = dataAttr( elem, key );
						if ( data !== undefined ) {
							return data;
						}

						// We tried really hard, but the data doesn't exist.
						return;
					}

					// Set the data...
					this.each( function() {

						// We always store the camelCased key
						dataUser.set( this, key, value );
					} );
				}, null, value, arguments.length > 1, null, true );
			},

			removeData: function( key ) {
				return this.each( function() {
					dataUser.remove( this, key );
				} );
			}
		} );


		jQuery.extend( {
			queue: function( elem, type, data ) {
				var queue;

				if ( elem ) {
					type = ( type || "fx" ) + "queue";
					queue = dataPriv.get( elem, type );

					// Speed up dequeue by getting out quickly if this is just a lookup
					if ( data ) {
						if ( !queue || Array.isArray( data ) ) {
							queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
						} else {
							queue.push( data );
						}
					}
					return queue || [];
				}
			},

			dequeue: function( elem, type ) {
				type = type || "fx";

				var queue = jQuery.queue( elem, type ),
					startLength = queue.length,
					fn = queue.shift(),
					hooks = jQuery._queueHooks( elem, type ),
					next = function() {
						jQuery.dequeue( elem, type );
					};

				// If the fx queue is dequeued, always remove the progress sentinel
				if ( fn === "inprogress" ) {
					fn = queue.shift();
					startLength--;
				}

				if ( fn ) {

					// Add a progress sentinel to prevent the fx queue from being
					// automatically dequeued
					if ( type === "fx" ) {
						queue.unshift( "inprogress" );
					}

					// Clear up the last queue stop function
					delete hooks.stop;
					fn.call( elem, next, hooks );
				}

				if ( !startLength && hooks ) {
					hooks.empty.fire();
				}
			},

			// Not public - generate a queueHooks object, or return the current one
			_queueHooks: function( elem, type ) {
				var key = type + "queueHooks";
				return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
					empty: jQuery.Callbacks( "once memory" ).add( function() {
						dataPriv.remove( elem, [ type + "queue", key ] );
					} )
				} );
			}
		} );

		jQuery.fn.extend( {
			queue: function( type, data ) {
				var setter = 2;

				if ( typeof type !== "string" ) {
					data = type;
					type = "fx";
					setter--;
				}

				if ( arguments.length < setter ) {
					return jQuery.queue( this[ 0 ], type );
				}

				return data === undefined ?
					this :
					this.each( function() {
						var queue = jQuery.queue( this, type, data );

						// Ensure a hooks for this queue
						jQuery._queueHooks( this, type );

						if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
							jQuery.dequeue( this, type );
						}
					} );
			},
			dequeue: function( type ) {
				return this.each( function() {
					jQuery.dequeue( this, type );
				} );
			},
			clearQueue: function( type ) {
				return this.queue( type || "fx", [] );
			},

			// Get a promise resolved when queues of a certain type
			// are emptied (fx is the type by default)
			promise: function( type, obj ) {
				var tmp,
					count = 1,
					defer = jQuery.Deferred(),
					elements = this,
					i = this.length,
					resolve = function() {
						if ( !( --count ) ) {
							defer.resolveWith( elements, [ elements ] );
						}
					};

				if ( typeof type !== "string" ) {
					obj = type;
					type = undefined;
				}
				type = type || "fx";

				while ( i-- ) {
					tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
					if ( tmp && tmp.empty ) {
						count++;
						tmp.empty.add( resolve );
					}
				}
				resolve();
				return defer.promise( obj );
			}
		} );
		var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

		var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


		var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

		var documentElement = document.documentElement;



			var isAttached = function( elem ) {
					return jQuery.contains( elem.ownerDocument, elem );
				},
				composed = { composed: true };

			// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
			// Check attachment across shadow DOM boundaries when possible (gh-3504)
			// Support: iOS 10.0-10.2 only
			// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
			// leading to errors. We need to check for `getRootNode`.
			if ( documentElement.getRootNode ) {
				isAttached = function( elem ) {
					return jQuery.contains( elem.ownerDocument, elem ) ||
						elem.getRootNode( composed ) === elem.ownerDocument;
				};
			}
		var isHiddenWithinTree = function( elem, el ) {

				// isHiddenWithinTree might be called from jQuery#filter function;
				// in that case, element will be second argument
				elem = el || elem;

				// Inline style trumps all
				return elem.style.display === "none" ||
					elem.style.display === "" &&

					// Otherwise, check computed style
					// Support: Firefox <=43 - 45
					// Disconnected elements can have computed display: none, so first confirm that elem is
					// in the document.
					isAttached( elem ) &&

					jQuery.css( elem, "display" ) === "none";
			};



		function adjustCSS( elem, prop, valueParts, tween ) {
			var adjusted, scale,
				maxIterations = 20,
				currentValue = tween ?
					function() {
						return tween.cur();
					} :
					function() {
						return jQuery.css( elem, prop, "" );
					},
				initial = currentValue(),
				unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				initialInUnit = elem.nodeType &&
					( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
					rcssNum.exec( jQuery.css( elem, prop ) );

			if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

				// Support: Firefox <=54
				// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
				initial = initial / 2;

				// Trust units reported by jQuery.css
				unit = unit || initialInUnit[ 3 ];

				// Iteratively approximate from a nonzero starting point
				initialInUnit = +initial || 1;

				while ( maxIterations-- ) {

					// Evaluate and update our best guess (doubling guesses that zero out).
					// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
					jQuery.style( elem, prop, initialInUnit + unit );
					if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
						maxIterations = 0;
					}
					initialInUnit = initialInUnit / scale;

				}

				initialInUnit = initialInUnit * 2;
				jQuery.style( elem, prop, initialInUnit + unit );

				// Make sure we update the tween properties later on
				valueParts = valueParts || [];
			}

			if ( valueParts ) {
				initialInUnit = +initialInUnit || +initial || 0;

				// Apply relative offset (+=/-=) if specified
				adjusted = valueParts[ 1 ] ?
					initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
					+valueParts[ 2 ];
				if ( tween ) {
					tween.unit = unit;
					tween.start = initialInUnit;
					tween.end = adjusted;
				}
			}
			return adjusted;
		}


		var defaultDisplayMap = {};

		function getDefaultDisplay( elem ) {
			var temp,
				doc = elem.ownerDocument,
				nodeName = elem.nodeName,
				display = defaultDisplayMap[ nodeName ];

			if ( display ) {
				return display;
			}

			temp = doc.body.appendChild( doc.createElement( nodeName ) );
			display = jQuery.css( temp, "display" );

			temp.parentNode.removeChild( temp );

			if ( display === "none" ) {
				display = "block";
			}
			defaultDisplayMap[ nodeName ] = display;

			return display;
		}

		function showHide( elements, show ) {
			var display, elem,
				values = [],
				index = 0,
				length = elements.length;

			// Determine new display value for elements that need to change
			for ( ; index < length; index++ ) {
				elem = elements[ index ];
				if ( !elem.style ) {
					continue;
				}

				display = elem.style.display;
				if ( show ) {

					// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
					// check is required in this first loop unless we have a nonempty display value (either
					// inline or about-to-be-restored)
					if ( display === "none" ) {
						values[ index ] = dataPriv.get( elem, "display" ) || null;
						if ( !values[ index ] ) {
							elem.style.display = "";
						}
					}
					if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
						values[ index ] = getDefaultDisplay( elem );
					}
				} else {
					if ( display !== "none" ) {
						values[ index ] = "none";

						// Remember what we're overwriting
						dataPriv.set( elem, "display", display );
					}
				}
			}

			// Set the display of the elements in a second loop to avoid constant reflow
			for ( index = 0; index < length; index++ ) {
				if ( values[ index ] != null ) {
					elements[ index ].style.display = values[ index ];
				}
			}

			return elements;
		}

		jQuery.fn.extend( {
			show: function() {
				return showHide( this, true );
			},
			hide: function() {
				return showHide( this );
			},
			toggle: function( state ) {
				if ( typeof state === "boolean" ) {
					return state ? this.show() : this.hide();
				}

				return this.each( function() {
					if ( isHiddenWithinTree( this ) ) {
						jQuery( this ).show();
					} else {
						jQuery( this ).hide();
					}
				} );
			}
		} );
		var rcheckableType = ( /^(?:checkbox|radio)$/i );

		var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

		var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



		( function() {
			var fragment = document.createDocumentFragment(),
				div = fragment.appendChild( document.createElement( "div" ) ),
				input = document.createElement( "input" );

			// Support: Android 4.0 - 4.3 only
			// Check state lost if the name is set (trac-11217)
			// Support: Windows Web Apps (WWA)
			// `name` and `type` must use .setAttribute for WWA (trac-14901)
			input.setAttribute( "type", "radio" );
			input.setAttribute( "checked", "checked" );
			input.setAttribute( "name", "t" );

			div.appendChild( input );

			// Support: Android <=4.1 only
			// Older WebKit doesn't clone checked state correctly in fragments
			support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

			// Support: IE <=11 only
			// Make sure textarea (and checkbox) defaultValue is properly cloned
			div.innerHTML = "<textarea>x</textarea>";
			support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

			// Support: IE <=9 only
			// IE <=9 replaces <option> tags with their contents when inserted outside of
			// the select element.
			div.innerHTML = "<option></option>";
			support.option = !!div.lastChild;
		} )();


		// We have to close these tags to support XHTML (trac-13200)
		var wrapMap = {

			// XHTML parsers do not magically insert elements in the
			// same way that tag soup parsers do. So we cannot shorten
			// this by omitting <tbody> or other required elements.
			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

			_default: [ 0, "", "" ]
		};

		wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
		wrapMap.th = wrapMap.td;

		// Support: IE <=9 only
		if ( !support.option ) {
			wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
		}


		function getAll( context, tag ) {

			// Support: IE <=9 - 11 only
			// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
			var ret;

			if ( typeof context.getElementsByTagName !== "undefined" ) {
				ret = context.getElementsByTagName( tag || "*" );

			} else if ( typeof context.querySelectorAll !== "undefined" ) {
				ret = context.querySelectorAll( tag || "*" );

			} else {
				ret = [];
			}

			if ( tag === undefined || tag && nodeName( context, tag ) ) {
				return jQuery.merge( [ context ], ret );
			}

			return ret;
		}


		// Mark scripts as having already been evaluated
		function setGlobalEval( elems, refElements ) {
			var i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				dataPriv.set(
					elems[ i ],
					"globalEval",
					!refElements || dataPriv.get( refElements[ i ], "globalEval" )
				);
			}
		}


		var rhtml = /<|&#?\w+;/;

		function buildFragment( elems, context, scripts, selection, ignored ) {
			var elem, tmp, tag, wrap, attached, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				elem = elems[ i ];

				if ( elem || elem === 0 ) {

					// Add nodes directly
					if ( toType( elem ) === "object" ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );

					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, tmp.childNodes );

						// Remember the top-level container
						tmp = fragment.firstChild;

						// Ensure the created nodes are orphaned (trac-12392)
						tmp.textContent = "";
					}
				}
			}

			// Remove wrapper from fragment
			fragment.textContent = "";

			i = 0;
			while ( ( elem = nodes[ i++ ] ) ) {

				// Skip elements already in the context collection (trac-4087)
				if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
					if ( ignored ) {
						ignored.push( elem );
					}
					continue;
				}

				attached = isAttached( elem );

				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );

				// Preserve script evaluation history
				if ( attached ) {
					setGlobalEval( tmp );
				}

				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( ( elem = tmp[ j++ ] ) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}

			return fragment;
		}


		var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

		function returnTrue() {
			return true;
		}

		function returnFalse() {
			return false;
		}

		function on( elem, types, selector, data, fn, one ) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {

				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {

					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					on( elem, type, selector, data, types[ type ], one );
				}
				return elem;
			}

			if ( data == null && fn == null ) {

				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {

					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {

					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return elem;
			}

			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {

					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};

				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return elem.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			} );
		}

		/*
		 * Helper functions for managing events -- not part of the public interface.
		 * Props to Dean Edwards' addEvent library for many of the ideas.
		 */
		jQuery.event = {

			global: {},

			add: function( elem, types, handler, data, selector ) {

				var handleObjIn, eventHandle, tmp,
					events, t, handleObj,
					special, handlers, type, namespaces, origType,
					elemData = dataPriv.get( elem );

				// Only attach events to objects that accept data
				if ( !acceptData( elem ) ) {
					return;
				}

				// Caller can pass in an object of custom data in lieu of the handler
				if ( handler.handler ) {
					handleObjIn = handler;
					handler = handleObjIn.handler;
					selector = handleObjIn.selector;
				}

				// Ensure that invalid selectors throw exceptions at attach time
				// Evaluate against documentElement in case elem is a non-element node (e.g., document)
				if ( selector ) {
					jQuery.find.matchesSelector( documentElement, selector );
				}

				// Make sure that the handler has a unique ID, used to find/remove it later
				if ( !handler.guid ) {
					handler.guid = jQuery.guid++;
				}

				// Init the element's event structure and main handler, if this is the first
				if ( !( events = elemData.events ) ) {
					events = elemData.events = Object.create( null );
				}
				if ( !( eventHandle = elemData.handle ) ) {
					eventHandle = elemData.handle = function( e ) {

						// Discard the second event of a jQuery.event.trigger() and
						// when an event is called after a page has unloaded
						return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
							jQuery.event.dispatch.apply( elem, arguments ) : undefined;
					};
				}

				// Handle multiple events separated by a space
				types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
				t = types.length;
				while ( t-- ) {
					tmp = rtypenamespace.exec( types[ t ] ) || [];
					type = origType = tmp[ 1 ];
					namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

					// There *must* be a type, no attaching namespace-only handlers
					if ( !type ) {
						continue;
					}

					// If event changes its type, use the special event handlers for the changed type
					special = jQuery.event.special[ type ] || {};

					// If selector defined, determine special event api type, otherwise given type
					type = ( selector ? special.delegateType : special.bindType ) || type;

					// Update special based on newly reset type
					special = jQuery.event.special[ type ] || {};

					// handleObj is passed to all event handlers
					handleObj = jQuery.extend( {
						type: type,
						origType: origType,
						data: data,
						handler: handler,
						guid: handler.guid,
						selector: selector,
						needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
						namespace: namespaces.join( "." )
					}, handleObjIn );

					// Init the event handler queue if we're the first
					if ( !( handlers = events[ type ] ) ) {
						handlers = events[ type ] = [];
						handlers.delegateCount = 0;

						// Only use addEventListener if the special events handler returns false
						if ( !special.setup ||
							special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

							if ( elem.addEventListener ) {
								elem.addEventListener( type, eventHandle );
							}
						}
					}

					if ( special.add ) {
						special.add.call( elem, handleObj );

						if ( !handleObj.handler.guid ) {
							handleObj.handler.guid = handler.guid;
						}
					}

					// Add to the element's handler list, delegates in front
					if ( selector ) {
						handlers.splice( handlers.delegateCount++, 0, handleObj );
					} else {
						handlers.push( handleObj );
					}

					// Keep track of which events have ever been used, for event optimization
					jQuery.event.global[ type ] = true;
				}

			},

			// Detach an event or set of events from an element
			remove: function( elem, types, handler, selector, mappedTypes ) {

				var j, origCount, tmp,
					events, t, handleObj,
					special, handlers, type, namespaces, origType,
					elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

				if ( !elemData || !( events = elemData.events ) ) {
					return;
				}

				// Once for each type.namespace in types; type may be omitted
				types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
				t = types.length;
				while ( t-- ) {
					tmp = rtypenamespace.exec( types[ t ] ) || [];
					type = origType = tmp[ 1 ];
					namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

					// Unbind all events (on this namespace, if provided) for the element
					if ( !type ) {
						for ( type in events ) {
							jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
						}
						continue;
					}

					special = jQuery.event.special[ type ] || {};
					type = ( selector ? special.delegateType : special.bindType ) || type;
					handlers = events[ type ] || [];
					tmp = tmp[ 2 ] &&
						new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

					// Remove matching events
					origCount = j = handlers.length;
					while ( j-- ) {
						handleObj = handlers[ j ];

						if ( ( mappedTypes || origType === handleObj.origType ) &&
							( !handler || handler.guid === handleObj.guid ) &&
							( !tmp || tmp.test( handleObj.namespace ) ) &&
							( !selector || selector === handleObj.selector ||
								selector === "**" && handleObj.selector ) ) {
							handlers.splice( j, 1 );

							if ( handleObj.selector ) {
								handlers.delegateCount--;
							}
							if ( special.remove ) {
								special.remove.call( elem, handleObj );
							}
						}
					}

					// Remove generic event handler if we removed something and no more handlers exist
					// (avoids potential for endless recursion during removal of special event handlers)
					if ( origCount && !handlers.length ) {
						if ( !special.teardown ||
							special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

							jQuery.removeEvent( elem, type, elemData.handle );
						}

						delete events[ type ];
					}
				}

				// Remove data and the expando if it's no longer used
				if ( jQuery.isEmptyObject( events ) ) {
					dataPriv.remove( elem, "handle events" );
				}
			},

			dispatch: function( nativeEvent ) {

				var i, j, ret, matched, handleObj, handlerQueue,
					args = new Array( arguments.length ),

					// Make a writable jQuery.Event from the native event object
					event = jQuery.event.fix( nativeEvent ),

					handlers = (
						dataPriv.get( this, "events" ) || Object.create( null )
					)[ event.type ] || [],
					special = jQuery.event.special[ event.type ] || {};

				// Use the fix-ed jQuery.Event rather than the (read-only) native event
				args[ 0 ] = event;

				for ( i = 1; i < arguments.length; i++ ) {
					args[ i ] = arguments[ i ];
				}

				event.delegateTarget = this;

				// Call the preDispatch hook for the mapped type, and let it bail if desired
				if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
					return;
				}

				// Determine handlers
				handlerQueue = jQuery.event.handlers.call( this, event, handlers );

				// Run delegates first; they may want to stop propagation beneath us
				i = 0;
				while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
					event.currentTarget = matched.elem;

					j = 0;
					while ( ( handleObj = matched.handlers[ j++ ] ) &&
						!event.isImmediatePropagationStopped() ) {

						// If the event is namespaced, then each handler is only invoked if it is
						// specially universal or its namespaces are a superset of the event's.
						if ( !event.rnamespace || handleObj.namespace === false ||
							event.rnamespace.test( handleObj.namespace ) ) {

							event.handleObj = handleObj;
							event.data = handleObj.data;

							ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
								handleObj.handler ).apply( matched.elem, args );

							if ( ret !== undefined ) {
								if ( ( event.result = ret ) === false ) {
									event.preventDefault();
									event.stopPropagation();
								}
							}
						}
					}
				}

				// Call the postDispatch hook for the mapped type
				if ( special.postDispatch ) {
					special.postDispatch.call( this, event );
				}

				return event.result;
			},

			handlers: function( event, handlers ) {
				var i, handleObj, sel, matchedHandlers, matchedSelectors,
					handlerQueue = [],
					delegateCount = handlers.delegateCount,
					cur = event.target;

				// Find delegate handlers
				if ( delegateCount &&

					// Support: IE <=9
					// Black-hole SVG <use> instance trees (trac-13180)
					cur.nodeType &&

					// Support: Firefox <=42
					// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
					// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
					// Support: IE 11 only
					// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
					!( event.type === "click" && event.button >= 1 ) ) {

					for ( ; cur !== this; cur = cur.parentNode || this ) {

						// Don't check non-elements (trac-13208)
						// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
						if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
							matchedHandlers = [];
							matchedSelectors = {};
							for ( i = 0; i < delegateCount; i++ ) {
								handleObj = handlers[ i ];

								// Don't conflict with Object.prototype properties (trac-13203)
								sel = handleObj.selector + " ";

								if ( matchedSelectors[ sel ] === undefined ) {
									matchedSelectors[ sel ] = handleObj.needsContext ?
										jQuery( sel, this ).index( cur ) > -1 :
										jQuery.find( sel, this, null, [ cur ] ).length;
								}
								if ( matchedSelectors[ sel ] ) {
									matchedHandlers.push( handleObj );
								}
							}
							if ( matchedHandlers.length ) {
								handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
							}
						}
					}
				}

				// Add the remaining (directly-bound) handlers
				cur = this;
				if ( delegateCount < handlers.length ) {
					handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
				}

				return handlerQueue;
			},

			addProp: function( name, hook ) {
				Object.defineProperty( jQuery.Event.prototype, name, {
					enumerable: true,
					configurable: true,

					get: isFunction( hook ) ?
						function() {
							if ( this.originalEvent ) {
								return hook( this.originalEvent );
							}
						} :
						function() {
							if ( this.originalEvent ) {
								return this.originalEvent[ name ];
							}
						},

					set: function( value ) {
						Object.defineProperty( this, name, {
							enumerable: true,
							configurable: true,
							writable: true,
							value: value
						} );
					}
				} );
			},

			fix: function( originalEvent ) {
				return originalEvent[ jQuery.expando ] ?
					originalEvent :
					new jQuery.Event( originalEvent );
			},

			special: {
				load: {

					// Prevent triggered image.load events from bubbling to window.load
					noBubble: true
				},
				click: {

					// Utilize native event to ensure correct state for checkable inputs
					setup: function( data ) {

						// For mutual compressibility with _default, replace `this` access with a local var.
						// `|| data` is dead code meant only to preserve the variable through minification.
						var el = this || data;

						// Claim the first handler
						if ( rcheckableType.test( el.type ) &&
							el.click && nodeName( el, "input" ) ) {

							// dataPriv.set( el, "click", ... )
							leverageNative( el, "click", true );
						}

						// Return false to allow normal processing in the caller
						return false;
					},
					trigger: function( data ) {

						// For mutual compressibility with _default, replace `this` access with a local var.
						// `|| data` is dead code meant only to preserve the variable through minification.
						var el = this || data;

						// Force setup before triggering a click
						if ( rcheckableType.test( el.type ) &&
							el.click && nodeName( el, "input" ) ) {

							leverageNative( el, "click" );
						}

						// Return non-false to allow normal event-path propagation
						return true;
					},

					// For cross-browser consistency, suppress native .click() on links
					// Also prevent it if we're currently inside a leveraged native-event stack
					_default: function( event ) {
						var target = event.target;
						return rcheckableType.test( target.type ) &&
							target.click && nodeName( target, "input" ) &&
							dataPriv.get( target, "click" ) ||
							nodeName( target, "a" );
					}
				},

				beforeunload: {
					postDispatch: function( event ) {

						// Support: Firefox 20+
						// Firefox doesn't alert if the returnValue field is not set.
						if ( event.result !== undefined && event.originalEvent ) {
							event.originalEvent.returnValue = event.result;
						}
					}
				}
			}
		};

		// Ensure the presence of an event listener that handles manually-triggered
		// synthetic events by interrupting progress until reinvoked in response to
		// *native* events that it fires directly, ensuring that state changes have
		// already occurred before other listeners are invoked.
		function leverageNative( el, type, isSetup ) {

			// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
			if ( !isSetup ) {
				if ( dataPriv.get( el, type ) === undefined ) {
					jQuery.event.add( el, type, returnTrue );
				}
				return;
			}

			// Register the controller as a special universal handler for all event namespaces
			dataPriv.set( el, type, false );
			jQuery.event.add( el, type, {
				namespace: false,
				handler: function( event ) {
					var result,
						saved = dataPriv.get( this, type );

					if ( ( event.isTrigger & 1 ) && this[ type ] ) {

						// Interrupt processing of the outer synthetic .trigger()ed event
						if ( !saved ) {

							// Store arguments for use when handling the inner native event
							// There will always be at least one argument (an event object), so this array
							// will not be confused with a leftover capture object.
							saved = slice.call( arguments );
							dataPriv.set( this, type, saved );

							// Trigger the native event and capture its result
							this[ type ]();
							result = dataPriv.get( this, type );
							dataPriv.set( this, type, false );

							if ( saved !== result ) {

								// Cancel the outer synthetic event
								event.stopImmediatePropagation();
								event.preventDefault();

								return result;
							}

						// If this is an inner synthetic event for an event with a bubbling surrogate
						// (focus or blur), assume that the surrogate already propagated from triggering
						// the native event and prevent that from happening again here.
						// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
						// bubbling surrogate propagates *after* the non-bubbling base), but that seems
						// less bad than duplication.
						} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
							event.stopPropagation();
						}

					// If this is a native event triggered above, everything is now in order
					// Fire an inner synthetic event with the original arguments
					} else if ( saved ) {

						// ...and capture the result
						dataPriv.set( this, type, jQuery.event.trigger(
							saved[ 0 ],
							saved.slice( 1 ),
							this
						) );

						// Abort handling of the native event by all jQuery handlers while allowing
						// native handlers on the same element to run. On target, this is achieved
						// by stopping immediate propagation just on the jQuery event. However,
						// the native event is re-wrapped by a jQuery one on each level of the
						// propagation so the only way to stop it for jQuery is to stop it for
						// everyone via native `stopPropagation()`. This is not a problem for
						// focus/blur which don't bubble, but it does also stop click on checkboxes
						// and radios. We accept this limitation.
						event.stopPropagation();
						event.isImmediatePropagationStopped = returnTrue;
					}
				}
			} );
		}

		jQuery.removeEvent = function( elem, type, handle ) {

			// This "if" is needed for plain objects
			if ( elem.removeEventListener ) {
				elem.removeEventListener( type, handle );
			}
		};

		jQuery.Event = function( src, props ) {

			// Allow instantiation without the 'new' keyword
			if ( !( this instanceof jQuery.Event ) ) {
				return new jQuery.Event( src, props );
			}

			// Event object
			if ( src && src.type ) {
				this.originalEvent = src;
				this.type = src.type;

				// Events bubbling up the document may have been marked as prevented
				// by a handler lower down the tree; reflect the correct value.
				this.isDefaultPrevented = src.defaultPrevented ||
						src.defaultPrevented === undefined &&

						// Support: Android <=2.3 only
						src.returnValue === false ?
					returnTrue :
					returnFalse;

				// Create target properties
				// Support: Safari <=6 - 7 only
				// Target should not be a text node (trac-504, trac-13143)
				this.target = ( src.target && src.target.nodeType === 3 ) ?
					src.target.parentNode :
					src.target;

				this.currentTarget = src.currentTarget;
				this.relatedTarget = src.relatedTarget;

			// Event type
			} else {
				this.type = src;
			}

			// Put explicitly provided properties onto the event object
			if ( props ) {
				jQuery.extend( this, props );
			}

			// Create a timestamp if incoming event doesn't have one
			this.timeStamp = src && src.timeStamp || Date.now();

			// Mark it as fixed
			this[ jQuery.expando ] = true;
		};

		// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
		// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
		jQuery.Event.prototype = {
			constructor: jQuery.Event,
			isDefaultPrevented: returnFalse,
			isPropagationStopped: returnFalse,
			isImmediatePropagationStopped: returnFalse,
			isSimulated: false,

			preventDefault: function() {
				var e = this.originalEvent;

				this.isDefaultPrevented = returnTrue;

				if ( e && !this.isSimulated ) {
					e.preventDefault();
				}
			},
			stopPropagation: function() {
				var e = this.originalEvent;

				this.isPropagationStopped = returnTrue;

				if ( e && !this.isSimulated ) {
					e.stopPropagation();
				}
			},
			stopImmediatePropagation: function() {
				var e = this.originalEvent;

				this.isImmediatePropagationStopped = returnTrue;

				if ( e && !this.isSimulated ) {
					e.stopImmediatePropagation();
				}

				this.stopPropagation();
			}
		};

		// Includes all common event props including KeyEvent and MouseEvent specific props
		jQuery.each( {
			altKey: true,
			bubbles: true,
			cancelable: true,
			changedTouches: true,
			ctrlKey: true,
			detail: true,
			eventPhase: true,
			metaKey: true,
			pageX: true,
			pageY: true,
			shiftKey: true,
			view: true,
			"char": true,
			code: true,
			charCode: true,
			key: true,
			keyCode: true,
			button: true,
			buttons: true,
			clientX: true,
			clientY: true,
			offsetX: true,
			offsetY: true,
			pointerId: true,
			pointerType: true,
			screenX: true,
			screenY: true,
			targetTouches: true,
			toElement: true,
			touches: true,
			which: true
		}, jQuery.event.addProp );

		jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

			function focusMappedHandler( nativeEvent ) {
				if ( document.documentMode ) {

					// Support: IE 11+
					// Attach a single focusin/focusout handler on the document while someone wants
					// focus/blur. This is because the former are synchronous in IE while the latter
					// are async. In other browsers, all those handlers are invoked synchronously.

					// `handle` from private data would already wrap the event, but we need
					// to change the `type` here.
					var handle = dataPriv.get( this, "handle" ),
						event = jQuery.event.fix( nativeEvent );
					event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
					event.isSimulated = true;

					// First, handle focusin/focusout
					handle( nativeEvent );

					// ...then, handle focus/blur
					//
					// focus/blur don't bubble while focusin/focusout do; simulate the former by only
					// invoking the handler at the lower level.
					if ( event.target === event.currentTarget ) {

						// The setup part calls `leverageNative`, which, in turn, calls
						// `jQuery.event.add`, so event handle will already have been set
						// by this point.
						handle( event );
					}
				} else {

					// For non-IE browsers, attach a single capturing handler on the document
					// while someone wants focusin/focusout.
					jQuery.event.simulate( delegateType, nativeEvent.target,
						jQuery.event.fix( nativeEvent ) );
				}
			}

			jQuery.event.special[ type ] = {

				// Utilize native event if possible so blur/focus sequence is correct
				setup: function() {

					var attaches;

					// Claim the first handler
					// dataPriv.set( this, "focus", ... )
					// dataPriv.set( this, "blur", ... )
					leverageNative( this, type, true );

					if ( document.documentMode ) {

						// Support: IE 9 - 11+
						// We use the same native handler for focusin & focus (and focusout & blur)
						// so we need to coordinate setup & teardown parts between those events.
						// Use `delegateType` as the key as `type` is already used by `leverageNative`.
						attaches = dataPriv.get( this, delegateType );
						if ( !attaches ) {
							this.addEventListener( delegateType, focusMappedHandler );
						}
						dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
					} else {

						// Return false to allow normal processing in the caller
						return false;
					}
				},
				trigger: function() {

					// Force setup before trigger
					leverageNative( this, type );

					// Return non-false to allow normal event-path propagation
					return true;
				},

				teardown: function() {
					var attaches;

					if ( document.documentMode ) {
						attaches = dataPriv.get( this, delegateType ) - 1;
						if ( !attaches ) {
							this.removeEventListener( delegateType, focusMappedHandler );
							dataPriv.remove( this, delegateType );
						} else {
							dataPriv.set( this, delegateType, attaches );
						}
					} else {

						// Return false to indicate standard teardown should be applied
						return false;
					}
				},

				// Suppress native focus or blur if we're currently inside
				// a leveraged native-event stack
				_default: function( event ) {
					return dataPriv.get( event.target, type );
				},

				delegateType: delegateType
			};

			// Support: Firefox <=44
			// Firefox doesn't have focus(in | out) events
			// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
			//
			// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
			// focus(in | out) events fire after focus & blur events,
			// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
			// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
			//
			// Support: IE 9 - 11+
			// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
			// attach a single handler for both events in IE.
			jQuery.event.special[ delegateType ] = {
				setup: function() {

					// Handle: regular nodes (via `this.ownerDocument`), window
					// (via `this.document`) & document (via `this`).
					var doc = this.ownerDocument || this.document || this,
						dataHolder = document.documentMode ? this : doc,
						attaches = dataPriv.get( dataHolder, delegateType );

					// Support: IE 9 - 11+
					// We use the same native handler for focusin & focus (and focusout & blur)
					// so we need to coordinate setup & teardown parts between those events.
					// Use `delegateType` as the key as `type` is already used by `leverageNative`.
					if ( !attaches ) {
						if ( document.documentMode ) {
							this.addEventListener( delegateType, focusMappedHandler );
						} else {
							doc.addEventListener( type, focusMappedHandler, true );
						}
					}
					dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this.document || this,
						dataHolder = document.documentMode ? this : doc,
						attaches = dataPriv.get( dataHolder, delegateType ) - 1;

					if ( !attaches ) {
						if ( document.documentMode ) {
							this.removeEventListener( delegateType, focusMappedHandler );
						} else {
							doc.removeEventListener( type, focusMappedHandler, true );
						}
						dataPriv.remove( dataHolder, delegateType );
					} else {
						dataPriv.set( dataHolder, delegateType, attaches );
					}
				}
			};
		} );

		// Create mouseenter/leave events using mouseover/out and event-time checks
		// so that event delegation works in jQuery.
		// Do the same for pointerenter/pointerleave and pointerover/pointerout
		//
		// Support: Safari 7 only
		// Safari sends mouseenter too often; see:
		// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
		// for the description of the bug (it existed in older Chrome versions as well).
		jQuery.each( {
			mouseenter: "mouseover",
			mouseleave: "mouseout",
			pointerenter: "pointerover",
			pointerleave: "pointerout"
		}, function( orig, fix ) {
			jQuery.event.special[ orig ] = {
				delegateType: fix,
				bindType: fix,

				handle: function( event ) {
					var ret,
						target = this,
						related = event.relatedTarget,
						handleObj = event.handleObj;

					// For mouseenter/leave call the handler if related is outside the target.
					// NB: No relatedTarget if the mouse left/entered the browser window
					if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
						event.type = handleObj.origType;
						ret = handleObj.handler.apply( this, arguments );
						event.type = fix;
					}
					return ret;
				}
			};
		} );

		jQuery.fn.extend( {

			on: function( types, selector, data, fn ) {
				return on( this, types, selector, data, fn );
			},
			one: function( types, selector, data, fn ) {
				return on( this, types, selector, data, fn, 1 );
			},
			off: function( types, selector, fn ) {
				var handleObj, type;
				if ( types && types.preventDefault && types.handleObj ) {

					// ( event )  dispatched jQuery.Event
					handleObj = types.handleObj;
					jQuery( types.delegateTarget ).off(
						handleObj.namespace ?
							handleObj.origType + "." + handleObj.namespace :
							handleObj.origType,
						handleObj.selector,
						handleObj.handler
					);
					return this;
				}
				if ( typeof types === "object" ) {

					// ( types-object [, selector] )
					for ( type in types ) {
						this.off( type, selector, types[ type ] );
					}
					return this;
				}
				if ( selector === false || typeof selector === "function" ) {

					// ( types [, fn] )
					fn = selector;
					selector = undefined;
				}
				if ( fn === false ) {
					fn = returnFalse;
				}
				return this.each( function() {
					jQuery.event.remove( this, types, fn, selector );
				} );
			}
		} );


		var

			// Support: IE <=10 - 11, Edge 12 - 13 only
			// In IE/Edge using regex groups here causes severe slowdowns.
			// See https://connect.microsoft.com/IE/feedback/details/1736512/
			rnoInnerhtml = /<script|<style|<link/i,

			// checked="checked" or checked
			rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

			rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

		// Prefer a tbody over its parent table for containing new rows
		function manipulationTarget( elem, content ) {
			if ( nodeName( elem, "table" ) &&
				nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

				return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
			}

			return elem;
		}

		// Replace/restore the type attribute of script elements for safe DOM manipulation
		function disableScript( elem ) {
			elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
			return elem;
		}
		function restoreScript( elem ) {
			if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
				elem.type = elem.type.slice( 5 );
			} else {
				elem.removeAttribute( "type" );
			}

			return elem;
		}

		function cloneCopyEvent( src, dest ) {
			var i, l, type, pdataOld, udataOld, udataCur, events;

			if ( dest.nodeType !== 1 ) {
				return;
			}

			// 1. Copy private data: events, handlers, etc.
			if ( dataPriv.hasData( src ) ) {
				pdataOld = dataPriv.get( src );
				events = pdataOld.events;

				if ( events ) {
					dataPriv.remove( dest, "handle events" );

					for ( type in events ) {
						for ( i = 0, l = events[ type ].length; i < l; i++ ) {
							jQuery.event.add( dest, type, events[ type ][ i ] );
						}
					}
				}
			}

			// 2. Copy user data
			if ( dataUser.hasData( src ) ) {
				udataOld = dataUser.access( src );
				udataCur = jQuery.extend( {}, udataOld );

				dataUser.set( dest, udataCur );
			}
		}

		// Fix IE bugs, see support tests
		function fixInput( src, dest ) {
			var nodeName = dest.nodeName.toLowerCase();

			// Fails to persist the checked state of a cloned checkbox or radio button.
			if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
				dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
			} else if ( nodeName === "input" || nodeName === "textarea" ) {
				dest.defaultValue = src.defaultValue;
			}
		}

		function domManip( collection, args, callback, ignored ) {

			// Flatten any nested arrays
			args = flat( args );

			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = collection.length,
				iNoClone = l - 1,
				value = args[ 0 ],
				valueIsFunction = isFunction( value );

			// We can't cloneNode fragments that contain checked, in WebKit
			if ( valueIsFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return collection.each( function( index ) {
					var self = collection.eq( index );
					if ( valueIsFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					domManip( self, args, callback, ignored );
				} );
			}

			if ( l ) {
				fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
				first = fragment.firstChild;

				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}

				// Require either new content or an interest in ignored elements to invoke the callback
				if ( first || ignored ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;

					// Use the original fragment for the last item
					// instead of the first because it can end up
					// being emptied incorrectly in certain situations (trac-8070).
					for ( ; i < l; i++ ) {
						node = fragment;

						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );

							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {

								// Support: Android <=4.0 only, PhantomJS 1 only
								// push.apply(_, arraylike) throws on ancient WebKit
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}

						callback.call( collection[ i ], node, i );
					}

					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;

						// Re-enable scripts
						jQuery.map( scripts, restoreScript );

						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!dataPriv.access( node, "globalEval" ) &&
								jQuery.contains( doc, node ) ) {

								if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl && !node.noModule ) {
										jQuery._evalUrl( node.src, {
											nonce: node.nonce || node.getAttribute( "nonce" )
										}, doc );
									}
								} else {

									// Unwrap a CDATA section containing script contents. This shouldn't be
									// needed as in XML documents they're already not visible when
									// inspecting element contents and in HTML documents they have no
									// meaning but we're preserving that logic for backwards compatibility.
									// This will be removed completely in 4.0. See gh-4904.
									DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
								}
							}
						}
					}
				}
			}

			return collection;
		}

		function remove( elem, selector, keepData ) {
			var node,
				nodes = selector ? jQuery.filter( selector, elem ) : elem,
				i = 0;

			for ( ; ( node = nodes[ i ] ) != null; i++ ) {
				if ( !keepData && node.nodeType === 1 ) {
					jQuery.cleanData( getAll( node ) );
				}

				if ( node.parentNode ) {
					if ( keepData && isAttached( node ) ) {
						setGlobalEval( getAll( node, "script" ) );
					}
					node.parentNode.removeChild( node );
				}
			}

			return elem;
		}

		jQuery.extend( {
			htmlPrefilter: function( html ) {
				return html;
			},

			clone: function( elem, dataAndEvents, deepDataAndEvents ) {
				var i, l, srcElements, destElements,
					clone = elem.cloneNode( true ),
					inPage = isAttached( elem );

				// Fix IE cloning issues
				if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
						!jQuery.isXMLDoc( elem ) ) {

					// We eschew jQuery#find here for performance reasons:
					// https://jsperf.com/getall-vs-sizzle/2
					destElements = getAll( clone );
					srcElements = getAll( elem );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						fixInput( srcElements[ i ], destElements[ i ] );
					}
				}

				// Copy the events from the original to the clone
				if ( dataAndEvents ) {
					if ( deepDataAndEvents ) {
						srcElements = srcElements || getAll( elem );
						destElements = destElements || getAll( clone );

						for ( i = 0, l = srcElements.length; i < l; i++ ) {
							cloneCopyEvent( srcElements[ i ], destElements[ i ] );
						}
					} else {
						cloneCopyEvent( elem, clone );
					}
				}

				// Preserve script evaluation history
				destElements = getAll( clone, "script" );
				if ( destElements.length > 0 ) {
					setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
				}

				// Return the cloned set
				return clone;
			},

			cleanData: function( elems ) {
				var data, elem, type,
					special = jQuery.event.special,
					i = 0;

				for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
					if ( acceptData( elem ) ) {
						if ( ( data = elem[ dataPriv.expando ] ) ) {
							if ( data.events ) {
								for ( type in data.events ) {
									if ( special[ type ] ) {
										jQuery.event.remove( elem, type );

									// This is a shortcut to avoid jQuery.event.remove's overhead
									} else {
										jQuery.removeEvent( elem, type, data.handle );
									}
								}
							}

							// Support: Chrome <=35 - 45+
							// Assign undefined instead of using delete, see Data#remove
							elem[ dataPriv.expando ] = undefined;
						}
						if ( elem[ dataUser.expando ] ) {

							// Support: Chrome <=35 - 45+
							// Assign undefined instead of using delete, see Data#remove
							elem[ dataUser.expando ] = undefined;
						}
					}
				}
			}
		} );

		jQuery.fn.extend( {
			detach: function( selector ) {
				return remove( this, selector, true );
			},

			remove: function( selector ) {
				return remove( this, selector );
			},

			text: function( value ) {
				return access( this, function( value ) {
					return value === undefined ?
						jQuery.text( this ) :
						this.empty().each( function() {
							if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
								this.textContent = value;
							}
						} );
				}, null, value, arguments.length );
			},

			append: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						var target = manipulationTarget( this, elem );
						target.appendChild( elem );
					}
				} );
			},

			prepend: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						var target = manipulationTarget( this, elem );
						target.insertBefore( elem, target.firstChild );
					}
				} );
			},

			before: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.parentNode ) {
						this.parentNode.insertBefore( elem, this );
					}
				} );
			},

			after: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.parentNode ) {
						this.parentNode.insertBefore( elem, this.nextSibling );
					}
				} );
			},

			empty: function() {
				var elem,
					i = 0;

				for ( ; ( elem = this[ i ] ) != null; i++ ) {
					if ( elem.nodeType === 1 ) {

						// Prevent memory leaks
						jQuery.cleanData( getAll( elem, false ) );

						// Remove any remaining nodes
						elem.textContent = "";
					}
				}

				return this;
			},

			clone: function( dataAndEvents, deepDataAndEvents ) {
				dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
				deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

				return this.map( function() {
					return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
				} );
			},

			html: function( value ) {
				return access( this, function( value ) {
					var elem = this[ 0 ] || {},
						i = 0,
						l = this.length;

					if ( value === undefined && elem.nodeType === 1 ) {
						return elem.innerHTML;
					}

					// See if we can take a shortcut and just use innerHTML
					if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
						!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

						value = jQuery.htmlPrefilter( value );

						try {
							for ( ; i < l; i++ ) {
								elem = this[ i ] || {};

								// Remove element nodes and prevent memory leaks
								if ( elem.nodeType === 1 ) {
									jQuery.cleanData( getAll( elem, false ) );
									elem.innerHTML = value;
								}
							}

							elem = 0;

						// If using innerHTML throws an exception, use the fallback method
						} catch ( e ) {}
					}

					if ( elem ) {
						this.empty().append( value );
					}
				}, null, value, arguments.length );
			},

			replaceWith: function() {
				var ignored = [];

				// Make the changes, replacing each non-ignored context element with the new content
				return domManip( this, arguments, function( elem ) {
					var parent = this.parentNode;

					if ( jQuery.inArray( this, ignored ) < 0 ) {
						jQuery.cleanData( getAll( this ) );
						if ( parent ) {
							parent.replaceChild( elem, this );
						}
					}

				// Force callback invocation
				}, ignored );
			}
		} );

		jQuery.each( {
			appendTo: "append",
			prependTo: "prepend",
			insertBefore: "before",
			insertAfter: "after",
			replaceAll: "replaceWith"
		}, function( name, original ) {
			jQuery.fn[ name ] = function( selector ) {
				var elems,
					ret = [],
					insert = jQuery( selector ),
					last = insert.length - 1,
					i = 0;

				for ( ; i <= last; i++ ) {
					elems = i === last ? this : this.clone( true );
					jQuery( insert[ i ] )[ original ]( elems );

					// Support: Android <=4.0 only, PhantomJS 1 only
					// .get() because push.apply(_, arraylike) throws on ancient WebKit
					push.apply( ret, elems.get() );
				}

				return this.pushStack( ret );
			};
		} );
		var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

		var rcustomProp = /^--/;


		var getStyles = function( elem ) {

				// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
				// IE throws on elements created in popups
				// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
				var view = elem.ownerDocument.defaultView;

				if ( !view || !view.opener ) {
					view = window;
				}

				return view.getComputedStyle( elem );
			};

		var swap = function( elem, options, callback ) {
			var ret, name,
				old = {};

			// Remember the old values, and insert the new ones
			for ( name in options ) {
				old[ name ] = elem.style[ name ];
				elem.style[ name ] = options[ name ];
			}

			ret = callback.call( elem );

			// Revert the old values
			for ( name in options ) {
				elem.style[ name ] = old[ name ];
			}

			return ret;
		};


		var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



		( function() {

			// Executing both pixelPosition & boxSizingReliable tests require only one layout
			// so they're executed at the same time to save the second computation.
			function computeStyleTests() {

				// This is a singleton, we need to execute it only once
				if ( !div ) {
					return;
				}

				container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
					"margin-top:1px;padding:0;border:0";
				div.style.cssText =
					"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
					"margin:auto;border:1px;padding:1px;" +
					"width:60%;top:1%";
				documentElement.appendChild( container ).appendChild( div );

				var divStyle = window.getComputedStyle( div );
				pixelPositionVal = divStyle.top !== "1%";

				// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
				reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

				// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
				// Some styles come back with percentage values, even though they shouldn't
				div.style.right = "60%";
				pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

				// Support: IE 9 - 11 only
				// Detect misreporting of content dimensions for box-sizing:border-box elements
				boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

				// Support: IE 9 only
				// Detect overflow:scroll screwiness (gh-3699)
				// Support: Chrome <=64
				// Don't get tricked when zoom affects offsetWidth (gh-4029)
				div.style.position = "absolute";
				scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

				documentElement.removeChild( container );

				// Nullify the div so it wouldn't be stored in the memory and
				// it will also be a sign that checks already performed
				div = null;
			}

			function roundPixelMeasures( measure ) {
				return Math.round( parseFloat( measure ) );
			}

			var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
				reliableTrDimensionsVal, reliableMarginLeftVal,
				container = document.createElement( "div" ),
				div = document.createElement( "div" );

			// Finish early in limited (non-browser) environments
			if ( !div.style ) {
				return;
			}

			// Support: IE <=9 - 11 only
			// Style of cloned element affects source element cloned (trac-8908)
			div.style.backgroundClip = "content-box";
			div.cloneNode( true ).style.backgroundClip = "";
			support.clearCloneStyle = div.style.backgroundClip === "content-box";

			jQuery.extend( support, {
				boxSizingReliable: function() {
					computeStyleTests();
					return boxSizingReliableVal;
				},
				pixelBoxStyles: function() {
					computeStyleTests();
					return pixelBoxStylesVal;
				},
				pixelPosition: function() {
					computeStyleTests();
					return pixelPositionVal;
				},
				reliableMarginLeft: function() {
					computeStyleTests();
					return reliableMarginLeftVal;
				},
				scrollboxSize: function() {
					computeStyleTests();
					return scrollboxSizeVal;
				},

				// Support: IE 9 - 11+, Edge 15 - 18+
				// IE/Edge misreport `getComputedStyle` of table rows with width/height
				// set in CSS while `offset*` properties report correct values.
				// Behavior in IE 9 is more subtle than in newer versions & it passes
				// some versions of this test; make sure not to make it pass there!
				//
				// Support: Firefox 70+
				// Only Firefox includes border widths
				// in computed dimensions. (gh-4529)
				reliableTrDimensions: function() {
					var table, tr, trChild, trStyle;
					if ( reliableTrDimensionsVal == null ) {
						table = document.createElement( "table" );
						tr = document.createElement( "tr" );
						trChild = document.createElement( "div" );

						table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
						tr.style.cssText = "box-sizing:content-box;border:1px solid";

						// Support: Chrome 86+
						// Height set through cssText does not get applied.
						// Computed height then comes back as 0.
						tr.style.height = "1px";
						trChild.style.height = "9px";

						// Support: Android 8 Chrome 86+
						// In our bodyBackground.html iframe,
						// display for all div elements is set to "inline",
						// which causes a problem only in Android 8 Chrome 86.
						// Ensuring the div is `display: block`
						// gets around this issue.
						trChild.style.display = "block";

						documentElement
							.appendChild( table )
							.appendChild( tr )
							.appendChild( trChild );

						trStyle = window.getComputedStyle( tr );
						reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
							parseInt( trStyle.borderTopWidth, 10 ) +
							parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

						documentElement.removeChild( table );
					}
					return reliableTrDimensionsVal;
				}
			} );
		} )();


		function curCSS( elem, name, computed ) {
			var width, minWidth, maxWidth, ret,
				isCustomProp = rcustomProp.test( name ),

				// Support: Firefox 51+
				// Retrieving style before computed somehow
				// fixes an issue with getting wrong values
				// on detached elements
				style = elem.style;

			computed = computed || getStyles( elem );

			// getPropertyValue is needed for:
			//   .css('filter') (IE 9 only, trac-12537)
			//   .css('--customProperty) (gh-3144)
			if ( computed ) {

				// Support: IE <=9 - 11+
				// IE only supports `"float"` in `getPropertyValue`; in computed styles
				// it's only available as `"cssFloat"`. We no longer modify properties
				// sent to `.css()` apart from camelCasing, so we need to check both.
				// Normally, this would create difference in behavior: if
				// `getPropertyValue` returns an empty string, the value returned
				// by `.css()` would be `undefined`. This is usually the case for
				// disconnected elements. However, in IE even disconnected elements
				// with no styles return `"none"` for `getPropertyValue( "float" )`
				ret = computed.getPropertyValue( name ) || computed[ name ];

				if ( isCustomProp && ret ) {

					// Support: Firefox 105+, Chrome <=105+
					// Spec requires trimming whitespace for custom properties (gh-4926).
					// Firefox only trims leading whitespace. Chrome just collapses
					// both leading & trailing whitespace to a single space.
					//
					// Fall back to `undefined` if empty string returned.
					// This collapses a missing definition with property defined
					// and set to an empty string but there's no standard API
					// allowing us to differentiate them without a performance penalty
					// and returning `undefined` aligns with older jQuery.
					//
					// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
					// as whitespace while CSS does not, but this is not a problem
					// because CSS preprocessing replaces them with U+000A LINE FEED
					// (which *is* CSS whitespace)
					// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
					ret = ret.replace( rtrimCSS, "$1" ) || undefined;
				}

				if ( ret === "" && !isAttached( elem ) ) {
					ret = jQuery.style( elem, name );
				}

				// A tribute to the "awesome hack by Dean Edwards"
				// Android Browser returns percentage for some values,
				// but width seems to be reliably pixels.
				// This is against the CSSOM draft spec:
				// https://drafts.csswg.org/cssom/#resolved-values
				if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

					// Remember the original values
					width = style.width;
					minWidth = style.minWidth;
					maxWidth = style.maxWidth;

					// Put in the new values to get a computed value out
					style.minWidth = style.maxWidth = style.width = ret;
					ret = computed.width;

					// Revert the changed values
					style.width = width;
					style.minWidth = minWidth;
					style.maxWidth = maxWidth;
				}
			}

			return ret !== undefined ?

				// Support: IE <=9 - 11 only
				// IE returns zIndex value as an integer.
				ret + "" :
				ret;
		}


		function addGetHookIf( conditionFn, hookFn ) {

			// Define the hook, we'll check on the first run if it's really needed.
			return {
				get: function() {
					if ( conditionFn() ) {

						// Hook not needed (or it's not possible to use it due
						// to missing dependency), remove it.
						delete this.get;
						return;
					}

					// Hook needed; redefine it so that the support test is not executed again.
					return ( this.get = hookFn ).apply( this, arguments );
				}
			};
		}


		var cssPrefixes = [ "Webkit", "Moz", "ms" ],
			emptyStyle = document.createElement( "div" ).style,
			vendorProps = {};

		// Return a vendor-prefixed property or undefined
		function vendorPropName( name ) {

			// Check for vendor prefixed names
			var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
				i = cssPrefixes.length;

			while ( i-- ) {
				name = cssPrefixes[ i ] + capName;
				if ( name in emptyStyle ) {
					return name;
				}
			}
		}

		// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
		function finalPropName( name ) {
			var final = jQuery.cssProps[ name ] || vendorProps[ name ];

			if ( final ) {
				return final;
			}
			if ( name in emptyStyle ) {
				return name;
			}
			return vendorProps[ name ] = vendorPropName( name ) || name;
		}


		var

			// Swappable if display is none or starts with table
			// except "table", "table-cell", or "table-caption"
			// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
			rdisplayswap = /^(none|table(?!-c[ea]).+)/,
			cssShow = { position: "absolute", visibility: "hidden", display: "block" },
			cssNormalTransform = {
				letterSpacing: "0",
				fontWeight: "400"
			};

		function setPositiveNumber( _elem, value, subtract ) {

			// Any relative (+/-) values have already been
			// normalized at this point
			var matches = rcssNum.exec( value );
			return matches ?

				// Guard against undefined "subtract", e.g., when used as in cssHooks
				Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
				value;
		}

		function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
			var i = dimension === "width" ? 1 : 0,
				extra = 0,
				delta = 0,
				marginDelta = 0;

			// Adjustment may not be necessary
			if ( box === ( isBorderBox ? "border" : "content" ) ) {
				return 0;
			}

			for ( ; i < 4; i += 2 ) {

				// Both box models exclude margin
				// Count margin delta separately to only add it after scroll gutter adjustment.
				// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
				if ( box === "margin" ) {
					marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
				}

				// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
				if ( !isBorderBox ) {

					// Add padding
					delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

					// For "border" or "margin", add border
					if ( box !== "padding" ) {
						delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

					// But still keep track of it otherwise
					} else {
						extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
					}

				// If we get here with a border-box (content + padding + border), we're seeking "content" or
				// "padding" or "margin"
				} else {

					// For "content", subtract padding
					if ( box === "content" ) {
						delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
					}

					// For "content" or "padding", subtract border
					if ( box !== "margin" ) {
						delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
					}
				}
			}

			// Account for positive content-box scroll gutter when requested by providing computedVal
			if ( !isBorderBox && computedVal >= 0 ) {

				// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
				// Assuming integer scroll gutter, subtract the rest and round down
				delta += Math.max( 0, Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					computedVal -
					delta -
					extra -
					0.5

				// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
				// Use an explicit zero to avoid NaN (gh-3964)
				) ) || 0;
			}

			return delta + marginDelta;
		}

		function getWidthOrHeight( elem, dimension, extra ) {

			// Start with computed style
			var styles = getStyles( elem ),

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
				// Fake content-box until we know it's needed to know the true value.
				boxSizingNeeded = !support.boxSizingReliable() || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				valueIsBorderBox = isBorderBox,

				val = curCSS( elem, dimension, styles ),
				offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

			// Support: Firefox <=54
			// Return a confounding non-pixel value or feign ignorance, as appropriate.
			if ( rnumnonpx.test( val ) ) {
				if ( !extra ) {
					return val;
				}
				val = "auto";
			}


			// Support: IE 9 - 11 only
			// Use offsetWidth/offsetHeight for when box sizing is unreliable.
			// In those cases, the computed value can be trusted to be border-box.
			if ( ( !support.boxSizingReliable() && isBorderBox ||

				// Support: IE 10 - 11+, Edge 15 - 18+
				// IE/Edge misreport `getComputedStyle` of table rows with width/height
				// set in CSS while `offset*` properties report correct values.
				// Interestingly, in some cases IE 9 doesn't suffer from this issue.
				!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

				// Fall back to offsetWidth/offsetHeight when value is "auto"
				// This happens for inline elements with no explicit setting (gh-3571)
				val === "auto" ||

				// Support: Android <=4.1 - 4.3 only
				// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
				!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

				// Make sure the element is visible & connected
				elem.getClientRects().length ) {

				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

				// Where available, offsetWidth/offsetHeight approximate border box dimensions.
				// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
				// retrieved value as a content box dimension.
				valueIsBorderBox = offsetProp in elem;
				if ( valueIsBorderBox ) {
					val = elem[ offsetProp ];
				}
			}

			// Normalize "" and auto
			val = parseFloat( val ) || 0;

			// Adjust for the element's box model
			return ( val +
				boxModelAdjustment(
					elem,
					dimension,
					extra || ( isBorderBox ? "border" : "content" ),
					valueIsBorderBox,
					styles,

					// Provide the current computed size to request scroll gutter calculation (gh-3589)
					val
				)
			) + "px";
		}

		jQuery.extend( {

			// Add in style property hooks for overriding the default
			// behavior of getting and setting a style property
			cssHooks: {
				opacity: {
					get: function( elem, computed ) {
						if ( computed ) {

							// We should always get a number back from opacity
							var ret = curCSS( elem, "opacity" );
							return ret === "" ? "1" : ret;
						}
					}
				}
			},

			// Don't automatically add "px" to these possibly-unitless properties
			cssNumber: {
				animationIterationCount: true,
				aspectRatio: true,
				borderImageSlice: true,
				columnCount: true,
				flexGrow: true,
				flexShrink: true,
				fontWeight: true,
				gridArea: true,
				gridColumn: true,
				gridColumnEnd: true,
				gridColumnStart: true,
				gridRow: true,
				gridRowEnd: true,
				gridRowStart: true,
				lineHeight: true,
				opacity: true,
				order: true,
				orphans: true,
				scale: true,
				widows: true,
				zIndex: true,
				zoom: true,

				// SVG-related
				fillOpacity: true,
				floodOpacity: true,
				stopOpacity: true,
				strokeMiterlimit: true,
				strokeOpacity: true
			},

			// Add in properties whose names you wish to fix before
			// setting or getting the value
			cssProps: {},

			// Get and set the style property on a DOM Node
			style: function( elem, name, value, extra ) {

				// Don't set styles on text and comment nodes
				if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
					return;
				}

				// Make sure that we're working with the right name
				var ret, type, hooks,
					origName = camelCase( name ),
					isCustomProp = rcustomProp.test( name ),
					style = elem.style;

				// Make sure that we're working with the right name. We don't
				// want to query the value if it is a CSS custom property
				// since they are user-defined.
				if ( !isCustomProp ) {
					name = finalPropName( origName );
				}

				// Gets hook for the prefixed version, then unprefixed version
				hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

				// Check if we're setting a value
				if ( value !== undefined ) {
					type = typeof value;

					// Convert "+=" or "-=" to relative numbers (trac-7345)
					if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
						value = adjustCSS( elem, name, ret );

						// Fixes bug trac-9237
						type = "number";
					}

					// Make sure that null and NaN values aren't set (trac-7116)
					if ( value == null || value !== value ) {
						return;
					}

					// If a number was passed in, add the unit (except for certain CSS properties)
					// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
					// "px" to a few hardcoded values.
					if ( type === "number" && !isCustomProp ) {
						value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
					}

					// background-* props affect original clone's values
					if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
						style[ name ] = "inherit";
					}

					// If a hook was provided, use that value, otherwise just set the specified value
					if ( !hooks || !( "set" in hooks ) ||
						( value = hooks.set( elem, value, extra ) ) !== undefined ) {

						if ( isCustomProp ) {
							style.setProperty( name, value );
						} else {
							style[ name ] = value;
						}
					}

				} else {

					// If a hook was provided get the non-computed value from there
					if ( hooks && "get" in hooks &&
						( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

						return ret;
					}

					// Otherwise just get the value from the style object
					return style[ name ];
				}
			},

			css: function( elem, name, extra, styles ) {
				var val, num, hooks,
					origName = camelCase( name ),
					isCustomProp = rcustomProp.test( name );

				// Make sure that we're working with the right name. We don't
				// want to modify the value if it is a CSS custom property
				// since they are user-defined.
				if ( !isCustomProp ) {
					name = finalPropName( origName );
				}

				// Try prefixed name followed by the unprefixed name
				hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

				// If a hook was provided get the computed value from there
				if ( hooks && "get" in hooks ) {
					val = hooks.get( elem, true, extra );
				}

				// Otherwise, if a way to get the computed value exists, use that
				if ( val === undefined ) {
					val = curCSS( elem, name, styles );
				}

				// Convert "normal" to computed value
				if ( val === "normal" && name in cssNormalTransform ) {
					val = cssNormalTransform[ name ];
				}

				// Make numeric if forced or a qualifier was provided and val looks numeric
				if ( extra === "" || extra ) {
					num = parseFloat( val );
					return extra === true || isFinite( num ) ? num || 0 : val;
				}

				return val;
			}
		} );

		jQuery.each( [ "height", "width" ], function( _i, dimension ) {
			jQuery.cssHooks[ dimension ] = {
				get: function( elem, computed, extra ) {
					if ( computed ) {

						// Certain elements can have dimension info if we invisibly show them
						// but it must have a current display style that would benefit
						return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

							// Support: Safari 8+
							// Table columns in Safari have non-zero offsetWidth & zero
							// getBoundingClientRect().width unless display is changed.
							// Support: IE <=11 only
							// Running getBoundingClientRect on a disconnected node
							// in IE throws an error.
							( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
					}
				},

				set: function( elem, value, extra ) {
					var matches,
						styles = getStyles( elem ),

						// Only read styles.position if the test has a chance to fail
						// to avoid forcing a reflow.
						scrollboxSizeBuggy = !support.scrollboxSize() &&
							styles.position === "absolute",

						// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
						boxSizingNeeded = scrollboxSizeBuggy || extra,
						isBorderBox = boxSizingNeeded &&
							jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						subtract = extra ?
							boxModelAdjustment(
								elem,
								dimension,
								extra,
								isBorderBox,
								styles
							) :
							0;

					// Account for unreliable border-box dimensions by comparing offset* to computed and
					// faking a content-box to get border and padding (gh-3699)
					if ( isBorderBox && scrollboxSizeBuggy ) {
						subtract -= Math.ceil(
							elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
							parseFloat( styles[ dimension ] ) -
							boxModelAdjustment( elem, dimension, "border", false, styles ) -
							0.5
						);
					}

					// Convert to pixels if value adjustment is needed
					if ( subtract && ( matches = rcssNum.exec( value ) ) &&
						( matches[ 3 ] || "px" ) !== "px" ) {

						elem.style[ dimension ] = value;
						value = jQuery.css( elem, dimension );
					}

					return setPositiveNumber( elem, value, subtract );
				}
			};
		} );

		jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
			function( elem, computed ) {
				if ( computed ) {
					return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
						elem.getBoundingClientRect().left -
							swap( elem, { marginLeft: 0 }, function() {
								return elem.getBoundingClientRect().left;
							} )
					) + "px";
				}
			}
		);

		// These hooks are used by animate to expand properties
		jQuery.each( {
			margin: "",
			padding: "",
			border: "Width"
		}, function( prefix, suffix ) {
			jQuery.cssHooks[ prefix + suffix ] = {
				expand: function( value ) {
					var i = 0,
						expanded = {},

						// Assumes a single number if not a string
						parts = typeof value === "string" ? value.split( " " ) : [ value ];

					for ( ; i < 4; i++ ) {
						expanded[ prefix + cssExpand[ i ] + suffix ] =
							parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
					}

					return expanded;
				}
			};

			if ( prefix !== "margin" ) {
				jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
			}
		} );

		jQuery.fn.extend( {
			css: function( name, value ) {
				return access( this, function( elem, name, value ) {
					var styles, len,
						map = {},
						i = 0;

					if ( Array.isArray( name ) ) {
						styles = getStyles( elem );
						len = name.length;

						for ( ; i < len; i++ ) {
							map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
						}

						return map;
					}

					return value !== undefined ?
						jQuery.style( elem, name, value ) :
						jQuery.css( elem, name );
				}, name, value, arguments.length > 1 );
			}
		} );


		function Tween( elem, options, prop, end, easing ) {
			return new Tween.prototype.init( elem, options, prop, end, easing );
		}
		jQuery.Tween = Tween;

		Tween.prototype = {
			constructor: Tween,
			init: function( elem, options, prop, end, easing, unit ) {
				this.elem = elem;
				this.prop = prop;
				this.easing = easing || jQuery.easing._default;
				this.options = options;
				this.start = this.now = this.cur();
				this.end = end;
				this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
			},
			cur: function() {
				var hooks = Tween.propHooks[ this.prop ];

				return hooks && hooks.get ?
					hooks.get( this ) :
					Tween.propHooks._default.get( this );
			},
			run: function( percent ) {
				var eased,
					hooks = Tween.propHooks[ this.prop ];

				if ( this.options.duration ) {
					this.pos = eased = jQuery.easing[ this.easing ](
						percent, this.options.duration * percent, 0, 1, this.options.duration
					);
				} else {
					this.pos = eased = percent;
				}
				this.now = ( this.end - this.start ) * eased + this.start;

				if ( this.options.step ) {
					this.options.step.call( this.elem, this.now, this );
				}

				if ( hooks && hooks.set ) {
					hooks.set( this );
				} else {
					Tween.propHooks._default.set( this );
				}
				return this;
			}
		};

		Tween.prototype.init.prototype = Tween.prototype;

		Tween.propHooks = {
			_default: {
				get: function( tween ) {
					var result;

					// Use a property on the element directly when it is not a DOM element,
					// or when there is no matching style property that exists.
					if ( tween.elem.nodeType !== 1 ||
						tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
						return tween.elem[ tween.prop ];
					}

					// Passing an empty string as a 3rd parameter to .css will automatically
					// attempt a parseFloat and fallback to a string if the parse fails.
					// Simple values such as "10px" are parsed to Float;
					// complex values such as "rotate(1rad)" are returned as-is.
					result = jQuery.css( tween.elem, tween.prop, "" );

					// Empty strings, null, undefined and "auto" are converted to 0.
					return !result || result === "auto" ? 0 : result;
				},
				set: function( tween ) {

					// Use step hook for back compat.
					// Use cssHook if its there.
					// Use .style if available and use plain properties where available.
					if ( jQuery.fx.step[ tween.prop ] ) {
						jQuery.fx.step[ tween.prop ]( tween );
					} else if ( tween.elem.nodeType === 1 && (
						jQuery.cssHooks[ tween.prop ] ||
							tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
						jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
					} else {
						tween.elem[ tween.prop ] = tween.now;
					}
				}
			}
		};

		// Support: IE <=9 only
		// Panic based approach to setting things on disconnected nodes
		Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
			set: function( tween ) {
				if ( tween.elem.nodeType && tween.elem.parentNode ) {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		};

		jQuery.easing = {
			linear: function( p ) {
				return p;
			},
			swing: function( p ) {
				return 0.5 - Math.cos( p * Math.PI ) / 2;
			},
			_default: "swing"
		};

		jQuery.fx = Tween.prototype.init;

		// Back compat <1.8 extension point
		jQuery.fx.step = {};




		var
			fxNow, inProgress,
			rfxtypes = /^(?:toggle|show|hide)$/,
			rrun = /queueHooks$/;

		function schedule() {
			if ( inProgress ) {
				if ( document.hidden === false && window.requestAnimationFrame ) {
					window.requestAnimationFrame( schedule );
				} else {
					window.setTimeout( schedule, jQuery.fx.interval );
				}

				jQuery.fx.tick();
			}
		}

		// Animations created synchronously will run synchronously
		function createFxNow() {
			window.setTimeout( function() {
				fxNow = undefined;
			} );
			return ( fxNow = Date.now() );
		}

		// Generate parameters to create a standard animation
		function genFx( type, includeWidth ) {
			var which,
				i = 0,
				attrs = { height: type };

			// If we include width, step value is 1 to do all cssExpand values,
			// otherwise step value is 2 to skip over Left and Right
			includeWidth = includeWidth ? 1 : 0;
			for ( ; i < 4; i += 2 - includeWidth ) {
				which = cssExpand[ i ];
				attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
			}

			if ( includeWidth ) {
				attrs.opacity = attrs.width = type;
			}

			return attrs;
		}

		function createTween( value, prop, animation ) {
			var tween,
				collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
				index = 0,
				length = collection.length;
			for ( ; index < length; index++ ) {
				if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

					// We're done with this property
					return tween;
				}
			}
		}

		function defaultPrefilter( elem, props, opts ) {
			var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
				isBox = "width" in props || "height" in props,
				anim = this,
				orig = {},
				style = elem.style,
				hidden = elem.nodeType && isHiddenWithinTree( elem ),
				dataShow = dataPriv.get( elem, "fxshow" );

			// Queue-skipping animations hijack the fx hooks
			if ( !opts.queue ) {
				hooks = jQuery._queueHooks( elem, "fx" );
				if ( hooks.unqueued == null ) {
					hooks.unqueued = 0;
					oldfire = hooks.empty.fire;
					hooks.empty.fire = function() {
						if ( !hooks.unqueued ) {
							oldfire();
						}
					};
				}
				hooks.unqueued++;

				anim.always( function() {

					// Ensure the complete handler is called before this completes
					anim.always( function() {
						hooks.unqueued--;
						if ( !jQuery.queue( elem, "fx" ).length ) {
							hooks.empty.fire();
						}
					} );
				} );
			}

			// Detect show/hide animations
			for ( prop in props ) {
				value = props[ prop ];
				if ( rfxtypes.test( value ) ) {
					delete props[ prop ];
					toggle = toggle || value === "toggle";
					if ( value === ( hidden ? "hide" : "show" ) ) {

						// Pretend to be hidden if this is a "show" and
						// there is still data from a stopped show/hide
						if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
							hidden = true;

						// Ignore all other no-op show/hide data
						} else {
							continue;
						}
					}
					orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
				}
			}

			// Bail out if this is a no-op like .hide().hide()
			propTween = !jQuery.isEmptyObject( props );
			if ( !propTween && jQuery.isEmptyObject( orig ) ) {
				return;
			}

			// Restrict "overflow" and "display" styles during box animations
			if ( isBox && elem.nodeType === 1 ) {

				// Support: IE <=9 - 11, Edge 12 - 15
				// Record all 3 overflow attributes because IE does not infer the shorthand
				// from identically-valued overflowX and overflowY and Edge just mirrors
				// the overflowX value there.
				opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

				// Identify a display type, preferring old show/hide data over the CSS cascade
				restoreDisplay = dataShow && dataShow.display;
				if ( restoreDisplay == null ) {
					restoreDisplay = dataPriv.get( elem, "display" );
				}
				display = jQuery.css( elem, "display" );
				if ( display === "none" ) {
					if ( restoreDisplay ) {
						display = restoreDisplay;
					} else {

						// Get nonempty value(s) by temporarily forcing visibility
						showHide( [ elem ], true );
						restoreDisplay = elem.style.display || restoreDisplay;
						display = jQuery.css( elem, "display" );
						showHide( [ elem ] );
					}
				}

				// Animate inline elements as inline-block
				if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
					if ( jQuery.css( elem, "float" ) === "none" ) {

						// Restore the original display value at the end of pure show/hide animations
						if ( !propTween ) {
							anim.done( function() {
								style.display = restoreDisplay;
							} );
							if ( restoreDisplay == null ) {
								display = style.display;
								restoreDisplay = display === "none" ? "" : display;
							}
						}
						style.display = "inline-block";
					}
				}
			}

			if ( opts.overflow ) {
				style.overflow = "hidden";
				anim.always( function() {
					style.overflow = opts.overflow[ 0 ];
					style.overflowX = opts.overflow[ 1 ];
					style.overflowY = opts.overflow[ 2 ];
				} );
			}

			// Implement show/hide animations
			propTween = false;
			for ( prop in orig ) {

				// General show/hide setup for this element animation
				if ( !propTween ) {
					if ( dataShow ) {
						if ( "hidden" in dataShow ) {
							hidden = dataShow.hidden;
						}
					} else {
						dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
					}

					// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
					if ( toggle ) {
						dataShow.hidden = !hidden;
					}

					// Show elements before animating them
					if ( hidden ) {
						showHide( [ elem ], true );
					}

					/* eslint-disable no-loop-func */

					anim.done( function() {

						/* eslint-enable no-loop-func */

						// The final step of a "hide" animation is actually hiding the element
						if ( !hidden ) {
							showHide( [ elem ] );
						}
						dataPriv.remove( elem, "fxshow" );
						for ( prop in orig ) {
							jQuery.style( elem, prop, orig[ prop ] );
						}
					} );
				}

				// Per-property setup
				propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = propTween.start;
					if ( hidden ) {
						propTween.end = propTween.start;
						propTween.start = 0;
					}
				}
			}
		}

		function propFilter( props, specialEasing ) {
			var index, name, easing, value, hooks;

			// camelCase, specialEasing and expand cssHook pass
			for ( index in props ) {
				name = camelCase( index );
				easing = specialEasing[ name ];
				value = props[ index ];
				if ( Array.isArray( value ) ) {
					easing = value[ 1 ];
					value = props[ index ] = value[ 0 ];
				}

				if ( index !== name ) {
					props[ name ] = value;
					delete props[ index ];
				}

				hooks = jQuery.cssHooks[ name ];
				if ( hooks && "expand" in hooks ) {
					value = hooks.expand( value );
					delete props[ name ];

					// Not quite $.extend, this won't overwrite existing keys.
					// Reusing 'index' because we have the correct "name"
					for ( index in value ) {
						if ( !( index in props ) ) {
							props[ index ] = value[ index ];
							specialEasing[ index ] = easing;
						}
					}
				} else {
					specialEasing[ name ] = easing;
				}
			}
		}

		function Animation( elem, properties, options ) {
			var result,
				stopped,
				index = 0,
				length = Animation.prefilters.length,
				deferred = jQuery.Deferred().always( function() {

					// Don't match elem in the :animated selector
					delete tick.elem;
				} ),
				tick = function() {
					if ( stopped ) {
						return false;
					}
					var currentTime = fxNow || createFxNow(),
						remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

						// Support: Android 2.3 only
						// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
						temp = remaining / animation.duration || 0,
						percent = 1 - temp,
						index = 0,
						length = animation.tweens.length;

					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( percent );
					}

					deferred.notifyWith( elem, [ animation, percent, remaining ] );

					// If there's more to do, yield
					if ( percent < 1 && length ) {
						return remaining;
					}

					// If this was an empty animation, synthesize a final progress notification
					if ( !length ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
					}

					// Resolve the animation and report its conclusion
					deferred.resolveWith( elem, [ animation ] );
					return false;
				},
				animation = deferred.promise( {
					elem: elem,
					props: jQuery.extend( {}, properties ),
					opts: jQuery.extend( true, {
						specialEasing: {},
						easing: jQuery.easing._default
					}, options ),
					originalProperties: properties,
					originalOptions: options,
					startTime: fxNow || createFxNow(),
					duration: options.duration,
					tweens: [],
					createTween: function( prop, end ) {
						var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
						animation.tweens.push( tween );
						return tween;
					},
					stop: function( gotoEnd ) {
						var index = 0,

							// If we are going to the end, we want to run all the tweens
							// otherwise we skip this part
							length = gotoEnd ? animation.tweens.length : 0;
						if ( stopped ) {
							return this;
						}
						stopped = true;
						for ( ; index < length; index++ ) {
							animation.tweens[ index ].run( 1 );
						}

						// Resolve when we played the last frame; otherwise, reject
						if ( gotoEnd ) {
							deferred.notifyWith( elem, [ animation, 1, 0 ] );
							deferred.resolveWith( elem, [ animation, gotoEnd ] );
						} else {
							deferred.rejectWith( elem, [ animation, gotoEnd ] );
						}
						return this;
					}
				} ),
				props = animation.props;

			propFilter( props, animation.opts.specialEasing );

			for ( ; index < length; index++ ) {
				result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
				if ( result ) {
					if ( isFunction( result.stop ) ) {
						jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
							result.stop.bind( result );
					}
					return result;
				}
			}

			jQuery.map( props, createTween, animation );

			if ( isFunction( animation.opts.start ) ) {
				animation.opts.start.call( elem, animation );
			}

			// Attach callbacks from options
			animation
				.progress( animation.opts.progress )
				.done( animation.opts.done, animation.opts.complete )
				.fail( animation.opts.fail )
				.always( animation.opts.always );

			jQuery.fx.timer(
				jQuery.extend( tick, {
					elem: elem,
					anim: animation,
					queue: animation.opts.queue
				} )
			);

			return animation;
		}

		jQuery.Animation = jQuery.extend( Animation, {

			tweeners: {
				"*": [ function( prop, value ) {
					var tween = this.createTween( prop, value );
					adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
					return tween;
				} ]
			},

			tweener: function( props, callback ) {
				if ( isFunction( props ) ) {
					callback = props;
					props = [ "*" ];
				} else {
					props = props.match( rnothtmlwhite );
				}

				var prop,
					index = 0,
					length = props.length;

				for ( ; index < length; index++ ) {
					prop = props[ index ];
					Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
					Animation.tweeners[ prop ].unshift( callback );
				}
			},

			prefilters: [ defaultPrefilter ],

			prefilter: function( callback, prepend ) {
				if ( prepend ) {
					Animation.prefilters.unshift( callback );
				} else {
					Animation.prefilters.push( callback );
				}
			}
		} );

		jQuery.speed = function( speed, easing, fn ) {
			var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
				complete: fn || !fn && easing ||
					isFunction( speed ) && speed,
				duration: speed,
				easing: fn && easing || easing && !isFunction( easing ) && easing
			};

			// Go to the end state if fx are off
			if ( jQuery.fx.off ) {
				opt.duration = 0;

			} else {
				if ( typeof opt.duration !== "number" ) {
					if ( opt.duration in jQuery.fx.speeds ) {
						opt.duration = jQuery.fx.speeds[ opt.duration ];

					} else {
						opt.duration = jQuery.fx.speeds._default;
					}
				}
			}

			// Normalize opt.queue - true/undefined/null -> "fx"
			if ( opt.queue == null || opt.queue === true ) {
				opt.queue = "fx";
			}

			// Queueing
			opt.old = opt.complete;

			opt.complete = function() {
				if ( isFunction( opt.old ) ) {
					opt.old.call( this );
				}

				if ( opt.queue ) {
					jQuery.dequeue( this, opt.queue );
				}
			};

			return opt;
		};

		jQuery.fn.extend( {
			fadeTo: function( speed, to, easing, callback ) {

				// Show any hidden elements after setting opacity to 0
				return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

					// Animate to the value specified
					.end().animate( { opacity: to }, speed, easing, callback );
			},
			animate: function( prop, speed, easing, callback ) {
				var empty = jQuery.isEmptyObject( prop ),
					optall = jQuery.speed( speed, easing, callback ),
					doAnimation = function() {

						// Operate on a copy of prop so per-property easing won't be lost
						var anim = Animation( this, jQuery.extend( {}, prop ), optall );

						// Empty animations, or finishing resolves immediately
						if ( empty || dataPriv.get( this, "finish" ) ) {
							anim.stop( true );
						}
					};

				doAnimation.finish = doAnimation;

				return empty || optall.queue === false ?
					this.each( doAnimation ) :
					this.queue( optall.queue, doAnimation );
			},
			stop: function( type, clearQueue, gotoEnd ) {
				var stopQueue = function( hooks ) {
					var stop = hooks.stop;
					delete hooks.stop;
					stop( gotoEnd );
				};

				if ( typeof type !== "string" ) {
					gotoEnd = clearQueue;
					clearQueue = type;
					type = undefined;
				}
				if ( clearQueue ) {
					this.queue( type || "fx", [] );
				}

				return this.each( function() {
					var dequeue = true,
						index = type != null && type + "queueHooks",
						timers = jQuery.timers,
						data = dataPriv.get( this );

					if ( index ) {
						if ( data[ index ] && data[ index ].stop ) {
							stopQueue( data[ index ] );
						}
					} else {
						for ( index in data ) {
							if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
								stopQueue( data[ index ] );
							}
						}
					}

					for ( index = timers.length; index--; ) {
						if ( timers[ index ].elem === this &&
							( type == null || timers[ index ].queue === type ) ) {

							timers[ index ].anim.stop( gotoEnd );
							dequeue = false;
							timers.splice( index, 1 );
						}
					}

					// Start the next in the queue if the last step wasn't forced.
					// Timers currently will call their complete callbacks, which
					// will dequeue but only if they were gotoEnd.
					if ( dequeue || !gotoEnd ) {
						jQuery.dequeue( this, type );
					}
				} );
			},
			finish: function( type ) {
				if ( type !== false ) {
					type = type || "fx";
				}
				return this.each( function() {
					var index,
						data = dataPriv.get( this ),
						queue = data[ type + "queue" ],
						hooks = data[ type + "queueHooks" ],
						timers = jQuery.timers,
						length = queue ? queue.length : 0;

					// Enable finishing flag on private data
					data.finish = true;

					// Empty the queue first
					jQuery.queue( this, type, [] );

					if ( hooks && hooks.stop ) {
						hooks.stop.call( this, true );
					}

					// Look for any active animations, and finish them
					for ( index = timers.length; index--; ) {
						if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
							timers[ index ].anim.stop( true );
							timers.splice( index, 1 );
						}
					}

					// Look for any animations in the old queue and finish them
					for ( index = 0; index < length; index++ ) {
						if ( queue[ index ] && queue[ index ].finish ) {
							queue[ index ].finish.call( this );
						}
					}

					// Turn off finishing flag
					delete data.finish;
				} );
			}
		} );

		jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
			var cssFn = jQuery.fn[ name ];
			jQuery.fn[ name ] = function( speed, easing, callback ) {
				return speed == null || typeof speed === "boolean" ?
					cssFn.apply( this, arguments ) :
					this.animate( genFx( name, true ), speed, easing, callback );
			};
		} );

		// Generate shortcuts for custom animations
		jQuery.each( {
			slideDown: genFx( "show" ),
			slideUp: genFx( "hide" ),
			slideToggle: genFx( "toggle" ),
			fadeIn: { opacity: "show" },
			fadeOut: { opacity: "hide" },
			fadeToggle: { opacity: "toggle" }
		}, function( name, props ) {
			jQuery.fn[ name ] = function( speed, easing, callback ) {
				return this.animate( props, speed, easing, callback );
			};
		} );

		jQuery.timers = [];
		jQuery.fx.tick = function() {
			var timer,
				i = 0,
				timers = jQuery.timers;

			fxNow = Date.now();

			for ( ; i < timers.length; i++ ) {
				timer = timers[ i ];

				// Run the timer and safely remove it when done (allowing for external removal)
				if ( !timer() && timers[ i ] === timer ) {
					timers.splice( i--, 1 );
				}
			}

			if ( !timers.length ) {
				jQuery.fx.stop();
			}
			fxNow = undefined;
		};

		jQuery.fx.timer = function( timer ) {
			jQuery.timers.push( timer );
			jQuery.fx.start();
		};

		jQuery.fx.interval = 13;
		jQuery.fx.start = function() {
			if ( inProgress ) {
				return;
			}

			inProgress = true;
			schedule();
		};

		jQuery.fx.stop = function() {
			inProgress = null;
		};

		jQuery.fx.speeds = {
			slow: 600,
			fast: 200,

			// Default speed
			_default: 400
		};


		// Based off of the plugin by Clint Helfers, with permission.
		jQuery.fn.delay = function( time, type ) {
			time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
			type = type || "fx";

			return this.queue( type, function( next, hooks ) {
				var timeout = window.setTimeout( next, time );
				hooks.stop = function() {
					window.clearTimeout( timeout );
				};
			} );
		};


		( function() {
			var input = document.createElement( "input" ),
				select = document.createElement( "select" ),
				opt = select.appendChild( document.createElement( "option" ) );

			input.type = "checkbox";

			// Support: Android <=4.3 only
			// Default value for a checkbox should be "on"
			support.checkOn = input.value !== "";

			// Support: IE <=11 only
			// Must access selectedIndex to make default options select
			support.optSelected = opt.selected;

			// Support: IE <=11 only
			// An input loses its value after becoming a radio
			input = document.createElement( "input" );
			input.value = "t";
			input.type = "radio";
			support.radioValue = input.value === "t";
		} )();


		var boolHook,
			attrHandle = jQuery.expr.attrHandle;

		jQuery.fn.extend( {
			attr: function( name, value ) {
				return access( this, jQuery.attr, name, value, arguments.length > 1 );
			},

			removeAttr: function( name ) {
				return this.each( function() {
					jQuery.removeAttr( this, name );
				} );
			}
		} );

		jQuery.extend( {
			attr: function( elem, name, value ) {
				var ret, hooks,
					nType = elem.nodeType;

				// Don't get/set attributes on text, comment and attribute nodes
				if ( nType === 3 || nType === 8 || nType === 2 ) {
					return;
				}

				// Fallback to prop when attributes are not supported
				if ( typeof elem.getAttribute === "undefined" ) {
					return jQuery.prop( elem, name, value );
				}

				// Attribute hooks are determined by the lowercase version
				// Grab necessary hook if one is defined
				if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
					hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
						( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
				}

				if ( value !== undefined ) {
					if ( value === null ) {
						jQuery.removeAttr( elem, name );
						return;
					}

					if ( hooks && "set" in hooks &&
						( ret = hooks.set( elem, value, name ) ) !== undefined ) {
						return ret;
					}

					elem.setAttribute( name, value + "" );
					return value;
				}

				if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
					return ret;
				}

				ret = jQuery.find.attr( elem, name );

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ? undefined : ret;
			},

			attrHooks: {
				type: {
					set: function( elem, value ) {
						if ( !support.radioValue && value === "radio" &&
							nodeName( elem, "input" ) ) {
							var val = elem.value;
							elem.setAttribute( "type", value );
							if ( val ) {
								elem.value = val;
							}
							return value;
						}
					}
				}
			},

			removeAttr: function( elem, value ) {
				var name,
					i = 0,

					// Attribute names can contain non-HTML whitespace characters
					// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
					attrNames = value && value.match( rnothtmlwhite );

				if ( attrNames && elem.nodeType === 1 ) {
					while ( ( name = attrNames[ i++ ] ) ) {
						elem.removeAttribute( name );
					}
				}
			}
		} );

		// Hooks for boolean attributes
		boolHook = {
			set: function( elem, value, name ) {
				if ( value === false ) {

					// Remove boolean attributes when set to false
					jQuery.removeAttr( elem, name );
				} else {
					elem.setAttribute( name, name );
				}
				return name;
			}
		};

		jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
			var getter = attrHandle[ name ] || jQuery.find.attr;

			attrHandle[ name ] = function( elem, name, isXML ) {
				var ret, handle,
					lowercaseName = name.toLowerCase();

				if ( !isXML ) {

					// Avoid an infinite loop by temporarily removing this function from the getter
					handle = attrHandle[ lowercaseName ];
					attrHandle[ lowercaseName ] = ret;
					ret = getter( elem, name, isXML ) != null ?
						lowercaseName :
						null;
					attrHandle[ lowercaseName ] = handle;
				}
				return ret;
			};
		} );




		var rfocusable = /^(?:input|select|textarea|button)$/i,
			rclickable = /^(?:a|area)$/i;

		jQuery.fn.extend( {
			prop: function( name, value ) {
				return access( this, jQuery.prop, name, value, arguments.length > 1 );
			},

			removeProp: function( name ) {
				return this.each( function() {
					delete this[ jQuery.propFix[ name ] || name ];
				} );
			}
		} );

		jQuery.extend( {
			prop: function( elem, name, value ) {
				var ret, hooks,
					nType = elem.nodeType;

				// Don't get/set properties on text, comment and attribute nodes
				if ( nType === 3 || nType === 8 || nType === 2 ) {
					return;
				}

				if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

					// Fix name and attach hooks
					name = jQuery.propFix[ name ] || name;
					hooks = jQuery.propHooks[ name ];
				}

				if ( value !== undefined ) {
					if ( hooks && "set" in hooks &&
						( ret = hooks.set( elem, value, name ) ) !== undefined ) {
						return ret;
					}

					return ( elem[ name ] = value );
				}

				if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
					return ret;
				}

				return elem[ name ];
			},

			propHooks: {
				tabIndex: {
					get: function( elem ) {

						// Support: IE <=9 - 11 only
						// elem.tabIndex doesn't always return the
						// correct value when it hasn't been explicitly set
						// Use proper attribute retrieval (trac-12072)
						var tabindex = jQuery.find.attr( elem, "tabindex" );

						if ( tabindex ) {
							return parseInt( tabindex, 10 );
						}

						if (
							rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) &&
							elem.href
						) {
							return 0;
						}

						return -1;
					}
				}
			},

			propFix: {
				"for": "htmlFor",
				"class": "className"
			}
		} );

		// Support: IE <=11 only
		// Accessing the selectedIndex property
		// forces the browser to respect setting selected
		// on the option
		// The getter ensures a default option is selected
		// when in an optgroup
		// eslint rule "no-unused-expressions" is disabled for this code
		// since it considers such accessions noop
		if ( !support.optSelected ) {
			jQuery.propHooks.selected = {
				get: function( elem ) {

					/* eslint no-unused-expressions: "off" */

					var parent = elem.parentNode;
					if ( parent && parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
					return null;
				},
				set: function( elem ) {

					/* eslint no-unused-expressions: "off" */

					var parent = elem.parentNode;
					if ( parent ) {
						parent.selectedIndex;

						if ( parent.parentNode ) {
							parent.parentNode.selectedIndex;
						}
					}
				}
			};
		}

		jQuery.each( [
			"tabIndex",
			"readOnly",
			"maxLength",
			"cellSpacing",
			"cellPadding",
			"rowSpan",
			"colSpan",
			"useMap",
			"frameBorder",
			"contentEditable"
		], function() {
			jQuery.propFix[ this.toLowerCase() ] = this;
		} );




			// Strip and collapse whitespace according to HTML spec
			// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
			function stripAndCollapse( value ) {
				var tokens = value.match( rnothtmlwhite ) || [];
				return tokens.join( " " );
			}


		function getClass( elem ) {
			return elem.getAttribute && elem.getAttribute( "class" ) || "";
		}

		function classesToArray( value ) {
			if ( Array.isArray( value ) ) {
				return value;
			}
			if ( typeof value === "string" ) {
				return value.match( rnothtmlwhite ) || [];
			}
			return [];
		}

		jQuery.fn.extend( {
			addClass: function( value ) {
				var classNames, cur, curValue, className, i, finalValue;

				if ( isFunction( value ) ) {
					return this.each( function( j ) {
						jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
					} );
				}

				classNames = classesToArray( value );

				if ( classNames.length ) {
					return this.each( function() {
						curValue = getClass( this );
						cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

						if ( cur ) {
							for ( i = 0; i < classNames.length; i++ ) {
								className = classNames[ i ];
								if ( cur.indexOf( " " + className + " " ) < 0 ) {
									cur += className + " ";
								}
							}

							// Only assign if different to avoid unneeded rendering.
							finalValue = stripAndCollapse( cur );
							if ( curValue !== finalValue ) {
								this.setAttribute( "class", finalValue );
							}
						}
					} );
				}

				return this;
			},

			removeClass: function( value ) {
				var classNames, cur, curValue, className, i, finalValue;

				if ( isFunction( value ) ) {
					return this.each( function( j ) {
						jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
					} );
				}

				if ( !arguments.length ) {
					return this.attr( "class", "" );
				}

				classNames = classesToArray( value );

				if ( classNames.length ) {
					return this.each( function() {
						curValue = getClass( this );

						// This expression is here for better compressibility (see addClass)
						cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

						if ( cur ) {
							for ( i = 0; i < classNames.length; i++ ) {
								className = classNames[ i ];

								// Remove *all* instances
								while ( cur.indexOf( " " + className + " " ) > -1 ) {
									cur = cur.replace( " " + className + " ", " " );
								}
							}

							// Only assign if different to avoid unneeded rendering.
							finalValue = stripAndCollapse( cur );
							if ( curValue !== finalValue ) {
								this.setAttribute( "class", finalValue );
							}
						}
					} );
				}

				return this;
			},

			toggleClass: function( value, stateVal ) {
				var classNames, className, i, self,
					type = typeof value,
					isValidValue = type === "string" || Array.isArray( value );

				if ( isFunction( value ) ) {
					return this.each( function( i ) {
						jQuery( this ).toggleClass(
							value.call( this, i, getClass( this ), stateVal ),
							stateVal
						);
					} );
				}

				if ( typeof stateVal === "boolean" && isValidValue ) {
					return stateVal ? this.addClass( value ) : this.removeClass( value );
				}

				classNames = classesToArray( value );

				return this.each( function() {
					if ( isValidValue ) {

						// Toggle individual class names
						self = jQuery( this );

						for ( i = 0; i < classNames.length; i++ ) {
							className = classNames[ i ];

							// Check each className given, space separated list
							if ( self.hasClass( className ) ) {
								self.removeClass( className );
							} else {
								self.addClass( className );
							}
						}

					// Toggle whole class name
					} else if ( value === undefined || type === "boolean" ) {
						className = getClass( this );
						if ( className ) {

							// Store className if set
							dataPriv.set( this, "__className__", className );
						}

						// If the element has a class name or if we're passed `false`,
						// then remove the whole classname (if there was one, the above saved it).
						// Otherwise bring back whatever was previously saved (if anything),
						// falling back to the empty string if nothing was stored.
						if ( this.setAttribute ) {
							this.setAttribute( "class",
								className || value === false ?
									"" :
									dataPriv.get( this, "__className__" ) || ""
							);
						}
					}
				} );
			},

			hasClass: function( selector ) {
				var className, elem,
					i = 0;

				className = " " + selector + " ";
				while ( ( elem = this[ i++ ] ) ) {
					if ( elem.nodeType === 1 &&
						( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
					}
				}

				return false;
			}
		} );




		var rreturn = /\r/g;

		jQuery.fn.extend( {
			val: function( value ) {
				var hooks, ret, valueIsFunction,
					elem = this[ 0 ];

				if ( !arguments.length ) {
					if ( elem ) {
						hooks = jQuery.valHooks[ elem.type ] ||
							jQuery.valHooks[ elem.nodeName.toLowerCase() ];

						if ( hooks &&
							"get" in hooks &&
							( ret = hooks.get( elem, "value" ) ) !== undefined
						) {
							return ret;
						}

						ret = elem.value;

						// Handle most common string cases
						if ( typeof ret === "string" ) {
							return ret.replace( rreturn, "" );
						}

						// Handle cases where value is null/undef or number
						return ret == null ? "" : ret;
					}

					return;
				}

				valueIsFunction = isFunction( value );

				return this.each( function( i ) {
					var val;

					if ( this.nodeType !== 1 ) {
						return;
					}

					if ( valueIsFunction ) {
						val = value.call( this, i, jQuery( this ).val() );
					} else {
						val = value;
					}

					// Treat null/undefined as ""; convert numbers to string
					if ( val == null ) {
						val = "";

					} else if ( typeof val === "number" ) {
						val += "";

					} else if ( Array.isArray( val ) ) {
						val = jQuery.map( val, function( value ) {
							return value == null ? "" : value + "";
						} );
					}

					hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

					// If set returns undefined, fall back to normal setting
					if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
						this.value = val;
					}
				} );
			}
		} );

		jQuery.extend( {
			valHooks: {
				option: {
					get: function( elem ) {

						var val = jQuery.find.attr( elem, "value" );
						return val != null ?
							val :

							// Support: IE <=10 - 11 only
							// option.text throws exceptions (trac-14686, trac-14858)
							// Strip and collapse whitespace
							// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
							stripAndCollapse( jQuery.text( elem ) );
					}
				},
				select: {
					get: function( elem ) {
						var value, option, i,
							options = elem.options,
							index = elem.selectedIndex,
							one = elem.type === "select-one",
							values = one ? null : [],
							max = one ? index + 1 : options.length;

						if ( index < 0 ) {
							i = max;

						} else {
							i = one ? index : 0;
						}

						// Loop through all the selected options
						for ( ; i < max; i++ ) {
							option = options[ i ];

							// Support: IE <=9 only
							// IE8-9 doesn't update selected after form reset (trac-2551)
							if ( ( option.selected || i === index ) &&

									// Don't return options that are disabled or in a disabled optgroup
									!option.disabled &&
									( !option.parentNode.disabled ||
										!nodeName( option.parentNode, "optgroup" ) ) ) {

								// Get the specific value for the option
								value = jQuery( option ).val();

								// We don't need an array for one selects
								if ( one ) {
									return value;
								}

								// Multi-Selects return an array
								values.push( value );
							}
						}

						return values;
					},

					set: function( elem, value ) {
						var optionSet, option,
							options = elem.options,
							values = jQuery.makeArray( value ),
							i = options.length;

						while ( i-- ) {
							option = options[ i ];

							/* eslint-disable no-cond-assign */

							if ( option.selected =
								jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
							) {
								optionSet = true;
							}

							/* eslint-enable no-cond-assign */
						}

						// Force browsers to behave consistently when non-matching value is set
						if ( !optionSet ) {
							elem.selectedIndex = -1;
						}
						return values;
					}
				}
			}
		} );

		// Radios and checkboxes getter/setter
		jQuery.each( [ "radio", "checkbox" ], function() {
			jQuery.valHooks[ this ] = {
				set: function( elem, value ) {
					if ( Array.isArray( value ) ) {
						return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
					}
				}
			};
			if ( !support.checkOn ) {
				jQuery.valHooks[ this ].get = function( elem ) {
					return elem.getAttribute( "value" ) === null ? "on" : elem.value;
				};
			}
		} );




		// Return jQuery for attributes-only inclusion
		var location = window.location;

		var nonce = { guid: Date.now() };

		var rquery = ( /\?/ );



		// Cross-browser xml parsing
		jQuery.parseXML = function( data ) {
			var xml, parserErrorElem;
			if ( !data || typeof data !== "string" ) {
				return null;
			}

			// Support: IE 9 - 11 only
			// IE throws on parseFromString with invalid input.
			try {
				xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
			} catch ( e ) {}

			parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
			if ( !xml || parserErrorElem ) {
				jQuery.error( "Invalid XML: " + (
					parserErrorElem ?
						jQuery.map( parserErrorElem.childNodes, function( el ) {
							return el.textContent;
						} ).join( "\n" ) :
						data
				) );
			}
			return xml;
		};


		var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
			stopPropagationCallback = function( e ) {
				e.stopPropagation();
			};

		jQuery.extend( jQuery.event, {

			trigger: function( event, data, elem, onlyHandlers ) {

				var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
					eventPath = [ elem || document ],
					type = hasOwn.call( event, "type" ) ? event.type : event,
					namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

				cur = lastElement = tmp = elem = elem || document;

				// Don't do events on text and comment nodes
				if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
					return;
				}

				// focus/blur morphs to focusin/out; ensure we're not firing them right now
				if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
					return;
				}

				if ( type.indexOf( "." ) > -1 ) {

					// Namespaced trigger; create a regexp to match event type in handle()
					namespaces = type.split( "." );
					type = namespaces.shift();
					namespaces.sort();
				}
				ontype = type.indexOf( ":" ) < 0 && "on" + type;

				// Caller can pass in a jQuery.Event object, Object, or just an event type string
				event = event[ jQuery.expando ] ?
					event :
					new jQuery.Event( type, typeof event === "object" && event );

				// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
				event.isTrigger = onlyHandlers ? 2 : 3;
				event.namespace = namespaces.join( "." );
				event.rnamespace = event.namespace ?
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
					null;

				// Clean up the event in case it is being reused
				event.result = undefined;
				if ( !event.target ) {
					event.target = elem;
				}

				// Clone any incoming data and prepend the event, creating the handler arg list
				data = data == null ?
					[ event ] :
					jQuery.makeArray( data, [ event ] );

				// Allow special events to draw outside the lines
				special = jQuery.event.special[ type ] || {};
				if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
					return;
				}

				// Determine event propagation path in advance, per W3C events spec (trac-9951)
				// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
				if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

					bubbleType = special.delegateType || type;
					if ( !rfocusMorph.test( bubbleType + type ) ) {
						cur = cur.parentNode;
					}
					for ( ; cur; cur = cur.parentNode ) {
						eventPath.push( cur );
						tmp = cur;
					}

					// Only add window if we got to document (e.g., not plain obj or detached DOM)
					if ( tmp === ( elem.ownerDocument || document ) ) {
						eventPath.push( tmp.defaultView || tmp.parentWindow || window );
					}
				}

				// Fire handlers on the event path
				i = 0;
				while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
					lastElement = cur;
					event.type = i > 1 ?
						bubbleType :
						special.bindType || type;

					// jQuery handler
					handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
						dataPriv.get( cur, "handle" );
					if ( handle ) {
						handle.apply( cur, data );
					}

					// Native handler
					handle = ontype && cur[ ontype ];
					if ( handle && handle.apply && acceptData( cur ) ) {
						event.result = handle.apply( cur, data );
						if ( event.result === false ) {
							event.preventDefault();
						}
					}
				}
				event.type = type;

				// If nobody prevented the default action, do it now
				if ( !onlyHandlers && !event.isDefaultPrevented() ) {

					if ( ( !special._default ||
						special._default.apply( eventPath.pop(), data ) === false ) &&
						acceptData( elem ) ) {

						// Call a native DOM method on the target with the same name as the event.
						// Don't do default actions on window, that's where global variables be (trac-6170)
						if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

							// Don't re-trigger an onFOO event when we call its FOO() method
							tmp = elem[ ontype ];

							if ( tmp ) {
								elem[ ontype ] = null;
							}

							// Prevent re-triggering of the same event, since we already bubbled it above
							jQuery.event.triggered = type;

							if ( event.isPropagationStopped() ) {
								lastElement.addEventListener( type, stopPropagationCallback );
							}

							elem[ type ]();

							if ( event.isPropagationStopped() ) {
								lastElement.removeEventListener( type, stopPropagationCallback );
							}

							jQuery.event.triggered = undefined;

							if ( tmp ) {
								elem[ ontype ] = tmp;
							}
						}
					}
				}

				return event.result;
			},

			// Piggyback on a donor event to simulate a different one
			// Used only for `focus(in | out)` events
			simulate: function( type, elem, event ) {
				var e = jQuery.extend(
					new jQuery.Event(),
					event,
					{
						type: type,
						isSimulated: true
					}
				);

				jQuery.event.trigger( e, null, elem );
			}

		} );

		jQuery.fn.extend( {

			trigger: function( type, data ) {
				return this.each( function() {
					jQuery.event.trigger( type, data, this );
				} );
			},
			triggerHandler: function( type, data ) {
				var elem = this[ 0 ];
				if ( elem ) {
					return jQuery.event.trigger( type, data, elem, true );
				}
			}
		} );


		var
			rbracket = /\[\]$/,
			rCRLF = /\r?\n/g,
			rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
			rsubmittable = /^(?:input|select|textarea|keygen)/i;

		function buildParams( prefix, obj, traditional, add ) {
			var name;

			if ( Array.isArray( obj ) ) {

				// Serialize array item.
				jQuery.each( obj, function( i, v ) {
					if ( traditional || rbracket.test( prefix ) ) {

						// Treat each array item as a scalar.
						add( prefix, v );

					} else {

						// Item is non-scalar (array or object), encode its numeric index.
						buildParams(
							prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
							v,
							traditional,
							add
						);
					}
				} );

			} else if ( !traditional && toType( obj ) === "object" ) {

				// Serialize object item.
				for ( name in obj ) {
					buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
				}

			} else {

				// Serialize scalar item.
				add( prefix, obj );
			}
		}

		// Serialize an array of form elements or a set of
		// key/values into a query string
		jQuery.param = function( a, traditional ) {
			var prefix,
				s = [],
				add = function( key, valueOrFunction ) {

					// If value is a function, invoke it and use its return value
					var value = isFunction( valueOrFunction ) ?
						valueOrFunction() :
						valueOrFunction;

					s[ s.length ] = encodeURIComponent( key ) + "=" +
						encodeURIComponent( value == null ? "" : value );
				};

			if ( a == null ) {
				return "";
			}

			// If an array was passed in, assume that it is an array of form elements.
			if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

				// Serialize the form elements
				jQuery.each( a, function() {
					add( this.name, this.value );
				} );

			} else {

				// If traditional, encode the "old" way (the way 1.3.2 or older
				// did it), otherwise encode params recursively.
				for ( prefix in a ) {
					buildParams( prefix, a[ prefix ], traditional, add );
				}
			}

			// Return the resulting serialization
			return s.join( "&" );
		};

		jQuery.fn.extend( {
			serialize: function() {
				return jQuery.param( this.serializeArray() );
			},
			serializeArray: function() {
				return this.map( function() {

					// Can add propHook for "elements" to filter or add form elements
					var elements = jQuery.prop( this, "elements" );
					return elements ? jQuery.makeArray( elements ) : this;
				} ).filter( function() {
					var type = this.type;

					// Use .is( ":disabled" ) so that fieldset[disabled] works
					return this.name && !jQuery( this ).is( ":disabled" ) &&
						rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
						( this.checked || !rcheckableType.test( type ) );
				} ).map( function( _i, elem ) {
					var val = jQuery( this ).val();

					if ( val == null ) {
						return null;
					}

					if ( Array.isArray( val ) ) {
						return jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} );
					}

					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} ).get();
			}
		} );


		var
			r20 = /%20/g,
			rhash = /#.*$/,
			rantiCache = /([?&])_=[^&]*/,
			rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

			// trac-7653, trac-8125, trac-8152: local protocol detection
			rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
			rnoContent = /^(?:GET|HEAD)$/,
			rprotocol = /^\/\//,

			/* Prefilters
			 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
			 * 2) These are called:
			 *    - BEFORE asking for a transport
			 *    - AFTER param serialization (s.data is a string if s.processData is true)
			 * 3) key is the dataType
			 * 4) the catchall symbol "*" can be used
			 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
			 */
			prefilters = {},

			/* Transports bindings
			 * 1) key is the dataType
			 * 2) the catchall symbol "*" can be used
			 * 3) selection will start with transport dataType and THEN go to "*" if needed
			 */
			transports = {},

			// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
			allTypes = "*/".concat( "*" ),

			// Anchor tag for parsing the document origin
			originAnchor = document.createElement( "a" );

		originAnchor.href = location.href;

		// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
		function addToPrefiltersOrTransports( structure ) {

			// dataTypeExpression is optional and defaults to "*"
			return function( dataTypeExpression, func ) {

				if ( typeof dataTypeExpression !== "string" ) {
					func = dataTypeExpression;
					dataTypeExpression = "*";
				}

				var dataType,
					i = 0,
					dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

				if ( isFunction( func ) ) {

					// For each dataType in the dataTypeExpression
					while ( ( dataType = dataTypes[ i++ ] ) ) {

						// Prepend if requested
						if ( dataType[ 0 ] === "+" ) {
							dataType = dataType.slice( 1 ) || "*";
							( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

						// Otherwise append
						} else {
							( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
						}
					}
				}
			};
		}

		// Base inspection function for prefilters and transports
		function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

			var inspected = {},
				seekingTransport = ( structure === transports );

			function inspect( dataType ) {
				var selected;
				inspected[ dataType ] = true;
				jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
					var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
					if ( typeof dataTypeOrTransport === "string" &&
						!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

						options.dataTypes.unshift( dataTypeOrTransport );
						inspect( dataTypeOrTransport );
						return false;
					} else if ( seekingTransport ) {
						return !( selected = dataTypeOrTransport );
					}
				} );
				return selected;
			}

			return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
		}

		// A special extend for ajax options
		// that takes "flat" options (not to be deep extended)
		// Fixes trac-9887
		function ajaxExtend( target, src ) {
			var key, deep,
				flatOptions = jQuery.ajaxSettings.flatOptions || {};

			for ( key in src ) {
				if ( src[ key ] !== undefined ) {
					( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
				}
			}
			if ( deep ) {
				jQuery.extend( true, target, deep );
			}

			return target;
		}

		/* Handles responses to an ajax request:
		 * - finds the right dataType (mediates between content-type and expected dataType)
		 * - returns the corresponding response
		 */
		function ajaxHandleResponses( s, jqXHR, responses ) {

			var ct, type, finalDataType, firstDataType,
				contents = s.contents,
				dataTypes = s.dataTypes;

			// Remove auto dataType and get content-type in the process
			while ( dataTypes[ 0 ] === "*" ) {
				dataTypes.shift();
				if ( ct === undefined ) {
					ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
				}
			}

			// Check if we're dealing with a known content-type
			if ( ct ) {
				for ( type in contents ) {
					if ( contents[ type ] && contents[ type ].test( ct ) ) {
						dataTypes.unshift( type );
						break;
					}
				}
			}

			// Check to see if we have a response for the expected dataType
			if ( dataTypes[ 0 ] in responses ) {
				finalDataType = dataTypes[ 0 ];
			} else {

				// Try convertible dataTypes
				for ( type in responses ) {
					if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
						finalDataType = type;
						break;
					}
					if ( !firstDataType ) {
						firstDataType = type;
					}
				}

				// Or just use first one
				finalDataType = finalDataType || firstDataType;
			}

			// If we found a dataType
			// We add the dataType to the list if needed
			// and return the corresponding response
			if ( finalDataType ) {
				if ( finalDataType !== dataTypes[ 0 ] ) {
					dataTypes.unshift( finalDataType );
				}
				return responses[ finalDataType ];
			}
		}

		/* Chain conversions given the request and the original response
		 * Also sets the responseXXX fields on the jqXHR instance
		 */
		function ajaxConvert( s, response, jqXHR, isSuccess ) {
			var conv2, current, conv, tmp, prev,
				converters = {},

				// Work with a copy of dataTypes in case we need to modify it for conversion
				dataTypes = s.dataTypes.slice();

			// Create converters map with lowercased keys
			if ( dataTypes[ 1 ] ) {
				for ( conv in s.converters ) {
					converters[ conv.toLowerCase() ] = s.converters[ conv ];
				}
			}

			current = dataTypes.shift();

			// Convert to each sequential dataType
			while ( current ) {

				if ( s.responseFields[ current ] ) {
					jqXHR[ s.responseFields[ current ] ] = response;
				}

				// Apply the dataFilter if provided
				if ( !prev && isSuccess && s.dataFilter ) {
					response = s.dataFilter( response, s.dataType );
				}

				prev = current;
				current = dataTypes.shift();

				if ( current ) {

					// There's only work to do if current dataType is non-auto
					if ( current === "*" ) {

						current = prev;

					// Convert response if prev dataType is non-auto and differs from current
					} else if ( prev !== "*" && prev !== current ) {

						// Seek a direct converter
						conv = converters[ prev + " " + current ] || converters[ "* " + current ];

						// If none found, seek a pair
						if ( !conv ) {
							for ( conv2 in converters ) {

								// If conv2 outputs current
								tmp = conv2.split( " " );
								if ( tmp[ 1 ] === current ) {

									// If prev can be converted to accepted input
									conv = converters[ prev + " " + tmp[ 0 ] ] ||
										converters[ "* " + tmp[ 0 ] ];
									if ( conv ) {

										// Condense equivalence converters
										if ( conv === true ) {
											conv = converters[ conv2 ];

										// Otherwise, insert the intermediate dataType
										} else if ( converters[ conv2 ] !== true ) {
											current = tmp[ 0 ];
											dataTypes.unshift( tmp[ 1 ] );
										}
										break;
									}
								}
							}
						}

						// Apply converter (if not an equivalence)
						if ( conv !== true ) {

							// Unless errors are allowed to bubble, catch and return them
							if ( conv && s.throws ) {
								response = conv( response );
							} else {
								try {
									response = conv( response );
								} catch ( e ) {
									return {
										state: "parsererror",
										error: conv ? e : "No conversion from " + prev + " to " + current
									};
								}
							}
						}
					}
				}
			}

			return { state: "success", data: response };
		}

		jQuery.extend( {

			// Counter for holding the number of active queries
			active: 0,

			// Last-Modified header cache for next request
			lastModified: {},
			etag: {},

			ajaxSettings: {
				url: location.href,
				type: "GET",
				isLocal: rlocalProtocol.test( location.protocol ),
				global: true,
				processData: true,
				async: true,
				contentType: "application/x-www-form-urlencoded; charset=UTF-8",

				/*
				timeout: 0,
				data: null,
				dataType: null,
				username: null,
				password: null,
				cache: null,
				throws: false,
				traditional: false,
				headers: {},
				*/

				accepts: {
					"*": allTypes,
					text: "text/plain",
					html: "text/html",
					xml: "application/xml, text/xml",
					json: "application/json, text/javascript"
				},

				contents: {
					xml: /\bxml\b/,
					html: /\bhtml/,
					json: /\bjson\b/
				},

				responseFields: {
					xml: "responseXML",
					text: "responseText",
					json: "responseJSON"
				},

				// Data converters
				// Keys separate source (or catchall "*") and destination types with a single space
				converters: {

					// Convert anything to text
					"* text": String,

					// Text to html (true = no transformation)
					"text html": true,

					// Evaluate text as a json expression
					"text json": JSON.parse,

					// Parse text as xml
					"text xml": jQuery.parseXML
				},

				// For options that shouldn't be deep extended:
				// you can add your own custom options here if
				// and when you create one that shouldn't be
				// deep extended (see ajaxExtend)
				flatOptions: {
					url: true,
					context: true
				}
			},

			// Creates a full fledged settings object into target
			// with both ajaxSettings and settings fields.
			// If target is omitted, writes into ajaxSettings.
			ajaxSetup: function( target, settings ) {
				return settings ?

					// Building a settings object
					ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

					// Extending ajaxSettings
					ajaxExtend( jQuery.ajaxSettings, target );
			},

			ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
			ajaxTransport: addToPrefiltersOrTransports( transports ),

			// Main method
			ajax: function( url, options ) {

				// If url is an object, simulate pre-1.5 signature
				if ( typeof url === "object" ) {
					options = url;
					url = undefined;
				}

				// Force options to be an object
				options = options || {};

				var transport,

					// URL without anti-cache param
					cacheURL,

					// Response headers
					responseHeadersString,
					responseHeaders,

					// timeout handle
					timeoutTimer,

					// Url cleanup var
					urlAnchor,

					// Request state (becomes false upon send and true upon completion)
					completed,

					// To know if global events are to be dispatched
					fireGlobals,

					// Loop variable
					i,

					// uncached part of the url
					uncached,

					// Create the final options object
					s = jQuery.ajaxSetup( {}, options ),

					// Callbacks context
					callbackContext = s.context || s,

					// Context for global events is callbackContext if it is a DOM node or jQuery collection
					globalEventContext = s.context &&
						( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

					// Deferreds
					deferred = jQuery.Deferred(),
					completeDeferred = jQuery.Callbacks( "once memory" ),

					// Status-dependent callbacks
					statusCode = s.statusCode || {},

					// Headers (they are sent all at once)
					requestHeaders = {},
					requestHeadersNames = {},

					// Default abort message
					strAbort = "canceled",

					// Fake xhr
					jqXHR = {
						readyState: 0,

						// Builds headers hashtable if needed
						getResponseHeader: function( key ) {
							var match;
							if ( completed ) {
								if ( !responseHeaders ) {
									responseHeaders = {};
									while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
										responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
											( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
												.concat( match[ 2 ] );
									}
								}
								match = responseHeaders[ key.toLowerCase() + " " ];
							}
							return match == null ? null : match.join( ", " );
						},

						// Raw string
						getAllResponseHeaders: function() {
							return completed ? responseHeadersString : null;
						},

						// Caches the header
						setRequestHeader: function( name, value ) {
							if ( completed == null ) {
								name = requestHeadersNames[ name.toLowerCase() ] =
									requestHeadersNames[ name.toLowerCase() ] || name;
								requestHeaders[ name ] = value;
							}
							return this;
						},

						// Overrides response content-type header
						overrideMimeType: function( type ) {
							if ( completed == null ) {
								s.mimeType = type;
							}
							return this;
						},

						// Status-dependent callbacks
						statusCode: function( map ) {
							var code;
							if ( map ) {
								if ( completed ) {

									// Execute the appropriate callbacks
									jqXHR.always( map[ jqXHR.status ] );
								} else {

									// Lazy-add the new callbacks in a way that preserves old ones
									for ( code in map ) {
										statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
									}
								}
							}
							return this;
						},

						// Cancel the request
						abort: function( statusText ) {
							var finalText = statusText || strAbort;
							if ( transport ) {
								transport.abort( finalText );
							}
							done( 0, finalText );
							return this;
						}
					};

				// Attach deferreds
				deferred.promise( jqXHR );

				// Add protocol if not provided (prefilters might expect it)
				// Handle falsy url in the settings object (trac-10093: consistency with old signature)
				// We also use the url parameter if available
				s.url = ( ( url || s.url || location.href ) + "" )
					.replace( rprotocol, location.protocol + "//" );

				// Alias method option to type as per ticket trac-12004
				s.type = options.method || options.type || s.method || s.type;

				// Extract dataTypes list
				s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

				// A cross-domain request is in order when the origin doesn't match the current origin.
				if ( s.crossDomain == null ) {
					urlAnchor = document.createElement( "a" );

					// Support: IE <=8 - 11, Edge 12 - 15
					// IE throws exception on accessing the href property if url is malformed,
					// e.g. http://example.com:80x/
					try {
						urlAnchor.href = s.url;

						// Support: IE <=8 - 11 only
						// Anchor's host property isn't correctly set when s.url is relative
						urlAnchor.href = urlAnchor.href;
						s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
							urlAnchor.protocol + "//" + urlAnchor.host;
					} catch ( e ) {

						// If there is an error parsing the URL, assume it is crossDomain,
						// it can be rejected by the transport if it is invalid
						s.crossDomain = true;
					}
				}

				// Convert data if not already a string
				if ( s.data && s.processData && typeof s.data !== "string" ) {
					s.data = jQuery.param( s.data, s.traditional );
				}

				// Apply prefilters
				inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

				// If request was aborted inside a prefilter, stop there
				if ( completed ) {
					return jqXHR;
				}

				// We can fire global events as of now if asked to
				// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
				fireGlobals = jQuery.event && s.global;

				// Watch for a new set of requests
				if ( fireGlobals && jQuery.active++ === 0 ) {
					jQuery.event.trigger( "ajaxStart" );
				}

				// Uppercase the type
				s.type = s.type.toUpperCase();

				// Determine if request has content
				s.hasContent = !rnoContent.test( s.type );

				// Save the URL in case we're toying with the If-Modified-Since
				// and/or If-None-Match header later on
				// Remove hash to simplify url manipulation
				cacheURL = s.url.replace( rhash, "" );

				// More options handling for requests with no content
				if ( !s.hasContent ) {

					// Remember the hash so we can put it back
					uncached = s.url.slice( cacheURL.length );

					// If data is available and should be processed, append data to url
					if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
						cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

						// trac-9682: remove data so that it's not used in an eventual retry
						delete s.data;
					}

					// Add or update anti-cache param if needed
					if ( s.cache === false ) {
						cacheURL = cacheURL.replace( rantiCache, "$1" );
						uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
							uncached;
					}

					// Put hash and anti-cache on the URL that will be requested (gh-1732)
					s.url = cacheURL + uncached;

				// Change '%20' to '+' if this is encoded form body content (gh-2658)
				} else if ( s.data && s.processData &&
					( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
					s.data = s.data.replace( r20, "+" );
				}

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					if ( jQuery.lastModified[ cacheURL ] ) {
						jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
					}
					if ( jQuery.etag[ cacheURL ] ) {
						jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
					}
				}

				// Set the correct header, if data is being sent
				if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
					jqXHR.setRequestHeader( "Content-Type", s.contentType );
				}

				// Set the Accepts header for the server, depending on the dataType
				jqXHR.setRequestHeader(
					"Accept",
					s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
						s.accepts[ s.dataTypes[ 0 ] ] +
							( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
						s.accepts[ "*" ]
				);

				// Check for headers option
				for ( i in s.headers ) {
					jqXHR.setRequestHeader( i, s.headers[ i ] );
				}

				// Allow custom headers/mimetypes and early abort
				if ( s.beforeSend &&
					( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

					// Abort if not done already and return
					return jqXHR.abort();
				}

				// Aborting is no longer a cancellation
				strAbort = "abort";

				// Install callbacks on deferreds
				completeDeferred.add( s.complete );
				jqXHR.done( s.success );
				jqXHR.fail( s.error );

				// Get transport
				transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

				// If no transport, we auto-abort
				if ( !transport ) {
					done( -1, "No Transport" );
				} else {
					jqXHR.readyState = 1;

					// Send global event
					if ( fireGlobals ) {
						globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
					}

					// If request was aborted inside ajaxSend, stop there
					if ( completed ) {
						return jqXHR;
					}

					// Timeout
					if ( s.async && s.timeout > 0 ) {
						timeoutTimer = window.setTimeout( function() {
							jqXHR.abort( "timeout" );
						}, s.timeout );
					}

					try {
						completed = false;
						transport.send( requestHeaders, done );
					} catch ( e ) {

						// Rethrow post-completion exceptions
						if ( completed ) {
							throw e;
						}

						// Propagate others as results
						done( -1, e );
					}
				}

				// Callback for when everything is done
				function done( status, nativeStatusText, responses, headers ) {
					var isSuccess, success, error, response, modified,
						statusText = nativeStatusText;

					// Ignore repeat invocations
					if ( completed ) {
						return;
					}

					completed = true;

					// Clear timeout if it exists
					if ( timeoutTimer ) {
						window.clearTimeout( timeoutTimer );
					}

					// Dereference transport for early garbage collection
					// (no matter how long the jqXHR object will be used)
					transport = undefined;

					// Cache response headers
					responseHeadersString = headers || "";

					// Set readyState
					jqXHR.readyState = status > 0 ? 4 : 0;

					// Determine if successful
					isSuccess = status >= 200 && status < 300 || status === 304;

					// Get response data
					if ( responses ) {
						response = ajaxHandleResponses( s, jqXHR, responses );
					}

					// Use a noop converter for missing script but not if jsonp
					if ( !isSuccess &&
						jQuery.inArray( "script", s.dataTypes ) > -1 &&
						jQuery.inArray( "json", s.dataTypes ) < 0 ) {
						s.converters[ "text script" ] = function() {};
					}

					// Convert no matter what (that way responseXXX fields are always set)
					response = ajaxConvert( s, response, jqXHR, isSuccess );

					// If successful, handle type chaining
					if ( isSuccess ) {

						// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
						if ( s.ifModified ) {
							modified = jqXHR.getResponseHeader( "Last-Modified" );
							if ( modified ) {
								jQuery.lastModified[ cacheURL ] = modified;
							}
							modified = jqXHR.getResponseHeader( "etag" );
							if ( modified ) {
								jQuery.etag[ cacheURL ] = modified;
							}
						}

						// if no content
						if ( status === 204 || s.type === "HEAD" ) {
							statusText = "nocontent";

						// if not modified
						} else if ( status === 304 ) {
							statusText = "notmodified";

						// If we have data, let's convert it
						} else {
							statusText = response.state;
							success = response.data;
							error = response.error;
							isSuccess = !error;
						}
					} else {

						// Extract error from statusText and normalize for non-aborts
						error = statusText;
						if ( status || !statusText ) {
							statusText = "error";
							if ( status < 0 ) {
								status = 0;
							}
						}
					}

					// Set data for the fake xhr object
					jqXHR.status = status;
					jqXHR.statusText = ( nativeStatusText || statusText ) + "";

					// Success/Error
					if ( isSuccess ) {
						deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
					} else {
						deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
					}

					// Status-dependent callbacks
					jqXHR.statusCode( statusCode );
					statusCode = undefined;

					if ( fireGlobals ) {
						globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
							[ jqXHR, s, isSuccess ? success : error ] );
					}

					// Complete
					completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

					if ( fireGlobals ) {
						globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

						// Handle the global AJAX counter
						if ( !( --jQuery.active ) ) {
							jQuery.event.trigger( "ajaxStop" );
						}
					}
				}

				return jqXHR;
			},

			getJSON: function( url, data, callback ) {
				return jQuery.get( url, data, callback, "json" );
			},

			getScript: function( url, callback ) {
				return jQuery.get( url, undefined, callback, "script" );
			}
		} );

		jQuery.each( [ "get", "post" ], function( _i, method ) {
			jQuery[ method ] = function( url, data, callback, type ) {

				// Shift arguments if data argument was omitted
				if ( isFunction( data ) ) {
					type = type || callback;
					callback = data;
					data = undefined;
				}

				// The url can be an options object (which then must have .url)
				return jQuery.ajax( jQuery.extend( {
					url: url,
					type: method,
					dataType: type,
					data: data,
					success: callback
				}, jQuery.isPlainObject( url ) && url ) );
			};
		} );

		jQuery.ajaxPrefilter( function( s ) {
			var i;
			for ( i in s.headers ) {
				if ( i.toLowerCase() === "content-type" ) {
					s.contentType = s.headers[ i ] || "";
				}
			}
		} );


		jQuery._evalUrl = function( url, options, doc ) {
			return jQuery.ajax( {
				url: url,

				// Make this explicit, since user can override this through ajaxSetup (trac-11264)
				type: "GET",
				dataType: "script",
				cache: true,
				async: false,
				global: false,

				// Only evaluate the response if it is successful (gh-4126)
				// dataFilter is not invoked for failure responses, so using it instead
				// of the default converter is kludgy but it works.
				converters: {
					"text script": function() {}
				},
				dataFilter: function( response ) {
					jQuery.globalEval( response, options, doc );
				}
			} );
		};


		jQuery.fn.extend( {
			wrapAll: function( html ) {
				var wrap;

				if ( this[ 0 ] ) {
					if ( isFunction( html ) ) {
						html = html.call( this[ 0 ] );
					}

					// The elements to wrap the target around
					wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

					if ( this[ 0 ].parentNode ) {
						wrap.insertBefore( this[ 0 ] );
					}

					wrap.map( function() {
						var elem = this;

						while ( elem.firstElementChild ) {
							elem = elem.firstElementChild;
						}

						return elem;
					} ).append( this );
				}

				return this;
			},

			wrapInner: function( html ) {
				if ( isFunction( html ) ) {
					return this.each( function( i ) {
						jQuery( this ).wrapInner( html.call( this, i ) );
					} );
				}

				return this.each( function() {
					var self = jQuery( this ),
						contents = self.contents();

					if ( contents.length ) {
						contents.wrapAll( html );

					} else {
						self.append( html );
					}
				} );
			},

			wrap: function( html ) {
				var htmlIsFunction = isFunction( html );

				return this.each( function( i ) {
					jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
				} );
			},

			unwrap: function( selector ) {
				this.parent( selector ).not( "body" ).each( function() {
					jQuery( this ).replaceWith( this.childNodes );
				} );
				return this;
			}
		} );


		jQuery.expr.pseudos.hidden = function( elem ) {
			return !jQuery.expr.pseudos.visible( elem );
		};
		jQuery.expr.pseudos.visible = function( elem ) {
			return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
		};




		jQuery.ajaxSettings.xhr = function() {
			try {
				return new window.XMLHttpRequest();
			} catch ( e ) {}
		};

		var xhrSuccessStatus = {

				// File protocol always yields status code 0, assume 200
				0: 200,

				// Support: IE <=9 only
				// trac-1450: sometimes IE returns 1223 when it should be 204
				1223: 204
			},
			xhrSupported = jQuery.ajaxSettings.xhr();

		support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
		support.ajax = xhrSupported = !!xhrSupported;

		jQuery.ajaxTransport( function( options ) {
			var callback, errorCallback;

			// Cross domain only allowed if supported through XMLHttpRequest
			if ( support.cors || xhrSupported && !options.crossDomain ) {
				return {
					send: function( headers, complete ) {
						var i,
							xhr = options.xhr();

						xhr.open(
							options.type,
							options.url,
							options.async,
							options.username,
							options.password
						);

						// Apply custom fields if provided
						if ( options.xhrFields ) {
							for ( i in options.xhrFields ) {
								xhr[ i ] = options.xhrFields[ i ];
							}
						}

						// Override mime type if needed
						if ( options.mimeType && xhr.overrideMimeType ) {
							xhr.overrideMimeType( options.mimeType );
						}

						// X-Requested-With header
						// For cross-domain requests, seeing as conditions for a preflight are
						// akin to a jigsaw puzzle, we simply never set it to be sure.
						// (it can always be set on a per-request basis or even using ajaxSetup)
						// For same-domain requests, won't change header if already provided.
						if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
							headers[ "X-Requested-With" ] = "XMLHttpRequest";
						}

						// Set headers
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}

						// Callback
						callback = function( type ) {
							return function() {
								if ( callback ) {
									callback = errorCallback = xhr.onload =
										xhr.onerror = xhr.onabort = xhr.ontimeout =
											xhr.onreadystatechange = null;

									if ( type === "abort" ) {
										xhr.abort();
									} else if ( type === "error" ) {

										// Support: IE <=9 only
										// On a manual native abort, IE9 throws
										// errors on any property access that is not readyState
										if ( typeof xhr.status !== "number" ) {
											complete( 0, "error" );
										} else {
											complete(

												// File: protocol always yields status 0; see trac-8605, trac-14207
												xhr.status,
												xhr.statusText
											);
										}
									} else {
										complete(
											xhrSuccessStatus[ xhr.status ] || xhr.status,
											xhr.statusText,

											// Support: IE <=9 only
											// IE9 has no XHR2 but throws on binary (trac-11426)
											// For XHR2 non-text, let the caller handle it (gh-2498)
											( xhr.responseType || "text" ) !== "text"  ||
											typeof xhr.responseText !== "string" ?
												{ binary: xhr.response } :
												{ text: xhr.responseText },
											xhr.getAllResponseHeaders()
										);
									}
								}
							};
						};

						// Listen to events
						xhr.onload = callback();
						errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

						// Support: IE 9 only
						// Use onreadystatechange to replace onabort
						// to handle uncaught aborts
						if ( xhr.onabort !== undefined ) {
							xhr.onabort = errorCallback;
						} else {
							xhr.onreadystatechange = function() {

								// Check readyState before timeout as it changes
								if ( xhr.readyState === 4 ) {

									// Allow onerror to be called first,
									// but that will not handle a native abort
									// Also, save errorCallback to a variable
									// as xhr.onerror cannot be accessed
									window.setTimeout( function() {
										if ( callback ) {
											errorCallback();
										}
									} );
								}
							};
						}

						// Create the abort callback
						callback = callback( "abort" );

						try {

							// Do send the request (this may raise an exception)
							xhr.send( options.hasContent && options.data || null );
						} catch ( e ) {

							// trac-14683: Only rethrow if this hasn't been notified as an error yet
							if ( callback ) {
								throw e;
							}
						}
					},

					abort: function() {
						if ( callback ) {
							callback();
						}
					}
				};
			}
		} );




		// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
		jQuery.ajaxPrefilter( function( s ) {
			if ( s.crossDomain ) {
				s.contents.script = false;
			}
		} );

		// Install script dataType
		jQuery.ajaxSetup( {
			accepts: {
				script: "text/javascript, application/javascript, " +
					"application/ecmascript, application/x-ecmascript"
			},
			contents: {
				script: /\b(?:java|ecma)script\b/
			},
			converters: {
				"text script": function( text ) {
					jQuery.globalEval( text );
					return text;
				}
			}
		} );

		// Handle cache's special case and crossDomain
		jQuery.ajaxPrefilter( "script", function( s ) {
			if ( s.cache === undefined ) {
				s.cache = false;
			}
			if ( s.crossDomain ) {
				s.type = "GET";
			}
		} );

		// Bind script tag hack transport
		jQuery.ajaxTransport( "script", function( s ) {

			// This transport only deals with cross domain or forced-by-attrs requests
			if ( s.crossDomain || s.scriptAttrs ) {
				var script, callback;
				return {
					send: function( _, complete ) {
						script = jQuery( "<script>" )
							.attr( s.scriptAttrs || {} )
							.prop( { charset: s.scriptCharset, src: s.url } )
							.on( "load error", callback = function( evt ) {
								script.remove();
								callback = null;
								if ( evt ) {
									complete( evt.type === "error" ? 404 : 200, evt.type );
								}
							} );

						// Use native DOM manipulation to avoid our domManip AJAX trickery
						document.head.appendChild( script[ 0 ] );
					},
					abort: function() {
						if ( callback ) {
							callback();
						}
					}
				};
			}
		} );




		var oldCallbacks = [],
			rjsonp = /(=)\?(?=&|$)|\?\?/;

		// Default jsonp settings
		jQuery.ajaxSetup( {
			jsonp: "callback",
			jsonpCallback: function() {
				var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
				this[ callback ] = true;
				return callback;
			}
		} );

		// Detect, normalize options and install callbacks for jsonp requests
		jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

			var callbackName, overwritten, responseContainer,
				jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
					"url" :
					typeof s.data === "string" &&
						( s.contentType || "" )
							.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
						rjsonp.test( s.data ) && "data"
				);

			// Handle iff the expected data type is "jsonp" or we have a parameter to set
			if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

				// Get callback name, remembering preexisting value associated with it
				callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
					s.jsonpCallback() :
					s.jsonpCallback;

				// Insert callback into url or form data
				if ( jsonProp ) {
					s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
				} else if ( s.jsonp !== false ) {
					s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
				}

				// Use data converter to retrieve json after script execution
				s.converters[ "script json" ] = function() {
					if ( !responseContainer ) {
						jQuery.error( callbackName + " was not called" );
					}
					return responseContainer[ 0 ];
				};

				// Force json dataType
				s.dataTypes[ 0 ] = "json";

				// Install callback
				overwritten = window[ callbackName ];
				window[ callbackName ] = function() {
					responseContainer = arguments;
				};

				// Clean-up function (fires after converters)
				jqXHR.always( function() {

					// If previous value didn't exist - remove it
					if ( overwritten === undefined ) {
						jQuery( window ).removeProp( callbackName );

					// Otherwise restore preexisting value
					} else {
						window[ callbackName ] = overwritten;
					}

					// Save back as free
					if ( s[ callbackName ] ) {

						// Make sure that re-using the options doesn't screw things around
						s.jsonpCallback = originalSettings.jsonpCallback;

						// Save the callback name for future use
						oldCallbacks.push( callbackName );
					}

					// Call if it was a function and we have a response
					if ( responseContainer && isFunction( overwritten ) ) {
						overwritten( responseContainer[ 0 ] );
					}

					responseContainer = overwritten = undefined;
				} );

				// Delegate to script
				return "script";
			}
		} );




		// Support: Safari 8 only
		// In Safari 8 documents created via document.implementation.createHTMLDocument
		// collapse sibling forms: the second one becomes a child of the first one.
		// Because of that, this security measure has to be disabled in Safari 8.
		// https://bugs.webkit.org/show_bug.cgi?id=137337
		support.createHTMLDocument = ( function() {
			var body = document.implementation.createHTMLDocument( "" ).body;
			body.innerHTML = "<form></form><form></form>";
			return body.childNodes.length === 2;
		} )();


		// Argument "data" should be string of html
		// context (optional): If specified, the fragment will be created in this context,
		// defaults to document
		// keepScripts (optional): If true, will include scripts passed in the html string
		jQuery.parseHTML = function( data, context, keepScripts ) {
			if ( typeof data !== "string" ) {
				return [];
			}
			if ( typeof context === "boolean" ) {
				keepScripts = context;
				context = false;
			}

			var base, parsed, scripts;

			if ( !context ) {

				// Stop scripts or inline event handlers from being executed immediately
				// by using document.implementation
				if ( support.createHTMLDocument ) {
					context = document.implementation.createHTMLDocument( "" );

					// Set the base href for the created document
					// so any parsed elements with URLs
					// are based on the document's URL (gh-2965)
					base = context.createElement( "base" );
					base.href = document.location.href;
					context.head.appendChild( base );
				} else {
					context = document;
				}
			}

			parsed = rsingleTag.exec( data );
			scripts = !keepScripts && [];

			// Single tag
			if ( parsed ) {
				return [ context.createElement( parsed[ 1 ] ) ];
			}

			parsed = buildFragment( [ data ], context, scripts );

			if ( scripts && scripts.length ) {
				jQuery( scripts ).remove();
			}

			return jQuery.merge( [], parsed.childNodes );
		};


		/**
		 * Load a url into a page
		 */
		jQuery.fn.load = function( url, params, callback ) {
			var selector, type, response,
				self = this,
				off = url.indexOf( " " );

			if ( off > -1 ) {
				selector = stripAndCollapse( url.slice( off ) );
				url = url.slice( 0, off );
			}

			// If it's a function
			if ( isFunction( params ) ) {

				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( params && typeof params === "object" ) {
				type = "POST";
			}

			// If we have elements to modify, make the request
			if ( self.length > 0 ) {
				jQuery.ajax( {
					url: url,

					// If "type" variable is undefined, then "GET" method will be used.
					// Make value of this field explicit since
					// user can override it through ajaxSetup method
					type: type || "GET",
					dataType: "html",
					data: params
				} ).done( function( responseText ) {

					// Save response for use in complete callback
					response = arguments;

					self.html( selector ?

						// If a selector was specified, locate the right elements in a dummy div
						// Exclude scripts to avoid IE 'Permission Denied' errors
						jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

						// Otherwise use the full result
						responseText );

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
				} ).always( callback && function( jqXHR, status ) {
					self.each( function() {
						callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
					} );
				} );
			}

			return this;
		};




		jQuery.expr.pseudos.animated = function( elem ) {
			return jQuery.grep( jQuery.timers, function( fn ) {
				return elem === fn.elem;
			} ).length;
		};




		jQuery.offset = {
			setOffset: function( elem, options, i ) {
				var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
					position = jQuery.css( elem, "position" ),
					curElem = jQuery( elem ),
					props = {};

				// Set position first, in-case top/left are set even on static elem
				if ( position === "static" ) {
					elem.style.position = "relative";
				}

				curOffset = curElem.offset();
				curCSSTop = jQuery.css( elem, "top" );
				curCSSLeft = jQuery.css( elem, "left" );
				calculatePosition = ( position === "absolute" || position === "fixed" ) &&
					( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

				// Need to be able to calculate position if either
				// top or left is auto and position is either absolute or fixed
				if ( calculatePosition ) {
					curPosition = curElem.position();
					curTop = curPosition.top;
					curLeft = curPosition.left;

				} else {
					curTop = parseFloat( curCSSTop ) || 0;
					curLeft = parseFloat( curCSSLeft ) || 0;
				}

				if ( isFunction( options ) ) {

					// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
					options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
				}

				if ( options.top != null ) {
					props.top = ( options.top - curOffset.top ) + curTop;
				}
				if ( options.left != null ) {
					props.left = ( options.left - curOffset.left ) + curLeft;
				}

				if ( "using" in options ) {
					options.using.call( elem, props );

				} else {
					curElem.css( props );
				}
			}
		};

		jQuery.fn.extend( {

			// offset() relates an element's border box to the document origin
			offset: function( options ) {

				// Preserve chaining for setter
				if ( arguments.length ) {
					return options === undefined ?
						this :
						this.each( function( i ) {
							jQuery.offset.setOffset( this, options, i );
						} );
				}

				var rect, win,
					elem = this[ 0 ];

				if ( !elem ) {
					return;
				}

				// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
				// Support: IE <=11 only
				// Running getBoundingClientRect on a
				// disconnected node in IE throws an error
				if ( !elem.getClientRects().length ) {
					return { top: 0, left: 0 };
				}

				// Get document-relative position by adding viewport scroll to viewport-relative gBCR
				rect = elem.getBoundingClientRect();
				win = elem.ownerDocument.defaultView;
				return {
					top: rect.top + win.pageYOffset,
					left: rect.left + win.pageXOffset
				};
			},

			// position() relates an element's margin box to its offset parent's padding box
			// This corresponds to the behavior of CSS absolute positioning
			position: function() {
				if ( !this[ 0 ] ) {
					return;
				}

				var offsetParent, offset, doc,
					elem = this[ 0 ],
					parentOffset = { top: 0, left: 0 };

				// position:fixed elements are offset from the viewport, which itself always has zero offset
				if ( jQuery.css( elem, "position" ) === "fixed" ) {

					// Assume position:fixed implies availability of getBoundingClientRect
					offset = elem.getBoundingClientRect();

				} else {
					offset = this.offset();

					// Account for the *real* offset parent, which can be the document or its root element
					// when a statically positioned element is identified
					doc = elem.ownerDocument;
					offsetParent = elem.offsetParent || doc.documentElement;
					while ( offsetParent &&
						( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
						jQuery.css( offsetParent, "position" ) === "static" ) {

						offsetParent = offsetParent.parentNode;
					}
					if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

						// Incorporate borders into its offset, since they are outside its content origin
						parentOffset = jQuery( offsetParent ).offset();
						parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
						parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
					}
				}

				// Subtract parent offsets and element margins
				return {
					top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
					left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
				};
			},

			// This method will return documentElement in the following cases:
			// 1) For the element inside the iframe without offsetParent, this method will return
			//    documentElement of the parent window
			// 2) For the hidden or detached element
			// 3) For body or html element, i.e. in case of the html node - it will return itself
			//
			// but those exceptions were never presented as a real life use-cases
			// and might be considered as more preferable results.
			//
			// This logic, however, is not guaranteed and can change at any point in the future
			offsetParent: function() {
				return this.map( function() {
					var offsetParent = this.offsetParent;

					while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
						offsetParent = offsetParent.offsetParent;
					}

					return offsetParent || documentElement;
				} );
			}
		} );

		// Create scrollLeft and scrollTop methods
		jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
			var top = "pageYOffset" === prop;

			jQuery.fn[ method ] = function( val ) {
				return access( this, function( elem, method, val ) {

					// Coalesce documents and windows
					var win;
					if ( isWindow( elem ) ) {
						win = elem;
					} else if ( elem.nodeType === 9 ) {
						win = elem.defaultView;
					}

					if ( val === undefined ) {
						return win ? win[ prop ] : elem[ method ];
					}

					if ( win ) {
						win.scrollTo(
							!top ? val : win.pageXOffset,
							top ? val : win.pageYOffset
						);

					} else {
						elem[ method ] = val;
					}
				}, method, val, arguments.length );
			};
		} );

		// Support: Safari <=7 - 9.1, Chrome <=37 - 49
		// Add the top/left cssHooks using jQuery.fn.position
		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
		// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
		// getComputedStyle returns percent when specified for top/left/bottom/right;
		// rather than make the css module depend on the offset module, just check for it here
		jQuery.each( [ "top", "left" ], function( _i, prop ) {
			jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
				function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );

						// If curCSS returns percentage, fallback to offset
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			);
		} );


		// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
		jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
			jQuery.each( {
				padding: "inner" + name,
				content: type,
				"": "outer" + name
			}, function( defaultExtra, funcName ) {

				// Margin is only for outerHeight, outerWidth
				jQuery.fn[ funcName ] = function( margin, value ) {
					var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
						extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

					return access( this, function( elem, type, value ) {
						var doc;

						if ( isWindow( elem ) ) {

							// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
							return funcName.indexOf( "outer" ) === 0 ?
								elem[ "inner" + name ] :
								elem.document.documentElement[ "client" + name ];
						}

						// Get document width or height
						if ( elem.nodeType === 9 ) {
							doc = elem.documentElement;

							// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
							// whichever is greatest
							return Math.max(
								elem.body[ "scroll" + name ], doc[ "scroll" + name ],
								elem.body[ "offset" + name ], doc[ "offset" + name ],
								doc[ "client" + name ]
							);
						}

						return value === undefined ?

							// Get width or height on the element, requesting but not forcing parseFloat
							jQuery.css( elem, type, extra ) :

							// Set width or height on the element
							jQuery.style( elem, type, value, extra );
					}, type, chainable ? margin : undefined, chainable );
				};
			} );
		} );


		jQuery.each( [
			"ajaxStart",
			"ajaxStop",
			"ajaxComplete",
			"ajaxError",
			"ajaxSuccess",
			"ajaxSend"
		], function( _i, type ) {
			jQuery.fn[ type ] = function( fn ) {
				return this.on( type, fn );
			};
		} );




		jQuery.fn.extend( {

			bind: function( types, data, fn ) {
				return this.on( types, null, data, fn );
			},
			unbind: function( types, fn ) {
				return this.off( types, null, fn );
			},

			delegate: function( selector, types, data, fn ) {
				return this.on( types, selector, data, fn );
			},
			undelegate: function( selector, types, fn ) {

				// ( namespace ) or ( selector, types [, fn] )
				return arguments.length === 1 ?
					this.off( selector, "**" ) :
					this.off( types, selector || "**", fn );
			},

			hover: function( fnOver, fnOut ) {
				return this
					.on( "mouseenter", fnOver )
					.on( "mouseleave", fnOut || fnOver );
			}
		} );

		jQuery.each(
			( "blur focus focusin focusout resize scroll click dblclick " +
			"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
			"change select submit keydown keypress keyup contextmenu" ).split( " " ),
			function( _i, name ) {

				// Handle event binding
				jQuery.fn[ name ] = function( data, fn ) {
					return arguments.length > 0 ?
						this.on( name, null, data, fn ) :
						this.trigger( name );
				};
			}
		);




		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		// Require that the "whitespace run" starts from a non-whitespace
		// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
		var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

		// Bind a function to a context, optionally partially applying any
		// arguments.
		// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
		// However, it is not slated for removal any time soon
		jQuery.proxy = function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		};

		jQuery.holdReady = function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		};
		jQuery.isArray = Array.isArray;
		jQuery.parseJSON = JSON.parse;
		jQuery.nodeName = nodeName;
		jQuery.isFunction = isFunction;
		jQuery.isWindow = isWindow;
		jQuery.camelCase = camelCase;
		jQuery.type = toType;

		jQuery.now = Date.now;

		jQuery.isNumeric = function( obj ) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&

				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		};

		jQuery.trim = function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "$1" );
		};



		// Register as a named AMD module, since jQuery can be concatenated with other
		// files that may use define, but not via a proper concatenation script that
		// understands anonymous AMD modules. A named AMD is safest and most robust
		// way to register. Lowercase jquery is used because AMD module names are
		// derived from file names, and jQuery is normally delivered in a lowercase
		// file name. Do this after creating the global so that if an AMD module wants
		// to call noConflict to hide this version of jQuery, it will work.

		// Note that for maximum portability, libraries that are not jQuery should
		// declare themselves as anonymous modules, and avoid setting a global if an
		// AMD loader is present. jQuery is a special case. For more information, see
		// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

		if ( typeof undefined === "function" && undefined.amd ) {
			undefined( "jquery", [], function() {
				return jQuery;
			} );
		}




		var

			// Map over jQuery in case of overwrite
			_jQuery = window.jQuery,

			// Map over the $ in case of overwrite
			_$ = window.$;

		jQuery.noConflict = function( deep ) {
			if ( window.$ === jQuery ) {
				window.$ = _$;
			}

			if ( deep && window.jQuery === jQuery ) {
				window.jQuery = _jQuery;
			}

			return jQuery;
		};

		// Expose jQuery and $ identifiers, even in AMD
		// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
		// and CommonJS for browser emulators (trac-13566)
		if ( typeof noGlobal === "undefined" ) {
			window.jQuery = window.$ = jQuery;
		}




		return jQuery;
		} ); 
	} (jquery$1));
	return jquery$1.exports;
}

var jqueryExports = requireJquery();
var JQuery = /*@__PURE__*/getDefaultExportFromCjs(jqueryExports);

var jquery_mousewheel$2 = {exports: {}};

/*!
 * jQuery Mousewheel 3.2.2
 * Copyright OpenJS Foundation and other contributors
 */
var jquery_mousewheel$1 = jquery_mousewheel$2.exports;

var hasRequiredJquery_mousewheel;

function requireJquery_mousewheel () {
	if (hasRequiredJquery_mousewheel) return jquery_mousewheel$2.exports;
	hasRequiredJquery_mousewheel = 1;
	(function (module, exports) {
		( function( factory ) {
		    "use strict";

		    if ( typeof undefined === "function" && undefined.amd ) {

		        // AMD. Register as an anonymous module.
		        undefined( [ "jquery" ], factory );
		    } else if ( 'object' === "object" ) {

		        // Node/CommonJS style for Browserify
		        module.exports = factory;
		    } else {

		        // Browser globals
		        factory( jQuery );
		    }
		} )( function( $ ) {
		    "use strict";

		    var nullLowestDeltaTimeout, lowestDelta,
		        modernEvents = !!$.fn.on,
		        toFix  = [ "wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll" ],
		        toBind = ( "onwheel" in window.document || window.document.documentMode >= 9 ) ?
		            [ "wheel" ] : [ "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ],
		        slice  = Array.prototype.slice;

		    if ( $.event.fixHooks ) {
		        for ( var i = toFix.length; i; ) {
		            $.event.fixHooks[ toFix[ --i ] ] = $.event.mouseHooks;
		        }
		    }

		    var special = $.event.special.mousewheel = {
		        version: "3.2.2",

		        setup: function() {
		            if ( this.addEventListener ) {
		                for ( var i = toBind.length; i; ) {
		                    this.addEventListener( toBind[ --i ], handler, false );
		                }
		            } else {
		                this.onmousewheel = handler;
		            }

		            // Store the line height and page height for this particular element
		            $.data( this, "mousewheel-line-height", special.getLineHeight( this ) );
		            $.data( this, "mousewheel-page-height", special.getPageHeight( this ) );
		        },

		        teardown: function() {
		            if ( this.removeEventListener ) {
		                for ( var i = toBind.length; i; ) {
		                    this.removeEventListener( toBind[ --i ], handler, false );
		                }
		            } else {
		                this.onmousewheel = null;
		            }

		            // Clean up the data we added to the element
		            $.removeData( this, "mousewheel-line-height" );
		            $.removeData( this, "mousewheel-page-height" );
		        },

		        getLineHeight: function( elem ) {
		            var $elem = $( elem ),
		                $parent = $elem[ "offsetParent" in $.fn ? "offsetParent" : "parent" ]();
		            if ( !$parent.length ) {
		                $parent = $( "body" );
		            }
		            return parseInt( $parent.css( "fontSize" ), 10 ) ||
		                parseInt( $elem.css( "fontSize" ), 10 ) || 16;
		        },

		        getPageHeight: function( elem ) {
		            return $( elem ).height();
		        },

		        settings: {
		            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
		            normalizeOffset: true  // calls getBoundingClientRect for each event
		        }
		    };

		    $.fn.extend( {
		        mousewheel: function( fn ) {
		            return fn ?
		                this[ modernEvents ? "on" : "bind" ]( "mousewheel", fn ) :
		                this.trigger( "mousewheel" );
		        },

		        unmousewheel: function( fn ) {
		            return this[ modernEvents ? "off" : "unbind" ]( "mousewheel", fn );
		        }
		    } );


		    function handler( event ) {
		        var orgEvent   = event || window.event,
		            args       = slice.call( arguments, 1 ),
		            delta      = 0,
		            deltaX     = 0,
		            deltaY     = 0,
		            absDelta   = 0;
		        event = $.event.fix( orgEvent );
		        event.type = "mousewheel";

		        // Old school scrollwheel delta
		        if ( "detail" in orgEvent ) {
		            deltaY = orgEvent.detail * -1;
		        }
		        if ( "wheelDelta" in orgEvent ) {
		            deltaY = orgEvent.wheelDelta;
		        }
		        if ( "wheelDeltaY" in orgEvent ) {
		            deltaY = orgEvent.wheelDeltaY;
		        }
		        if ( "wheelDeltaX" in orgEvent ) {
		            deltaX = orgEvent.wheelDeltaX * -1;
		        }

		        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
		        if ( "axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
		            deltaX = deltaY * -1;
		            deltaY = 0;
		        }

		        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatability
		        delta = deltaY === 0 ? deltaX : deltaY;

		        // New school wheel delta (wheel event)
		        if ( "deltaY" in orgEvent ) {
		            deltaY = orgEvent.deltaY * -1;
		            delta  = deltaY;
		        }
		        if ( "deltaX" in orgEvent ) {
		            deltaX = orgEvent.deltaX;
		            if ( deltaY === 0 ) {
		                delta  = deltaX * -1;
		            }
		        }

		        // No change actually happened, no reason to go any further
		        if ( deltaY === 0 && deltaX === 0 ) {
		            return;
		        }

		        // Need to convert lines and pages to pixels if we aren't already in pixels
		        // There are three delta modes:
		        //   * deltaMode 0 is by pixels, nothing to do
		        //   * deltaMode 1 is by lines
		        //   * deltaMode 2 is by pages
		        if ( orgEvent.deltaMode === 1 ) {
		            var lineHeight = $.data( this, "mousewheel-line-height" );
		            delta  *= lineHeight;
		            deltaY *= lineHeight;
		            deltaX *= lineHeight;
		        } else if ( orgEvent.deltaMode === 2 ) {
		            var pageHeight = $.data( this, "mousewheel-page-height" );
		            delta  *= pageHeight;
		            deltaY *= pageHeight;
		            deltaX *= pageHeight;
		        }

		        // Store lowest absolute delta to normalize the delta values
		        absDelta = Math.max( Math.abs( deltaY ), Math.abs( deltaX ) );

		        if ( !lowestDelta || absDelta < lowestDelta ) {
		            lowestDelta = absDelta;

		            // Adjust older deltas if necessary
		            if ( shouldAdjustOldDeltas( orgEvent, absDelta ) ) {
		                lowestDelta /= 40;
		            }
		        }

		        // Adjust older deltas if necessary
		        if ( shouldAdjustOldDeltas( orgEvent, absDelta ) ) {

		            // Divide all the things by 40!
		            delta  /= 40;
		            deltaX /= 40;
		            deltaY /= 40;
		        }

		        // Get a whole, normalized value for the deltas
		        delta  = Math[ delta  >= 1 ? "floor" : "ceil" ]( delta  / lowestDelta );
		        deltaX = Math[ deltaX >= 1 ? "floor" : "ceil" ]( deltaX / lowestDelta );
		        deltaY = Math[ deltaY >= 1 ? "floor" : "ceil" ]( deltaY / lowestDelta );

		        // Normalise offsetX and offsetY properties
		        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
		            var boundingRect = this.getBoundingClientRect();
		            event.offsetX = event.clientX - boundingRect.left;
		            event.offsetY = event.clientY - boundingRect.top;
		        }

		        // Add information to the event object
		        event.deltaX = deltaX;
		        event.deltaY = deltaY;
		        event.deltaFactor = lowestDelta;

		        // Go ahead and set deltaMode to 0 since we converted to pixels
		        // Although this is a little odd since we overwrite the deltaX/Y
		        // properties with normalized deltas.
		        event.deltaMode = 0;

		        // Add event and delta to the front of the arguments
		        args.unshift( event, delta, deltaX, deltaY );

		        // Clear out lowestDelta after sometime to better
		        // handle multiple device types that give different
		        // a different lowestDelta
		        // Ex: trackpad = 3 and mouse wheel = 120
		        if ( nullLowestDeltaTimeout ) {
		            window.clearTimeout( nullLowestDeltaTimeout );
		        }
		        nullLowestDeltaTimeout = window.setTimeout( function() {
		            lowestDelta = null;
		        }, 200 );

		        return ( $.event.dispatch || $.event.handle ).apply( this, args );
		    }

		    function shouldAdjustOldDeltas( orgEvent, absDelta ) {

		        // If this is an older event and the delta is divisible by 120,
		        // then we are assuming that the browser is treating this as an
		        // older mouse wheel event and that we should divide the deltas
		        // by 40 to try and get a more usable deltaFactor.
		        // Side note, this actually impacts the reported scroll distance
		        // in older browsers and can cause scrolling to be slower than native.
		        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
		        return special.settings.adjustOldDeltas && orgEvent.type === "mousewheel" &&
		            absDelta % 120 === 0;
		    }

		} ); 
	} (jquery_mousewheel$2, jquery_mousewheel$2.exports));
	return jquery_mousewheel$2.exports;
}

var jquery_mousewheelExports = requireJquery_mousewheel();
var jquery_mousewheel = /*@__PURE__*/getDefaultExportFromCjs(jquery_mousewheelExports);

/* eslint-disable no-underscore-dangle */
let _IS_MAC = false;
let _IS_IOS = false;
let _IS_WINDOWS = false;
let _IS_IE = false;
let _IS_IE11 = false;
let _IS_EDGE = false;
let _IS_NETSCAPE = false;
let _IS_CHROME_APP = false;
let _IS_CHROME = false;
let _IS_OPERA = false;
let _IS_FIREFOX = false;
let _IS_SAFARI = false;
let _SUPPORT_TOUCH = false;
let _SUPPORT_POINTER = false;
let _SUPPORT_PASSIVE = false;
let _NO_FOREIGNOBJECT = false;
if (typeof navigator === 'object') {
    const ua = navigator.userAgent;
    _IS_MAC = ua.indexOf('Macintosh') >= 0;
    _IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g);
    _IS_WINDOWS = ua.indexOf('Windows') >= 0;
    _IS_IE = ua.indexOf('MSIE') >= 0;
    _IS_IE11 = !!ua.match(/Trident\/7\./);
    _IS_EDGE = !!ua.match(/Edge\//);
    _IS_NETSCAPE =
        ua.indexOf('Mozilla/') >= 0 &&
            ua.indexOf('MSIE') < 0 &&
            ua.indexOf('Edge/') < 0;
    _IS_CHROME = ua.indexOf('Chrome/') >= 0 && ua.indexOf('Edge/') < 0;
    _IS_OPERA = ua.indexOf('Opera/') >= 0 || ua.indexOf('OPR/') >= 0;
    _IS_FIREFOX = ua.indexOf('Firefox/') >= 0;
    _IS_SAFARI =
        ua.indexOf('AppleWebKit/') >= 0 &&
            ua.indexOf('Chrome/') < 0 &&
            ua.indexOf('Edge/') < 0;
    if (typeof document === 'object') {
        _NO_FOREIGNOBJECT =
            !document.createElementNS ||
                `${document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')}` !== '[object SVGForeignObjectElement]' ||
                ua.indexOf('Opera/') >= 0;
    }
}
if (typeof window === 'object') {
    _IS_CHROME_APP =
        window.chrome != null &&
            window.chrome.app != null &&
            window.chrome.app.runtime != null;
    _SUPPORT_POINTER = window.PointerEvent != null && !_IS_MAC;
}
if (typeof document === 'object') {
    _SUPPORT_TOUCH = 'ontouchstart' in document.documentElement;
    try {
        const options = Object.defineProperty({}, 'passive', {
            get() {
                _SUPPORT_PASSIVE = true;
            },
        });
        const div = document.createElement('div');
        if (div.addEventListener) {
            div.addEventListener('click', () => { }, options);
        }
    }
    catch (err) {
        // pass
    }
}
var Platform;
(function (Platform) {
    Platform.IS_MAC = _IS_MAC;
    Platform.IS_IOS = _IS_IOS;
    Platform.IS_WINDOWS = _IS_WINDOWS;
    Platform.IS_IE = _IS_IE;
    Platform.IS_IE11 = _IS_IE11;
    Platform.IS_EDGE = _IS_EDGE;
    /**
     * A flag indicating whether the browser is Netscape (including Firefox).
     */
    Platform.IS_NETSCAPE = _IS_NETSCAPE;
    /**
     * A flag indicating whether the the this is running inside a Chrome App.
     */
    Platform.IS_CHROME_APP = _IS_CHROME_APP;
    Platform.IS_CHROME = _IS_CHROME;
    Platform.IS_OPERA = _IS_OPERA;
    Platform.IS_FIREFOX = _IS_FIREFOX;
    Platform.IS_SAFARI = _IS_SAFARI;
    /**
     * A flag indicating whether this device supports touchstart/-move/-end
     * events (Apple iOS, Android, Chromebook and Chrome Browser on touch-enabled
     * devices).
     */
    Platform.SUPPORT_TOUCH = _SUPPORT_TOUCH;
    /**
     * A flag indicating whether this device supports Microsoft pointer events.
     */
    Platform.SUPPORT_POINTER = _SUPPORT_POINTER;
    Platform.SUPPORT_PASSIVE = _SUPPORT_PASSIVE;
    /**
     * A flag indicating whether foreignObject support is not available. This
     * is the case for Opera, older SVG-based browsers and all versions of IE.
     */
    Platform.NO_FOREIGNOBJECT = _NO_FOREIGNOBJECT;
    Platform.SUPPORT_FOREIGNOBJECT = !Platform.NO_FOREIGNOBJECT;
})(Platform || (Platform = {}));
(function (Platform) {
    function getHMRStatus() {
        const mod = window.module;
        if (mod != null && mod.hot != null && mod.hot.status != null) {
            return mod.hot.status();
        }
        return 'unkonwn';
    }
    Platform.getHMRStatus = getHMRStatus;
    function isApplyingHMR() {
        return getHMRStatus() === 'apply';
    }
    Platform.isApplyingHMR = isApplyingHMR;
    // This function checks if the specified event is supported by the browser.
    // Source: http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
    const TAGNAMES = {
        select: 'input',
        change: 'input',
        submit: 'form',
        reset: 'form',
        error: 'img',
        load: 'img',
        abort: 'img',
    };
    function isEventSupported(event) {
        const elem = document.createElement(TAGNAMES[event] || 'div');
        const eventName = `on${event}`;
        let isSupported = eventName in elem;
        if (!isSupported) {
            elem.setAttribute(eventName, 'return;');
            isSupported = typeof elem[eventName] === 'function';
        }
        return isSupported;
    }
    Platform.isEventSupported = isEventSupported;
})(Platform || (Platform = {}));

if (Platform.SUPPORT_PASSIVE) {
    JQuery.event.special.touchstart = {
        setup(data, ns, handle) {
            if (!this.addEventListener) {
                return false;
            }
            this.addEventListener('touchstart', handle, {
                passive: true,
            });
        },
    };
    const hook = JQuery.event.special.mousewheel;
    if (hook) {
        const setup = hook.setup;
        hook.setup = function () {
            const addEventListener = this.addEventListener;
            if (!addEventListener) {
                return false;
            }
            this.addEventListener = (name, handler) => {
                addEventListener.call(this, name, handler, { passive: true });
            };
            setup.call(this);
            this.addEventListener = addEventListener;
        };
    }
}
// compatible with NodeList.prototype.forEach() before chrome 51
// https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
}
// compatible with ParentNode.append() before chrome 54
// https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/append()/append().md
;
(function (arr) {
    arr.forEach((item) => {
        if (Object.prototype.hasOwnProperty.call(item, 'append')) {
            return;
        }
        Object.defineProperty(item, 'append', {
            configurable: true,
            enumerable: true,
            writable: true,
            value(...args) {
                const docFrag = document.createDocumentFragment();
                args.forEach((arg) => {
                    const isNode = arg instanceof Node;
                    docFrag.appendChild(isNode ? arg : document.createTextNode(String(arg)));
                });
                this.appendChild(docFrag);
            },
        });
    });
})([Element.prototype, Document.prototype, DocumentFragment.prototype]);

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$s = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$o = objectProto$s.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$3 = objectProto$s.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$o.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$r = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$2 = objectProto$r.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$2.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$3 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
}

/** Used as references for various `Number` constants. */
var NAN$2 = 0 / 0;

/**
 * The base implementation of `_.toNumber` which doesn't ensure correct
 * conversions of binary, hexadecimal, or octal string values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 */
function baseToNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN$2;
  }
  return +value;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used as references for various `Number` constants. */
var INFINITY$5 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$5) ? '-0' : result;
}

/**
 * Creates a function that performs a mathematical operation on two values.
 *
 * @private
 * @param {Function} operator The function to perform the operation.
 * @param {number} [defaultValue] The value used for `undefined` arguments.
 * @returns {Function} Returns the new mathematical operation function.
 */
function createMathOperation(operator, defaultValue) {
  return function(value, other) {
    var result;
    if (value === undefined && other === undefined) {
      return defaultValue;
    }
    if (value !== undefined) {
      result = value;
    }
    if (other !== undefined) {
      if (result === undefined) {
        return other;
      }
      if (typeof value == 'string' || typeof other == 'string') {
        value = baseToString(value);
        other = baseToString(other);
      } else {
        value = baseToNumber(value);
        other = baseToNumber(other);
      }
      result = operator(value, other);
    }
    return result;
  };
}

/**
 * Adds two numbers.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {number} augend The first number in an addition.
 * @param {number} addend The second number in an addition.
 * @returns {number} Returns the total.
 * @example
 *
 * _.add(6, 4);
 * // => 10
 */
var add = createMathOperation(function(augend, addend) {
  return augend + addend;
}, 0);

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart$2 = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart$2, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN$1 = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN$1;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN$1 : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY$4 = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$4 || value === -INFINITY$4) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/** Error message constants. */
var FUNC_ERROR_TEXT$b = 'Expected a function';

/**
 * The opposite of `_.before`; this method creates a function that invokes
 * `func` once it's called `n` or more times.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {number} n The number of calls before `func` is invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var saves = ['profile', 'settings'];
 *
 * var done = _.after(saves.length, function() {
 *   console.log('done saving!');
 * });
 *
 * _.forEach(saves, function(type) {
 *   asyncSave({ 'type': type, 'complete': done });
 * });
 * // => Logs 'done saving!' after the two async saves have completed.
 */
function after(n, func) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$b);
  }
  n = toInteger(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$q = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$n = objectProto$q.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$n).replace(reRegExpChar$1, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root, 'WeakMap');

/** Used to store function metadata. */
var metaMap = WeakMap$1 && new WeakMap$1;

/**
 * The base implementation of `setData` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$8 = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG$8,
      Ctor = createCtor(func);

  function wrapper() {
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$g = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax$g(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$f = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax$f(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      ++result;
    }
  }
  return result;
}

/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$6 = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH$6;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop$1() {
  // No operation performed.
}

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop$1 : function(func) {
  return metaMap.get(func);
};

/** Used to lookup unminified function names. */
var realNames = {};

/** Used for built-in method references. */
var objectProto$p = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$m = objectProto$p.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = hasOwnProperty$m.call(realNames, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

/** Used for built-in method references. */
var objectProto$o = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$l = objectProto$o.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash$1(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty$l.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash$1.prototype = baseLodash.prototype;
lodash$1.prototype.constructor = lodash$1;

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash$1[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = shortOut(baseSetData);

/** Used to match wrap detail comments. */
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
    reSplitDetails = /,? & /;

/**
 * Extracts wrapper details from the `source` body comment.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {Array} Returns the wrapper details.
 */
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}

/** Used to match wrap detail comments. */
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

/**
 * Inserts wrapper `details` in a comment at the top of the `source` body.
 *
 * @private
 * @param {string} source The source to modify.
 * @returns {Array} details The details to insert.
 * @returns {string} Returns the modified source.
 */
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
  details = details.join(length > 2 ? ', ' : ' ');
  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$7 = 1,
    WRAP_BIND_KEY_FLAG$6 = 2,
    WRAP_CURRY_FLAG$6 = 8,
    WRAP_CURRY_RIGHT_FLAG$3 = 16,
    WRAP_PARTIAL_FLAG$6 = 32,
    WRAP_PARTIAL_RIGHT_FLAG$3 = 64,
    WRAP_ARY_FLAG$4 = 128,
    WRAP_REARG_FLAG$3 = 256,
    WRAP_FLIP_FLAG$2 = 512;

/** Used to associate wrap methods with their bit flags. */
var wrapFlags = [
  ['ary', WRAP_ARY_FLAG$4],
  ['bind', WRAP_BIND_FLAG$7],
  ['bindKey', WRAP_BIND_KEY_FLAG$6],
  ['curry', WRAP_CURRY_FLAG$6],
  ['curryRight', WRAP_CURRY_RIGHT_FLAG$3],
  ['flip', WRAP_FLIP_FLAG$2],
  ['partial', WRAP_PARTIAL_FLAG$6],
  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG$3],
  ['rearg', WRAP_REARG_FLAG$3]
];

/**
 * Updates wrapper `details` based on `bitmask` flags.
 *
 * @private
 * @returns {Array} details The details to modify.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Array} Returns `details`.
 */
function updateWrapDetails(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = '_.' + pair[0];
    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}

/**
 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
 * with wrapper details in a comment at the top of the source body.
 *
 * @private
 * @param {Function} wrapper The function to modify.
 * @param {Function} reference The reference function.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Function} Returns `wrapper`.
 */
function setWrapToString(wrapper, reference, bitmask) {
  var source = (reference + '');
  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$6 = 1,
    WRAP_BIND_KEY_FLAG$5 = 2,
    WRAP_CURRY_BOUND_FLAG$1 = 4,
    WRAP_CURRY_FLAG$5 = 8,
    WRAP_PARTIAL_FLAG$5 = 32,
    WRAP_PARTIAL_RIGHT_FLAG$2 = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG$5,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$5 : WRAP_PARTIAL_RIGHT_FLAG$2);
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$2 : WRAP_PARTIAL_FLAG$5);

  if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
    bitmask &= ~(WRAP_BIND_FLAG$6 | WRAP_BIND_KEY_FLAG$5);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (isLaziable(func)) {
    setData(result, newData);
  }
  result.placeholder = placeholder;
  return setWrapToString(result, func, bitmask);
}

/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$5 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$5 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$e = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin$e(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

/** Used as the internal argument placeholder. */
var PLACEHOLDER$1 = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER$1) {
      array[index] = PLACEHOLDER$1;
      result[resIndex++] = index;
    }
  }
  return result;
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$5 = 1,
    WRAP_BIND_KEY_FLAG$4 = 2,
    WRAP_CURRY_FLAG$4 = 8,
    WRAP_CURRY_RIGHT_FLAG$2 = 16,
    WRAP_ARY_FLAG$3 = 128,
    WRAP_FLIP_FLAG$1 = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG$3,
      isBind = bitmask & WRAP_BIND_FLAG$5,
      isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4,
      isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2),
      isFlip = bitmask & WRAP_FLIP_FLAG$1,
      Ctor = isBindKey ? undefined : createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtor(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply$1(fn, this, args);
  }
  return wrapper;
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$4 = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG$4,
      Ctor = createCtor(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply$1(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$3 = 1,
    WRAP_BIND_KEY_FLAG$3 = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG$3 = 8,
    WRAP_ARY_FLAG$2 = 128,
    WRAP_REARG_FLAG$2 = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$d = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (WRAP_BIND_FLAG$3 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);

  var isCombo =
    ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
    ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$2) && (data[7].length <= source[8])) ||
    ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & WRAP_BIND_FLAG$3) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & WRAP_BIND_FLAG$3 ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & WRAP_ARY_FLAG$2) {
    data[8] = data[8] == null ? source[8] : nativeMin$d(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

/** Error message constants. */
var FUNC_ERROR_TEXT$a = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$2 = 1,
    WRAP_BIND_KEY_FLAG$2 = 2,
    WRAP_CURRY_FLAG$2 = 8,
    WRAP_CURRY_RIGHT_FLAG$1 = 16,
    WRAP_PARTIAL_FLAG$4 = 32,
    WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$e = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags.
 *    1 - `_.bind`
 *    2 - `_.bindKey`
 *    4 - `_.curry` or `_.curryRight` of a bound function
 *    8 - `_.curry`
 *   16 - `_.curryRight`
 *   32 - `_.partial`
 *   64 - `_.partialRight`
 *  128 - `_.rearg`
 *  256 - `_.ary`
 *  512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$a);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG$4 | WRAP_PARTIAL_RIGHT_FLAG$1);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax$e(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$1) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === undefined
    ? (isBindKey ? 0 : func.length)
    : nativeMax$e(newData[9] - length, 0);

  if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1)) {
    bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG$2) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG$1) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG$4 || bitmask == (WRAP_BIND_FLAG$2 | WRAP_PARTIAL_FLAG$4)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func, bitmask);
}

/** Used to compose bitmasks for function metadata. */
var WRAP_ARY_FLAG$1 = 128;

/**
 * Creates a function that invokes `func`, with up to `n` arguments,
 * ignoring any additional arguments.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to cap arguments for.
 * @param {number} [n=func.length] The arity cap.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new capped function.
 * @example
 *
 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
 * // => [6, 8, 10]
 */
function ary(func, n, guard) {
  n = guard ? undefined : n;
  n = (func && n == null) ? func.length : n;
  return createWrap(func, WRAP_ARY_FLAG$1, undefined, undefined, undefined, undefined, n);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$n = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$k = objectProto$n.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$k.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$d = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$d(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$d(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply$1(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$4 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$4;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/** Used for built-in method references. */
var objectProto$m = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$m;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}

/** Used for built-in method references. */
var objectProto$l = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$j = objectProto$l.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$l.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$j.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$1 = moduleExports$2 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$4 = '[object Boolean]',
    dateTag$4 = '[object Date]',
    errorTag$3 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$9 = '[object Map]',
    numberTag$4 = '[object Number]',
    objectTag$4 = '[object Object]',
    regexpTag$4 = '[object RegExp]',
    setTag$9 = '[object Set]',
    stringTag$4 = '[object String]',
    weakMapTag$3 = '[object WeakMap]';

var arrayBufferTag$4 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
typedArrayTags[arrayBufferTag$4] = typedArrayTags[boolTag$4] =
typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$4] =
typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$9] = typedArrayTags[numberTag$4] =
typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$4] =
typedArrayTags[setTag$9] = typedArrayTags[stringTag$4] =
typedArrayTags[weakMapTag$3] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$k = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$i = objectProto$k.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$i.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$j = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$h = objectProto$j.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$h.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used for built-in method references. */
var objectProto$i = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$g = objectProto$i.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty$g.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$h = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$f = objectProto$h.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$f.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */
var assignIn = createAssigner(function(object, source) {
  copyObject(source, keysIn(source), object);
});

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * This method is like `_.assign` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignInWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keys(source), object, customizer);
});

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$g = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$e = objectProto$g.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$e.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$f.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$d.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto$5 = Array.prototype;

/** Built-in value references. */
var splice$2 = arrayProto$5.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$2.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT$9 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$9);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY$3 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.at` without support for individual paths.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {string[]} paths The property paths to pick.
 * @returns {Array} Returns the picked elements.
 */
function baseAt(object, paths) {
  var index = -1,
      length = paths.length,
      result = Array(length),
      skip = object == null;

  while (++index < length) {
    result[index] = skip ? undefined : get(object, paths[index]);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten$1), func + '');
}

/**
 * Creates an array of values corresponding to `paths` of `object`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Array} Returns the picked values.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
 *
 * _.at(object, ['a[0].b.c', 'a[1]']);
 * // => [3, 4]
 */
var at = flatRest(baseAt);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */
var objectTag$3 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$e = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$e.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$c.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag$2 = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag$2 || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply$1(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/** Error message constants. */
var FUNC_ERROR_TEXT$8 = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before$1(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$8);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG$1 = 1,
    WRAP_PARTIAL_FLAG$3 = 32;

/**
 * Creates a function that invokes `func` with the `this` binding of `thisArg`
 * and `partials` prepended to the arguments it receives.
 *
 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for partially applied arguments.
 *
 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
 * property of bound functions.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * function greet(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * }
 *
 * var object = { 'user': 'fred' };
 *
 * var bound = _.bind(greet, object, 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bind(greet, object, _, '!');
 * bound('hi');
 * // => 'hi fred!'
 */
var bind = baseRest(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG$1;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= WRAP_PARTIAL_FLAG$3;
  }
  return createWrap(func, bitmask, thisArg, partials, holders);
});

// Assign default placeholders.
bind.placeholder = {};

/**
 * Binds methods of an object to the object itself, overwriting the existing
 * method.
 *
 * **Note:** This method doesn't set the "length" property of bound functions.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {Object} object The object to bind and assign the bound methods to.
 * @param {...(string|string[])} methodNames The object method names to bind.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var view = {
 *   'label': 'docs',
 *   'click': function() {
 *     console.log('clicked ' + this.label);
 *   }
 * };
 *
 * _.bindAll(view, ['click']);
 * jQuery(element).on('click', view.click);
 * // => Logs 'clicked docs' when clicked.
 */
var bindAll = flatRest(function(object, methodNames) {
  arrayEach(methodNames, function(key) {
    key = toKey(key);
    baseAssignValue(object, key, bind(object[key], object));
  });
  return object;
});

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG$1 = 2,
    WRAP_PARTIAL_FLAG$2 = 32;

/**
 * Creates a function that invokes the method at `object[key]` with `partials`
 * prepended to the arguments it receives.
 *
 * This method differs from `_.bind` by allowing bound functions to reference
 * methods that may be redefined or don't yet exist. See
 * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
 * for more details.
 *
 * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Function
 * @param {Object} object The object to invoke the method on.
 * @param {string} key The key of the method.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * var object = {
 *   'user': 'fred',
 *   'greet': function(greeting, punctuation) {
 *     return greeting + ' ' + this.user + punctuation;
 *   }
 * };
 *
 * var bound = _.bindKey(object, 'greet', 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * object.greet = function(greeting, punctuation) {
 *   return greeting + 'ya ' + this.user + punctuation;
 * };
 *
 * bound('!');
 * // => 'hiya fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bindKey(object, 'greet', _, '!');
 * bound('hi');
 * // => 'hiya fred!'
 */
var bindKey = baseRest(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG$1;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG$2;
  }
  return createWrap(key, bitmask, object, partials, holders);
});

// Assign default placeholders.
bindKey.placeholder = {};

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/** Used to compose unicode character classes. */
var rsAstralRange$3 = '\\ud800-\\udfff',
    rsComboMarksRange$4 = '\\u0300-\\u036f',
    reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
    rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
    rsVarRange$3 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$3 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$3 + rsAstralRange$3  + rsComboRange$4 + rsVarRange$3 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange$2 = '\\ud800-\\udfff',
    rsComboMarksRange$3 = '\\u0300-\\u036f',
    reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
    rsVarRange$2 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral$1 = '[' + rsAstralRange$2 + ']',
    rsCombo$3 = '[' + rsComboRange$3 + ']',
    rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
    rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
    rsNonAstral$2 = '[^' + rsAstralRange$2 + ']',
    rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ$2 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod$2 = rsModifier$2 + '?',
    rsOptVar$2 = '[' + rsVarRange$2 + ']?',
    rsOptJoin$2 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
    rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
    rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode$1) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange$2 = '\\u0300-\\u036f',
    reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;

/** Used to compose unicode capture groups. */
var rsCombo$2 = '[' + rsComboRange$2 + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo$2, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange$1 = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo$1 = '[' + rsComboRange$1 + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange$1 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
    rsModifier$1 = '(?:' + rsCombo$1 + '|' + rsFitz$1 + ')',
    rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
    rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod$1 = rsModifier$1 + '?',
    rsOptVar$1 = '[' + rsVarRange$1 + ']?',
    rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

/**
 * Casts `value` as an array if it's not one.
 *
 * @static
 * @memberOf _
 * @since 4.4.0
 * @category Lang
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast array.
 * @example
 *
 * _.castArray(1);
 * // => [1]
 *
 * _.castArray({ 'a': 1 });
 * // => [{ 'a': 1 }]
 *
 * _.castArray('abc');
 * // => ['abc']
 *
 * _.castArray(null);
 * // => [null]
 *
 * _.castArray(undefined);
 * // => [undefined]
 *
 * _.castArray();
 * // => []
 *
 * var array = [1, 2, 3];
 * console.log(_.castArray(array) === array);
 * // => true
 */
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray(value) ? value : [value];
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsFinite$1 = root.isFinite,
    nativeMin$c = Math.min;

/**
 * Creates a function like `_.round`.
 *
 * @private
 * @param {string} methodName The name of the `Math` method to use when rounding.
 * @returns {Function} Returns the new round function.
 */
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = precision == null ? 0 : nativeMin$c(toInteger(precision), 292);
    if (precision && nativeIsFinite$1(number)) {
      // Shift with exponential notation to avoid floating-point issues.
      // See [MDN](https://mdn.io/round#Examples) for more details.
      var pair = (toString(number) + 'e').split('e'),
          value = func(pair[0] + 'e' + (+pair[1] + precision));

      pair = (toString(value) + 'e').split('e');
      return +(pair[0] + 'e' + (+pair[1] - precision));
    }
    return func(number);
  };
}

/**
 * Computes `number` rounded up to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round up.
 * @param {number} [precision=0] The precision to round up to.
 * @returns {number} Returns the rounded up number.
 * @example
 *
 * _.ceil(4.006);
 * // => 5
 *
 * _.ceil(6.004, 2);
 * // => 6.01
 *
 * _.ceil(6040, -2);
 * // => 6100
 */
var ceil = createRound('ceil');

/**
 * Creates a `lodash` wrapper instance that wraps `value` with explicit method
 * chain sequences enabled. The result of such sequences must be unwrapped
 * with `_#value`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Seq
 * @param {*} value The value to wrap.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36 },
 *   { 'user': 'fred',    'age': 40 },
 *   { 'user': 'pebbles', 'age': 1 }
 * ];
 *
 * var youngest = _
 *   .chain(users)
 *   .sortBy('age')
 *   .map(function(o) {
 *     return o.user + ' is ' + o.age;
 *   })
 *   .head()
 *   .value();
 * // => 'pebbles is 1'
 */
function chain(value) {
  var result = lodash$1(value);
  result.__chain__ = true;
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$3 = Math.ceil,
    nativeMax$c = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax$c(toInteger(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil$3(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp$1(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$2 = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE$2 - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$d.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/** `Object#toString` result references. */
var mapTag$8 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$8 = '[object Set]',
    weakMapTag$2 = '[object WeakMap]';

var dataViewTag$3 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
    (Map$1 && getTag(new Map$1) != mapTag$8) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$8) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$2)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$3;
        case mapCtorString: return mapTag$8;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$8;
        case weakMapCtorString: return weakMapTag$2;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$b.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/** Built-in value references. */
var Uint8Array$1 = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags$1 = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags$1.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$3 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    mapTag$7 = '[object Map]',
    numberTag$3 = '[object Number]',
    regexpTag$3 = '[object RegExp]',
    setTag$7 = '[object Set]',
    stringTag$3 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$3:
      return cloneArrayBuffer(object);

    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$7:
      return new Ctor;

    case numberTag$3:
    case stringTag$3:
      return new Ctor(object);

    case regexpTag$3:
      return cloneRegExp(object);

    case setTag$7:
      return new Ctor;

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$6 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$6;
}

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

/** `Object#toString` result references. */
var setTag$6 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$6;
}

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$7 = 1,
    CLONE_FLAT_FLAG$1 = 2,
    CLONE_SYMBOLS_FLAG$5 = 4;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag$5 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag$2 = '[object RegExp]',
    setTag$5 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$1] =
cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag$5] =
cloneableTags[numberTag$2] = cloneableTags[objectTag$1] =
cloneableTags[regexpTag$2] = cloneableTags[setTag$5] =
cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] =
cloneableTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$7,
      isFlat = bitmask & CLONE_FLAT_FLAG$1,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$5;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG$4 = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG$4);
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$6 = 1,
    CLONE_SYMBOLS_FLAG$3 = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$6 | CLONE_SYMBOLS_FLAG$3);
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$5 = 1,
    CLONE_SYMBOLS_FLAG$2 = 4;

/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return baseClone(value, CLONE_DEEP_FLAG$5 | CLONE_SYMBOLS_FLAG$2, customizer);
}

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * This method is like `_.clone` except that it accepts `customizer` which
 * is invoked to produce the cloned value. If `customizer` returns `undefined`,
 * cloning is handled by the method instead. The `customizer` is invoked with
 * up to four arguments; (value [, index|key, object, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeepWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(false);
 *   }
 * }
 *
 * var el = _.cloneWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 0
 */
function cloneWith(value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return baseClone(value, CLONE_SYMBOLS_FLAG$1, customizer);
}

/**
 * Executes the chain sequence and returns the wrapped result.
 *
 * @name commit
 * @memberOf _
 * @since 3.2.0
 * @category Seq
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var array = [1, 2];
 * var wrapped = _(array).push(3);
 *
 * console.log(array);
 * // => [1, 2]
 *
 * wrapped = wrapped.commit();
 * console.log(array);
 * // => [1, 2, 3]
 *
 * wrapped.last();
 * // => 3
 *
 * console.log(array);
 * // => [1, 2, 3]
 */
function wrapperCommit() {
  return new LodashWrapper(this.value(), this.__chain__);
}

/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Creates a new array concatenating `array` with any additional arrays
 * and/or values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to concatenate.
 * @param {...*} [values] The values to concatenate.
 * @returns {Array} Returns the new concatenated array.
 * @example
 *
 * var array = [1];
 * var other = _.concat(array, 2, [3], [[4]]);
 *
 * console.log(other);
 * // => [1, 2, 3, [4]]
 *
 * console.log(array);
 * // => [1]
 */
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1),
      array = arguments[0],
      index = length;

  while (index--) {
    args[index - 1] = arguments[index];
  }
  return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag = '[object Error]',
    mapTag$4 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$4:
      var convert = mapToArray;

    case setTag$4:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$9.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$9.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/** Error message constants. */
var FUNC_ERROR_TEXT$7 = 'Expected a function';

/**
 * Creates a function that iterates over `pairs` and invokes the corresponding
 * function of the first predicate to return truthy. The predicate-function
 * pairs are invoked with the `this` binding and arguments of the created
 * function.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {Array} pairs The predicate-function pairs.
 * @returns {Function} Returns the new composite function.
 * @example
 *
 * var func = _.cond([
 *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
 *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
 *   [_.stubTrue,                      _.constant('no match')]
 * ]);
 *
 * func({ 'a': 1, 'b': 2 });
 * // => 'matches A'
 *
 * func({ 'a': 0, 'b': 1 });
 * // => 'matches B'
 *
 * func({ 'a': '1', 'b': '2' });
 * // => 'no match'
 */
function cond(pairs) {
  var length = pairs == null ? 0 : pairs.length,
      toIteratee = baseIteratee;

  pairs = !length ? [] : arrayMap(pairs, function(pair) {
    if (typeof pair[1] != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$7);
    }
    return [toIteratee(pair[0]), pair[1]];
  });

  return baseRest(function(args) {
    var index = -1;
    while (++index < length) {
      var pair = pairs[index];
      if (apply$1(pair[0], this, args)) {
        return apply$1(pair[1], this, args);
      }
    }
  });
}

/**
 * The base implementation of `_.conformsTo` which accepts `props` to check.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property predicates to conform to.
 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
 */
function baseConformsTo(object, source, props) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (length--) {
    var key = props[length],
        predicate = source[key],
        value = object[key];

    if ((value === undefined && !(key in object)) || !predicate(value)) {
      return false;
    }
  }
  return true;
}

/**
 * The base implementation of `_.conforms` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property predicates to conform to.
 * @returns {Function} Returns the new spec function.
 */
function baseConforms(source) {
  var props = keys(source);
  return function(object) {
    return baseConformsTo(object, source, props);
  };
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$4 = 1;

/**
 * Creates a function that invokes the predicate properties of `source` with
 * the corresponding property values of a given object, returning `true` if
 * all predicates return truthy, else `false`.
 *
 * **Note:** The created function is equivalent to `_.conformsTo` with
 * `source` partially applied.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {Object} source The object of property predicates to conform to.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * var objects = [
 *   { 'a': 2, 'b': 1 },
 *   { 'a': 1, 'b': 2 }
 * ];
 *
 * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
 * // => [{ 'a': 1, 'b': 2 }]
 */
function conforms(source) {
  return baseConforms(baseClone(source, CLONE_DEEP_FLAG$4));
}

/**
 * Checks if `object` conforms to `source` by invoking the predicate
 * properties of `source` with the corresponding property values of `object`.
 *
 * **Note:** This method is equivalent to `_.conforms` when `source` is
 * partially applied.
 *
 * @static
 * @memberOf _
 * @since 4.14.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property predicates to conform to.
 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 *
 * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
 * // => true
 *
 * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
 * // => false
 */
function conformsTo(object, source) {
  return source == null || baseConformsTo(object, source, keys(source));
}

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The corresponding value of
 * each key is the number of times the key was returned by `iteratee`. The
 * iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.countBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': 1, '6': 2 }
 *
 * // The `_.property` iteratee shorthand.
 * _.countBy(['one', 'two', 'three'], 'length');
 * // => { '3': 2, '5': 1 }
 */
var countBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty$8.call(result, key)) {
    ++result[key];
  } else {
    baseAssignValue(result, key, 1);
  }
});

/**
 * Creates an object that inherits from the `prototype` object. If a
 * `properties` object is given, its own enumerable string keyed properties
 * are assigned to the created object.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create$1(prototype, properties) {
  var result = baseCreate(prototype);
  return properties == null ? result : baseAssign(result, properties);
}

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG$1 = 8;

/**
 * Creates a function that accepts arguments of `func` and either invokes
 * `func` returning its result, if at least `arity` number of arguments have
 * been provided, or returns a function that accepts the remaining `func`
 * arguments, and so on. The arity of `func` may be specified if `func.length`
 * is not sufficient.
 *
 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curry(abc);
 *
 * curried(1)(2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(1)(_, 3)(2);
 * // => [1, 2, 3]
 */
function curry(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrap(func, WRAP_CURRY_FLAG$1, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curry.placeholder;
  return result;
}

// Assign default placeholders.
curry.placeholder = {};

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_RIGHT_FLAG = 16;

/**
 * This method is like `_.curry` except that arguments are applied to `func`
 * in the manner of `_.partialRight` instead of `_.partial`.
 *
 * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curryRight(abc);
 *
 * curried(3)(2)(1);
 * // => [1, 2, 3]
 *
 * curried(2, 3)(1);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(3)(1, _)(2);
 * // => [1, 2, 3]
 */
function curryRight(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curryRight.placeholder;
  return result;
}

// Assign default placeholders.
curryRight.placeholder = {};

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/** Error message constants. */
var FUNC_ERROR_TEXT$6 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$b = Math.max,
    nativeMin$b = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$1(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$6);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax$b(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin$b(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks `value` to determine whether a default value should be returned in
 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
 * or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.14.0
 * @category Util
 * @param {*} value The value to check.
 * @param {*} defaultValue The default value.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * _.defaultTo(1, 10);
 * // => 1
 *
 * _.defaultTo(undefined, 10);
 * // => 10
 */
function defaultTo(value, defaultValue) {
  return (value == null || value !== value) ? defaultValue : value;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults$3 = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto$8[key]) && !hasOwnProperty$7.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
 * objects into destination objects that are passed thru.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = baseRest(function(args) {
  args.push(undefined, customDefaultsMerge);
  return apply$1(mergeWith, undefined, args);
});

/** Error message constants. */
var FUNC_ERROR_TEXT$5 = 'Expected a function';

/**
 * The base implementation of `_.delay` and `_.defer` which accepts `args`
 * to provide to `func`.
 *
 * @private
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {Array} args The arguments to provide to `func`.
 * @returns {number|Object} Returns the timer id or timeout object.
 */
function baseDelay(func, wait, args) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$5);
  }
  return setTimeout(function() { func.apply(undefined, args); }, wait);
}

/**
 * Defers invoking the `func` until the current call stack has cleared. Any
 * additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to defer.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.defer(function(text) {
 *   console.log(text);
 * }, 'deferred');
 * // => Logs 'deferred' after one millisecond.
 */
var defer = baseRest(function(func, args) {
  return baseDelay(func, 1, args);
});

/**
 * Invokes `func` after `wait` milliseconds. Any additional arguments are
 * provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.delay(function(text) {
 *   console.log(text);
 * }, 1000, 'later');
 * // => Logs 'later' after one second.
 */
var delay = baseRest(function(func, wait, args) {
  return baseDelay(func, toNumber(wait) || 0, args);
});

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE$1) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

/**
 * This method is like `_.difference` except that it accepts `iteratee` which
 * is invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. The order and references of result values are
 * determined by the first array. The iteratee is invoked with one argument:
 * (value).
 *
 * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
 * // => [1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var differenceBy = baseRest(function(array, values) {
  var iteratee = last(values);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee, 2))
    : [];
});

/**
 * This method is like `_.difference` except that it accepts `comparator`
 * which is invoked to compare elements of `array` to `values`. The order and
 * references of result values are determined by the first array. The comparator
 * is invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 *
 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }]
 */
var differenceWith = baseRest(function(array, values) {
  var comparator = last(values);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
    : [];
});

/**
 * Divide two numbers.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Math
 * @param {number} dividend The first number in a division.
 * @param {number} divisor The second number in a division.
 * @returns {number} Returns the quotient.
 * @example
 *
 * _.divide(6, 4);
 * // => 1.5
 */
var divide = createMathOperation(function(dividend, divisor) {
  return dividend / divisor;
}, 1);

/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  return baseSlice(array, n < 0 ? 0 : n, length);
}

/**
 * Creates a slice of `array` with `n` elements dropped from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.dropRight([1, 2, 3]);
 * // => [1, 2]
 *
 * _.dropRight([1, 2, 3], 2);
 * // => [1]
 *
 * _.dropRight([1, 2, 3], 5);
 * // => []
 *
 * _.dropRight([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function dropRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

/**
 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
 * without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the slice of `array`.
 */
function baseWhile(array, predicate, isDrop, fromRight) {
  var length = array.length,
      index = fromRight ? length : -1;

  while ((fromRight ? index-- : ++index < length) &&
    predicate(array[index], index, array)) {}

  return isDrop
    ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
    : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
}

/**
 * Creates a slice of `array` excluding elements dropped from the end.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.dropRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropRightWhile(users, ['active', false]);
 * // => objects for ['barney']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropRightWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropRightWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3), true, true)
    : [];
}

/**
 * Creates a slice of `array` excluding elements dropped from the beginning.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.dropWhile(users, function(o) { return !o.active; });
 * // => objects for ['pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropWhile(users, ['active', false]);
 * // => objects for ['pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3), true)
    : [];
}

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

/**
 * A specialized version of `_.forEachRight` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEachRight(array, iteratee) {
  var length = array == null ? 0 : array.length;

  while (length--) {
    if (iteratee(array[length], length, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * This function is like `baseFor` except that it iterates over properties
 * in the opposite order.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseForRight = createBaseFor(true);

/**
 * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwnRight(object, iteratee) {
  return object && baseForRight(object, iteratee, keys);
}

/**
 * The base implementation of `_.forEachRight` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEachRight = createBaseEach(baseForOwnRight, true);

/**
 * This method is like `_.forEach` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @alias eachRight
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEach
 * @example
 *
 * _.forEachRight([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `2` then `1`.
 */
function forEachRight(collection, iteratee) {
  var func = isArray(collection) ? arrayEachRight : baseEachRight;
  return func(collection, castFunction(iteratee));
}

/**
 * Checks if `string` ends with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=string.length] The position to search up to.
 * @returns {boolean} Returns `true` if `string` ends with `target`,
 *  else `false`.
 * @example
 *
 * _.endsWith('abc', 'c');
 * // => true
 *
 * _.endsWith('abc', 'b');
 * // => false
 *
 * _.endsWith('abc', 'b', 2);
 * // => true
 */
function endsWith(string, target, position) {
  string = toString(string);
  target = baseToString(target);

  var length = string.length;
  position = position === undefined
    ? length
    : baseClamp(toInteger(position), 0, length);

  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function(key) {
    return [key, object[key]];
  });
}

/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]',
    setTag$3 = '[object Set]';

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag$1(object);
    if (tag == mapTag$3) {
      return mapToArray(object);
    }
    if (tag == setTag$3) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys);

/**
 * Creates an array of own and inherited enumerable string keyed-value pairs
 * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
 * or set, its entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entriesIn
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairsIn(new Foo);
 * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
 */
var toPairsIn = createToPairs(keysIn);

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
}

/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * **Note:** This method returns `true` for
 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty collections.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, guard) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$5 = 4294967295;

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * **Note:** This method is based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toLength(3.2);
 * // => 3
 *
 * _.toLength(Number.MIN_VALUE);
 * // => 0
 *
 * _.toLength(Infinity);
 * // => 4294967295
 *
 * _.toLength('3.2');
 * // => 3
 */
function toLength(value) {
  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$5) : 0;
}

/**
 * The base implementation of `_.fill` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 */
function baseFill(array, value, start, end) {
  var length = array.length;

  start = toInteger(start);
  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = (end === undefined || end > length) ? length : toInteger(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}

/**
 * Fills elements of `array` with `value` from `start` up to, but not
 * including, `end`.
 *
 * **Note:** This method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Array
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.fill(array, 'a');
 * console.log(array);
 * // => ['a', 'a', 'a']
 *
 * _.fill(Array(3), 2);
 * // => [2, 2, 2]
 *
 * _.fill([4, 6, 8, 10], '*', 1, 3);
 * // => [4, '*', '*', 10]
 */
function fill$1(array, value, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
    start = 0;
    end = length;
  }
  return baseFill(array, value, start, end);
}

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter$1(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$a = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$a(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find$1 = createFind(findIndex);

/**
 * The base implementation of methods like `_.findKey` and `_.findLastKey`,
 * without support for iteratee shorthands, which iterates over `collection`
 * using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the found element or its key, else `undefined`.
 */
function baseFindKey(collection, predicate, eachFunc) {
  var result;
  eachFunc(collection, function(value, key, collection) {
    if (predicate(value, key, collection)) {
      result = key;
      return false;
    }
  });
  return result;
}

/**
 * This method is like `_.find` except that it returns the key of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else `undefined`.
 * @example
 *
 * var users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * };
 *
 * _.findKey(users, function(o) { return o.age < 40; });
 * // => 'barney' (iteration order is not guaranteed)
 *
 * // The `_.matches` iteratee shorthand.
 * _.findKey(users, { 'age': 1, 'active': true });
 * // => 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findKey(users, ['active', false]);
 * // => 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.findKey(users, 'active');
 * // => 'barney'
 */
function findKey(object, predicate) {
  return baseFindKey(object, baseIteratee(predicate, 3), baseForOwn);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$9 = Math.max,
    nativeMin$a = Math.min;

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = fromIndex < 0
      ? nativeMax$9(length + index, 0)
      : nativeMin$a(index, length - 1);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);
}

/**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
var findLast = createFind(findLastIndex);

/**
 * This method is like `_.findKey` except that it iterates over elements of
 * a collection in the opposite order.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else `undefined`.
 * @example
 *
 * var users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * };
 *
 * _.findLastKey(users, function(o) { return o.age < 40; });
 * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastKey(users, { 'age': 36, 'active': true });
 * // => 'barney'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastKey(users, ['active', false]);
 * // => 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastKey(users, 'active');
 * // => 'pebbles'
 */
function findLastKey(object, predicate) {
  return baseFindKey(object, baseIteratee(predicate, 3), baseForOwnRight);
}

/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

/**
 * Creates a flattened array of values by running each element in `collection`
 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
 * with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [n, n];
 * }
 *
 * _.flatMap([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */
function flatMap(collection, iteratee) {
  return baseFlatten(map(collection, iteratee), 1);
}

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/**
 * This method is like `_.flatMap` except that it recursively flattens the
 * mapped results.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [[[n, n]]];
 * }
 *
 * _.flatMapDeep([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */
function flatMapDeep(collection, iteratee) {
  return baseFlatten(map(collection, iteratee), INFINITY$2);
}

/**
 * This method is like `_.flatMap` except that it recursively flattens the
 * mapped results up to `depth` times.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [[[n, n]]];
 * }
 *
 * _.flatMapDepth([1, 2], duplicate, 2);
 * // => [[1, 1], [2, 2]]
 */
function flatMapDepth(collection, iteratee, depth) {
  depth = depth === undefined ? 1 : toInteger(depth);
  return baseFlatten(map(collection, iteratee), depth);
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Recursively flattens `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flattenDeep([1, [2, [3, [4]], 5]]);
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, INFINITY$1) : [];
}

/**
 * Recursively flatten `array` up to `depth` times.
 *
 * @static
 * @memberOf _
 * @since 4.4.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * var array = [1, [2, [3, [4]], 5]];
 *
 * _.flattenDepth(array, 1);
 * // => [1, 2, [3, [4]], 5]
 *
 * _.flattenDepth(array, 2);
 * // => [1, 2, 3, [4], 5]
 */
function flattenDepth(array, depth) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  depth = depth === undefined ? 1 : toInteger(depth);
  return baseFlatten(array, depth);
}

/** Used to compose bitmasks for function metadata. */
var WRAP_FLIP_FLAG = 512;

/**
 * Creates a function that invokes `func` with arguments reversed.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to flip arguments for.
 * @returns {Function} Returns the new flipped function.
 * @example
 *
 * var flipped = _.flip(function() {
 *   return _.toArray(arguments);
 * });
 *
 * flipped('a', 'b', 'c', 'd');
 * // => ['d', 'c', 'b', 'a']
 */
function flip(func) {
  return createWrap(func, WRAP_FLIP_FLAG);
}

/**
 * Computes `number` rounded down to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round down.
 * @param {number} [precision=0] The precision to round down to.
 * @returns {number} Returns the rounded down number.
 * @example
 *
 * _.floor(4.006);
 * // => 4
 *
 * _.floor(0.046, 2);
 * // => 0.04
 *
 * _.floor(4060, -2);
 * // => 4000
 */
var floor = createRound('floor');

/** Error message constants. */
var FUNC_ERROR_TEXT$4 = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG$1 = 32,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG$1 = 256;

/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */
function createFlow(fromRight) {
  return flatRest(function(funcs) {
    var length = funcs.length,
        index = length,
        prereq = LodashWrapper.prototype.thru;

    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$4);
      }
      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
        var wrapper = new LodashWrapper([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];

      var funcName = getFuncName(func),
          data = funcName == 'wrapper' ? getData(func) : undefined;

      if (data && isLaziable(data[0]) &&
            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG$1 | WRAP_REARG_FLAG$1) &&
            !data[4].length && data[9] == 1
          ) {
        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = (func.length == 1 && isLaziable(func))
          ? wrapper[funcName]()
          : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments,
          value = args[0];

      if (wrapper && args.length == 1 && isArray(value)) {
        return wrapper.plant(value).value();
      }
      var index = 0,
          result = length ? funcs[index].apply(this, args) : value;

      while (++index < length) {
        result = funcs[index].call(this, result);
      }
      return result;
    };
  });
}

/**
 * Creates a function that returns the result of invoking the given functions
 * with the `this` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flowRight
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flow([_.add, square]);
 * addSquare(1, 2);
 * // => 9
 */
var flow = createFlow();

/**
 * This method is like `_.flow` except that it creates a function that
 * invokes the given functions from right to left.
 *
 * @static
 * @since 3.0.0
 * @memberOf _
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flow
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flowRight([square, _.add]);
 * addSquare(1, 2);
 * // => 9
 */
var flowRight = createFlow(true);

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

/**
 * This method is like `_.forIn` except that it iterates over properties of
 * `object` in the opposite order.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forInRight(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
 */
function forInRight(object, iteratee) {
  return object == null
    ? object
    : baseForRight(object, castFunction(iteratee), keysIn);
}

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object, iteratee) {
  return object && baseForOwn(object, castFunction(iteratee));
}

/**
 * This method is like `_.forOwn` except that it iterates over properties of
 * `object` in the opposite order.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwnRight(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
 */
function forOwnRight(object, iteratee) {
  return object && baseForOwnRight(object, castFunction(iteratee));
}

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs == null ? 0 : pairs.length,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

/**
 * The base implementation of `_.functions` which creates an array of
 * `object` function property names filtered from `props`.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} props The property names to filter.
 * @returns {Array} Returns the function names.
 */
function baseFunctions(object, props) {
  return arrayFilter(props, function(key) {
    return isFunction(object[key]);
  });
}

/**
 * Creates an array of function property names from own enumerable properties
 * of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the function names.
 * @see _.functionsIn
 * @example
 *
 * function Foo() {
 *   this.a = _.constant('a');
 *   this.b = _.constant('b');
 * }
 *
 * Foo.prototype.c = _.constant('c');
 *
 * _.functions(new Foo);
 * // => ['a', 'b']
 */
function functions(object) {
  return object == null ? [] : baseFunctions(object, keys(object));
}

/**
 * Creates an array of function property names from own and inherited
 * enumerable properties of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the function names.
 * @see _.functions
 * @example
 *
 * function Foo() {
 *   this.a = _.constant('a');
 *   this.b = _.constant('b');
 * }
 *
 * Foo.prototype.c = _.constant('c');
 *
 * _.functionsIn(new Foo);
 * // => ['a', 'b', 'c']
 */
function functionsIn(object) {
  return object == null ? [] : baseFunctions(object, keysIn(object));
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty$6.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

/**
 * Creates a function that performs a relational operation on two values.
 *
 * @private
 * @param {Function} operator The function to perform the operation.
 * @returns {Function} Returns the new relational operation function.
 */
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == 'string' && typeof other == 'string')) {
      value = toNumber(value);
      other = toNumber(other);
    }
    return operator(value, other);
  };
}

/**
 * Checks if `value` is greater than `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 * @see _.lt
 * @example
 *
 * _.gt(3, 1);
 * // => true
 *
 * _.gt(3, 3);
 * // => false
 *
 * _.gt(1, 3);
 * // => false
 */
var gt = createRelationalOperation(baseGt);

/**
 * Checks if `value` is greater than or equal to `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than or equal to
 *  `other`, else `false`.
 * @see _.lte
 * @example
 *
 * _.gte(3, 1);
 * // => true
 *
 * _.gte(3, 3);
 * // => true
 *
 * _.gte(1, 3);
 * // => false
 */
var gte = createRelationalOperation(function(value, other) {
  return value >= other;
});

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty$5.call(object, key);
}

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$8 = Math.max,
    nativeMin$9 = Math.min;

/**
 * The base implementation of `_.inRange` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */
function baseInRange(number, start, end) {
  return number >= nativeMin$9(start, end) && number < nativeMax$8(start, end);
}

/**
 * Checks if `n` is between `start` and up to, but not including, `end`. If
 * `end` is not specified, it's set to `start` with `start` then set to `0`.
 * If `start` is greater than `end` the params are swapped to support
 * negative ranges.
 *
 * @static
 * @memberOf _
 * @since 3.3.0
 * @category Number
 * @param {number} number The number to check.
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 * @see _.range, _.rangeRight
 * @example
 *
 * _.inRange(3, 2, 4);
 * // => true
 *
 * _.inRange(4, 8);
 * // => true
 *
 * _.inRange(4, 2);
 * // => false
 *
 * _.inRange(2, 2);
 * // => false
 *
 * _.inRange(1.2, 2);
 * // => true
 *
 * _.inRange(5.2, 4);
 * // => false
 *
 * _.inRange(-3, -2, -6);
 * // => true
 */
function inRange(number, start, end) {
  start = toFinite(start);
  if (end === undefined) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  number = toNumber(number);
  return baseInRange(number, start, end);
}

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$7 = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax$7(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$6 = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$6(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

/**
 * Gets all but the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.initial([1, 2, 3]);
 * // => [1, 2]
 */
function initial(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 0, -1) : [];
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$8 = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin$8(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

/**
 * This method is like `_.intersection` except that it accepts `iteratee`
 * which is invoked for each element of each `arrays` to generate the criterion
 * by which they're compared. The order and references of result values are
 * determined by the first array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
 * // => [2.1]
 *
 * // The `_.property` iteratee shorthand.
 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }]
 */
var intersectionBy = baseRest(function(arrays) {
  var iteratee = last(arrays),
      mapped = arrayMap(arrays, castArrayLikeObject);

  if (iteratee === last(mapped)) {
    iteratee = undefined;
  } else {
    mapped.pop();
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped, baseIteratee(iteratee, 2))
    : [];
});

/**
 * This method is like `_.intersection` except that it accepts `comparator`
 * which is invoked to compare elements of `arrays`. The order and references
 * of result values are determined by the first array. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.intersectionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }]
 */
var intersectionWith = baseRest(function(arrays) {
  var comparator = last(arrays),
      mapped = arrayMap(arrays, castArrayLikeObject);

  comparator = typeof comparator == 'function' ? comparator : undefined;
  if (comparator) {
    mapped.pop();
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped, undefined, comparator)
    : [];
});

/**
 * The base implementation of `_.invert` and `_.invertBy` which inverts
 * `object` with values transformed by `iteratee` and set by `setter`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform values.
 * @param {Object} accumulator The initial inverted object.
 * @returns {Function} Returns `accumulator`.
 */
function baseInverter(object, setter, iteratee, accumulator) {
  baseForOwn(object, function(value, key, object) {
    setter(accumulator, iteratee(value), key, object);
  });
  return accumulator;
}

/**
 * Creates a function like `_.invertBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} toIteratee The function to resolve iteratees.
 * @returns {Function} Returns the new inverter function.
 */
function createInverter(setter, toIteratee) {
  return function(object, iteratee) {
    return baseInverter(object, setter, toIteratee(iteratee), {});
  };
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$5.toString;

/**
 * Creates an object composed of the inverted keys and values of `object`.
 * If `object` contains duplicate values, subsequent values overwrite
 * property assignments of previous values.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Object
 * @param {Object} object The object to invert.
 * @returns {Object} Returns the new inverted object.
 * @example
 *
 * var object = { 'a': 1, 'b': 2, 'c': 1 };
 *
 * _.invert(object);
 * // => { '1': 'c', '2': 'b' }
 */
var invert$1 = createInverter(function(result, value, key) {
  if (value != null &&
      typeof value.toString != 'function') {
    value = nativeObjectToString$1.call(value);
  }

  result[value] = key;
}, constant(identity));

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$4.toString;

/**
 * This method is like `_.invert` except that the inverted object is generated
 * from the results of running each element of `object` thru `iteratee`. The
 * corresponding inverted value of each inverted key is an array of keys
 * responsible for generating the inverted value. The iteratee is invoked
 * with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.1.0
 * @category Object
 * @param {Object} object The object to invert.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Object} Returns the new inverted object.
 * @example
 *
 * var object = { 'a': 1, 'b': 2, 'c': 1 };
 *
 * _.invertBy(object);
 * // => { '1': ['a', 'c'], '2': ['b'] }
 *
 * _.invertBy(object, function(value) {
 *   return 'group' + value;
 * });
 * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
 */
var invertBy = createInverter(function(result, value, key) {
  if (value != null &&
      typeof value.toString != 'function') {
    value = nativeObjectToString.call(value);
  }

  if (hasOwnProperty$4.call(result, value)) {
    result[value].push(key);
  } else {
    result[value] = [key];
  }
}, baseIteratee);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

/**
 * The base implementation of `_.invoke` without support for individual
 * method arguments.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} args The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 */
function baseInvoke(object, path, args) {
  path = castPath(path, object);
  object = parent(object, path);
  var func = object == null ? object : object[toKey(last(path))];
  return func == null ? undefined : apply$1(func, object, args);
}

/**
 * Invokes the method at `path` of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
 *
 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
 * // => [2, 3]
 */
var invoke = baseRest(baseInvoke);

/**
 * Invokes the method at `path` of each element in `collection`, returning
 * an array of the results of each invoked method. Any additional arguments
 * are provided to each invoked method. If `path` is a function, it's invoked
 * for, and `this` bound to, each element in `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|string} path The path of the method to invoke or
 *  the function invoked per iteration.
 * @param {...*} [args] The arguments to invoke each method with.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
 * // => [[1, 5, 7], [1, 2, 3]]
 *
 * _.invokeMap([123, 456], String.prototype.split, '');
 * // => [['1', '2', '3'], ['4', '5', '6']]
 */
var invokeMap = baseRest(function(collection, path, args) {
  var index = -1,
      isFunc = typeof path == 'function',
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value) {
    result[++index] = isFunc ? apply$1(path, value, args) : baseInvoke(value, path, args);
  });
  return result;
});

var arrayBufferTag = '[object ArrayBuffer]';

/**
 * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
 */
function baseIsArrayBuffer(value) {
  return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
}

/* Node.js helper references. */
var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;

/**
 * Checks if `value` is classified as an `ArrayBuffer` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
 * @example
 *
 * _.isArrayBuffer(new ArrayBuffer(2));
 * // => true
 *
 * _.isArrayBuffer(new Array(2));
 * // => false
 */
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && baseGetTag(value) == boolTag);
}

/** `Object#toString` result references. */
var dateTag = '[object Date]';

/**
 * The base implementation of `_.isDate` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
 */
function baseIsDate(value) {
  return isObjectLike(value) && baseGetTag(value) == dateTag;
}

/* Node.js helper references. */
var nodeIsDate = nodeUtil && nodeUtil.isDate;

/**
 * Checks if `value` is classified as a `Date` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
 * @example
 *
 * _.isDate(new Date);
 * // => true
 *
 * _.isDate('Mon April 23 2012');
 * // => false
 */
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

/**
 * Checks if `value` is likely a DOM element.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
 * @example
 *
 * _.isElement(document.body);
 * // => true
 *
 * _.isElement('<body>');
 * // => false
 */
function isElement(value) {
  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
}

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]',
    setTag$2 = '[object Set]';

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag$1(value);
  if (tag == mapTag$2 || tag == setTag$2) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$3.call(value, key)) {
      return false;
    }
  }
  return true;
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * This method is like `_.isEqual` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with up to
 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqualWith(array, other, customizer);
 * // => true
 */
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsFinite = root.isFinite;

/**
 * Checks if `value` is a finite primitive number.
 *
 * **Note:** This method is based on
 * [`Number.isFinite`](https://mdn.io/Number/isFinite).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
 * @example
 *
 * _.isFinite(3);
 * // => true
 *
 * _.isFinite(Number.MIN_VALUE);
 * // => true
 *
 * _.isFinite(Infinity);
 * // => false
 *
 * _.isFinite('3');
 * // => false
 */
function isFinite$1(value) {
  return typeof value == 'number' && nativeIsFinite(value);
}

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

/**
 * Performs a partial deep comparison between `object` and `source` to
 * determine if `object` contains equivalent property values.
 *
 * **Note:** This method is equivalent to `_.matches` when `source` is
 * partially applied.
 *
 * Partial comparisons will match empty array and empty object `source`
 * values against any array or object value, respectively. See `_.isEqual`
 * for a list of supported value comparisons.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 *
 * _.isMatch(object, { 'b': 2 });
 * // => true
 *
 * _.isMatch(object, { 'b': 1 });
 * // => false
 */
function isMatch(object, source) {
  return object === source || baseIsMatch(object, source, getMatchData(source));
}

/**
 * This method is like `_.isMatch` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with five
 * arguments: (objValue, srcValue, index|key, object, source).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, srcValue) {
 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
 *     return true;
 *   }
 * }
 *
 * var object = { 'greeting': 'hello' };
 * var source = { 'greeting': 'hi' };
 *
 * _.isMatchWith(object, source, customizer);
 * // => true
 */
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return baseIsMatch(object, source, getMatchData(source), customizer);
}

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

/**
 * Checks if `value` is `NaN`.
 *
 * **Note:** This method is based on
 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
 * `undefined` and other non-number values.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 * @example
 *
 * _.isNaN(NaN);
 * // => true
 *
 * _.isNaN(new Number(NaN));
 * // => true
 *
 * isNaN(undefined);
 * // => true
 *
 * _.isNaN(undefined);
 * // => false
 */
function isNaN$1(value) {
  // An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber(value) && value != +value;
}

/**
 * Checks if `func` is capable of being masked.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
 */
var isMaskable = coreJsData ? isFunction : stubFalse;

/** Error message constants. */
var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.';

/**
 * Checks if `value` is a pristine native function.
 *
 * **Note:** This method can't reliably detect native functions in the presence
 * of the core-js package because core-js circumvents this kind of detection.
 * Despite multiple requests, the core-js maintainer has made it clear: any
 * attempt to fix the detection will be obstructed. As a result, we're left
 * with little choice but to throw an error. Unfortunately, this also affects
 * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
 * which rely on core-js.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (isMaskable(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative(value);
}

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$3 = 9007199254740991;

/**
 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
 * double precision number which isn't the result of a rounded unsafe integer.
 *
 * **Note:** This method is based on
 * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
 * @example
 *
 * _.isSafeInteger(3);
 * // => true
 *
 * _.isSafeInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isSafeInteger(Infinity);
 * // => false
 *
 * _.isSafeInteger('3');
 * // => false
 */
function isSafeInteger(value) {
  return isInteger(value) && value >= -MAX_SAFE_INTEGER$3 && value <= MAX_SAFE_INTEGER$3;
}

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

/** `Object#toString` result references. */
var weakMapTag = '[object WeakMap]';

/**
 * Checks if `value` is classified as a `WeakMap` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
 * @example
 *
 * _.isWeakMap(new WeakMap);
 * // => true
 *
 * _.isWeakMap(new Map);
 * // => false
 */
function isWeakMap(value) {
  return isObjectLike(value) && getTag$1(value) == weakMapTag;
}

/** `Object#toString` result references. */
var weakSetTag = '[object WeakSet]';

/**
 * Checks if `value` is classified as a `WeakSet` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
 * @example
 *
 * _.isWeakSet(new WeakSet);
 * // => true
 *
 * _.isWeakSet(new Set);
 * // => false
 */
function isWeakSet(value) {
  return isObjectLike(value) && baseGetTag(value) == weakSetTag;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$3 = 1;

/**
 * Creates a function that invokes `func` with the arguments of the created
 * function. If `func` is a property name, the created function returns the
 * property value for a given element. If `func` is an array or object, the
 * created function returns `true` for elements that contain the equivalent
 * source properties, otherwise it returns `false`.
 *
 * @static
 * @since 4.0.0
 * @memberOf _
 * @category Util
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @returns {Function} Returns the callback.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, _.iteratee(['user', 'fred']));
 * // => [{ 'user': 'fred', 'age': 40 }]
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, _.iteratee('user'));
 * // => ['barney', 'fred']
 *
 * // Create custom iteratee shorthands.
 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
 *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
 *     return func.test(string);
 *   };
 * });
 *
 * _.filter(['abc', 'def'], /ef/);
 * // => ['def']
 */
function iteratee(func) {
  return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG$3));
}

/** Used for built-in method references. */
var arrayProto$4 = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeJoin = arrayProto$4.join;

/**
 * Converts all elements in `array` into a string separated by `separator`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to convert.
 * @param {string} [separator=','] The element separator.
 * @returns {string} Returns the joined string.
 * @example
 *
 * _.join(['a', 'b', 'c'], '~');
 * // => 'a~b~c'
 */
function join(array, separator) {
  return array == null ? '' : nativeJoin.call(array, separator);
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase$1 = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The corresponding value of
 * each key is the last element responsible for generating the key. The
 * iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * var array = [
 *   { 'dir': 'left', 'code': 97 },
 *   { 'dir': 'right', 'code': 100 }
 * ];
 *
 * _.keyBy(array, function(o) {
 *   return String.fromCharCode(o.code);
 * });
 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
 *
 * _.keyBy(array, 'dir');
 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
 */
var keyBy = createAggregator(function(result, value, key) {
  baseAssignValue(result, key, value);
});

/**
 * A specialized version of `_.lastIndexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictLastIndexOf(array, value, fromIndex) {
  var index = fromIndex + 1;
  while (index--) {
    if (array[index] === value) {
      return index;
    }
  }
  return index;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$5 = Math.max,
    nativeMin$7 = Math.min;

/**
 * This method is like `_.indexOf` except that it iterates over elements of
 * `array` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.lastIndexOf([1, 2, 1, 2], 2);
 * // => 3
 *
 * // Search from the `fromIndex`.
 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
 * // => 1
 */
function lastIndexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = index < 0 ? nativeMax$5(length + index, 0) : nativeMin$7(index, length - 1);
  }
  return value === value
    ? strictLastIndexOf(array, value, index)
    : baseFindIndex(array, baseIsNaN, index, true);
}

/**
 * Converts `string`, as space separated words, to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.lowerCase('--Foo-Bar--');
 * // => 'foo bar'
 *
 * _.lowerCase('fooBar');
 * // => 'foo bar'
 *
 * _.lowerCase('__FOO_BAR__');
 * // => 'foo bar'
 */
var lowerCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toLowerCase();
});

/**
 * Converts the first character of `string` to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.lowerFirst('Fred');
 * // => 'fred'
 *
 * _.lowerFirst('FRED');
 * // => 'fRED'
 */
var lowerFirst = createCaseFirst('toLowerCase');

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

/**
 * Checks if `value` is less than `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 * @see _.gt
 * @example
 *
 * _.lt(1, 3);
 * // => true
 *
 * _.lt(3, 3);
 * // => false
 *
 * _.lt(3, 1);
 * // => false
 */
var lt = createRelationalOperation(baseLt);

/**
 * Checks if `value` is less than or equal to `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than or equal to
 *  `other`, else `false`.
 * @see _.gte
 * @example
 *
 * _.lte(1, 3);
 * // => true
 *
 * _.lte(3, 3);
 * // => true
 *
 * _.lte(3, 1);
 * // => false
 */
var lte = createRelationalOperation(function(value, other) {
  return value <= other;
});

/**
 * The opposite of `_.mapValues`; this method creates an object with the
 * same values as `object` and keys generated by running each own enumerable
 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
 * with three arguments: (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapValues
 * @example
 *
 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
 *   return key + value;
 * });
 * // => { 'a1': 1, 'b2': 2 }
 */
function mapKeys(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, iteratee(value, key, object), value);
  });
  return result;
}

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$2 = 1;

/**
 * Creates a function that performs a partial deep comparison between a given
 * object and `source`, returning `true` if the given object has equivalent
 * property values, else `false`.
 *
 * **Note:** The created function is equivalent to `_.isMatch` with `source`
 * partially applied.
 *
 * Partial comparisons will match empty array and empty object `source`
 * values against any array or object value, respectively. See `_.isEqual`
 * for a list of supported value comparisons.
 *
 * **Note:** Multiple values can be checked by combining several matchers
 * using `_.overSome`
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * var objects = [
 *   { 'a': 1, 'b': 2, 'c': 3 },
 *   { 'a': 4, 'b': 5, 'c': 6 }
 * ];
 *
 * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
 * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
 *
 * // Checking for several possible values
 * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
 * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
 */
function matches(source) {
  return baseMatches(baseClone(source, CLONE_DEEP_FLAG$2));
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1;

/**
 * Creates a function that performs a partial deep comparison between the
 * value at `path` of a given object to `srcValue`, returning `true` if the
 * object value is equivalent, else `false`.
 *
 * **Note:** Partial comparisons will match empty array and empty object
 * `srcValue` values against any array or object value, respectively. See
 * `_.isEqual` for a list of supported value comparisons.
 *
 * **Note:** Multiple values can be checked by combining several matchers
 * using `_.overSome`
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * var objects = [
 *   { 'a': 1, 'b': 2, 'c': 3 },
 *   { 'a': 4, 'b': 5, 'c': 6 }
 * ];
 *
 * _.find(objects, _.matchesProperty('a', 4));
 * // => { 'a': 4, 'b': 5, 'c': 6 }
 *
 * // Checking for several possible values
 * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
 * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
 */
function matchesProperty(path, srcValue) {
  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$1));
}

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * // The `_.property` iteratee shorthand.
 * _.maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
function maxBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseGt)
    : undefined;
}

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/**
 * The base implementation of `_.mean` and `_.meanBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the mean.
 */
function baseMean(array, iteratee) {
  var length = array == null ? 0 : array.length;
  return length ? (baseSum(array, iteratee) / length) : NAN;
}

/**
 * Computes the mean of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the mean.
 * @example
 *
 * _.mean([4, 2, 8, 6]);
 * // => 5
 */
function mean(array) {
  return baseMean(array, identity);
}

/**
 * This method is like `_.mean` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be averaged.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the mean.
 * @example
 *
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 *
 * _.meanBy(objects, function(o) { return o.n; });
 * // => 5
 *
 * // The `_.property` iteratee shorthand.
 * _.meanBy(objects, 'n');
 * // => 5
 */
function meanBy(array, iteratee) {
  return baseMean(array, baseIteratee(iteratee, 2));
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates a function that invokes the method at `path` of a given object.
 * Any additional arguments are provided to the invoked method.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Util
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {Function} Returns the new invoker function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': _.constant(2) } },
 *   { 'a': { 'b': _.constant(1) } }
 * ];
 *
 * _.map(objects, _.method('a.b'));
 * // => [2, 1]
 *
 * _.map(objects, _.method(['a', 'b']));
 * // => [2, 1]
 */
var method = baseRest(function(path, args) {
  return function(object) {
    return baseInvoke(object, path, args);
  };
});

/**
 * The opposite of `_.method`; this method creates a function that invokes
 * the method at a given path of `object`. Any additional arguments are
 * provided to the invoked method.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Util
 * @param {Object} object The object to query.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {Function} Returns the new invoker function.
 * @example
 *
 * var array = _.times(3, _.constant),
 *     object = { 'a': array, 'b': array, 'c': array };
 *
 * _.map(['a[2]', 'c[0]'], _.methodOf(object));
 * // => [2, 0]
 *
 * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
 * // => [2, 0]
 */
var methodOf = baseRest(function(object, args) {
  return function(path) {
    return baseInvoke(object, path, args);
  };
});

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)
    : undefined;
}

/**
 * Adds all own enumerable string keyed function properties of a source
 * object to the destination object. If `object` is a function, then methods
 * are added to its prototype as well.
 *
 * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
 * avoid conflicts caused by modifying the original.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {Function|Object} [object=lodash] The destination object.
 * @param {Object} source The object of functions to add.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
 * @returns {Function|Object} Returns `object`.
 * @example
 *
 * function vowels(string) {
 *   return _.filter(string, function(v) {
 *     return /[aeiou]/i.test(v);
 *   });
 * }
 *
 * _.mixin({ 'vowels': vowels });
 * _.vowels('fred');
 * // => ['e']
 *
 * _('fred').vowels().value();
 * // => ['e']
 *
 * _.mixin({ 'vowels': vowels }, { 'chain': false });
 * _('fred').vowels();
 * // => ['e']
 */
function mixin$1(object, source, options) {
  var props = keys(source),
      methodNames = baseFunctions(source, props);

  var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
      isFunc = isFunction(object);

  arrayEach(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain || chainAll) {
          var result = object(this.__wrapped__),
              actions = result.__actions__ = copyArray(this.__actions__);

          actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
          result.__chain__ = chainAll;
          return result;
        }
        return func.apply(object, arrayPush([this.value()], arguments));
      };
    }
  });

  return object;
}

/**
 * Multiply two numbers.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Math
 * @param {number} multiplier The first number in a multiplication.
 * @param {number} multiplicand The second number in a multiplication.
 * @returns {number} Returns the product.
 * @example
 *
 * _.multiply(6, 4);
 * // => 24
 */
var multiply = createMathOperation(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);

/** Error message constants. */
var FUNC_ERROR_TEXT$3 = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]',
    setTag$1 = '[object Set]';

/** Built-in value references. */
var symIterator$1 = Symbol$1 ? Symbol$1.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator$1 && value[symIterator$1]) {
    return iteratorToArray(value[symIterator$1]());
  }
  var tag = getTag$1(value),
      func = tag == mapTag$1 ? mapToArray : (tag == setTag$1 ? setToArray : values);

  return func(value);
}

/**
 * Gets the next value on a wrapped object following the
 * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
 *
 * @name next
 * @memberOf _
 * @since 4.0.0
 * @category Seq
 * @returns {Object} Returns the next iterator value.
 * @example
 *
 * var wrapped = _([1, 2]);
 *
 * wrapped.next();
 * // => { 'done': false, 'value': 1 }
 *
 * wrapped.next();
 * // => { 'done': false, 'value': 2 }
 *
 * wrapped.next();
 * // => { 'done': true, 'value': undefined }
 */
function wrapperNext() {
  if (this.__values__ === undefined) {
    this.__values__ = toArray(this.value());
  }
  var done = this.__index__ >= this.__values__.length,
      value = done ? undefined : this.__values__[this.__index__++];

  return { 'done': done, 'value': value };
}

/**
 * The base implementation of `_.nth` which doesn't coerce arguments.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {number} n The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 */
function baseNth(array, n) {
  var length = array.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return isIndex(n, length) ? array[n] : undefined;
}

/**
 * Gets the element at index `n` of `array`. If `n` is negative, the nth
 * element from the end is returned.
 *
 * @static
 * @memberOf _
 * @since 4.11.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=0] The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'd'];
 *
 * _.nth(array, 1);
 * // => 'b'
 *
 * _.nth(array, -2);
 * // => 'c';
 */
function nth(array, n) {
  return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
}

/**
 * Creates a function that gets the argument at index `n`. If `n` is negative,
 * the nth argument from the end is returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {number} [n=0] The index of the argument to return.
 * @returns {Function} Returns the new pass-thru function.
 * @example
 *
 * var func = _.nthArg(1);
 * func('a', 'b', 'c', 'd');
 * // => 'b'
 *
 * var func = _.nthArg(-2);
 * func('a', 'b', 'c', 'd');
 * // => 'c'
 */
function nthArg(n) {
  n = toInteger(n);
  return baseRest(function(args) {
    return baseNth(args, n);
  });
}

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

/**
 * The opposite of `_.pickBy`; this method creates an object composed of
 * the own and inherited enumerable string keyed properties of `object` that
 * `predicate` doesn't return truthy for. The predicate is invoked with two
 * arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omitBy(object, _.isNumber);
 * // => { 'b': '2' }
 */
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before$1(2, func);
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? undefined : orders;
  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy(collection, iteratees, orders);
}

/**
 * Creates a function like `_.over`.
 *
 * @private
 * @param {Function} arrayFunc The function to iterate over iteratees.
 * @returns {Function} Returns the new over function.
 */
function createOver(arrayFunc) {
  return flatRest(function(iteratees) {
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    return baseRest(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee) {
        return apply$1(iteratee, thisArg, args);
      });
    });
  });
}

/**
 * Creates a function that invokes `iteratees` with the arguments it receives
 * and returns their results.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to invoke.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var func = _.over([Math.max, Math.min]);
 *
 * func(1, 2, 3, 4);
 * // => [4, 1]
 */
var over = createOver(arrayMap);

/**
 * A `baseRest` alias which can be replaced with `identity` by module
 * replacement plugins.
 *
 * @private
 * @type {Function}
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
var castRest = baseRest;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$6 = Math.min;

/**
 * Creates a function that invokes `func` with its arguments transformed.
 *
 * @static
 * @since 4.0.0
 * @memberOf _
 * @category Function
 * @param {Function} func The function to wrap.
 * @param {...(Function|Function[])} [transforms=[_.identity]]
 *  The argument transforms.
 * @returns {Function} Returns the new function.
 * @example
 *
 * function doubled(n) {
 *   return n * 2;
 * }
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var func = _.overArgs(function(x, y) {
 *   return [x, y];
 * }, [square, doubled]);
 *
 * func(9, 3);
 * // => [81, 6]
 *
 * func(10, 5);
 * // => [100, 10]
 */
var overArgs = castRest(function(func, transforms) {
  transforms = (transforms.length == 1 && isArray(transforms[0]))
    ? arrayMap(transforms[0], baseUnary(baseIteratee))
    : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));

  var funcsLength = transforms.length;
  return baseRest(function(args) {
    var index = -1,
        length = nativeMin$6(args.length, funcsLength);

    while (++index < length) {
      args[index] = transforms[index].call(this, args[index]);
    }
    return apply$1(func, this, args);
  });
});

/**
 * Creates a function that checks if **all** of the `predicates` return
 * truthy when invoked with the arguments it receives.
 *
 * Following shorthands are possible for providing predicates.
 * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
 * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {...(Function|Function[])} [predicates=[_.identity]]
 *  The predicates to check.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var func = _.overEvery([Boolean, isFinite]);
 *
 * func('1');
 * // => true
 *
 * func(null);
 * // => false
 *
 * func(NaN);
 * // => false
 */
var overEvery = createOver(arrayEvery);

/**
 * Creates a function that checks if **any** of the `predicates` return
 * truthy when invoked with the arguments it receives.
 *
 * Following shorthands are possible for providing predicates.
 * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
 * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {...(Function|Function[])} [predicates=[_.identity]]
 *  The predicates to check.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var func = _.overSome([Boolean, isFinite]);
 *
 * func('1');
 * // => true
 *
 * func(null);
 * // => true
 *
 * func(NaN);
 * // => false
 *
 * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
 * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
 */
var overSome = createOver(arraySome);

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$2 = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor$3 = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER$2) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor$3(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$2 = Math.ceil;

/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */
function createPadding(length, chars) {
  chars = chars === undefined ? ' ' : baseToString(chars);

  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }
  var result = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
  return hasUnicode(chars)
    ? castSlice(stringToArray(result), 0, length).join('')
    : result.slice(0, length);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$1 = Math.ceil,
    nativeFloor$2 = Math.floor;

/**
 * Pads `string` on the left and right sides if it's shorter than `length`.
 * Padding characters are truncated if they can't be evenly divided by `length`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.pad('abc', 8);
 * // => '  abc   '
 *
 * _.pad('abc', 8, '_-');
 * // => '_-abc_-_'
 *
 * _.pad('abc', 3);
 * // => 'abc'
 */
function pad(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  if (!length || strLength >= length) {
    return string;
  }
  var mid = (length - strLength) / 2;
  return (
    createPadding(nativeFloor$2(mid), chars) +
    string +
    createPadding(nativeCeil$1(mid), chars)
  );
}

/**
 * Pads `string` on the right side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padEnd('abc', 6);
 * // => 'abc   '
 *
 * _.padEnd('abc', 6, '_-');
 * // => 'abc_-_'
 *
 * _.padEnd('abc', 3);
 * // => 'abc'
 */
function padEnd(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (string + createPadding(length - strLength, chars))
    : string;
}

/**
 * Pads `string` on the left side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padStart('abc', 6);
 * // => '   abc'
 *
 * _.padStart('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padStart('abc', 3);
 * // => 'abc'
 */
function padStart(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (createPadding(length - strLength, chars) + string)
    : string;
}

/** Used to match leading whitespace. */
var reTrimStart$1 = /^\s+/;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeParseInt = root.parseInt;

/**
 * Converts `string` to an integer of the specified radix. If `radix` is
 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
 * hexadecimal, in which case a `radix` of `16` is used.
 *
 * **Note:** This method aligns with the
 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category String
 * @param {string} string The string to convert.
 * @param {number} [radix=10] The radix to interpret `value` by.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.parseInt('08');
 * // => 8
 *
 * _.map(['6', '08', '10'], _.parseInt);
 * // => [6, 8, 10]
 */
function parseInt$1(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString(string).replace(reTrimStart$1, ''), radix || 0);
}

/** Used to compose bitmasks for function metadata. */
var WRAP_PARTIAL_FLAG = 32;

/**
 * Creates a function that invokes `func` with `partials` prepended to the
 * arguments it receives. This method is like `_.bind` except it does **not**
 * alter the `this` binding.
 *
 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * **Note:** This method doesn't set the "length" property of partially
 * applied functions.
 *
 * @static
 * @memberOf _
 * @since 0.2.0
 * @category Function
 * @param {Function} func The function to partially apply arguments to.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new partially applied function.
 * @example
 *
 * function greet(greeting, name) {
 *   return greeting + ' ' + name;
 * }
 *
 * var sayHelloTo = _.partial(greet, 'hello');
 * sayHelloTo('fred');
 * // => 'hello fred'
 *
 * // Partially applied with placeholders.
 * var greetFred = _.partial(greet, _, 'fred');
 * greetFred('hi');
 * // => 'hi fred'
 */
var partial = baseRest(function(func, partials) {
  var holders = replaceHolders(partials, getHolder(partial));
  return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
});

// Assign default placeholders.
partial.placeholder = {};

/** Used to compose bitmasks for function metadata. */
var WRAP_PARTIAL_RIGHT_FLAG = 64;

/**
 * This method is like `_.partial` except that partially applied arguments
 * are appended to the arguments it receives.
 *
 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * **Note:** This method doesn't set the "length" property of partially
 * applied functions.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Function
 * @param {Function} func The function to partially apply arguments to.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new partially applied function.
 * @example
 *
 * function greet(greeting, name) {
 *   return greeting + ' ' + name;
 * }
 *
 * var greetFred = _.partialRight(greet, 'fred');
 * greetFred('hi');
 * // => 'hi fred'
 *
 * // Partially applied with placeholders.
 * var sayHelloTo = _.partialRight(greet, 'hello', _);
 * sayHelloTo('fred');
 * // => 'hello fred'
 */
var partialRight = baseRest(function(func, partials) {
  var holders = replaceHolders(partials, getHolder(partialRight));
  return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
});

// Assign default placeholders.
partialRight.placeholder = {};

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements `predicate` returns truthy for, the second of which
 * contains elements `predicate` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ];
 *
 * _.partition(users, function(o) { return o.active; });
 * // => objects for [['fred'], ['barney', 'pebbles']]
 *
 * // The `_.matches` iteratee shorthand.
 * _.partition(users, { 'age': 1, 'active': false });
 * // => objects for [['pebbles'], ['barney', 'fred']]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.partition(users, ['active', false]);
 * // => objects for [['barney', 'pebbles'], ['fred']]
 *
 * // The `_.property` iteratee shorthand.
 * _.partition(users, 'active');
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
var partition = createAggregator(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() { return [[], []]; });

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

/**
 * Creates a clone of the chain sequence planting `value` as the wrapped value.
 *
 * @name plant
 * @memberOf _
 * @since 3.2.0
 * @category Seq
 * @param {*} value The value to plant.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2]).map(square);
 * var other = wrapped.plant([3, 4]);
 *
 * other.value();
 * // => [9, 16]
 *
 * wrapped.value();
 * // => [1, 4]
 */
function wrapperPlant(value) {
  var result,
      parent = this;

  while (parent instanceof baseLodash) {
    var clone = wrapperClone(parent);
    clone.__index__ = 0;
    clone.__values__ = undefined;
    if (result) {
      previous.__wrapped__ = clone;
    } else {
      result = clone;
    }
    var previous = clone;
    parent = parent.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result;
}

/**
 * The opposite of `_.property`; this method creates a function that returns
 * the value at a given path of `object`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var array = [0, 1, 2],
 *     object = { 'a': array, 'b': array, 'c': array };
 *
 * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
 * // => [2, 0]
 *
 * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
 * // => [2, 0]
 */
function propertyOf(object) {
  return function(path) {
    return object == null ? undefined : baseGet(object, path);
  };
}

/**
 * This function is like `baseIndexOf` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto$3 = Array.prototype;

/** Built-in value references. */
var splice$1 = arrayProto$3.splice;

/**
 * The base implementation of `_.pullAllBy` without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 */
function basePullAll(array, values, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
      index = -1,
      length = values.length,
      seen = array;

  if (array === values) {
    values = copyArray(values);
  }
  if (iteratee) {
    seen = arrayMap(array, baseUnary(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0,
        value = values[index],
        computed = iteratee ? iteratee(value) : value;

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice$1.call(seen, fromIndex, 1);
      }
      splice$1.call(array, fromIndex, 1);
    }
  }
  return array;
}

/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pullAll(array, ['a', 'c']);
 * console.log(array);
 * // => ['b', 'b']
 */
function pullAll(array, values) {
  return (array && array.length && values && values.length)
    ? basePullAll(array, values)
    : array;
}

/**
 * Removes all given values from `array` using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
 * to remove elements from an array by predicate.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pull(array, 'a', 'c');
 * console.log(array);
 * // => ['b', 'b']
 */
var pull = baseRest(pullAll);

/**
 * This method is like `_.pullAll` except that it accepts `iteratee` which is
 * invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. The iteratee is invoked with one argument: (value).
 *
 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
 *
 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
 * console.log(array);
 * // => [{ 'x': 2 }]
 */
function pullAllBy(array, values, iteratee) {
  return (array && array.length && values && values.length)
    ? basePullAll(array, values, baseIteratee(iteratee, 2))
    : array;
}

/**
 * This method is like `_.pullAll` except that it accepts `comparator` which
 * is invoked to compare elements of `array` to `values`. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
 *
 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
 * console.log(array);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
 */
function pullAllWith(array, values, comparator) {
  return (array && array.length && values && values.length)
    ? basePullAll(array, values, undefined, comparator)
    : array;
}

/** Used for built-in method references. */
var arrayProto$2 = Array.prototype;

/** Built-in value references. */
var splice = arrayProto$2.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array, index, 1);
      } else {
        baseUnset(array, index);
      }
    }
  }
  return array;
}

/**
 * Removes elements from `array` corresponding to `indexes` and returns an
 * array of removed elements.
 *
 * **Note:** Unlike `_.at`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = ['a', 'b', 'c', 'd'];
 * var pulled = _.pullAt(array, [1, 3]);
 *
 * console.log(array);
 * // => ['a', 'c']
 *
 * console.log(pulled);
 * // => ['b', 'd']
 */
var pullAt = flatRest(function(array, indexes) {
  var length = array == null ? 0 : array.length,
      result = baseAt(array, indexes);

  basePullAt(array, arrayMap(indexes, function(index) {
    return isIndex(index, length) ? +index : index;
  }).sort(compareAscending));

  return result;
});

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor$1 = Math.floor,
    nativeRandom$1 = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor$1(nativeRandom$1() * (upper - lower + 1));
}

/** Built-in method references without a dependency on `root`. */
var freeParseFloat = parseFloat;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$5 = Math.min,
    nativeRandom = Math.random;

/**
 * Produces a random number between the inclusive `lower` and `upper` bounds.
 * If only one argument is provided a number between `0` and the given number
 * is returned. If `floating` is `true`, or either `lower` or `upper` are
 * floats, a floating-point number is returned instead of an integer.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Number
 * @param {number} [lower=0] The lower bound.
 * @param {number} [upper=1] The upper bound.
 * @param {boolean} [floating] Specify returning a floating-point number.
 * @returns {number} Returns the random number.
 * @example
 *
 * _.random(0, 5);
 * // => an integer between 0 and 5
 *
 * _.random(5);
 * // => also an integer between 0 and 5
 *
 * _.random(5, true);
 * // => a floating-point number between 0 and 5
 *
 * _.random(1.2, 5.2);
 * // => a floating-point number between 1.2 and 5.2
 */
function random$2(lower, upper, floating) {
  if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
    upper = floating = undefined;
  }
  if (floating === undefined) {
    if (typeof upper == 'boolean') {
      floating = upper;
      upper = undefined;
    }
    else if (typeof lower == 'boolean') {
      floating = lower;
      lower = undefined;
    }
  }
  if (lower === undefined && upper === undefined) {
    lower = 0;
    upper = 1;
  }
  else {
    lower = toFinite(lower);
    if (upper === undefined) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom();
    return nativeMin$5(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
  }
  return baseRandom(lower, upper);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax$4 = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax$4(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

/**
 * This method is like `_.range` except that it populates values in
 * descending order.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.range
 * @example
 *
 * _.rangeRight(4);
 * // => [3, 2, 1, 0]
 *
 * _.rangeRight(-4);
 * // => [-3, -2, -1, 0]
 *
 * _.rangeRight(1, 5);
 * // => [4, 3, 2, 1]
 *
 * _.rangeRight(0, 20, 5);
 * // => [15, 10, 5, 0]
 *
 * _.rangeRight(0, -4, -1);
 * // => [-3, -2, -1, 0]
 *
 * _.rangeRight(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.rangeRight(0);
 * // => []
 */
var rangeRight = createRange(true);

/** Used to compose bitmasks for function metadata. */
var WRAP_REARG_FLAG = 256;

/**
 * Creates a function that invokes `func` with arguments arranged according
 * to the specified `indexes` where the argument value at the first index is
 * provided as the first argument, the argument value at the second index is
 * provided as the second argument, and so on.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to rearrange arguments for.
 * @param {...(number|number[])} indexes The arranged argument indexes.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var rearged = _.rearg(function(a, b, c) {
 *   return [a, b, c];
 * }, [2, 0, 1]);
 *
 * rearged('b', 'c', 'a')
 * // => ['a', 'b', 'c']
 */
var rearg = flatRest(function(func, indexes) {
  return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
});

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

/**
 * A specialized version of `_.reduceRight` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the last element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduceRight(array, iteratee, accumulator, initAccum) {
  var length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee(accumulator, array[length], length, array);
  }
  return accumulator;
}

/**
 * This method is like `_.reduce` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduce
 * @example
 *
 * var array = [[0, 1], [2, 3], [4, 5]];
 *
 * _.reduceRight(array, function(flattened, other) {
 *   return flattened.concat(other);
 * }, []);
 * // => [4, 5, 2, 3, 0, 1]
 */
function reduceRight(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduceRight : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
}

/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, negate(baseIteratee(predicate, 3)));
}

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove$1(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function repeat(string, n, guard) {
  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return baseRepeat(toString(string), n);
}

/**
 * Replaces matches for `pattern` in `string` with `replacement`.
 *
 * **Note:** This method is based on
 * [`String#replace`](https://mdn.io/String/replace).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to modify.
 * @param {RegExp|string} pattern The pattern to replace.
 * @param {Function|string} replacement The match replacement.
 * @returns {string} Returns the modified string.
 * @example
 *
 * _.replace('Hi Fred', 'Fred', 'Barney');
 * // => 'Hi Barney'
 */
function replace() {
  var args = arguments,
      string = toString(args[0]);

  return args.length < 3 ? string : string.replace(args[1], args[2]);
}

/** Error message constants. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  start = start === undefined ? start : toInteger(start);
  return baseRest(func, start);
}

/**
 * This method is like `_.get` except that if the resolved value is a
 * function it's invoked with the `this` binding of its parent object and
 * its result is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to resolve.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
 *
 * _.result(object, 'a[0].b.c1');
 * // => 3
 *
 * _.result(object, 'a[0].b.c2');
 * // => 4
 *
 * _.result(object, 'a[0].b.c3', 'default');
 * // => 'default'
 *
 * _.result(object, 'a[0].b.c3', _.constant('default'));
 * // => 'default'
 */
function result(object, path, defaultValue) {
  path = castPath(path, object);

  var index = -1,
      length = path.length;

  // Ensure the loop is entered when path is empty.
  if (!length) {
    length = 1;
    object = undefined;
  }
  while (++index < length) {
    var value = object == null ? undefined : object[toKey(path[index])];
    if (value === undefined) {
      index = length;
      value = defaultValue;
    }
    object = isFunction(value) ? value.call(object) : value;
  }
  return object;
}

/** Used for built-in method references. */
var arrayProto$1 = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeReverse = arrayProto$1.reverse;

/**
 * Reverses `array` so that the first element becomes the last, the second
 * element becomes the second to last, and so on.
 *
 * **Note:** This method mutates `array` and is based on
 * [`Array#reverse`](https://mdn.io/Array/reverse).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.reverse(array);
 * // => [3, 2, 1]
 *
 * console.log(array);
 * // => [3, 2, 1]
 */
function reverse(array) {
  return array == null ? array : nativeReverse.call(array);
}

/**
 * Computes `number` rounded to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round.
 * @param {number} [precision=0] The precision to round to.
 * @returns {number} Returns the rounded number.
 * @example
 *
 * _.round(4.006);
 * // => 4
 *
 * _.round(4.006, 2);
 * // => 4.01
 *
 * _.round(4060, -2);
 * // => 4100
 */
var round$2 = createRound('round');

/**
 * A specialized version of `_.sample` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @returns {*} Returns the random element.
 */
function arraySample(array) {
  var length = array.length;
  return length ? array[baseRandom(0, length - 1)] : undefined;
}

/**
 * The base implementation of `_.sample`.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 */
function baseSample(collection) {
  return arraySample(values(collection));
}

/**
 * Gets a random element from `collection`.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 */
function sample$1(collection) {
  var func = isArray(collection) ? arraySample : baseSample;
  return func(collection);
}

/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */
function shuffleSelf(array, size) {
  var index = -1,
      length = array.length,
      lastIndex = length - 1;

  size = size === undefined ? length : size;
  while (++index < size) {
    var rand = baseRandom(index, lastIndex),
        value = array[rand];

    array[rand] = array[index];
    array[index] = value;
  }
  array.length = size;
  return array;
}

/**
 * A specialized version of `_.sampleSize` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */
function arraySampleSize(array, n) {
  return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
}

/**
 * The base implementation of `_.sampleSize` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */
function baseSampleSize(collection, n) {
  var array = values(collection);
  return shuffleSelf(array, baseClamp(n, 0, array.length));
}

/**
 * Gets `n` random elements at unique keys from `collection` up to the
 * size of `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @param {number} [n=1] The number of elements to sample.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the random elements.
 * @example
 *
 * _.sampleSize([1, 2, 3], 2);
 * // => [3, 1]
 *
 * _.sampleSize([1, 2, 3], 4);
 * // => [2, 3, 1]
 */
function sampleSize(collection, n, guard) {
  if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  var func = isArray(collection) ? arraySampleSize : baseSampleSize;
  return func(collection, n);
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/**
 * This method is like `_.set` except that it accepts `customizer` which is
 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
 * path creation is handled by the method instead. The `customizer` is invoked
 * with three arguments: (nsValue, key, nsObject).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {};
 *
 * _.setWith(object, '[0][1]', 'a', Object);
 * // => { '0': { '1': 'a' } }
 */
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return object == null ? object : baseSet(object, path, value, customizer);
}

/**
 * A specialized version of `_.shuffle` for arrays.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function arrayShuffle(array) {
  return shuffleSelf(copyArray(array));
}

/**
 * The base implementation of `_.shuffle`.
 *
 * @private
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function baseShuffle(collection) {
  return shuffleSelf(values(collection));
}

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  var func = isArray(collection) ? arrayShuffle : baseShuffle;
  return func(collection);
}

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag = getTag$1(collection);
  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }
  return baseKeys(collection).length;
}

/**
 * Creates a slice of `array` from `start` up to, but not including, `end`.
 *
 * **Note:** This method is used instead of
 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
 * returned.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function slice(array, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
    start = 0;
    end = length;
  }
  else {
    start = start == null ? 0 : toInteger(start);
    end = end === undefined ? length : toInteger(end);
  }
  return baseSlice(array, start, end);
}

/**
 * Converts `string` to
 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the snake cased string.
 * @example
 *
 * _.snakeCase('Foo Bar');
 * // => 'foo_bar'
 *
 * _.snakeCase('fooBar');
 * // => 'foo_bar'
 *
 * _.snakeCase('--FOO-BAR--');
 * // => 'foo_bar'
 */
var snakeCase = createCompounder(function(result, word, index) {
  return result + (index ? '_' : '') + word.toLowerCase();
});

/**
 * The base implementation of `_.some` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  baseEach(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * Iteration is stopped once `predicate` returns truthy. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.some(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, guard) {
  var func = isArray(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$4 = 4294967295,
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeMin$4 = Math.min;

/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndexBy(array, value, iteratee, retHighest) {
  var low = 0,
      high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }

  value = iteratee(value);
  var valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = isSymbol(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = isSymbol(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? (computed <= value) : (computed < value);
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin$4(high, MAX_ARRAY_INDEX);
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$3 = 4294967295,
    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;

/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array == null ? low : array.length;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = (low + high) >>> 1,
          computed = array[mid];

      if (computed !== null && !isSymbol(computed) &&
          (retHighest ? (computed <= value) : (computed < value))) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy(array, value, identity, retHighest);
}

/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 */
function sortedIndex(array, value) {
  return baseSortedIndex(array, value);
}

/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
 * // => 0
 */
function sortedIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee, 2));
}

/**
 * This method is like `_.indexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
 * // => 1
 */
function sortedIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index = baseSortedIndex(array, value);
    if (index < length && eq(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/**
 * This method is like `_.sortedIndex` except that it returns the highest
 * index at which `value` should be inserted into `array` in order to
 * maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
 * // => 4
 */
function sortedLastIndex(array, value) {
  return baseSortedIndex(array, value, true);
}

/**
 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 1
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
 * // => 1
 */
function sortedLastIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee, 2), true);
}

/**
 * This method is like `_.lastIndexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
 * // => 3
 */
function sortedLastIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index = baseSortedIndex(array, value, true) - 1;
    if (eq(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseSortedUniq(array, iteratee) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    if (!index || !eq(computed, seen)) {
      var seen = computed;
      result[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result;
}

/**
 * This method is like `_.uniq` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniq([1, 1, 2]);
 * // => [1, 2]
 */
function sortedUniq(array) {
  return (array && array.length)
    ? baseSortedUniq(array)
    : [];
}

/**
 * This method is like `_.uniqBy` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
 * // => [1.1, 2.3]
 */
function sortedUniqBy(array, iteratee) {
  return (array && array.length)
    ? baseSortedUniq(array, baseIteratee(iteratee, 2))
    : [];
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$2 = 4294967295;

/**
 * Splits `string` by `separator`.
 *
 * **Note:** This method is based on
 * [`String#split`](https://mdn.io/String/split).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to split.
 * @param {RegExp|string} separator The separator pattern to split by.
 * @param {number} [limit] The length to truncate results to.
 * @returns {Array} Returns the string segments.
 * @example
 *
 * _.split('a-b-c', '-', 2);
 * // => ['a', 'b']
 */
function split(string, separator, limit) {
  if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
    separator = limit = undefined;
  }
  limit = limit === undefined ? MAX_ARRAY_LENGTH$2 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString(string);
  if (string && (
        typeof separator == 'string' ||
        (separator != null && !isRegExp(separator))
      )) {
    separator = baseToString(separator);
    if (!separator && hasUnicode(string)) {
      return castSlice(stringToArray(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$3 = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * create function and an array of arguments much like
 * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
 *
 * **Note:** This method is based on the
 * [spread operator](https://mdn.io/spread_operator).
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Function
 * @param {Function} func The function to spread arguments over.
 * @param {number} [start=0] The start position of the spread.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.spread(function(who, what) {
 *   return who + ' says ' + what;
 * });
 *
 * say(['fred', 'hello']);
 * // => 'fred says hello'
 *
 * var numbers = Promise.all([
 *   Promise.resolve(40),
 *   Promise.resolve(36)
 * ]);
 *
 * numbers.then(_.spread(function(x, y) {
 *   return x + y;
 * }));
 * // => a Promise of 76
 */
function spread(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  start = start == null ? 0 : nativeMax$3(toInteger(start), 0);
  return baseRest(function(args) {
    var array = args[start],
        otherArgs = castSlice(args, 0, start);

    if (array) {
      arrayPush(otherArgs, array);
    }
    return apply$1(func, this, otherArgs);
  });
}

/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + upperFirst(word);
});

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString(string);
  position = position == null
    ? 0
    : baseClamp(toInteger(position), 0, string.length);

  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}

/**
 * This method returns a new empty object.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Object} Returns the new empty object.
 * @example
 *
 * var objects = _.times(2, _.stubObject);
 *
 * console.log(objects);
 * // => [{}, {}]
 *
 * console.log(objects[0] === objects[1]);
 * // => false
 */
function stubObject() {
  return {};
}

/**
 * This method returns an empty string.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {string} Returns the empty string.
 * @example
 *
 * _.times(2, _.stubString);
 * // => ['', '']
 */
function stubString() {
  return '';
}

/**
 * This method returns `true`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `true`.
 * @example
 *
 * _.times(2, _.stubTrue);
 * // => [true, true]
 */
function stubTrue() {
  return true;
}

/**
 * Subtract two numbers.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {number} minuend The first number in a subtraction.
 * @param {number} subtrahend The second number in a subtraction.
 * @returns {number} Returns the difference.
 * @example
 *
 * _.subtract(6, 4);
 * // => 2
 */
var subtract = createMathOperation(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum(array) {
  return (array && array.length)
    ? baseSum(array, identity)
    : 0;
}

/**
 * This method is like `_.sum` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be summed.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the sum.
 * @example
 *
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 *
 * _.sumBy(objects, function(o) { return o.n; });
 * // => 20
 *
 * // The `_.property` iteratee shorthand.
 * _.sumBy(objects, 'n');
 * // => 20
 */
function sumBy(array, iteratee) {
  return (array && array.length)
    ? baseSum(array, baseIteratee(iteratee, 2))
    : 0;
}

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 1, length) : [];
}

/**
 * Creates a slice of `array` with `n` elements taken from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.take([1, 2, 3]);
 * // => [1]
 *
 * _.take([1, 2, 3], 2);
 * // => [1, 2]
 *
 * _.take([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.take([1, 2, 3], 0);
 * // => []
 */
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

/**
 * Creates a slice of `array` with `n` elements taken from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.takeRight([1, 2, 3]);
 * // => [3]
 *
 * _.takeRight([1, 2, 3], 2);
 * // => [2, 3]
 *
 * _.takeRight([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.takeRight([1, 2, 3], 0);
 * // => []
 */
function takeRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array, n < 0 ? 0 : n, length);
}

/**
 * Creates a slice of `array` with elements taken from the end. Elements are
 * taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.takeRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeRightWhile(users, ['active', false]);
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeRightWhile(users, 'active');
 * // => []
 */
function takeRightWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3), false, true)
    : [];
}

/**
 * Creates a slice of `array` with elements taken from the beginning. Elements
 * are taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.takeWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeWhile(users, ['active', false]);
 * // => objects for ['barney', 'fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeWhile(users, 'active');
 * // => []
 */
function takeWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3))
    : [];
}

/**
 * This method invokes `interceptor` and returns `value`. The interceptor
 * is invoked with one argument; (value). The purpose of this method is to
 * "tap into" a method chain sequence in order to modify intermediate results.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Seq
 * @param {*} value The value to provide to `interceptor`.
 * @param {Function} interceptor The function to invoke.
 * @returns {*} Returns `value`.
 * @example
 *
 * _([1, 2, 3])
 *  .tap(function(array) {
 *    // Mutate input array.
 *    array.pop();
 *  })
 *  .reverse()
 *  .value();
 * // => [2, 1]
 */
function tap(value, interceptor) {
  interceptor(value);
  return value;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto$2[key]) && !hasOwnProperty$2.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

/** Error message constants. */
var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL = hasOwnProperty$1.call(options, 'sourceURL')
    ? ('//# sourceURL=' +
       (options.sourceURL + '').replace(/\s/g, ' ') +
       '\n')
    : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = hasOwnProperty$1.call(options, 'variable') && options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }

  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce$1(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * This method is like `_.tap` except that it returns the result of `interceptor`.
 * The purpose of this method is to "pass thru" values replacing intermediate
 * results in a method chain sequence.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Seq
 * @param {*} value The value to provide to `interceptor`.
 * @param {Function} interceptor The function to invoke.
 * @returns {*} Returns the result of `interceptor`.
 * @example
 *
 * _('  abc  ')
 *  .chain()
 *  .trim()
 *  .thru(function(value) {
 *    return [value];
 *  })
 *  .value();
 * // => ['abc']
 */
function thru(value, interceptor) {
  return interceptor(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$1 = 4294967295;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$3 = Math.min;

/**
 * Invokes the iteratee `n` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument; (index).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.times(3, String);
 * // => ['0', '1', '2']
 *
 *  _.times(4, _.constant(0));
 * // => [0, 0, 0, 0]
 */
function times(n, iteratee) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER$1) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH$1,
      length = nativeMin$3(n, MAX_ARRAY_LENGTH$1);

  iteratee = castFunction(iteratee);
  n -= MAX_ARRAY_LENGTH$1;

  var result = baseTimes(length, iteratee);
  while (++index < n) {
    iteratee(index);
  }
  return result;
}

/**
 * Enables the wrapper to be iterable.
 *
 * @name Symbol.iterator
 * @memberOf _
 * @since 4.0.0
 * @category Seq
 * @returns {Object} Returns the wrapper object.
 * @example
 *
 * var wrapped = _([1, 2]);
 *
 * wrapped[Symbol.iterator]() === wrapped;
 * // => true
 *
 * Array.from(wrapped);
 * // => [1, 2]
 */
function wrapperToIterator() {
  return this;
}

/**
 * The base implementation of `wrapperValue` which returns the result of
 * performing a sequence of actions on the unwrapped `value`, where each
 * successive action is supplied the return value of the previous.
 *
 * @private
 * @param {*} value The unwrapped value.
 * @param {Array} actions Actions to perform to resolve the unwrapped value.
 * @returns {*} Returns the resolved value.
 */
function baseWrapperValue(value, actions) {
  var result = value;
  if (result instanceof LazyWrapper) {
    result = result.value();
  }
  return arrayReduce(actions, function(result, action) {
    return action.func.apply(action.thisArg, arrayPush([result], action.args));
  }, result);
}

/**
 * Executes the chain sequence to resolve the unwrapped value.
 *
 * @name value
 * @memberOf _
 * @since 0.1.0
 * @alias toJSON, valueOf
 * @category Seq
 * @returns {*} Returns the resolved unwrapped value.
 * @example
 *
 * _([1, 2, 3]).value();
 * // => [1, 2, 3]
 */
function wrapperValue() {
  return baseWrapperValue(this.__wrapped__, this.__actions__);
}

/**
 * Converts `string`, as a whole, to lower case just like
 * [String#toLowerCase](https://mdn.io/toLowerCase).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.toLower('--Foo-Bar--');
 * // => '--foo-bar--'
 *
 * _.toLower('fooBar');
 * // => 'foobar'
 *
 * _.toLower('__FOO_BAR__');
 * // => '__foo_bar__'
 */
function toLower(value) {
  return toString(value).toLowerCase();
}

/**
 * Converts `value` to a property path array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {*} value The value to convert.
 * @returns {Array} Returns the new property path array.
 * @example
 *
 * _.toPath('a.b.c');
 * // => ['a', 'b', 'c']
 *
 * _.toPath('a[0].b.c');
 * // => ['a', '0', 'b', 'c']
 */
function toPath$1(value) {
  if (isArray(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Converts `value` to a safe integer. A safe integer can be compared and
 * represented correctly.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toSafeInteger(3.2);
 * // => 3
 *
 * _.toSafeInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toSafeInteger(Infinity);
 * // => 9007199254740991
 *
 * _.toSafeInteger('3.2');
 * // => 3
 */
function toSafeInteger(value) {
  return value
    ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
    : (value === 0 ? value : 0);
}

/**
 * Converts `string`, as a whole, to upper case just like
 * [String#toUpperCase](https://mdn.io/toUpperCase).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the upper cased string.
 * @example
 *
 * _.toUpper('--foo-bar--');
 * // => '--FOO-BAR--'
 *
 * _.toUpper('fooBar');
 * // => 'FOOBAR'
 *
 * _.toUpper('__foo_bar__');
 * // => '__FOO_BAR__'
 */
function toUpper(value) {
  return toString(value).toUpperCase();
}

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform$2(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return baseTrim(string);
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

/**
 * Removes trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimEnd('  abc  ');
 * // => '  abc'
 *
 * _.trimEnd('-_-abc-_-', '_-');
 * // => '-_-abc'
 */
function trimEnd(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.slice(0, trimmedEndIndex(string) + 1);
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

  return castSlice(strSymbols, 0, end).join('');
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * Removes leading whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimStart('  abc  ');
 * // => 'abc  '
 *
 * _.trimStart('-_-abc-_-', '_-');
 * // => 'abc-_-'
 */
function trimStart(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrimStart, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      start = charsStartIndex(strSymbols, stringToArray(chars));

  return castSlice(strSymbols, start).join('');
}

/** Used as default options for `_.truncate`. */
var DEFAULT_TRUNC_LENGTH = 30,
    DEFAULT_TRUNC_OMISSION = '...';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Truncates `string` if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission
 * string which defaults to "...".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to truncate.
 * @param {Object} [options={}] The options object.
 * @param {number} [options.length=30] The maximum string length.
 * @param {string} [options.omission='...'] The string to indicate text is omitted.
 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
 * @returns {string} Returns the truncated string.
 * @example
 *
 * _.truncate('hi-diddly-ho there, neighborino');
 * // => 'hi-diddly-ho there, neighbo...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': ' '
 * });
 * // => 'hi-diddly-ho there,...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': /,? +/
 * });
 * // => 'hi-diddly-ho there...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'omission': ' [...]'
 * });
 * // => 'hi-diddly-ho there, neig [...]'
 */
function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH,
      omission = DEFAULT_TRUNC_OMISSION;

  if (isObject(options)) {
    var separator = 'separator' in options ? options.separator : separator;
    length = 'length' in options ? toInteger(options.length) : length;
    omission = 'omission' in options ? baseToString(options.omission) : omission;
  }
  string = toString(string);

  var strLength = string.length;
  if (hasUnicode(string)) {
    var strSymbols = stringToArray(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize(omission);
  if (end < 1) {
    return omission;
  }
  var result = strSymbols
    ? castSlice(strSymbols, 0, end).join('')
    : string.slice(0, end);

  if (separator === undefined) {
    return result + omission;
  }
  if (strSymbols) {
    end += (result.length - end);
  }
  if (isRegExp(separator)) {
    if (string.slice(end).search(separator)) {
      var match,
          substring = result;

      if (!separator.global) {
        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
      }
      separator.lastIndex = 0;
      while ((match = separator.exec(substring))) {
        var newEnd = match.index;
      }
      result = result.slice(0, newEnd === undefined ? end : newEnd);
    }
  } else if (string.indexOf(baseToString(separator), end) != end) {
    var index = result.lastIndexOf(separator);
    if (index > -1) {
      result = result.slice(0, index);
    }
  }
  return result + omission;
}

/**
 * Creates a function that accepts up to one argument, ignoring any
 * additional arguments.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 * @example
 *
 * _.map(['6', '8', '10'], _.unary(parseInt));
 * // => [6, 8, 10]
 */
function unary(func) {
  return ary(func, 1);
}

/** Used to map HTML entities to characters. */
var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'"
};

/**
 * Used by `_.unescape` to convert HTML entities to characters.
 *
 * @private
 * @param {string} chr The matched character to unescape.
 * @returns {string} Returns the unescaped character.
 */
var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

/** Used to match HTML entities and HTML characters. */
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
    reHasEscapedHtml = RegExp(reEscapedHtml.source);

/**
 * The inverse of `_.escape`; this method converts the HTML entities
 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
 * their corresponding characters.
 *
 * **Note:** No other HTML entities are unescaped. To unescape additional
 * HTML entities use a third-party library like [_he_](https://mths.be/he).
 *
 * @static
 * @memberOf _
 * @since 0.6.0
 * @category String
 * @param {string} [string=''] The string to unescape.
 * @returns {string} Returns the unescaped string.
 * @example
 *
 * _.unescape('fred, barney, &amp; pebbles');
 * // => 'fred, barney, & pebbles'
 */
function unescape$1(string) {
  string = toString(string);
  return (string && reHasEscapedHtml.test(string))
    ? string.replace(reEscapedHtml, unescapeHtmlChar)
    : string;
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set$1 && (1 / setToArray(new Set$1([,-0]))[1]) == INFINITY) ? noop$1 : function(values) {
  return new Set$1(values);
};

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

/**
 * This method is like `_.union` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which uniqueness is computed. Result values are chosen from the first
 * array in which the value occurs. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.unionBy([2.1], [1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
var unionBy = baseRest(function(arrays) {
  var iteratee = last(arrays);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee, 2));
});

/**
 * This method is like `_.union` except that it accepts `comparator` which
 * is invoked to compare elements of `arrays`. Result values are chosen from
 * the first array in which the value occurs. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.unionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var unionWith = baseRest(function(arrays) {
  var comparator = last(arrays);
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
});

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
}

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array, comparator) {
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
}

/** Used to generate unique IDs. */
var idCounter$1 = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId$1(prefix) {
  var id = ++idCounter$1;
  return toString(prefix) + id;
}

/**
 * Removes the property at `path` of `object`.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
 * _.unset(object, 'a[0].b.c');
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 *
 * _.unset(object, ['a', '0', 'b', 'c']);
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 */
function unset(object, path) {
  return object == null ? true : baseUnset(object, path);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$2 = Math.max;

/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 *
 * _.unzip(zipped);
 * // => [['a', 'b'], [1, 2], [true, false]]
 */
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter(array, function(group) {
    if (isArrayLikeObject(group)) {
      length = nativeMax$2(group.length, length);
      return true;
    }
  });
  return baseTimes(length, function(index) {
    return arrayMap(array, baseProperty(index));
  });
}

/**
 * This method is like `_.unzip` except that it accepts `iteratee` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * _.unzipWith(zipped, _.add);
 * // => [3, 30, 300]
 */
function unzipWith(array, iteratee) {
  if (!(array && array.length)) {
    return [];
  }
  var result = unzip(array);
  if (iteratee == null) {
    return result;
  }
  return arrayMap(result, function(group) {
    return apply$1(iteratee, undefined, group);
  });
}

/**
 * The base implementation of `_.update`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to update.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseUpdate(object, path, updater, customizer) {
  return baseSet(object, path, updater(baseGet(object, path)), customizer);
}

/**
 * This method is like `_.set` except that accepts `updater` to produce the
 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
 * is invoked with one argument: (value).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
 * console.log(object.a[0].b.c);
 * // => 9
 *
 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
 * console.log(object.x[0].y.z);
 * // => 0
 */
function update(object, path, updater) {
  return object == null ? object : baseUpdate(object, path, castFunction(updater));
}

/**
 * This method is like `_.update` except that it accepts `customizer` which is
 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
 * path creation is handled by the method instead. The `customizer` is invoked
 * with three arguments: (nsValue, key, nsObject).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {};
 *
 * _.updateWith(object, '[0][1]', _.constant('a'), Object);
 * // => { '0': { '1': 'a' } }
 */
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
}

/**
 * Converts `string`, as space separated words, to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the upper cased string.
 * @example
 *
 * _.upperCase('--foo-bar');
 * // => 'FOO BAR'
 *
 * _.upperCase('fooBar');
 * // => 'FOO BAR'
 *
 * _.upperCase('__foo_bar__');
 * // => 'FOO BAR'
 */
var upperCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toUpperCase();
});

/**
 * Creates an array of the own and inherited enumerable string keyed property
 * values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.valuesIn(new Foo);
 * // => [1, 2, 3] (iteration order is not guaranteed)
 */
function valuesIn(object) {
  return object == null ? [] : baseValues(object, keysIn(object));
}

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

/**
 * Creates a function that provides `value` to `wrapper` as its first
 * argument. Any additional arguments provided to the function are appended
 * to those provided to the `wrapper`. The wrapper is invoked with the `this`
 * binding of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {*} value The value to wrap.
 * @param {Function} [wrapper=identity] The wrapper function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var p = _.wrap(_.escape, function(func, text) {
 *   return '<p>' + func(text) + '</p>';
 * });
 *
 * p('fred, barney, & pebbles');
 * // => '<p>fred, barney, &amp; pebbles</p>'
 */
function wrap(value, wrapper) {
  return partial(castFunction(wrapper), value);
}

/**
 * This method is the wrapper version of `_.at`.
 *
 * @name at
 * @memberOf _
 * @since 1.0.0
 * @category Seq
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
 *
 * _(object).at(['a[0].b.c', 'a[1]']).value();
 * // => [3, 4]
 */
var wrapperAt = flatRest(function(paths) {
  var length = paths.length,
      start = length ? paths[0] : 0,
      value = this.__wrapped__,
      interceptor = function(object) { return baseAt(object, paths); };

  if (length > 1 || this.__actions__.length ||
      !(value instanceof LazyWrapper) || !isIndex(start)) {
    return this.thru(interceptor);
  }
  value = value.slice(start, +start + (length ? 1 : 0));
  value.__actions__.push({
    'func': thru,
    'args': [interceptor],
    'thisArg': undefined
  });
  return new LodashWrapper(value, this.__chain__).thru(function(array) {
    if (length && !array.length) {
      array.push(undefined);
    }
    return array;
  });
});

/**
 * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
 *
 * @name chain
 * @memberOf _
 * @since 0.1.0
 * @category Seq
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 }
 * ];
 *
 * // A sequence without explicit chaining.
 * _(users).head();
 * // => { 'user': 'barney', 'age': 36 }
 *
 * // A sequence with explicit chaining.
 * _(users)
 *   .chain()
 *   .head()
 *   .pick('user')
 *   .value();
 * // => { 'user': 'barney' }
 */
function wrapperChain() {
  return chain(this);
}

/**
 * This method is the wrapper version of `_.reverse`.
 *
 * **Note:** This method mutates the wrapped array.
 *
 * @name reverse
 * @memberOf _
 * @since 0.1.0
 * @category Seq
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _(array).reverse().value()
 * // => [3, 2, 1]
 *
 * console.log(array);
 * // => [3, 2, 1]
 */
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      'func': thru,
      'args': [reverse],
      'thisArg': undefined
    });
    return new LodashWrapper(wrapped, this.__chain__);
  }
  return this.thru(reverse);
}

/**
 * The base implementation of methods like `_.xor`, without support for
 * iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor(arrays, iteratee, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq(arrays[0]) : [];
  }
  var index = -1,
      result = Array(length);

  while (++index < length) {
    var array = arrays[index],
        othIndex = -1;

    while (++othIndex < length) {
      if (othIndex != index) {
        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
      }
    }
  }
  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
}

/**
 * Creates an array of unique values that is the
 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 * of the given arrays. The order of result values is determined by the order
 * they occur in the arrays.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.without
 * @example
 *
 * _.xor([2, 1], [2, 3]);
 * // => [1, 3]
 */
var xor = baseRest(function(arrays) {
  return baseXor(arrayFilter(arrays, isArrayLikeObject));
});

/**
 * This method is like `_.xor` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which by which they're compared. The order of result values is determined
 * by the order they occur in the arrays. The iteratee is invoked with one
 * argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
 * // => [1.2, 3.4]
 *
 * // The `_.property` iteratee shorthand.
 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var xorBy = baseRest(function(arrays) {
  var iteratee = last(arrays);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee, 2));
});

/**
 * This method is like `_.xor` except that it accepts `comparator` which is
 * invoked to compare elements of `arrays`. The order of result values is
 * determined by the order they occur in the arrays. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.xorWith(objects, others, _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var xorWith = baseRest(function(arrays) {
  var comparator = last(arrays);
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
});

/**
 * Creates an array of grouped elements, the first of which contains the
 * first elements of the given arrays, the second of which contains the
 * second elements of the given arrays, and so on.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 */
var zip = baseRest(unzip);

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return baseZipObject(props || [], values || [], assignValue);
}

/**
 * This method is like `_.zipObject` except that it supports property paths.
 *
 * @static
 * @memberOf _
 * @since 4.1.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
 */
function zipObjectDeep(props, values) {
  return baseZipObject(props || [], values || [], baseSet);
}

/**
 * This method is like `_.zip` except that it accepts `iteratee` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
 *   return a + b + c;
 * });
 * // => [111, 222]
 */
var zipWith = baseRest(function(arrays) {
  var length = arrays.length,
      iteratee = length > 1 ? arrays[length - 1] : undefined;

  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
  return unzipWith(arrays, iteratee);
});

var array$3 = {
  chunk, compact, concat, difference, differenceBy,
  differenceWith, drop, dropRight, dropRightWhile, dropWhile,
  fill: fill$1, findIndex, findLastIndex, first: head, flatten: flatten$1,
  flattenDeep, flattenDepth, fromPairs, head, indexOf,
  initial, intersection, intersectionBy, intersectionWith, join,
  last, lastIndexOf, nth, pull, pullAll,
  pullAllBy, pullAllWith, pullAt, remove: remove$1, reverse,
  slice, sortedIndex, sortedIndexBy, sortedIndexOf, sortedLastIndex,
  sortedLastIndexBy, sortedLastIndexOf, sortedUniq, sortedUniqBy, tail,
  take, takeRight, takeRightWhile, takeWhile, union,
  unionBy, unionWith, uniq, uniqBy, uniqWith,
  unzip, unzipWith, without, xor, xorBy,
  xorWith, zip, zipObject, zipObjectDeep, zipWith
};

var collection = {
  countBy, each: forEach, eachRight: forEachRight, every, filter: filter$1,
  find: find$1, findLast, flatMap, flatMapDeep, flatMapDepth,
  forEach, forEachRight, groupBy, includes, invokeMap,
  keyBy, map, orderBy, partition, reduce,
  reduceRight, reject, sample: sample$1, sampleSize, shuffle,
  size, some, sortBy
};

var date = {
  now
};

var func = {
  after, ary, before: before$1, bind, bindKey,
  curry, curryRight, debounce: debounce$1, defer, delay,
  flip, memoize, negate, once, overArgs,
  partial, partialRight, rearg, rest, spread,
  throttle, unary, wrap
};

var lang$3 = {
  castArray, clone, cloneDeep, cloneDeepWith, cloneWith,
  conformsTo, eq, gt, gte, isArguments,
  isArray, isArrayBuffer, isArrayLike, isArrayLikeObject, isBoolean,
  isBuffer, isDate, isElement, isEmpty, isEqual,
  isEqualWith, isError, isFinite: isFinite$1, isFunction, isInteger,
  isLength, isMap, isMatch, isMatchWith, isNaN: isNaN$1,
  isNative, isNil, isNull, isNumber, isObject,
  isObjectLike, isPlainObject, isRegExp, isSafeInteger, isSet,
  isString, isSymbol, isTypedArray, isUndefined, isWeakMap,
  isWeakSet, lt, lte, toArray, toFinite,
  toInteger, toLength, toNumber, toPlainObject, toSafeInteger,
  toString
};

var math = {
  add, ceil, divide, floor, max,
  maxBy, mean, meanBy, min, minBy,
  multiply, round: round$2, subtract, sum, sumBy
};

var number$3 = {
  clamp: clamp$1, inRange, random: random$2
};

var object$4 = {
  assign, assignIn, assignInWith, assignWith, at,
  create: create$1, defaults: defaults$3, defaultsDeep, entries: toPairs, entriesIn: toPairsIn,
  extend: assignIn, extendWith: assignInWith, findKey, findLastKey, forIn,
  forInRight, forOwn, forOwnRight, functions, functionsIn,
  get, has, hasIn, invert: invert$1, invertBy,
  invoke, keys, keysIn, mapKeys, mapValues,
  merge, mergeWith, omit, omitBy, pick,
  pickBy, result, set, setWith, toPairs,
  toPairsIn, transform: transform$2, unset, update, updateWith,
  values, valuesIn
};

var seq = {
  at: wrapperAt, chain, commit: wrapperCommit, lodash: lodash$1, next: wrapperNext,
  plant: wrapperPlant, reverse: wrapperReverse, tap, thru, toIterator: wrapperToIterator,
  toJSON: wrapperValue, value: wrapperValue, valueOf: wrapperValue, wrapperChain
};

var string$3 = {
  camelCase, capitalize, deburr, endsWith, escape,
  escapeRegExp, kebabCase: kebabCase$1, lowerCase, lowerFirst, pad,
  padEnd, padStart, parseInt: parseInt$1, repeat, replace,
  snakeCase, split, startCase, startsWith, template,
  templateSettings, toLower, toUpper, trim, trimEnd,
  trimStart, truncate, unescape: unescape$1, upperCase, upperFirst,
  words
};

var util$6 = {
  attempt, bindAll, cond, conforms, constant,
  defaultTo, flow, flowRight, identity, iteratee,
  matches, matchesProperty, method, methodOf, mixin: mixin$1,
  noop: noop$1, nthArg, over, overEvery, overSome,
  property, propertyOf, range, rangeRight, stubArray,
  stubFalse, stubObject, stubString, stubTrue, times,
  toPath: toPath$1, uniqueId: uniqueId$1
};

/**
 * Creates a clone of the lazy wrapper object.
 *
 * @private
 * @name clone
 * @memberOf LazyWrapper
 * @returns {Object} Returns the cloned `LazyWrapper` object.
 */
function lazyClone() {
  var result = new LazyWrapper(this.__wrapped__);
  result.__actions__ = copyArray(this.__actions__);
  result.__dir__ = this.__dir__;
  result.__filtered__ = this.__filtered__;
  result.__iteratees__ = copyArray(this.__iteratees__);
  result.__takeCount__ = this.__takeCount__;
  result.__views__ = copyArray(this.__views__);
  return result;
}

/**
 * Reverses the direction of lazy iteration.
 *
 * @private
 * @name reverse
 * @memberOf LazyWrapper
 * @returns {Object} Returns the new reversed `LazyWrapper` object.
 */
function lazyReverse() {
  if (this.__filtered__) {
    var result = new LazyWrapper(this);
    result.__dir__ = -1;
    result.__filtered__ = true;
  } else {
    result = this.clone();
    result.__dir__ *= -1;
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max,
    nativeMin$2 = Math.min;

/**
 * Gets the view, applying any `transforms` to the `start` and `end` positions.
 *
 * @private
 * @param {number} start The start of the view.
 * @param {number} end The end of the view.
 * @param {Array} transforms The transformations to apply to the view.
 * @returns {Object} Returns an object containing the `start` and `end`
 *  positions of the view.
 */
function getView(start, end, transforms) {
  var index = -1,
      length = transforms.length;

  while (++index < length) {
    var data = transforms[index],
        size = data.size;

    switch (data.type) {
      case 'drop':      start += size; break;
      case 'dropRight': end -= size; break;
      case 'take':      end = nativeMin$2(end, start + size); break;
      case 'takeRight': start = nativeMax$1(start, end - size); break;
    }
  }
  return { 'start': start, 'end': end };
}

/** Used to indicate the type of lazy iteratees. */
var LAZY_FILTER_FLAG$1 = 1,
    LAZY_MAP_FLAG = 2;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$1 = Math.min;

/**
 * Extracts the unwrapped value from its lazy wrapper.
 *
 * @private
 * @name value
 * @memberOf LazyWrapper
 * @returns {*} Returns the unwrapped value.
 */
function lazyValue() {
  var array = this.__wrapped__.value(),
      dir = this.__dir__,
      isArr = isArray(array),
      isRight = dir < 0,
      arrLength = isArr ? array.length : 0,
      view = getView(0, arrLength, this.__views__),
      start = view.start,
      end = view.end,
      length = end - start,
      index = isRight ? end : (start - 1),
      iteratees = this.__iteratees__,
      iterLength = iteratees.length,
      resIndex = 0,
      takeCount = nativeMin$1(length, this.__takeCount__);

  if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
    return baseWrapperValue(array, this.__actions__);
  }
  var result = [];

  outer:
  while (length-- && resIndex < takeCount) {
    index += dir;

    var iterIndex = -1,
        value = array[index];

    while (++iterIndex < iterLength) {
      var data = iteratees[iterIndex],
          iteratee = data.iteratee,
          type = data.type,
          computed = iteratee(value);

      if (type == LAZY_MAP_FLAG) {
        value = computed;
      } else if (!computed) {
        if (type == LAZY_FILTER_FLAG$1) {
          continue outer;
        } else {
          break outer;
        }
      }
    }
    result[resIndex++] = value;
  }
  return result;
}

/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the semantic version number. */
var VERSION = '4.17.21';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_KEY_FLAG = 2;

/** Used to indicate the type of lazy iteratees. */
var LAZY_FILTER_FLAG = 1,
    LAZY_WHILE_FLAG = 3;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var symIterator = Symbol$1 ? Symbol$1.iterator : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

// wrap `_.mixin` so it works when provided only one argument
var mixin = (function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject(source),
          props = isObj && keys(source),
          methodNames = props && props.length && baseFunctions(source, props);

      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
}(mixin$1));

// Add methods that return wrapped values in chain sequences.
lodash$1.after = func.after;
lodash$1.ary = func.ary;
lodash$1.assign = object$4.assign;
lodash$1.assignIn = object$4.assignIn;
lodash$1.assignInWith = object$4.assignInWith;
lodash$1.assignWith = object$4.assignWith;
lodash$1.at = object$4.at;
lodash$1.before = func.before;
lodash$1.bind = func.bind;
lodash$1.bindAll = util$6.bindAll;
lodash$1.bindKey = func.bindKey;
lodash$1.castArray = lang$3.castArray;
lodash$1.chain = seq.chain;
lodash$1.chunk = array$3.chunk;
lodash$1.compact = array$3.compact;
lodash$1.concat = array$3.concat;
lodash$1.cond = util$6.cond;
lodash$1.conforms = util$6.conforms;
lodash$1.constant = util$6.constant;
lodash$1.countBy = collection.countBy;
lodash$1.create = object$4.create;
lodash$1.curry = func.curry;
lodash$1.curryRight = func.curryRight;
lodash$1.debounce = func.debounce;
lodash$1.defaults = object$4.defaults;
lodash$1.defaultsDeep = object$4.defaultsDeep;
lodash$1.defer = func.defer;
lodash$1.delay = func.delay;
lodash$1.difference = array$3.difference;
lodash$1.differenceBy = array$3.differenceBy;
lodash$1.differenceWith = array$3.differenceWith;
lodash$1.drop = array$3.drop;
lodash$1.dropRight = array$3.dropRight;
lodash$1.dropRightWhile = array$3.dropRightWhile;
lodash$1.dropWhile = array$3.dropWhile;
lodash$1.fill = array$3.fill;
lodash$1.filter = collection.filter;
lodash$1.flatMap = collection.flatMap;
lodash$1.flatMapDeep = collection.flatMapDeep;
lodash$1.flatMapDepth = collection.flatMapDepth;
lodash$1.flatten = array$3.flatten;
lodash$1.flattenDeep = array$3.flattenDeep;
lodash$1.flattenDepth = array$3.flattenDepth;
lodash$1.flip = func.flip;
lodash$1.flow = util$6.flow;
lodash$1.flowRight = util$6.flowRight;
lodash$1.fromPairs = array$3.fromPairs;
lodash$1.functions = object$4.functions;
lodash$1.functionsIn = object$4.functionsIn;
lodash$1.groupBy = collection.groupBy;
lodash$1.initial = array$3.initial;
lodash$1.intersection = array$3.intersection;
lodash$1.intersectionBy = array$3.intersectionBy;
lodash$1.intersectionWith = array$3.intersectionWith;
lodash$1.invert = object$4.invert;
lodash$1.invertBy = object$4.invertBy;
lodash$1.invokeMap = collection.invokeMap;
lodash$1.iteratee = util$6.iteratee;
lodash$1.keyBy = collection.keyBy;
lodash$1.keys = keys;
lodash$1.keysIn = object$4.keysIn;
lodash$1.map = collection.map;
lodash$1.mapKeys = object$4.mapKeys;
lodash$1.mapValues = object$4.mapValues;
lodash$1.matches = util$6.matches;
lodash$1.matchesProperty = util$6.matchesProperty;
lodash$1.memoize = func.memoize;
lodash$1.merge = object$4.merge;
lodash$1.mergeWith = object$4.mergeWith;
lodash$1.method = util$6.method;
lodash$1.methodOf = util$6.methodOf;
lodash$1.mixin = mixin;
lodash$1.negate = negate;
lodash$1.nthArg = util$6.nthArg;
lodash$1.omit = object$4.omit;
lodash$1.omitBy = object$4.omitBy;
lodash$1.once = func.once;
lodash$1.orderBy = collection.orderBy;
lodash$1.over = util$6.over;
lodash$1.overArgs = func.overArgs;
lodash$1.overEvery = util$6.overEvery;
lodash$1.overSome = util$6.overSome;
lodash$1.partial = func.partial;
lodash$1.partialRight = func.partialRight;
lodash$1.partition = collection.partition;
lodash$1.pick = object$4.pick;
lodash$1.pickBy = object$4.pickBy;
lodash$1.property = util$6.property;
lodash$1.propertyOf = util$6.propertyOf;
lodash$1.pull = array$3.pull;
lodash$1.pullAll = array$3.pullAll;
lodash$1.pullAllBy = array$3.pullAllBy;
lodash$1.pullAllWith = array$3.pullAllWith;
lodash$1.pullAt = array$3.pullAt;
lodash$1.range = util$6.range;
lodash$1.rangeRight = util$6.rangeRight;
lodash$1.rearg = func.rearg;
lodash$1.reject = collection.reject;
lodash$1.remove = array$3.remove;
lodash$1.rest = func.rest;
lodash$1.reverse = array$3.reverse;
lodash$1.sampleSize = collection.sampleSize;
lodash$1.set = object$4.set;
lodash$1.setWith = object$4.setWith;
lodash$1.shuffle = collection.shuffle;
lodash$1.slice = array$3.slice;
lodash$1.sortBy = collection.sortBy;
lodash$1.sortedUniq = array$3.sortedUniq;
lodash$1.sortedUniqBy = array$3.sortedUniqBy;
lodash$1.split = string$3.split;
lodash$1.spread = func.spread;
lodash$1.tail = array$3.tail;
lodash$1.take = array$3.take;
lodash$1.takeRight = array$3.takeRight;
lodash$1.takeRightWhile = array$3.takeRightWhile;
lodash$1.takeWhile = array$3.takeWhile;
lodash$1.tap = seq.tap;
lodash$1.throttle = func.throttle;
lodash$1.thru = thru;
lodash$1.toArray = lang$3.toArray;
lodash$1.toPairs = object$4.toPairs;
lodash$1.toPairsIn = object$4.toPairsIn;
lodash$1.toPath = util$6.toPath;
lodash$1.toPlainObject = lang$3.toPlainObject;
lodash$1.transform = object$4.transform;
lodash$1.unary = func.unary;
lodash$1.union = array$3.union;
lodash$1.unionBy = array$3.unionBy;
lodash$1.unionWith = array$3.unionWith;
lodash$1.uniq = array$3.uniq;
lodash$1.uniqBy = array$3.uniqBy;
lodash$1.uniqWith = array$3.uniqWith;
lodash$1.unset = object$4.unset;
lodash$1.unzip = array$3.unzip;
lodash$1.unzipWith = array$3.unzipWith;
lodash$1.update = object$4.update;
lodash$1.updateWith = object$4.updateWith;
lodash$1.values = object$4.values;
lodash$1.valuesIn = object$4.valuesIn;
lodash$1.without = array$3.without;
lodash$1.words = string$3.words;
lodash$1.wrap = func.wrap;
lodash$1.xor = array$3.xor;
lodash$1.xorBy = array$3.xorBy;
lodash$1.xorWith = array$3.xorWith;
lodash$1.zip = array$3.zip;
lodash$1.zipObject = array$3.zipObject;
lodash$1.zipObjectDeep = array$3.zipObjectDeep;
lodash$1.zipWith = array$3.zipWith;

// Add aliases.
lodash$1.entries = object$4.toPairs;
lodash$1.entriesIn = object$4.toPairsIn;
lodash$1.extend = object$4.assignIn;
lodash$1.extendWith = object$4.assignInWith;

// Add methods to `lodash.prototype`.
mixin(lodash$1, lodash$1);

// Add methods that return unwrapped values in chain sequences.
lodash$1.add = math.add;
lodash$1.attempt = util$6.attempt;
lodash$1.camelCase = string$3.camelCase;
lodash$1.capitalize = string$3.capitalize;
lodash$1.ceil = math.ceil;
lodash$1.clamp = number$3.clamp;
lodash$1.clone = lang$3.clone;
lodash$1.cloneDeep = lang$3.cloneDeep;
lodash$1.cloneDeepWith = lang$3.cloneDeepWith;
lodash$1.cloneWith = lang$3.cloneWith;
lodash$1.conformsTo = lang$3.conformsTo;
lodash$1.deburr = string$3.deburr;
lodash$1.defaultTo = util$6.defaultTo;
lodash$1.divide = math.divide;
lodash$1.endsWith = string$3.endsWith;
lodash$1.eq = lang$3.eq;
lodash$1.escape = string$3.escape;
lodash$1.escapeRegExp = string$3.escapeRegExp;
lodash$1.every = collection.every;
lodash$1.find = collection.find;
lodash$1.findIndex = array$3.findIndex;
lodash$1.findKey = object$4.findKey;
lodash$1.findLast = collection.findLast;
lodash$1.findLastIndex = array$3.findLastIndex;
lodash$1.findLastKey = object$4.findLastKey;
lodash$1.floor = math.floor;
lodash$1.forEach = collection.forEach;
lodash$1.forEachRight = collection.forEachRight;
lodash$1.forIn = object$4.forIn;
lodash$1.forInRight = object$4.forInRight;
lodash$1.forOwn = object$4.forOwn;
lodash$1.forOwnRight = object$4.forOwnRight;
lodash$1.get = object$4.get;
lodash$1.gt = lang$3.gt;
lodash$1.gte = lang$3.gte;
lodash$1.has = object$4.has;
lodash$1.hasIn = object$4.hasIn;
lodash$1.head = array$3.head;
lodash$1.identity = identity;
lodash$1.includes = collection.includes;
lodash$1.indexOf = array$3.indexOf;
lodash$1.inRange = number$3.inRange;
lodash$1.invoke = object$4.invoke;
lodash$1.isArguments = lang$3.isArguments;
lodash$1.isArray = isArray;
lodash$1.isArrayBuffer = lang$3.isArrayBuffer;
lodash$1.isArrayLike = lang$3.isArrayLike;
lodash$1.isArrayLikeObject = lang$3.isArrayLikeObject;
lodash$1.isBoolean = lang$3.isBoolean;
lodash$1.isBuffer = lang$3.isBuffer;
lodash$1.isDate = lang$3.isDate;
lodash$1.isElement = lang$3.isElement;
lodash$1.isEmpty = lang$3.isEmpty;
lodash$1.isEqual = lang$3.isEqual;
lodash$1.isEqualWith = lang$3.isEqualWith;
lodash$1.isError = lang$3.isError;
lodash$1.isFinite = lang$3.isFinite;
lodash$1.isFunction = lang$3.isFunction;
lodash$1.isInteger = lang$3.isInteger;
lodash$1.isLength = lang$3.isLength;
lodash$1.isMap = lang$3.isMap;
lodash$1.isMatch = lang$3.isMatch;
lodash$1.isMatchWith = lang$3.isMatchWith;
lodash$1.isNaN = lang$3.isNaN;
lodash$1.isNative = lang$3.isNative;
lodash$1.isNil = lang$3.isNil;
lodash$1.isNull = lang$3.isNull;
lodash$1.isNumber = lang$3.isNumber;
lodash$1.isObject = isObject;
lodash$1.isObjectLike = lang$3.isObjectLike;
lodash$1.isPlainObject = lang$3.isPlainObject;
lodash$1.isRegExp = lang$3.isRegExp;
lodash$1.isSafeInteger = lang$3.isSafeInteger;
lodash$1.isSet = lang$3.isSet;
lodash$1.isString = lang$3.isString;
lodash$1.isSymbol = lang$3.isSymbol;
lodash$1.isTypedArray = lang$3.isTypedArray;
lodash$1.isUndefined = lang$3.isUndefined;
lodash$1.isWeakMap = lang$3.isWeakMap;
lodash$1.isWeakSet = lang$3.isWeakSet;
lodash$1.join = array$3.join;
lodash$1.kebabCase = string$3.kebabCase;
lodash$1.last = last;
lodash$1.lastIndexOf = array$3.lastIndexOf;
lodash$1.lowerCase = string$3.lowerCase;
lodash$1.lowerFirst = string$3.lowerFirst;
lodash$1.lt = lang$3.lt;
lodash$1.lte = lang$3.lte;
lodash$1.max = math.max;
lodash$1.maxBy = math.maxBy;
lodash$1.mean = math.mean;
lodash$1.meanBy = math.meanBy;
lodash$1.min = math.min;
lodash$1.minBy = math.minBy;
lodash$1.stubArray = util$6.stubArray;
lodash$1.stubFalse = util$6.stubFalse;
lodash$1.stubObject = util$6.stubObject;
lodash$1.stubString = util$6.stubString;
lodash$1.stubTrue = util$6.stubTrue;
lodash$1.multiply = math.multiply;
lodash$1.nth = array$3.nth;
lodash$1.noop = util$6.noop;
lodash$1.now = date.now;
lodash$1.pad = string$3.pad;
lodash$1.padEnd = string$3.padEnd;
lodash$1.padStart = string$3.padStart;
lodash$1.parseInt = string$3.parseInt;
lodash$1.random = number$3.random;
lodash$1.reduce = collection.reduce;
lodash$1.reduceRight = collection.reduceRight;
lodash$1.repeat = string$3.repeat;
lodash$1.replace = string$3.replace;
lodash$1.result = object$4.result;
lodash$1.round = math.round;
lodash$1.sample = collection.sample;
lodash$1.size = collection.size;
lodash$1.snakeCase = string$3.snakeCase;
lodash$1.some = collection.some;
lodash$1.sortedIndex = array$3.sortedIndex;
lodash$1.sortedIndexBy = array$3.sortedIndexBy;
lodash$1.sortedIndexOf = array$3.sortedIndexOf;
lodash$1.sortedLastIndex = array$3.sortedLastIndex;
lodash$1.sortedLastIndexBy = array$3.sortedLastIndexBy;
lodash$1.sortedLastIndexOf = array$3.sortedLastIndexOf;
lodash$1.startCase = string$3.startCase;
lodash$1.startsWith = string$3.startsWith;
lodash$1.subtract = math.subtract;
lodash$1.sum = math.sum;
lodash$1.sumBy = math.sumBy;
lodash$1.template = string$3.template;
lodash$1.times = util$6.times;
lodash$1.toFinite = lang$3.toFinite;
lodash$1.toInteger = toInteger;
lodash$1.toLength = lang$3.toLength;
lodash$1.toLower = string$3.toLower;
lodash$1.toNumber = lang$3.toNumber;
lodash$1.toSafeInteger = lang$3.toSafeInteger;
lodash$1.toString = lang$3.toString;
lodash$1.toUpper = string$3.toUpper;
lodash$1.trim = string$3.trim;
lodash$1.trimEnd = string$3.trimEnd;
lodash$1.trimStart = string$3.trimStart;
lodash$1.truncate = string$3.truncate;
lodash$1.unescape = string$3.unescape;
lodash$1.uniqueId = util$6.uniqueId;
lodash$1.upperCase = string$3.upperCase;
lodash$1.upperFirst = string$3.upperFirst;

// Add aliases.
lodash$1.each = collection.forEach;
lodash$1.eachRight = collection.forEachRight;
lodash$1.first = array$3.head;

mixin(lodash$1, (function() {
  var source = {};
  baseForOwn(lodash$1, function(func, methodName) {
    if (!hasOwnProperty.call(lodash$1.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}()), { 'chain': false });

/**
 * The semantic version number.
 *
 * @static
 * @memberOf _
 * @type {string}
 */
lodash$1.VERSION = VERSION;
(lodash$1.templateSettings = string$3.templateSettings).imports._ = lodash$1;

// Assign default placeholders.
arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
  lodash$1[methodName].placeholder = lodash$1;
});

// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop', 'take'], function(methodName, index) {
  LazyWrapper.prototype[methodName] = function(n) {
    n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

    var result = (this.__filtered__ && !index)
      ? new LazyWrapper(this)
      : this.clone();

    if (result.__filtered__) {
      result.__takeCount__ = nativeMin(n, result.__takeCount__);
    } else {
      result.__views__.push({
        'size': nativeMin(n, MAX_ARRAY_LENGTH),
        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
      });
    }
    return result;
  };

  LazyWrapper.prototype[methodName + 'Right'] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});

// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
  var type = index + 1,
      isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

  LazyWrapper.prototype[methodName] = function(iteratee) {
    var result = this.clone();
    result.__iteratees__.push({
      'iteratee': baseIteratee(iteratee, 3),
      'type': type
    });
    result.__filtered__ = result.__filtered__ || isFilter;
    return result;
  };
});

// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head', 'last'], function(methodName, index) {
  var takeName = 'take' + (index ? 'Right' : '');

  LazyWrapper.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});

// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial', 'tail'], function(methodName, index) {
  var dropName = 'drop' + (index ? '' : 'Right');

  LazyWrapper.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
  };
});

LazyWrapper.prototype.compact = function() {
  return this.filter(identity);
};

LazyWrapper.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};

LazyWrapper.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};

LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
  if (typeof path == 'function') {
    return new LazyWrapper(this);
  }
  return this.map(function(value) {
    return baseInvoke(value, path, args);
  });
});

LazyWrapper.prototype.reject = function(predicate) {
  return this.filter(negate(baseIteratee(predicate)));
};

LazyWrapper.prototype.slice = function(start, end) {
  start = toInteger(start);

  var result = this;
  if (result.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper(result);
  }
  if (start < 0) {
    result = result.takeRight(-start);
  } else if (start) {
    result = result.drop(start);
  }
  if (end !== undefined) {
    end = toInteger(end);
    result = end < 0 ? result.dropRight(-end) : result.take(end - start);
  }
  return result;
};

LazyWrapper.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};

LazyWrapper.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH);
};

// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
      isTaker = /^(?:head|last)$/.test(methodName),
      lodashFunc = lodash$1[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
      retUnwrapped = isTaker || /^find/.test(methodName);

  if (!lodashFunc) {
    return;
  }
  lodash$1.prototype[methodName] = function() {
    var value = this.__wrapped__,
        args = isTaker ? [1] : arguments,
        isLazy = value instanceof LazyWrapper,
        iteratee = args[0],
        useLazy = isLazy || isArray(value);

    var interceptor = function(value) {
      var result = lodashFunc.apply(lodash$1, arrayPush([value], args));
      return (isTaker && chainAll) ? result[0] : result;
    };

    if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
      // Avoid lazy use if the iteratee has a "length" value other than `1`.
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__,
        isHybrid = !!this.__actions__.length,
        isUnwrapped = retUnwrapped && !chainAll,
        onlyLazy = isLazy && !isHybrid;

    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper(this);
      var result = func.apply(value, args);
      result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
      return new LodashWrapper(result, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result = this.thru(interceptor);
    return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
  };
});

// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
  var func = arrayProto[methodName],
      chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
      retUnwrapped = /^(?:pop|shift)$/.test(methodName);

  lodash$1.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func.apply(isArray(value) ? value : [], args);
    }
    return this[chainName](function(value) {
      return func.apply(isArray(value) ? value : [], args);
    });
  };
});

// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype, function(func, methodName) {
  var lodashFunc = lodash$1[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + '';
    if (!hasOwnProperty.call(realNames, key)) {
      realNames[key] = [];
    }
    realNames[key].push({ 'name': methodName, 'func': lodashFunc });
  }
});

realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
  'name': 'wrapper',
  'func': undefined
}];

// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone = lazyClone;
LazyWrapper.prototype.reverse = lazyReverse;
LazyWrapper.prototype.value = lazyValue;

// Add chain sequence methods to the `lodash` wrapper.
lodash$1.prototype.at = seq.at;
lodash$1.prototype.chain = seq.wrapperChain;
lodash$1.prototype.commit = seq.commit;
lodash$1.prototype.next = seq.next;
lodash$1.prototype.plant = seq.plant;
lodash$1.prototype.reverse = seq.reverse;
lodash$1.prototype.toJSON = lodash$1.prototype.valueOf = lodash$1.prototype.value = seq.value;

// Add lazy aliases.
lodash$1.prototype.first = lodash$1.prototype.head;

if (symIterator) {
  lodash$1.prototype[symIterator] = seq.toIterator;
}

/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash = /*#__PURE__*/Object.freeze({
	__proto__: null,
	add: add,
	after: after,
	ary: ary,
	assign: assign,
	assignIn: assignIn,
	assignInWith: assignInWith,
	assignWith: assignWith,
	at: at,
	attempt: attempt,
	before: before$1,
	bind: bind,
	bindAll: bindAll,
	bindKey: bindKey,
	camelCase: camelCase,
	capitalize: capitalize,
	castArray: castArray,
	ceil: ceil,
	chain: chain,
	chunk: chunk,
	clamp: clamp$1,
	clone: clone,
	cloneDeep: cloneDeep,
	cloneDeepWith: cloneDeepWith,
	cloneWith: cloneWith,
	commit: wrapperCommit,
	compact: compact,
	concat: concat,
	cond: cond,
	conforms: conforms,
	conformsTo: conformsTo,
	constant: constant,
	countBy: countBy,
	create: create$1,
	curry: curry,
	curryRight: curryRight,
	debounce: debounce$1,
	deburr: deburr,
	default: lodash$1,
	defaultTo: defaultTo,
	defaults: defaults$3,
	defaultsDeep: defaultsDeep,
	defer: defer,
	delay: delay,
	difference: difference,
	differenceBy: differenceBy,
	differenceWith: differenceWith,
	divide: divide,
	drop: drop,
	dropRight: dropRight,
	dropRightWhile: dropRightWhile,
	dropWhile: dropWhile,
	each: forEach,
	eachRight: forEachRight,
	endsWith: endsWith,
	entries: toPairs,
	entriesIn: toPairsIn,
	eq: eq,
	escape: escape,
	escapeRegExp: escapeRegExp,
	every: every,
	extend: assignIn,
	extendWith: assignInWith,
	fill: fill$1,
	filter: filter$1,
	find: find$1,
	findIndex: findIndex,
	findKey: findKey,
	findLast: findLast,
	findLastIndex: findLastIndex,
	findLastKey: findLastKey,
	first: head,
	flatMap: flatMap,
	flatMapDeep: flatMapDeep,
	flatMapDepth: flatMapDepth,
	flatten: flatten$1,
	flattenDeep: flattenDeep,
	flattenDepth: flattenDepth,
	flip: flip,
	floor: floor,
	flow: flow,
	flowRight: flowRight,
	forEach: forEach,
	forEachRight: forEachRight,
	forIn: forIn,
	forInRight: forInRight,
	forOwn: forOwn,
	forOwnRight: forOwnRight,
	fromPairs: fromPairs,
	functions: functions,
	functionsIn: functionsIn,
	get: get,
	groupBy: groupBy,
	gt: gt,
	gte: gte,
	has: has,
	hasIn: hasIn,
	head: head,
	identity: identity,
	inRange: inRange,
	includes: includes,
	indexOf: indexOf,
	initial: initial,
	intersection: intersection,
	intersectionBy: intersectionBy,
	intersectionWith: intersectionWith,
	invert: invert$1,
	invertBy: invertBy,
	invoke: invoke,
	invokeMap: invokeMap,
	isArguments: isArguments,
	isArray: isArray,
	isArrayBuffer: isArrayBuffer,
	isArrayLike: isArrayLike,
	isArrayLikeObject: isArrayLikeObject,
	isBoolean: isBoolean,
	isBuffer: isBuffer,
	isDate: isDate,
	isElement: isElement,
	isEmpty: isEmpty,
	isEqual: isEqual,
	isEqualWith: isEqualWith,
	isError: isError,
	isFinite: isFinite$1,
	isFunction: isFunction,
	isInteger: isInteger,
	isLength: isLength,
	isMap: isMap,
	isMatch: isMatch,
	isMatchWith: isMatchWith,
	isNaN: isNaN$1,
	isNative: isNative,
	isNil: isNil,
	isNull: isNull,
	isNumber: isNumber,
	isObject: isObject,
	isObjectLike: isObjectLike,
	isPlainObject: isPlainObject,
	isRegExp: isRegExp,
	isSafeInteger: isSafeInteger,
	isSet: isSet,
	isString: isString,
	isSymbol: isSymbol,
	isTypedArray: isTypedArray,
	isUndefined: isUndefined,
	isWeakMap: isWeakMap,
	isWeakSet: isWeakSet,
	iteratee: iteratee,
	join: join,
	kebabCase: kebabCase$1,
	keyBy: keyBy,
	keys: keys,
	keysIn: keysIn,
	last: last,
	lastIndexOf: lastIndexOf,
	lodash: lodash$1,
	lowerCase: lowerCase,
	lowerFirst: lowerFirst,
	lt: lt,
	lte: lte,
	map: map,
	mapKeys: mapKeys,
	mapValues: mapValues,
	matches: matches,
	matchesProperty: matchesProperty,
	max: max,
	maxBy: maxBy,
	mean: mean,
	meanBy: meanBy,
	memoize: memoize,
	merge: merge,
	mergeWith: mergeWith,
	method: method,
	methodOf: methodOf,
	min: min,
	minBy: minBy,
	mixin: mixin$1,
	multiply: multiply,
	negate: negate,
	next: wrapperNext,
	noop: noop$1,
	now: now,
	nth: nth,
	nthArg: nthArg,
	omit: omit,
	omitBy: omitBy,
	once: once,
	orderBy: orderBy,
	over: over,
	overArgs: overArgs,
	overEvery: overEvery,
	overSome: overSome,
	pad: pad,
	padEnd: padEnd,
	padStart: padStart,
	parseInt: parseInt$1,
	partial: partial,
	partialRight: partialRight,
	partition: partition,
	pick: pick,
	pickBy: pickBy,
	plant: wrapperPlant,
	property: property,
	propertyOf: propertyOf,
	pull: pull,
	pullAll: pullAll,
	pullAllBy: pullAllBy,
	pullAllWith: pullAllWith,
	pullAt: pullAt,
	random: random$2,
	range: range,
	rangeRight: rangeRight,
	rearg: rearg,
	reduce: reduce,
	reduceRight: reduceRight,
	reject: reject,
	remove: remove$1,
	repeat: repeat,
	replace: replace,
	rest: rest,
	result: result,
	reverse: reverse,
	round: round$2,
	sample: sample$1,
	sampleSize: sampleSize,
	set: set,
	setWith: setWith,
	shuffle: shuffle,
	size: size,
	slice: slice,
	snakeCase: snakeCase,
	some: some,
	sortBy: sortBy,
	sortedIndex: sortedIndex,
	sortedIndexBy: sortedIndexBy,
	sortedIndexOf: sortedIndexOf,
	sortedLastIndex: sortedLastIndex,
	sortedLastIndexBy: sortedLastIndexBy,
	sortedLastIndexOf: sortedLastIndexOf,
	sortedUniq: sortedUniq,
	sortedUniqBy: sortedUniqBy,
	split: split,
	spread: spread,
	startCase: startCase,
	startsWith: startsWith,
	stubArray: stubArray,
	stubFalse: stubFalse,
	stubObject: stubObject,
	stubString: stubString,
	stubTrue: stubTrue,
	subtract: subtract,
	sum: sum,
	sumBy: sumBy,
	tail: tail,
	take: take,
	takeRight: takeRight,
	takeRightWhile: takeRightWhile,
	takeWhile: takeWhile,
	tap: tap,
	template: template,
	templateSettings: templateSettings,
	throttle: throttle,
	thru: thru,
	times: times,
	toArray: toArray,
	toFinite: toFinite,
	toInteger: toInteger,
	toIterator: wrapperToIterator,
	toJSON: wrapperValue,
	toLength: toLength,
	toLower: toLower,
	toNumber: toNumber,
	toPairs: toPairs,
	toPairsIn: toPairsIn,
	toPath: toPath$1,
	toPlainObject: toPlainObject,
	toSafeInteger: toSafeInteger,
	toString: toString,
	toUpper: toUpper,
	transform: transform$2,
	trim: trim,
	trimEnd: trimEnd,
	trimStart: trimStart,
	truncate: truncate,
	unary: unary,
	unescape: unescape$1,
	union: union,
	unionBy: unionBy,
	unionWith: unionWith,
	uniq: uniq,
	uniqBy: uniqBy,
	uniqWith: uniqWith,
	uniqueId: uniqueId$1,
	unset: unset,
	unzip: unzip,
	unzipWith: unzipWith,
	update: update,
	updateWith: updateWith,
	upperCase: upperCase,
	upperFirst: upperFirst,
	value: wrapperValue,
	valueOf: wrapperValue,
	values: values,
	valuesIn: valuesIn,
	without: without,
	words: words,
	wrap: wrap,
	wrapperAt: wrapperAt,
	wrapperChain: wrapperChain,
	wrapperCommit: wrapperCommit,
	wrapperLodash: lodash$1,
	wrapperNext: wrapperNext,
	wrapperPlant: wrapperPlant,
	wrapperReverse: wrapperReverse,
	wrapperToIterator: wrapperToIterator,
	wrapperValue: wrapperValue,
	xor: xor,
	xorBy: xorBy,
	xorWith: xorWith,
	zip: zip,
	zipObject: zipObject,
	zipObjectDeep: zipObjectDeep,
	zipWith: zipWith
});

const isWindow = (value) => value && value === value.window;
const isNumeric = (value) => !Array.isArray(value) && value - parseFloat(value) + 1 >= 0;

var lang$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	isArray: isArray,
	isArrayLike: isArrayLike,
	isBoolean: isBoolean,
	isFunction: isFunction,
	isNil: isNil,
	isNull: isNull,
	isNumber: isNumber,
	isNumeric: isNumeric,
	isObject: isObject,
	isString: isString,
	isUndefined: isUndefined,
	isWindow: isWindow
});

function diff$1(oldList, newList, key) {
    const oldMap = makeKeyIndexAndFree(oldList, key);
    const newMap = makeKeyIndexAndFree(newList, key);
    const newFree = newMap.free;
    const oldKeyIndex = oldMap.keyIndex;
    const newKeyIndex = newMap.keyIndex;
    const moves = [];
    const children = [];
    let i = 0;
    let item;
    let itemKey;
    let freeIndex = 0;
    while (i < oldList.length) {
        item = oldList[i];
        itemKey = item[key];
        if (itemKey) {
            // eslint-disable-next-line
            if (!newKeyIndex.hasOwnProperty(itemKey)) {
                children.push(null);
            }
            else {
                const newItemIndex = newKeyIndex[itemKey];
                children.push(newList[newItemIndex]);
            }
        }
        else {
            freeIndex += 1;
            const freeItem = newFree[freeIndex];
            children.push(freeItem || null);
        }
        i += 1;
    }
    const simulateList = children.slice(0);
    i = 0;
    while (i < simulateList.length) {
        if (simulateList[i] === null) {
            remove(i);
            removeSimulate(i);
        }
        else {
            i += 1;
        }
    }
    let j = (i = 0);
    while (i < newList.length) {
        item = newList[i];
        itemKey = item[key];
        const simulateItem = simulateList[j];
        if (simulateItem) {
            const simulateItemKey = simulateItem[key];
            if (itemKey === simulateItemKey) {
                j += 1;
            }
            else {
                // eslint-disable-next-line
                if (!oldKeyIndex.hasOwnProperty(itemKey)) {
                    insert(i, item);
                }
                else {
                    const nextSimulateItem = simulateList[j + 1];
                    if (nextSimulateItem) {
                        const nextItemKey = nextSimulateItem[key];
                        if (nextItemKey === itemKey) {
                            remove(i);
                            removeSimulate(j);
                            j += 1;
                        }
                        else {
                            insert(i, item);
                        }
                    }
                }
            }
        }
        else {
            insert(i, item);
        }
        i += 1;
    }
    let k = simulateList.length - j;
    while ((j += 1) < simulateList.length) {
        k -= 1;
        remove(k + i);
    }
    function remove(index) {
        const move = { index, type: 0, item: null };
        moves.push(move);
    }
    function insert(index, item) {
        const move = { index, item, type: 1 };
        moves.push(move);
    }
    function removeSimulate(index) {
        simulateList.splice(index, 1);
    }
    return {
        moves,
    };
}
function makeKeyIndexAndFree(list, key) {
    const keyIndex = {};
    const free = [];
    for (let i = 0, len = list.length; i < len; i += 1) {
        const item = list[i];
        const itemKey = item[key];
        if (itemKey) {
            keyIndex[itemKey] = i;
        }
        else {
            free.push(item);
        }
    }
    return {
        keyIndex,
        free,
    };
}

var array$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	diff: diff$1,
	difference: difference,
	groupBy: groupBy,
	isArray: isArray,
	isArrayLike: isArrayLike,
	max: max,
	sortBy: sortBy,
	sortedIndex: sortedIndex,
	sortedIndexBy: sortedIndexBy,
	union: union,
	uniq: uniq
});

/**
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 */
function applyMixins(derivedCtor, ...baseCtors) {
    baseCtors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            if (name !== 'constructor') {
                Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }
        });
    });
}

const extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array &&
        function (d, b) {
            d.__proto__ = b; // eslint-disable-line no-proto
        }) ||
    function (d, b) {
        // eslint-disable-next-line no-restricted-syntax
        for (const p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) {
                d[p] = b[p];
            }
        }
    };
/**
 * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309
 */
// eslint-disable-next-line
function inherit$1(cls, base) {
    extendStatics(cls, base);
    function tmp() {
        this.constructor = cls;
    }
    cls.prototype =
        base === null
            ? Object.create(base)
            : ((tmp.prototype = base.prototype), new tmp());
}
class A {
}
const isNativeClass = /^\s*class\s+/.test(`${A}`) || /^\s*class\s*\{/.test(`${class {
}}`);
/**
 * Extends class with specified class name.
 */
function createClass(className, base) {
    let cls;
    if (isNativeClass) {
        cls = class extends base {
        };
    }
    else {
        cls = function () {
            return base.apply(this, arguments); // eslint-disable-line
        };
        inherit$1(cls, base);
    }
    Object.defineProperty(cls, 'name', { value: className });
    return cls;
}

function ensure(value, defaultValue) {
    return value != null ? value : defaultValue;
}
function getValue(obj, key, defaultValue) {
    const value = obj != null ? obj[key] : null;
    return defaultValue !== undefined ? ensure(value, defaultValue) : value;
}
function getNumber$1(obj, key, defaultValue) {
    let value = obj != null ? obj[key] : null;
    if (value == null) {
        return defaultValue;
    }
    value = +value;
    if (Number.isNaN(value) || !Number.isFinite(value)) {
        return defaultValue;
    }
    return value;
}
function getBoolean(obj, key, defaultValue) {
    const value = obj != null ? obj[key] : null;
    if (value == null) {
        return defaultValue;
    }
    return !!value;
}
function isMaliciousProp(prop) {
    return prop === '__proto__';
}
function getByPath(obj, path, delimiter = '/') {
    let ret;
    const keys = Array.isArray(path) ? path : path.split(delimiter);
    if (keys.length) {
        ret = obj;
        while (keys.length) {
            const key = keys.shift();
            if (Object(ret) === ret && key && key in ret) {
                ret = ret[key];
            }
            else {
                return undefined;
            }
        }
    }
    return ret;
}
function setByPath(obj, path, value, delimiter = '/') {
    const keys = Array.isArray(path) ? path : path.split(delimiter);
    const lastKey = keys.pop();
    if (lastKey && !isMaliciousProp(lastKey)) {
        let diver = obj;
        keys.forEach((key) => {
            if (!isMaliciousProp(key)) {
                if (diver[key] == null) {
                    diver[key] = {};
                }
                diver = diver[key];
            }
        });
        diver[lastKey] = value;
    }
    return obj;
}
function unsetByPath(obj, path, delimiter = '/') {
    const keys = Array.isArray(path) ? path.slice() : path.split(delimiter);
    const propertyToRemove = keys.pop();
    if (propertyToRemove) {
        if (keys.length > 0) {
            const parent = getByPath(obj, keys);
            if (parent) {
                delete parent[propertyToRemove];
            }
        }
        else {
            delete obj[propertyToRemove];
        }
    }
    return obj;
}
function flatten(obj, delim = '/', stop) {
    const ret = {};
    Object.keys(obj).forEach((key) => {
        const val = obj[key];
        let deep = typeof val === 'object' || Array.isArray(val);
        if (deep && stop && stop(val)) {
            deep = false;
        }
        if (deep) {
            const flatObject = flatten(val, delim, stop);
            Object.keys(flatObject).forEach((flatKey) => {
                ret[key + delim + flatKey] = flatObject[flatKey];
            });
        }
        else {
            ret[key] = val;
        }
    });
    // eslint-disable-next-line no-restricted-syntax
    for (const key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
            continue;
        }
    }
    return ret;
}

var object$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	applyMixins: applyMixins,
	clone: clone,
	cloneDeep: cloneDeep,
	createClass: createClass,
	defaults: defaults$3,
	defaultsDeep: defaultsDeep,
	ensure: ensure,
	extend: assignIn,
	flatten: flatten,
	forIn: forIn,
	getBoolean: getBoolean,
	getByPath: getByPath,
	getNumber: getNumber$1,
	getValue: getValue,
	has: has,
	inherit: inherit$1,
	isEmpty: isEmpty,
	isEqual: isEqual,
	isMaliciousProp: isMaliciousProp,
	isObject: isObject,
	isPlainObject: isPlainObject,
	merge: merge,
	pick: pick,
	setByPath: setByPath,
	unsetByPath: unsetByPath
});

function exec(exp) {
    let result = null;
    try {
        result = window.eval(exp); // eslint-disable-line
    }
    catch (e) {
        // pass
    }
    return result;
}

// @see: https://medium.com/@robertsavian/javascript-case-converters-using-lodash-4f2f964091cc
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const kebabCase = cacheStringFunction((s) => s.replace(/\B([A-Z])/g, '-$1').toLowerCase());
const pascalCase = cacheStringFunction((s) => startCase(camelCase(s)).replace(/ /g, ''));
const constantCase = cacheStringFunction((s) => upperCase(s).replace(/ /g, '_'));
const dotCase = cacheStringFunction((s) => lowerCase(s).replace(/ /g, '.'));
const pathCase = cacheStringFunction((s) => lowerCase(s).replace(/ /g, '/'));
const sentenceCase = cacheStringFunction((s) => upperFirst(lowerCase(s)));
const titleCase = cacheStringFunction((s) => startCase(camelCase(s)));

/* eslint-disable no-bitwise */
/**
 * Return a simple hash code from a string.
 * Source from: https://github.com/sindresorhus/fnv1a/blob/master/index.js#L25
 */
function hashcode$1(str) {
    let hash = 2166136261;
    let isUnicoded = false;
    let string = str;
    for (let i = 0, ii = string.length; i < ii; i += 1) {
        let characterCode = string.charCodeAt(i);
        // Non-ASCII characters trigger the Unicode escape logic
        if (characterCode > 0x7f && !isUnicoded) {
            string = unescape(encodeURIComponent(string));
            characterCode = string.charCodeAt(i);
            isUnicoded = true;
        }
        hash ^= characterCode;
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }
    return hash >>> 0;
}

/* eslint-disable no-bitwise */
function uuid$1() {
    // credit: http://stackoverflow.com/posts/2117523/revisions
    // return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    //   const r = (Math.random() * 16) | 0
    //   const v = c === 'x' ? r : (r & 0x3) | 0x8
    //   return v.toString(16)
    // })
    let res = '';
    const template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    for (let i = 0, len = template.length; i < len; i += 1) {
        const s = template[i];
        const r = (Math.random() * 16) | 0;
        const v = s === 'x' ? r : s === 'y' ? (r & 0x3) | 0x8 : s;
        res += v.toString(16);
    }
    return res;
}

function sanitizeHTML(html, options = {}) {
    // If documentContext (second parameter) is not specified or given as
    // `null` or `undefined`, a new document is used. Inline events will not
    // execute when the HTML is parsed; this includes, for example, sending
    // GET requests for images.
    // If keepScripts (last parameter) is `false`, scripts are not executed.
    const nodes = JQuery.parseHTML(html, null, false);
    nodes.forEach((node) => {
        const elem = node;
        if (elem) {
            const attrs = elem.attributes;
            if (attrs) {
                for (let i = 0, ii = attrs.length; i < ii; i += 1) {
                    const attr = attrs.item(i);
                    if (attr) {
                        const val = attr.value.toLowerCase();
                        const name = attr.name.toLowerCase();
                        // Removes attribute name starts with "on" (e.g. onload,
                        // onerror...).
                        // Removes attribute value starts with "javascript:" pseudo
                        // protocol (e.g. `href="javascript:alert(1)"`).
                        if (name.startsWith('on') ||
                            val.startsWith('javascript:') || // eslint-disable-line no-script-url
                            // ref: https://lgtm.com/rules/1510852698359/
                            val.startsWith('data:') ||
                            val.startsWith('vbscript:')) {
                            elem.removeAttribute(name);
                        }
                    }
                }
            }
        }
    });
    if (options.raw) {
        return nodes;
    }
    return JQuery('<div/>').append(nodes).html();
}

// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts
/**
 * Given a name and a list of names that are not equal to the name, return a
 * spelling suggestion if there is one that is close enough. Names less than
 * length 3 only check for case-insensitive equality, not Levenshtein distance.
 *
 * - If there is a candidate that's the same except for case, return that.
 * - If there is a candidate that's within one edit of the name, return that.
 * - Otherwise, return the candidate with the smallest Levenshtein distance,
 *     except for candidates:
 *       * With no name
 *       * Whose length differs from the target name by more than 0.34 of the
 *         length of the name.
 *       * Whose levenshtein distance is more than 0.4 of the length of the
 *         name (0.4 allows 1 substitution/transposition for every 5 characters,
 *         and 1 insertion/deletion at 3 characters)
 */
function getSpellingSuggestion(name, candidates, getName) {
    const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
    // If the best result isn't better than this, don't bother.
    let bestDistance = Math.floor(name.length * 0.4) + 1;
    let bestCandidate;
    let justCheckExactMatches = false;
    const nameLowerCase = name.toLowerCase();
    // eslint-disable-next-line
    for (const candidate of candidates) {
        const candidateName = getName(candidate);
        if (candidateName !== undefined &&
            Math.abs(candidateName.length - nameLowerCase.length) <=
                maximumLengthDifference) {
            const candidateNameLowerCase = candidateName.toLowerCase();
            if (candidateNameLowerCase === nameLowerCase) {
                if (candidateName === name) {
                    continue;
                }
                return candidate;
            }
            if (justCheckExactMatches) {
                continue;
            }
            if (candidateName.length < 3) {
                // Don't bother, user would have noticed a
                // 2-character name having an extra character.
                continue;
            }
            // Only care about a result better than the best so far.
            const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);
            if (distance === undefined) {
                continue;
            }
            if (distance < 3) {
                justCheckExactMatches = true;
                bestCandidate = candidate;
            }
            else {
                // Debug.assert(distance < bestDistance)
                bestDistance = distance;
                bestCandidate = candidate;
            }
        }
    }
    return bestCandidate;
}
function levenshteinWithMax(s1, s2, max) {
    let previous = new Array(s2.length + 1); // eslint-disable-line
    let current = new Array(s2.length + 1); // eslint-disable-line
    /** Represents any value > max. We don't care about the particular value. */
    const big = max + 1;
    for (let i = 0; i <= s2.length; i += 1) {
        previous[i] = i;
    }
    for (let i = 1; i <= s1.length; i += 1) {
        const c1 = s1.charCodeAt(i - 1);
        const minJ = i > max ? i - max : 1;
        const maxJ = s2.length > max + i ? max + i : s2.length;
        current[0] = i;
        /** Smallest value of the matrix in the ith column. */
        let colMin = i;
        for (let j = 1; j < minJ; j += 1) {
            current[j] = big;
        }
        for (let j = minJ; j <= maxJ; j += 1) {
            const dist = c1 === s2.charCodeAt(j - 1)
                ? previous[j - 1]
                : Math.min(
                /* delete */ previous[j] + 1, 
                /* insert */ current[j - 1] + 1, 
                /* substitute */ previous[j - 1] + 2);
            current[j] = dist;
            colMin = Math.min(colMin, dist);
        }
        for (let j = maxJ + 1; j <= s2.length; j += 1) {
            current[j] = big;
        }
        if (colMin > max) {
            // Give up -- everything in this column is > max
            // and it can't get better in future columns.
            return undefined;
        }
        const temp = previous;
        previous = current;
        current = temp;
    }
    const res = previous[s2.length];
    return res > max ? undefined : res;
}

var string$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	camelCase: camelCase,
	constantCase: constantCase,
	dotCase: dotCase,
	endsWith: endsWith,
	escape: escape,
	eval: exec,
	getSpellingSuggestion: getSpellingSuggestion,
	hashcode: hashcode$1,
	isString: isString,
	kebabCase: kebabCase,
	lowerFirst: lowerFirst,
	pad: pad,
	padEnd: padEnd,
	padStart: padStart,
	pascalCase: pascalCase,
	pathCase: pathCase,
	repeat: repeat,
	sanitizeHTML: sanitizeHTML,
	sentenceCase: sentenceCase,
	split: split,
	startsWith: startsWith,
	template: template,
	titleCase: titleCase,
	toString: toString,
	truncate: truncate,
	unescape: unescape$1,
	uniqueId: uniqueId$1,
	upperFirst: upperFirst,
	uuid: uuid$1
});

/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */
function mod$1(n, m) {
    return ((n % m) + m) % m;
}
function random$1(lower, upper) {
    if (upper == null) {
        upper = lower == null ? 1 : lower; // eslint-disable-line
        lower = 0; // eslint-disable-line
    }
    else if (upper < lower) {
        const tmp = lower;
        lower = upper; // eslint-disable-line
        upper = tmp; // eslint-disable-line
    }
    return Math.floor(Math.random() * (upper - lower + 1) + lower);
}
function isPercentage(val) {
    return typeof val === 'string' && val.slice(-1) === '%';
}
function normalizePercentage(num, ref) {
    if (num == null) {
        return 0;
    }
    let raw;
    if (typeof num === 'string') {
        raw = parseFloat(num);
        if (isPercentage(num)) {
            raw /= 100;
            if (Number.isFinite(raw)) {
                return raw * ref;
            }
        }
    }
    else {
        raw = num;
    }
    if (!Number.isFinite(raw)) {
        return 0;
    }
    if (raw > 0 && raw < 1) {
        return raw * ref;
    }
    return raw;
}
function parseCssNumeric(val, units) {
    function getUnit(regexp) {
        const matches = new RegExp(`(?:\\d+(?:\\.\\d+)*)(${regexp})$`).exec(val);
        if (!matches) {
            return null;
        }
        return matches[1];
    }
    const number = parseFloat(val);
    if (Number.isNaN(number)) {
        return null;
    }
    // determine the unit
    let regexp;
    if (units == null) {
        // accept any unit, as well as no unit
        regexp = '[A-Za-z]*';
    }
    else if (Array.isArray(units)) {
        if (units.length === 0) {
            return null;
        }
        regexp = units.join('|');
    }
    else if (typeof units === 'string') {
        regexp = units;
    }
    const unit = getUnit(regexp);
    if (unit === null) {
        return null;
    }
    return {
        unit,
        value: number,
    };
}
function normalizeSides(box) {
    if (typeof box === 'object') {
        let left = 0;
        let top = 0;
        let right = 0;
        let bottom = 0;
        if (box.vertical != null && Number.isFinite(box.vertical)) {
            top = bottom = box.vertical;
        }
        if (box.horizontal != null && Number.isFinite(box.horizontal)) {
            right = left = box.horizontal;
        }
        if (box.left != null && Number.isFinite(box.left))
            left = box.left;
        if (box.top != null && Number.isFinite(box.top))
            top = box.top;
        if (box.right != null && Number.isFinite(box.right))
            right = box.right;
        if (box.bottom != null && Number.isFinite(box.bottom))
            bottom = box.bottom;
        return { top, right, bottom, left };
    }
    let val = 0;
    if (box != null && Number.isFinite(box)) {
        val = box;
    }
    return { top: val, right: val, bottom: val, left: val };
}

var number$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	clamp: clamp$1,
	inRange: inRange,
	isFinite: isFinite$1,
	isInteger: isInteger,
	isNaN: isNaN$1,
	isNumber: isNumber,
	isNumeric: isNumeric,
	isPercentage: isPercentage,
	isSafeInteger: isSafeInteger,
	mod: mod$1,
	normalizePercentage: normalizePercentage,
	normalizeSides: normalizeSides,
	parseCssNumeric: parseCssNumeric,
	parseInt: parseInt$1,
	random: random$1,
	toFinite: toFinite,
	toInteger: toInteger,
	toNumber: toNumber,
	toSafeInteger: toSafeInteger
});

function apply(fn, ctx, args) {
    if (args) {
        switch (args.length) {
            case 0:
                return fn.call(ctx);
            case 1:
                return fn.call(ctx, args[0]);
            case 2:
                return fn.call(ctx, args[0], args[1]);
            case 3:
                return fn.call(ctx, args[0], args[1], args[2]);
            case 4:
                return fn.call(ctx, args[0], args[1], args[2], args[3]);
            case 5:
                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);
            case 6:
                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);
            default:
                return fn.apply(ctx, args);
        }
    }
    return fn.call(ctx);
}
function call(fn, ctx, ...args) {
    return apply(fn, ctx, args);
}
function repush(array, item) {
    for (let i = 0, ii = array.length; i < ii; i += 1) {
        if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
}
function cacher(fn, ctx, postProcessor) {
    const keys = [];
    const cache = {};
    const f = (...args) => {
        let hasCache = false;
        const key = args.join('\u2400');
        if (key in cache) {
            hasCache = true;
            repush(keys, key);
        }
        else {
            if (keys.length >= 1000) {
                delete cache[keys.shift()];
            }
            keys.push(key);
            cache[key] = apply(fn, ctx || null, args);
        }
        return postProcessor ? postProcessor(cache[key], hasCache) : cache[key];
    };
    return f;
}

function isAsyncLike(obj) {
    return typeof obj === 'object' && obj.then && typeof obj.then === 'function';
}
function isAsync(obj) {
    return obj != null && (obj instanceof Promise || isAsyncLike(obj));
}
function toAsyncBoolean(...inputs) {
    const results = [];
    inputs.forEach((arg) => {
        if (Array.isArray(arg)) {
            results.push(...arg);
        }
        else {
            results.push(arg);
        }
    });
    const hasAsync = results.some((res) => isAsync(res));
    if (hasAsync) {
        const deferres = results.map((res) => isAsync(res) ? res : Promise.resolve(res !== false));
        return Promise.all(deferres).then((arr) => arr.reduce((memo, item) => item !== false && memo, true));
    }
    return results.every((res) => res !== false);
}
function toDeferredBoolean(...inputs) {
    const ret = toAsyncBoolean(inputs);
    return typeof ret === 'boolean' ? Promise.resolve(ret) : ret;
}

var main$5 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	apply: apply,
	cacher: cacher,
	call: call,
	debounce: debounce$1,
	defer: defer,
	isAsync: isAsync,
	isAsyncLike: isAsyncLike,
	isFunction: isFunction,
	noop: noop$1,
	once: once,
	toAsyncBoolean: toAsyncBoolean,
	toDeferredBoolean: toDeferredBoolean
});

const rclass = /[\t\r\n\f]/g;
const rnotwhite = /\S+/g;
const fillSpaces = (str) => ` ${str} `;
function getClass(elem) {
    return (elem && elem.getAttribute && elem.getAttribute('class')) || '';
}
function hasClass(elem, selector) {
    if (elem == null || selector == null) {
        return false;
    }
    const classNames = fillSpaces(getClass(elem));
    const className = fillSpaces(selector);
    return elem.nodeType === 1
        ? classNames.replace(rclass, ' ').includes(className)
        : false;
}
function addClass(elem, selector) {
    if (elem == null || selector == null) {
        return;
    }
    if (typeof selector === 'function') {
        return addClass(elem, selector(getClass(elem)));
    }
    if (typeof selector === 'string' && elem.nodeType === 1) {
        const classes = selector.match(rnotwhite) || [];
        const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
        let newValue = classes.reduce((memo, cls) => {
            if (memo.indexOf(fillSpaces(cls)) < 0) {
                return `${memo}${cls} `;
            }
            return memo;
        }, oldValue);
        newValue = newValue.trim();
        if (oldValue !== newValue) {
            elem.setAttribute('class', newValue);
        }
    }
}
function removeClass(elem, selector) {
    if (elem == null) {
        return;
    }
    if (typeof selector === 'function') {
        return removeClass(elem, selector(getClass(elem)));
    }
    if ((!selector || typeof selector === 'string') && elem.nodeType === 1) {
        const classes = (selector || '').match(rnotwhite) || [];
        const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
        let newValue = classes.reduce((memo, cls) => {
            const className = fillSpaces(cls);
            if (memo.indexOf(className) > -1) {
                return memo.replace(className, ' ');
            }
            return memo;
        }, oldValue);
        newValue = selector ? newValue.trim() : '';
        if (oldValue !== newValue) {
            elem.setAttribute('class', newValue);
        }
    }
}
function toggleClass(elem, selector, stateVal) {
    if (elem == null || selector == null) {
        return;
    }
    if (stateVal != null && typeof selector === 'string') {
        stateVal ? addClass(elem, selector) : removeClass(elem, selector);
        return;
    }
    if (typeof selector === 'function') {
        return toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
    }
    if (typeof selector === 'string') {
        const metches = selector.match(rnotwhite) || [];
        metches.forEach((cls) => {
            hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls);
        });
    }
}

let idCounter = 0;
function uniqueId() {
    idCounter += 1;
    return `v${idCounter}`;
}
function ensureId(elem) {
    if (elem.id == null || elem.id === '') {
        elem.id = uniqueId();
    }
    return elem.id;
}
/**
 * Returns true if object is an instance of SVGGraphicsElement.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
 */
function isSVGGraphicsElement(elem) {
    if (elem == null) {
        return false;
    }
    return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;
}
const ns = {
    svg: 'http://www.w3.org/2000/svg',
    xmlns: 'http://www.w3.org/2000/xmlns/',
    xml: 'http://www.w3.org/XML/1998/namespace',
    xlink: 'http://www.w3.org/1999/xlink',
    xhtml: 'http://www.w3.org/1999/xhtml',
};
const svgVersion = '1.1';
function createElement(tagName, doc = document) {
    return doc.createElement(tagName);
}
function createElementNS(tagName, namespaceURI = ns.xhtml, doc = document) {
    return doc.createElementNS(namespaceURI, tagName);
}
function createSvgElement(tagName, doc = document) {
    return createElementNS(tagName, ns.svg, doc);
}
function createSvgDocument(content) {
    if (content) {
        const xml = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${svgVersion}">${content}</svg>`; // lgtm[js/html-constructed-from-input]
        const { documentElement } = parseXML(xml, { async: false });
        return documentElement;
    }
    const svg = document.createElementNS(ns.svg, 'svg');
    svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);
    svg.setAttribute('version', svgVersion);
    return svg;
}
function parseXML(data, options = {}) {
    let xml;
    try {
        const parser = new DOMParser();
        if (options.async != null) {
            const instance = parser;
            instance.async = options.async;
        }
        xml = parser.parseFromString(data, options.mimeType || 'text/xml');
    }
    catch (error) {
        xml = undefined;
    }
    if (!xml || xml.getElementsByTagName('parsererror').length) {
        throw new Error(`Invalid XML: ${data}`);
    }
    return xml;
}
function tagName(node, lowercase = true) {
    const nodeName = node.nodeName;
    return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
}
function index$4(elem) {
    let index = 0;
    let node = elem.previousSibling;
    while (node) {
        if (node.nodeType === 1) {
            index += 1;
        }
        node = node.previousSibling;
    }
    return index;
}
function find(elem, selector) {
    return elem.querySelectorAll(selector);
}
function findOne(elem, selector) {
    return elem.querySelector(selector);
}
function findParentByClass(elem, className, terminator) {
    const ownerSVGElement = elem.ownerSVGElement;
    let node = elem.parentNode;
    while (node && node !== terminator && node !== ownerSVGElement) {
        if (hasClass(node, className)) {
            return node;
        }
        node = node.parentNode;
    }
    return null;
}
function contains(parent, child) {
    const bup = child && child.parentNode;
    return (parent === bup ||
        !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise
    );
}
function remove(elem) {
    if (elem.parentNode) {
        elem.parentNode.removeChild(elem);
    }
}
function empty(elem) {
    while (elem.firstChild) {
        elem.removeChild(elem.firstChild);
    }
}
function append(elem, elems) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach((child) => {
        if (child != null) {
            elem.appendChild(child);
        }
    });
}
function prepend(elem, elems) {
    const child = elem.firstChild;
    return child ? before(child, elems) : append(elem, elems);
}
function before(elem, elems) {
    const parent = elem.parentNode;
    if (parent) {
        const arr = Array.isArray(elems) ? elems : [elems];
        arr.forEach((child) => {
            if (child != null) {
                parent.insertBefore(child, elem);
            }
        });
    }
}
function appendTo(elem, target) {
    if (target != null) {
        target.appendChild(elem);
    }
}
// Determines whether a node is an HTML node
function isHTMLElement(elem) {
    try {
        // Using W3 DOM2 (works for FF, Opera and Chrome)
        return elem instanceof HTMLElement;
    }
    catch (e) {
        // Browsers not supporting W3 DOM2 don't have HTMLElement and
        // an exception is thrown and we end up here. Testing some
        // properties that all elements have (works on IE7)
        return (typeof elem === 'object' &&
            elem.nodeType === 1 &&
            typeof elem.style === 'object' &&
            typeof elem.ownerDocument === 'object');
    }
}
function clickable(elem) {
    if (!elem || !isHTMLElement(elem)) {
        return false;
    }
    if (['a', 'button'].includes(tagName(elem))) {
        return true;
    }
    if (elem.getAttribute('role') === 'button' ||
        elem.getAttribute('type') === 'button') {
        return true;
    }
    return clickable(elem.parentNode);
}
function isInputElement(elem) {
    const elemTagName = tagName(elem);
    if (elemTagName === 'input') {
        const type = elem.getAttribute('type');
        if (type == null ||
            ['text', 'password', 'number', 'email', 'search', 'tel', 'url'].includes(type)) {
            return true;
        }
    }
    return false;
}

const CASE_SENSITIVE_ATTR = [
    'viewBox',
    'attributeName',
    'attributeType',
    'repeatCount',
];
function getAttribute(elem, name) {
    return elem.getAttribute(name);
}
function removeAttribute(elem, name) {
    const qualified = qualifyAttr(name);
    if (qualified.ns) {
        if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
            elem.removeAttributeNS(qualified.ns, qualified.local);
        }
    }
    else if (elem.hasAttribute(name)) {
        elem.removeAttribute(name);
    }
}
function setAttribute(elem, name, value) {
    if (value == null) {
        return removeAttribute(elem, name);
    }
    const qualified = qualifyAttr(name);
    if (qualified.ns && typeof value === 'string') {
        elem.setAttributeNS(qualified.ns, name, value);
    }
    else if (name === 'id') {
        elem.id = `${value}`;
    }
    else {
        elem.setAttribute(name, `${value}`);
    }
}
function setAttributes(elem, attrs) {
    Object.keys(attrs).forEach((name) => {
        setAttribute(elem, name, attrs[name]);
    });
}
function attr$1(elem, name, value) {
    if (name == null) {
        const attrs = elem.attributes;
        const ret = {};
        for (let i = 0; i < attrs.length; i += 1) {
            ret[attrs[i].name] = attrs[i].value;
        }
        return ret;
    }
    if (typeof name === 'string' && value === undefined) {
        return elem.getAttribute(name);
    }
    if (typeof name === 'object') {
        setAttributes(elem, name);
    }
    else {
        setAttribute(elem, name, value);
    }
}
function qualifyAttr(name) {
    if (name.indexOf(':') !== -1) {
        const combinedKey = name.split(':');
        return {
            ns: ns[combinedKey[0]],
            local: combinedKey[1],
        };
    }
    return {
        ns: null,
        local: name,
    };
}
function kebablizeAttrs(attrs) {
    const result = {};
    Object.keys(attrs).forEach((key) => {
        const name = CASE_SENSITIVE_ATTR.includes(key) ? key : kebabCase(key);
        result[name] = attrs[key];
    });
    return result;
}
function styleToObject(styleString) {
    const ret = {};
    const styles = styleString.split(';');
    styles.forEach((item) => {
        const section = item.trim();
        if (section) {
            const pair = section.split('=');
            if (pair.length) {
                ret[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
            }
        }
    });
    return ret;
}
function mergeAttrs(target, source) {
    Object.keys(source).forEach((attr) => {
        if (attr === 'class') {
            target[attr] = target[attr]
                ? `${target[attr]} ${source[attr]}`
                : source[attr];
        }
        else if (attr === 'style') {
            const to = typeof target[attr] === 'object';
            const so = typeof source[attr] === 'object';
            let tt;
            let ss;
            if (to && so) {
                tt = target[attr];
                ss = source[attr];
            }
            else if (to) {
                tt = target[attr];
                ss = styleToObject(source[attr]);
            }
            else if (so) {
                tt = styleToObject(target[attr]);
                ss = source[attr];
            }
            else {
                tt = styleToObject(target[attr]);
                ss = styleToObject(source[attr]);
            }
            target[attr] = mergeAttrs(tt, ss);
        }
        else {
            target[attr] = source[attr];
        }
    });
    return target;
}

function annotate$1(t, annotations, opt = {}) {
    const offset = opt.offset || 0;
    const compacted = [];
    const ret = [];
    let curr;
    let prev;
    let batch = null;
    for (let i = 0; i < t.length; i += 1) {
        curr = ret[i] = t[i];
        for (let j = 0, jj = annotations.length; j < jj; j += 1) {
            const annotation = annotations[j];
            const start = annotation.start + offset;
            const end = annotation.end + offset;
            if (i >= start && i < end) {
                if (typeof curr === 'string') {
                    curr = ret[i] = {
                        t: t[i],
                        attrs: annotation.attrs,
                    };
                }
                else {
                    curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);
                }
                if (opt.includeAnnotationIndices) {
                    if (curr.annotations == null) {
                        curr.annotations = [];
                    }
                    curr.annotations.push(j);
                }
            }
        }
        prev = ret[i - 1];
        if (!prev) {
            batch = curr;
        }
        else if (isObject(curr) && isObject(prev)) {
            batch = batch;
            // Both previous item and the current one are annotations.
            // If the attributes didn't change, merge the text.
            if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
                batch.t += curr.t;
            }
            else {
                compacted.push(batch);
                batch = curr;
            }
        }
        else if (isObject(curr)) {
            // Previous item was a string, current item is an annotation.
            batch = batch;
            compacted.push(batch);
            batch = curr;
        }
        else if (isObject(prev)) {
            // Previous item was an annotation, current item is a string.
            batch = batch;
            compacted.push(batch);
            batch = curr;
        }
        else {
            // Both previous and current item are strings.
            batch = (batch || '') + curr;
        }
    }
    if (batch != null) {
        compacted.push(batch);
    }
    return compacted;
}
function findAnnotationsAtIndex(annotations, index) {
    return annotations
        ? annotations.filter((a) => a.start < index && index <= a.end)
        : [];
}
function findAnnotationsBetweenIndexes(annotations, start, end) {
    return annotations
        ? annotations.filter((a) => (start >= a.start && start < a.end) ||
            (end > a.start && end <= a.end) ||
            (a.start >= start && a.end < end))
        : [];
}
function shiftAnnotations(annotations, index, offset) {
    if (annotations) {
        annotations.forEach((a) => {
            if (a.start < index && a.end >= index) {
                a.end += offset;
            }
            else if (a.start >= index) {
                a.start += offset;
                a.end += offset;
            }
        });
    }
    return annotations;
}

/**
 * Replaces all spaces with the Unicode No-break space.
 * ref: http://www.fileformat.info/info/unicode/char/a0/index.htm
 *
 * IE would otherwise collapse all spaces into one. This is useful
 * e.g. in tests when you want to compare the actual DOM text content
 * without having to add the unicode character in the place of all spaces.
 */
function sanitize$1(text) {
    return text.replace(/ /g, '\u00A0');
}

var main$4 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	annotate: annotate$1,
	findAnnotationsAtIndex: findAnnotationsAtIndex,
	findAnnotationsBetweenIndexes: findAnnotationsBetweenIndexes,
	sanitize: sanitize$1,
	shiftAnnotations: shiftAnnotations
});

/**
 * The namespace for JSON-specific functions.
 */
var JSONExt;
(function (JSONExt) {
    /**
     * A shared frozen empty JSONObject
     */
    JSONExt.emptyObject = Object.freeze({});
    /**
     * A shared frozen empty JSONArray
     */
    JSONExt.emptyArray = Object.freeze([]);
    /**
     * Test whether a JSON value is a primitive.
     *
     * @param value - The JSON value of interest.
     *
     * @returns `true` if the value is a primitive,`false` otherwise.
     */
    function isPrimitive(value) {
        return (value === null ||
            value === undefined ||
            typeof value === 'boolean' ||
            typeof value === 'number' ||
            typeof value === 'string');
    }
    JSONExt.isPrimitive = isPrimitive;
    function isArray(value) {
        return Array.isArray(value);
    }
    JSONExt.isArray = isArray;
    function isObject(value) {
        return !isPrimitive(value) && !isArray(value);
    }
    JSONExt.isObject = isObject;
    /**
     * Compare two JSON values for deep equality.
     *
     * @param first - The first JSON value of interest.
     *
     * @param second - The second JSON value of interest.
     *
     * @returns `true` if the values are equivalent, `false` otherwise.
     */
    function deepEqual(first, second) {
        // Check referential and primitive equality first.
        if (first === second) {
            return true;
        }
        // If one is a primitive, the `===` check ruled out the other.
        if (isPrimitive(first) || isPrimitive(second)) {
            return false;
        }
        // Test whether they are arrays.
        const a1 = isArray(first);
        const a2 = isArray(second);
        // Bail if the types are different.
        if (a1 !== a2) {
            return false;
        }
        // If they are both arrays, compare them.
        if (a1 && a2) {
            return deepArrayEqual(first, second);
        }
        // At this point, they must both be objects.
        return deepObjectEqual(first, second);
    }
    JSONExt.deepEqual = deepEqual;
    /**
     * Create a deep copy of a JSON value.
     *
     * @param value - The JSON value to copy.
     *
     * @returns A deep copy of the given JSON value.
     */
    function deepCopy(value) {
        // Do nothing for primitive values.
        if (isPrimitive(value)) {
            return value;
        }
        // Deep copy an array.
        if (isArray(value)) {
            return deepArrayCopy(value);
        }
        // Deep copy an object.
        return deepObjectCopy(value);
    }
    JSONExt.deepCopy = deepCopy;
    /**
     * Compare two JSON arrays for deep equality.
     */
    function deepArrayEqual(first, second) {
        // Check referential equality first.
        if (first === second) {
            return true;
        }
        // Test the arrays for equal length.
        if (first.length !== second.length) {
            return false;
        }
        // Compare the values for equality.
        for (let i = 0, n = first.length; i < n; i += 1) {
            if (!deepEqual(first[i], second[i])) {
                return false;
            }
        }
        // At this point, the arrays are equal.
        return true;
    }
    /**
     * Compare two JSON objects for deep equality.
     */
    function deepObjectEqual(first, second) {
        // Check referential equality first.
        if (first === second) {
            return true;
        }
        // Check for the first object's keys in the second object.
        // eslint-disable-next-line
        for (const key in first) {
            if (!(key in second)) {
                return false;
            }
        }
        // Check for the second object's keys in the first object.
        // eslint-disable-next-line
        for (const key in second) {
            if (!(key in first)) {
                return false;
            }
        }
        // Compare the values for equality.
        // eslint-disable-next-line
        for (const key in first) {
            if (!deepEqual(first[key], second[key])) {
                return false;
            }
        }
        // At this point, the objects are equal.
        return true;
    }
    /**
     * Create a deep copy of a JSON array.
     */
    function deepArrayCopy(value) {
        const result = new Array(value.length); // eslint-disable-line
        for (let i = 0, n = value.length; i < n; i += 1) {
            result[i] = deepCopy(value[i]);
        }
        return result;
    }
    /**
     * Create a deep copy of a JSON object.
     */
    function deepObjectCopy(value) {
        const result = {};
        Object.keys(value).forEach((key) => {
            result[key] = deepCopy(value[key]);
        });
        return result;
    }
})(JSONExt || (JSONExt = {}));

var DataUri;
(function (DataUri) {
    function isDataUrl(url) {
        const prefix = 'data:';
        return url.substr(0, prefix.length) === prefix;
    }
    DataUri.isDataUrl = isDataUrl;
    /**
     * Converts an image at `url` to base64-encoded data uri.
     * The mime type of the image is inferred from the `url` file extension.
     */
    function imageToDataUri(url, callback) {
        // No need to convert to data uri if it is already in data uri.
        if (!url || isDataUrl(url)) {
            // Keep the async nature of the function.
            setTimeout(() => callback(null, url));
            return;
        }
        const onError = () => {
            callback(new Error(`Failed to load image: ${url}`));
        };
        const onLoad = window.FileReader
            ? // chrome, IE10+
                (xhr) => {
                    if (xhr.status === 200) {
                        const reader = new FileReader();
                        reader.onload = (evt) => {
                            const dataUri = evt.target.result;
                            callback(null, dataUri);
                        };
                        reader.onerror = onError;
                        reader.readAsDataURL(xhr.response);
                    }
                    else {
                        onError();
                    }
                }
            : (xhr) => {
                const toString = (u8a) => {
                    const CHUNK_SZ = 0x8000;
                    const c = [];
                    for (let i = 0; i < u8a.length; i += CHUNK_SZ) {
                        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
                    }
                    return c.join('');
                };
                if (xhr.status === 200) {
                    let suffix = url.split('.').pop() || 'png';
                    if (suffix === 'svg') {
                        suffix = 'svg+xml';
                    }
                    const meta = `data:image/${suffix};base64,`;
                    const bytes = new Uint8Array(xhr.response);
                    const base64 = meta + btoa(toString(bytes));
                    callback(null, base64);
                }
                else {
                    onError();
                }
            };
        const xhr = new XMLHttpRequest();
        xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';
        xhr.open('GET', url, true);
        xhr.addEventListener('error', onError);
        xhr.addEventListener('load', () => onLoad(xhr));
        xhr.send();
    }
    DataUri.imageToDataUri = imageToDataUri;
    function dataUriToBlob(dataUrl) {
        let uri = dataUrl.replace(/\s/g, '');
        uri = decodeURIComponent(uri);
        const index = uri.indexOf(',');
        const dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'
        const mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'
        const data = uri.slice(index + 1);
        let decodedString;
        if (dataType.indexOf('base64') >= 0) {
            // data may be encoded in base64
            decodedString = atob(data);
        }
        else {
            // convert the decoded string to UTF-8
            decodedString = unescape(encodeURIComponent(data));
        }
        // write the bytes of the string to a typed array
        const ia = new Uint8Array(decodedString.length);
        for (let i = 0; i < decodedString.length; i += 1) {
            ia[i] = decodedString.charCodeAt(i);
        }
        return new Blob([ia], { type: mime });
    }
    DataUri.dataUriToBlob = dataUriToBlob;
    function downloadBlob(blob, fileName) {
        const msSaveBlob = window.navigator.msSaveBlob;
        if (msSaveBlob) {
            // requires IE 10+
            // pulls up a save dialog
            msSaveBlob(blob, fileName);
        }
        else {
            // other browsers
            // downloads directly in Chrome and Safari
            // presents a save/open dialog in Firefox
            // Firefox bug: `from` field in save dialog always shows `from:blob:`
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            // mark the url for garbage collection
            window.URL.revokeObjectURL(url);
        }
    }
    DataUri.downloadBlob = downloadBlob;
    function downloadDataUri(dataUrl, fileName) {
        const blob = dataUriToBlob(dataUrl);
        downloadBlob(blob, fileName);
    }
    DataUri.downloadDataUri = downloadDataUri;
    function parseViewBox(svg) {
        const matches = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        if (matches && matches[2]) {
            return matches[2].replace(/\s+/, ' ').split(' ');
        }
        return null;
    }
    function getNumber(str) {
        const ret = parseFloat(str);
        return Number.isNaN(ret) ? null : ret;
    }
    function svgToDataUrl(svg, options = {}) {
        let viewBox = null;
        const getNumberFromViewBox = (index) => {
            if (viewBox == null) {
                viewBox = parseViewBox(svg);
            }
            if (viewBox != null) {
                return getNumber(viewBox[index]);
            }
            return null;
        };
        const getNumberFromMatches = (reg) => {
            const matches = svg.match(reg);
            if (matches && matches[2]) {
                return getNumber(matches[2]);
            }
            return null;
        };
        let w = options.width;
        if (w == null) {
            w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        }
        if (w == null) {
            w = getNumberFromViewBox(2);
        }
        if (w == null) {
            throw new Error('Can not parse width from svg string');
        }
        let h = options.height;
        if (h == null) {
            h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        }
        if (h == null) {
            h = getNumberFromViewBox(3);
        }
        if (h == null) {
            throw new Error('Can not parse height from svg string');
        }
        const decoded = encodeURIComponent(svg)
            .replace(/'/g, '%27')
            .replace(/"/g, '%22');
        const header = 'data:image/svg+xml';
        const dataUrl = `${header},${decoded}`;
        return dataUrl;
    }
    DataUri.svgToDataUrl = svgToDataUrl;
})(DataUri || (DataUri = {}));

let millimeterSize;
const supportedUnits = {
    px(val) {
        return val;
    },
    mm(val) {
        return millimeterSize * val;
    },
    cm(val) {
        return millimeterSize * val * 10;
    },
    in(val) {
        return millimeterSize * val * 25.4;
    },
    pt(val) {
        return millimeterSize * ((25.4 * val) / 72);
    },
    pc(val) {
        return millimeterSize * ((25.4 * val) / 6);
    },
};
// eslint-disable-next-line
var Unit;
(function (Unit) {
    function measure(cssWidth, cssHeight, unit) {
        const div = JQuery('<div/>')
            .css({
            display: 'inline-block',
            position: 'absolute',
            left: -15000,
            top: -15000,
            width: cssWidth + (unit || ''),
            height: cssHeight + (unit || ''),
        })
            .appendTo(document.body);
        const size = {
            width: div.width() || 0,
            height: div.height() || 0,
        };
        div.remove();
        return size;
    }
    Unit.measure = measure;
    function toPx(val, unit) {
        if (millimeterSize == null) {
            millimeterSize = measure(`1`, `1`, 'mm').width;
        }
        const convert = unit ? supportedUnits[unit] : null;
        if (convert) {
            return convert(val);
        }
        return val;
    }
    Unit.toPx = toPx;
})(Unit || (Unit = {}));

const requestAnimationFrame$1 = (function () {
    let raf;
    const win = window;
    if (win != null) {
        raf =
            win.requestAnimationFrame ||
                win.webkitRequestAnimationFrame ||
                win.mozRequestAnimationFrame ||
                win.oRequestAnimationFrame ||
                win.msRequestAnimationFrame;
        if (raf != null) {
            raf = raf.bind(win);
        }
    }
    if (raf == null) {
        let lastTime = 0;
        raf = (callback) => {
            const currTime = new Date().getTime();
            const timeToCall = Math.max(0, 16 - (currTime - lastTime));
            const id = setTimeout(() => {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }
    return raf;
})();
const cancelAnimationFrame$1 = (function () {
    let caf;
    const win = window;
    if (win != null) {
        caf =
            win.cancelAnimationFrame ||
                win.webkitCancelAnimationFrame ||
                win.webkitCancelRequestAnimationFrame ||
                win.msCancelAnimationFrame ||
                win.msCancelRequestAnimationFrame ||
                win.oCancelAnimationFrame ||
                win.oCancelRequestAnimationFrame ||
                win.mozCancelAnimationFrame ||
                win.mozCancelRequestAnimationFrame;
        if (caf) {
            caf = caf.bind(win);
        }
    }
    if (caf == null) {
        caf = clearTimeout;
    }
    return caf;
})();

const hyphenPattern = /-(.)/g;
function camelize(str) {
    return str.replace(hyphenPattern, (_, char) => char.toUpperCase());
}
const memoized = {};
const prefixes = ['Webkit', 'ms', 'Moz', 'O'];
const testStyle = document ? document.createElement('div').style : {};
function getWithPrefix(name) {
    for (let i = 0; i < prefixes.length; i += 1) {
        const prefixedName = prefixes[i] + name;
        if (prefixedName in testStyle) {
            return prefixedName;
        }
    }
    return null;
}
function getVendorPrefixedName(property) {
    const name = camelize(property);
    if (memoized[name] == null) {
        const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
        memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
    }
    return memoized[name];
}

function setPrefixedStyle(style, name, value) {
    const vendor = getVendorPrefixedName(name);
    if (vendor != null) {
        style[vendor] = value;
    }
    style[name] = value;
}
function getComputedStyle$1(elem, name) {
    // IE9+
    const computed = elem.ownerDocument &&
        elem.ownerDocument.defaultView &&
        elem.ownerDocument.defaultView.opener
        ? elem.ownerDocument.defaultView.getComputedStyle(elem, null)
        : window.getComputedStyle(elem, null);
    if (computed && name) {
        return computed.getPropertyValue(name) || computed[name];
    }
    return computed;
}
function hasScrollbars(container) {
    const style = getComputedStyle$1(container);
    return (style != null && (style.overflow === 'scroll' || style.overflow === 'auto'));
}

const clearSelection = (function () {
    const doc = document;
    if (doc.selection) {
        return function () {
            doc.selection.empty();
        };
    }
    if (window.getSelection) {
        return function () {
            const selection = window.getSelection();
            if (selection) {
                if (selection.empty) {
                    selection.empty();
                }
                else if (selection.removeAllRanges) {
                    selection.removeAllRanges();
                }
            }
        };
    }
    return function () { };
})();

var Angle;
(function (Angle) {
    /**
     * Converts radian angle to degree angle.
     * @param rad The radians to convert.
     */
    function toDeg(rad) {
        return ((180 * rad) / Math.PI) % 360;
    }
    Angle.toDeg = toDeg;
    /**
     * Converts degree angle to radian angle.
     * @param deg The degree angle to convert.
     * @param over360
     */
    Angle.toRad = function (deg, over360 = false) {
        const d = over360 ? deg : deg % 360;
        return (d * Math.PI) / 180;
    };
    /**
     * Returns the angle in degrees and clamps its value between `0` and `360`.
     */
    function normalize(angle) {
        return (angle % 360) + (angle < 0 ? 360 : 0);
    }
    Angle.normalize = normalize;
})(Angle || (Angle = {}));

function round$1(num, precision = 0) {
    return Number.isInteger(num) ? num : +num.toFixed(precision);
}
function random(min, max) {
    let mmin;
    let mmax;
    if (max == null) {
        mmax = min == null ? 1 : min;
        mmin = 0;
    }
    else {
        mmax = max;
        mmin = min == null ? 0 : min;
    }
    if (mmax < mmin) {
        const temp = mmin;
        mmin = mmax;
        mmax = temp;
    }
    return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
}
function clamp(value, min, max) {
    if (Number.isNaN(value)) {
        return NaN;
    }
    if (Number.isNaN(min) || Number.isNaN(max)) {
        return 0;
    }
    return min < max
        ? value < min
            ? min
            : value > max
                ? max
                : value
        : value < max
            ? max
            : value > min
                ? min
                : value;
}
function snapToGrid(value, gridSize) {
    return gridSize * Math.round(value / gridSize);
}
function containsPoint(rect, point) {
    return (point != null &&
        rect != null &&
        point.x >= rect.x &&
        point.x <= rect.x + rect.width &&
        point.y >= rect.y &&
        point.y <= rect.y + rect.height);
}
function squaredLength(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
}

class Geometry {
    valueOf() {
        return this.toJSON();
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}

class Point extends Geometry {
    constructor(x, y) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
    }
    get [Symbol.toStringTag]() {
        return Point.toStringTag;
    }
    /**
     * Rounds the point to the given precision.
     */
    round(precision = 0) {
        this.x = round$1(this.x, precision);
        this.y = round$1(this.y, precision);
        return this;
    }
    add(x, y) {
        const p = Point.create(x, y);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    update(x, y) {
        const p = Point.create(x, y);
        this.x = p.x;
        this.y = p.y;
        return this;
    }
    translate(dx, dy) {
        const t = Point.create(dx, dy);
        this.x += t.x;
        this.y += t.y;
        return this;
    }
    /**
     * Rotate the point by `degree` around `center`.
     */
    rotate(degree, center) {
        const p = Point.rotate(this, degree, center);
        this.x = p.x;
        this.y = p.y;
        return this;
    }
    /**
     * Scale point by `sx` and `sy` around the given `origin`. If origin is not
     * specified, the point is scaled around `0,0`.
     */
    scale(sx, sy, origin = new Point()) {
        const ref = Point.create(origin);
        this.x = ref.x + sx * (this.x - ref.x);
        this.y = ref.y + sy * (this.y - ref.y);
        return this;
    }
    /**
     * Chooses the point closest to this point from among `points`. If `points`
     * is an empty array, `null` is returned.
     */
    closest(points) {
        if (points.length === 1) {
            return Point.create(points[0]);
        }
        let ret = null;
        let min = Infinity;
        points.forEach((p) => {
            const dist = this.squaredDistance(p);
            if (dist < min) {
                ret = p;
                min = dist;
            }
        });
        return ret ? Point.create(ret) : null;
    }
    /**
     * Returns the distance between the point and another point `p`.
     */
    distance(p) {
        return Math.sqrt(this.squaredDistance(p));
    }
    /**
     * Returns the squared distance between the point and another point `p`.
     *
     * Useful for distance comparisons in which real distance is not necessary
     * (saves one `Math.sqrt()` operation).
     */
    squaredDistance(p) {
        const ref = Point.create(p);
        const dx = this.x - ref.x;
        const dy = this.y - ref.y;
        return dx * dx + dy * dy;
    }
    manhattanDistance(p) {
        const ref = Point.create(p);
        return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);
    }
    /**
     * Returns the magnitude of the point vector.
     *
     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
     */
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
    }
    /**
     * Returns the angle(in degrees) between vector from this point to `p` and
     * the x-axis.
     */
    theta(p = new Point()) {
        const ref = Point.create(p);
        const y = -(ref.y - this.y); // invert the y-axis.
        const x = ref.x - this.x;
        let rad = Math.atan2(y, x);
        // Correction for III. and IV. quadrant.
        if (rad < 0) {
            rad = 2 * Math.PI + rad;
        }
        return (180 * rad) / Math.PI;
    }
    /**
     * Returns the angle(in degrees) between vector from this point to `p1` and
     * the vector from this point to `p2`.
     *
     * The ordering of points `p1` and `p2` is important.
     *
     * The function returns a value between `0` and `180` when the angle (in the
     * direction from `p1` to `p2`) is clockwise, and a value between `180` and
     * `360` when the angle is counterclockwise.
     *
     * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
     */
    angleBetween(p1, p2) {
        if (this.equals(p1) || this.equals(p2)) {
            return NaN;
        }
        let angle = this.theta(p2) - this.theta(p1);
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    }
    /**
     * Returns the angle(in degrees) between the line from `(0,0)` and this point
     * and the line from `(0,0)` to `p`.
     *
     * The function returns a value between `0` and `180` when the angle (in the
     * direction from this point to `p`) is clockwise, and a value between `180`
     * and `360` when the angle is counterclockwise. Returns `NaN` if called from
     * point `(0,0)` or if `p` is `(0,0)`.
     */
    vectorAngle(p) {
        const zero = new Point(0, 0);
        return zero.angleBetween(this, p);
    }
    /**
     * Converts rectangular to polar coordinates.
     */
    toPolar(origin) {
        this.update(Point.toPolar(this, origin));
        return this;
    }
    /**
     * Returns the change in angle(in degrees) that is the result of moving the
     * point from its previous position to its current position.
     *
     * More specifically, this function computes the angle between the line from
     * the ref point to the previous position of this point(i.e. current position
     * `-dx`, `-dy`) and the line from the `ref` point to the current position of
     * this point.
     *
     * The function returns a positive value between `0` and `180` when the angle
     * (in the direction from previous position of this point to its current
     * position) is clockwise, and a negative value between `0` and `-180` when
     * the angle is counterclockwise.
     *
     * The function returns `0` if the previous and current positions of this
     * point are the same (i.e. both `dx` and `dy` are `0`).
     */
    changeInAngle(dx, dy, ref = new Point()) {
        // Revert the translation and measure the change in angle around x-axis.
        return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);
    }
    /**
     * If the point lies outside the rectangle `rect`, adjust the point so that
     * it becomes the nearest point on the boundary of `rect`.
     */
    adhereToRect(rect) {
        if (!containsPoint(rect, this)) {
            this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);
            this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);
        }
        return this;
    }
    /**
     * Returns the bearing(cardinal direction) between me and the given point.
     *
     * @see https://en.wikipedia.org/wiki/Cardinal_direction
     */
    bearing(p) {
        const ref = Point.create(p);
        const lat1 = Angle.toRad(this.y);
        const lat2 = Angle.toRad(ref.y);
        const lon1 = this.x;
        const lon2 = ref.x;
        const dLon = Angle.toRad(lon2 - lon1);
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        const brng = Angle.toDeg(Math.atan2(y, x));
        const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
        let index = brng - 22.5;
        if (index < 0) {
            index += 360;
        }
        index = parseInt((index / 45), 10);
        return bearings[index];
    }
    /**
     * Returns the cross product of the vector from me to `p1` and the vector
     * from me to `p2`.
     *
     * The left-hand rule is used because the coordinate system is left-handed.
     */
    cross(p1, p2) {
        if (p1 != null && p2 != null) {
            const a = Point.create(p1);
            const b = Point.create(p2);
            return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
        }
        return NaN;
    }
    /**
     * Returns the dot product of this point with given other point.
     */
    dot(p) {
        const ref = Point.create(p);
        return this.x * ref.x + this.y * ref.y;
    }
    diff(dx, dy) {
        if (typeof dx === 'number') {
            return new Point(this.x - dx, this.y - dy);
        }
        const p = Point.create(dx);
        return new Point(this.x - p.x, this.y - p.y);
    }
    /**
     * Returns an interpolation between me and point `p` for a parametert in
     * the closed interval `[0, 1]`.
     */
    lerp(p, t) {
        const ref = Point.create(p);
        return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);
    }
    /**
     * Normalize the point vector, scale the line segment between `(0, 0)`
     * and the point in order for it to have the given length. If length is
     * not specified, it is considered to be `1`; in that case, a unit vector
     * is computed.
     */
    normalize(length = 1) {
        const scale = length / this.magnitude();
        return this.scale(scale, scale);
    }
    /**
     * Moves this point along the line starting from `ref` to this point by a
     * certain `distance`.
     */
    move(ref, distance) {
        const p = Point.create(ref);
        const rad = Angle.toRad(p.theta(this));
        return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
    }
    /**
     * Returns a point that is the reflection of me with the center of inversion
     * in `ref` point.
     */
    reflection(ref) {
        return Point.create(ref).move(this, this.distance(ref));
    }
    snapToGrid(gx, gy) {
        this.x = snapToGrid(this.x, gx);
        this.y = snapToGrid(this.y, gy == null ? gx : gy);
        return this;
    }
    equals(p) {
        const ref = Point.create(p);
        return ref != null && ref.x === this.x && ref.y === this.y;
    }
    clone() {
        return Point.clone(this);
    }
    /**
     * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
     */
    toJSON() {
        return Point.toJSON(this);
    }
    serialize() {
        return `${this.x} ${this.y}`;
    }
}
(function (Point) {
    Point.toStringTag = `X6.Geometry.${Point.name}`;
    function isPoint(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Point) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const point = instance;
        if ((tag == null || tag === Point.toStringTag) &&
            typeof point.x === 'number' &&
            typeof point.y === 'number' &&
            typeof point.toPolar === 'function') {
            return true;
        }
        return false;
    }
    Point.isPoint = isPoint;
})(Point || (Point = {}));
(function (Point) {
    function isPointLike(p) {
        return (p != null &&
            typeof p === 'object' &&
            typeof p.x === 'number' &&
            typeof p.y === 'number');
    }
    Point.isPointLike = isPointLike;
    function isPointData(p) {
        return (p != null &&
            Array.isArray(p) &&
            p.length === 2 &&
            typeof p[0] === 'number' &&
            typeof p[1] === 'number');
    }
    Point.isPointData = isPointData;
})(Point || (Point = {}));
(function (Point) {
    function create(x, y) {
        if (x == null || typeof x === 'number') {
            return new Point(x, y);
        }
        return clone(x);
    }
    Point.create = create;
    function clone(p) {
        if (Point.isPoint(p)) {
            return new Point(p.x, p.y);
        }
        if (Array.isArray(p)) {
            return new Point(p[0], p[1]);
        }
        return new Point(p.x, p.y);
    }
    Point.clone = clone;
    function toJSON(p) {
        if (Point.isPoint(p)) {
            return { x: p.x, y: p.y };
        }
        if (Array.isArray(p)) {
            return { x: p[0], y: p[1] };
        }
        return { x: p.x, y: p.y };
    }
    Point.toJSON = toJSON;
    /**
     * Returns a new Point object from the given polar coordinates.
     * @see http://en.wikipedia.org/wiki/Polar_coordinate_system
     */
    function fromPolar(r, rad, origin = new Point()) {
        let x = Math.abs(r * Math.cos(rad));
        let y = Math.abs(r * Math.sin(rad));
        const org = clone(origin);
        const deg = Angle.normalize(Angle.toDeg(rad));
        if (deg < 90) {
            y = -y;
        }
        else if (deg < 180) {
            x = -x;
            y = -y;
        }
        else if (deg < 270) {
            x = -x;
        }
        return new Point(org.x + x, org.y + y);
    }
    Point.fromPolar = fromPolar;
    /**
     * Converts rectangular to polar coordinates.
     */
    function toPolar(point, origin = new Point()) {
        const p = clone(point);
        const o = clone(origin);
        const dx = p.x - o.x;
        const dy = p.y - o.y;
        return new Point(Math.sqrt(dx * dx + dy * dy), // r
        Angle.toRad(o.theta(p)));
    }
    Point.toPolar = toPolar;
    function equals(p1, p2) {
        if (p1 === p2) {
            return true;
        }
        if (p1 != null && p2 != null) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        return false;
    }
    Point.equals = equals;
    function equalPoints(p1, p2) {
        if ((p1 == null && p2 != null) ||
            (p1 != null && p2 == null) ||
            (p1 != null && p2 != null && p1.length !== p2.length)) {
            return false;
        }
        if (p1 != null && p2 != null) {
            for (let i = 0, ii = p1.length; i < ii; i += 1) {
                if (!equals(p1[i], p2[i])) {
                    return false;
                }
            }
        }
        return true;
    }
    Point.equalPoints = equalPoints;
    /**
     * Returns a point with random coordinates that fall within the range
     * `[x1, x2]` and `[y1, y2]`.
     */
    function random$1(x1, x2, y1, y2) {
        return new Point(random(x1, x2), random(y1, y2));
    }
    Point.random = random$1;
    function rotate(point, angle, center) {
        const rad = Angle.toRad(Angle.normalize(-angle));
        const sin = Math.sin(rad);
        const cos = Math.cos(rad);
        return rotateEx(point, cos, sin, center);
    }
    Point.rotate = rotate;
    function rotateEx(point, cos, sin, center = new Point()) {
        const source = clone(point);
        const origin = clone(center);
        const dx = source.x - origin.x;
        const dy = source.y - origin.y;
        const x1 = dx * cos - dy * sin;
        const y1 = dy * cos + dx * sin;
        return new Point(x1 + origin.x, y1 + origin.y);
    }
    Point.rotateEx = rotateEx;
})(Point || (Point = {}));

class Rectangle extends Geometry {
    constructor(x, y, width, height) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
        this.width = width == null ? 0 : width;
        this.height = height == null ? 0 : height;
    }
    get [Symbol.toStringTag]() {
        return Rectangle.toStringTag;
    }
    get left() {
        return this.x;
    }
    get top() {
        return this.y;
    }
    get right() {
        return this.x + this.width;
    }
    get bottom() {
        return this.y + this.height;
    }
    get origin() {
        return new Point(this.x, this.y);
    }
    get topLeft() {
        return new Point(this.x, this.y);
    }
    get topCenter() {
        return new Point(this.x + this.width / 2, this.y);
    }
    get topRight() {
        return new Point(this.x + this.width, this.y);
    }
    get center() {
        return new Point(this.x + this.width / 2, this.y + this.height / 2);
    }
    get bottomLeft() {
        return new Point(this.x, this.y + this.height);
    }
    get bottomCenter() {
        return new Point(this.x + this.width / 2, this.y + this.height);
    }
    get bottomRight() {
        return new Point(this.x + this.width, this.y + this.height);
    }
    get corner() {
        return new Point(this.x + this.width, this.y + this.height);
    }
    get rightMiddle() {
        return new Point(this.x + this.width, this.y + this.height / 2);
    }
    get leftMiddle() {
        return new Point(this.x, this.y + this.height / 2);
    }
    get topLine() {
        return new Line(this.topLeft, this.topRight);
    }
    get rightLine() {
        return new Line(this.topRight, this.bottomRight);
    }
    get bottomLine() {
        return new Line(this.bottomLeft, this.bottomRight);
    }
    get leftLine() {
        return new Line(this.topLeft, this.bottomLeft);
    }
    getOrigin() {
        return this.origin;
    }
    getTopLeft() {
        return this.topLeft;
    }
    getTopCenter() {
        return this.topCenter;
    }
    getTopRight() {
        return this.topRight;
    }
    getCenter() {
        return this.center;
    }
    getCenterX() {
        return this.x + this.width / 2;
    }
    getCenterY() {
        return this.y + this.height / 2;
    }
    getBottomLeft() {
        return this.bottomLeft;
    }
    getBottomCenter() {
        return this.bottomCenter;
    }
    getBottomRight() {
        return this.bottomRight;
    }
    getCorner() {
        return this.corner;
    }
    getRightMiddle() {
        return this.rightMiddle;
    }
    getLeftMiddle() {
        return this.leftMiddle;
    }
    getTopLine() {
        return this.topLine;
    }
    getRightLine() {
        return this.rightLine;
    }
    getBottomLine() {
        return this.bottomLine;
    }
    getLeftLine() {
        return this.leftLine;
    }
    /**
     * Returns a rectangle that is the bounding box of the rectangle.
     *
     * If `angle` is specified, the bounding box calculation will take into
     * account the rotation of the rectangle by angle degrees around its center.
     */
    bbox(angle) {
        if (!angle) {
            return this.clone();
        }
        const rad = Angle.toRad(angle);
        const st = Math.abs(Math.sin(rad));
        const ct = Math.abs(Math.cos(rad));
        const w = this.width * ct + this.height * st;
        const h = this.width * st + this.height * ct;
        return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
    }
    round(precision = 0) {
        this.x = round$1(this.x, precision);
        this.y = round$1(this.y, precision);
        this.width = round$1(this.width, precision);
        this.height = round$1(this.height, precision);
        return this;
    }
    add(x, y, width, height) {
        const rect = Rectangle.create(x, y, width, height);
        const minX = Math.min(this.x, rect.x);
        const minY = Math.min(this.y, rect.y);
        const maxX = Math.max(this.x + this.width, rect.x + rect.width);
        const maxY = Math.max(this.y + this.height, rect.y + rect.height);
        this.x = minX;
        this.y = minY;
        this.width = maxX - minX;
        this.height = maxY - minY;
        return this;
    }
    update(x, y, width, height) {
        const rect = Rectangle.create(x, y, width, height);
        this.x = rect.x;
        this.y = rect.y;
        this.width = rect.width;
        this.height = rect.height;
        return this;
    }
    inflate(dx, dy) {
        const w = dx;
        const h = dy != null ? dy : dx;
        this.x -= w;
        this.y -= h;
        this.width += 2 * w;
        this.height += 2 * h;
        return this;
    }
    snapToGrid(gx, gy) {
        const origin = this.origin.snapToGrid(gx, gy);
        const corner = this.corner.snapToGrid(gx, gy);
        this.x = origin.x;
        this.y = origin.y;
        this.width = corner.x - origin.x;
        this.height = corner.y - origin.y;
        return this;
    }
    translate(tx, ty) {
        const p = Point.create(tx, ty);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    scale(sx, sy, origin = new Point()) {
        const pos = this.origin.scale(sx, sy, origin);
        this.x = pos.x;
        this.y = pos.y;
        this.width *= sx;
        this.height *= sy;
        return this;
    }
    rotate(degree, center = this.getCenter()) {
        if (degree !== 0) {
            const rad = Angle.toRad(degree);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            let p1 = this.getOrigin();
            let p2 = this.getTopRight();
            let p3 = this.getBottomRight();
            let p4 = this.getBottomLeft();
            p1 = Point.rotateEx(p1, cos, sin, center);
            p2 = Point.rotateEx(p2, cos, sin, center);
            p3 = Point.rotateEx(p3, cos, sin, center);
            p4 = Point.rotateEx(p4, cos, sin, center);
            const rect = new Rectangle(p1.x, p1.y, 0, 0);
            rect.add(p2.x, p2.y, 0, 0);
            rect.add(p3.x, p3.y, 0, 0);
            rect.add(p4.x, p4.y, 0, 0);
            this.update(rect);
        }
        return this;
    }
    rotate90() {
        const t = (this.width - this.height) / 2;
        this.x += t;
        this.y -= t;
        const tmp = this.width;
        this.width = this.height;
        this.height = tmp;
        return this;
    }
    /**
     * Translates the rectangle by `rect.x` and `rect.y` and expand it by
     * `rect.width` and `rect.height`.
     */
    moveAndExpand(rect) {
        const ref = Rectangle.clone(rect);
        this.x += ref.x || 0;
        this.y += ref.y || 0;
        this.width += ref.width || 0;
        this.height += ref.height || 0;
        return this;
    }
    /**
     * Returns an object where `sx` and `sy` give the maximum scaling that can be
     * applied to the rectangle so that it would still fit into `limit`. If
     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
     * scaled around its center.
     */
    getMaxScaleToFit(limit, origin = this.center) {
        const rect = Rectangle.clone(limit);
        const ox = origin.x;
        const oy = origin.y;
        // Find the maximal possible scale for all corners, so when the scale
        // is applied the point is still inside the rectangle.
        let sx1 = Infinity;
        let sx2 = Infinity;
        let sx3 = Infinity;
        let sx4 = Infinity;
        let sy1 = Infinity;
        let sy2 = Infinity;
        let sy3 = Infinity;
        let sy4 = Infinity;
        // Top Left
        const p1 = rect.topLeft;
        if (p1.x < ox) {
            sx1 = (this.x - ox) / (p1.x - ox);
        }
        if (p1.y < oy) {
            sy1 = (this.y - oy) / (p1.y - oy);
        }
        // Bottom Right
        const p2 = rect.bottomRight;
        if (p2.x > ox) {
            sx2 = (this.x + this.width - ox) / (p2.x - ox);
        }
        if (p2.y > oy) {
            sy2 = (this.y + this.height - oy) / (p2.y - oy);
        }
        // Top Right
        const p3 = rect.topRight;
        if (p3.x > ox) {
            sx3 = (this.x + this.width - ox) / (p3.x - ox);
        }
        if (p3.y < oy) {
            sy3 = (this.y - oy) / (p3.y - oy);
        }
        // Bottom Left
        const p4 = rect.bottomLeft;
        if (p4.x < ox) {
            sx4 = (this.x - ox) / (p4.x - ox);
        }
        if (p4.y > oy) {
            sy4 = (this.y + this.height - oy) / (p4.y - oy);
        }
        return {
            sx: Math.min(sx1, sx2, sx3, sx4),
            sy: Math.min(sy1, sy2, sy3, sy4),
        };
    }
    /**
     * Returns a number that specifies the maximum scaling that can be applied to
     * the rectangle along both axes so that it would still fit into `limit`. If
     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
     * scaled around its center.
     */
    getMaxUniformScaleToFit(limit, origin = this.center) {
        const scale = this.getMaxScaleToFit(limit, origin);
        return Math.min(scale.sx, scale.sy);
    }
    containsPoint(x, y) {
        return containsPoint(this, Point.create(x, y));
    }
    containsRect(x, y, width, height) {
        const b = Rectangle.create(x, y, width, height);
        const x1 = this.x;
        const y1 = this.y;
        const w1 = this.width;
        const h1 = this.height;
        const x2 = b.x;
        const y2 = b.y;
        const w2 = b.width;
        const h2 = b.height;
        // one of the dimensions is 0
        if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
            return false;
        }
        return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
    }
    /**
     * Returns an array of the intersection points of the rectangle and the line.
     * Return `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const rectLines = [
            this.topLine,
            this.rightLine,
            this.bottomLine,
            this.leftLine,
        ];
        const points = [];
        const dedupeArr = [];
        rectLines.forEach((l) => {
            const p = line.intersectsWithLine(l);
            if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
                points.push(p);
                dedupeArr.push(p.toString());
            }
        });
        return points.length > 0 ? points : null;
    }
    /**
     * Returns the point on the boundary of the rectangle that is the intersection
     * of the rectangle with a line starting in the center the rectangle ending in
     * the point `p`.
     *
     * If `angle` is specified, the intersection will take into account the
     * rotation of the rectangle by `angle` degrees around its center.
     */
    intersectsWithLineFromCenterToPoint(p, angle) {
        const ref = Point.clone(p);
        const center = this.center;
        let result = null;
        if (angle != null && angle !== 0) {
            ref.rotate(angle, center);
        }
        const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
        const connector = new Line(center, ref);
        for (let i = sides.length - 1; i >= 0; i -= 1) {
            const intersection = sides[i].intersectsWithLine(connector);
            if (intersection !== null) {
                result = intersection;
                break;
            }
        }
        if (result && angle != null && angle !== 0) {
            result.rotate(-angle, center);
        }
        return result;
    }
    intersectsWithRect(x, y, width, height) {
        const ref = Rectangle.create(x, y, width, height);
        // no intersection
        if (!this.isIntersectWithRect(ref)) {
            return null;
        }
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        const xx = Math.max(myOrigin.x, rOrigin.x);
        const yy = Math.max(myOrigin.y, rOrigin.y);
        return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
    }
    isIntersectWithRect(x, y, width, height) {
        const ref = Rectangle.create(x, y, width, height);
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        if (rCorner.x <= myOrigin.x ||
            rCorner.y <= myOrigin.y ||
            rOrigin.x >= myCorner.x ||
            rOrigin.y >= myCorner.y) {
            return false;
        }
        return true;
    }
    /**
     * Normalize the rectangle, i.e. make it so that it has non-negative
     * width and height. If width is less than `0`, the function swaps left and
     * right corners and if height is less than `0`, the top and bottom corners
     * are swapped.
     */
    normalize() {
        let newx = this.x;
        let newy = this.y;
        let newwidth = this.width;
        let newheight = this.height;
        if (this.width < 0) {
            newx = this.x + this.width;
            newwidth = -this.width;
        }
        if (this.height < 0) {
            newy = this.y + this.height;
            newheight = -this.height;
        }
        this.x = newx;
        this.y = newy;
        this.width = newwidth;
        this.height = newheight;
        return this;
    }
    /**
     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
     */
    union(rect) {
        const ref = Rectangle.clone(rect);
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        const originX = Math.min(myOrigin.x, rOrigin.x);
        const originY = Math.min(myOrigin.y, rOrigin.y);
        const cornerX = Math.max(myCorner.x, rCorner.x);
        const cornerY = Math.max(myCorner.y, rCorner.y);
        return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);
    }
    /**
     * Returns a string ("top", "left", "right" or "bottom") denoting the side of
     * the rectangle which is nearest to the point `p`.
     */
    getNearestSideToPoint(p) {
        const ref = Point.clone(p);
        const distLeft = ref.x - this.x;
        const distRight = this.x + this.width - ref.x;
        const distTop = ref.y - this.y;
        const distBottom = this.y + this.height - ref.y;
        let closest = distLeft;
        let side = 'left';
        if (distRight < closest) {
            closest = distRight;
            side = 'right';
        }
        if (distTop < closest) {
            closest = distTop;
            side = 'top';
        }
        if (distBottom < closest) {
            side = 'bottom';
        }
        return side;
    }
    /**
     * Returns a point on the boundary of the rectangle nearest to the point `p`.
     */
    getNearestPointToPoint(p) {
        const ref = Point.clone(p);
        if (this.containsPoint(ref)) {
            const side = this.getNearestSideToPoint(ref);
            switch (side) {
                case 'right':
                    return new Point(this.x + this.width, ref.y);
                case 'left':
                    return new Point(this.x, ref.y);
                case 'bottom':
                    return new Point(ref.x, this.y + this.height);
                case 'top':
                    return new Point(ref.x, this.y);
                default:
                    break;
            }
        }
        return ref.adhereToRect(this);
    }
    equals(rect) {
        return (rect != null &&
            rect.x === this.x &&
            rect.y === this.y &&
            rect.width === this.width &&
            rect.height === this.height);
    }
    clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
    toJSON() {
        return { x: this.x, y: this.y, width: this.width, height: this.height };
    }
    serialize() {
        return `${this.x} ${this.y} ${this.width} ${this.height}`;
    }
}
(function (Rectangle) {
    Rectangle.toStringTag = `X6.Geometry.${Rectangle.name}`;
    function isRectangle(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Rectangle) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const rect = instance;
        if ((tag == null || tag === Rectangle.toStringTag) &&
            typeof rect.x === 'number' &&
            typeof rect.y === 'number' &&
            typeof rect.width === 'number' &&
            typeof rect.height === 'number' &&
            typeof rect.inflate === 'function' &&
            typeof rect.moveAndExpand === 'function') {
            return true;
        }
        return false;
    }
    Rectangle.isRectangle = isRectangle;
})(Rectangle || (Rectangle = {}));
(function (Rectangle) {
    function isRectangleLike(o) {
        return (o != null &&
            typeof o === 'object' &&
            typeof o.x === 'number' &&
            typeof o.y === 'number' &&
            typeof o.width === 'number' &&
            typeof o.height === 'number');
    }
    Rectangle.isRectangleLike = isRectangleLike;
})(Rectangle || (Rectangle = {}));
(function (Rectangle) {
    function create(x, y, width, height) {
        if (x == null || typeof x === 'number') {
            return new Rectangle(x, y, width, height);
        }
        return clone(x);
    }
    Rectangle.create = create;
    function clone(rect) {
        if (Rectangle.isRectangle(rect)) {
            return rect.clone();
        }
        if (Array.isArray(rect)) {
            return new Rectangle(rect[0], rect[1], rect[2], rect[3]);
        }
        return new Rectangle(rect.x, rect.y, rect.width, rect.height);
    }
    Rectangle.clone = clone;
    function fromSize(size) {
        return new Rectangle(0, 0, size.width, size.height);
    }
    Rectangle.fromSize = fromSize;
    function fromPositionAndSize(pos, size) {
        return new Rectangle(pos.x, pos.y, size.width, size.height);
    }
    Rectangle.fromPositionAndSize = fromPositionAndSize;
    /**
     * Returns a new rectangle from the given ellipse.
     */
    function fromEllipse(ellipse) {
        return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);
    }
    Rectangle.fromEllipse = fromEllipse;
})(Rectangle || (Rectangle = {}));

class Line extends Geometry {
    constructor(x1, y1, x2, y2) {
        super();
        if (typeof x1 === 'number' && typeof y1 === 'number') {
            this.start = new Point(x1, y1);
            this.end = new Point(x2, y2);
        }
        else {
            this.start = Point.create(x1);
            this.end = Point.create(y1);
        }
    }
    get [Symbol.toStringTag]() {
        return Line.toStringTag;
    }
    get center() {
        return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
    }
    getCenter() {
        return this.center;
    }
    /**
     * Rounds the line to the given `precision`.
     */
    round(precision = 0) {
        this.start.round(precision);
        this.end.round(precision);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.start.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.start.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    /**
     * Rotate the line by `angle` around `origin`.
     */
    rotate(angle, origin) {
        this.start.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    /**
     * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
     * specified, the line is scaled around `0,0`.
     */
    scale(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    /**
     * Returns the length of the line.
     */
    length() {
        return Math.sqrt(this.squaredLength());
    }
    /**
     * Useful for distance comparisons in which real length is not necessary
     * (saves one `Math.sqrt()` operation).
     */
    squaredLength() {
        const dx = this.start.x - this.end.x;
        const dy = this.start.y - this.end.y;
        return dx * dx + dy * dy;
    }
    /**
     * Scale the line so that it has the requested length. The start point of
     * the line is preserved.
     */
    setLength(length) {
        const total = this.length();
        if (!total) {
            return this;
        }
        const scale = length / total;
        return this.scale(scale, scale, this.start);
    }
    parallel(distance) {
        const line = this.clone();
        if (!line.isDifferentiable()) {
            return line;
        }
        const { start, end } = line;
        const eRef = start.clone().rotate(270, end);
        const sRef = end.clone().rotate(90, start);
        start.move(sRef, distance);
        end.move(eRef, distance);
        return line;
    }
    /**
     * Returns the vector of the line with length equal to length of the line.
     */
    vector() {
        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);
    }
    /**
     * Returns the angle of incline of the line.
     *
     * The function returns `NaN` if the start and end endpoints of the line
     * both lie at the same coordinates(it is impossible to determine the angle
     * of incline of a line that appears to be a point). The
     * `line.isDifferentiable()` function may be used in advance to determine
     * whether the angle of incline can be computed for a given line.
     */
    angle() {
        const horizontal = new Point(this.start.x + 1, this.start.y);
        return this.start.angleBetween(this.end, horizontal);
    }
    /**
     * Returns a rectangle that is the bounding box of the line.
     */
    bbox() {
        const left = Math.min(this.start.x, this.end.x);
        const top = Math.min(this.start.y, this.end.y);
        const right = Math.max(this.start.x, this.end.x);
        const bottom = Math.max(this.start.y, this.end.y);
        return new Rectangle(left, top, right - left, bottom - top);
    }
    /**
     * Returns the bearing (cardinal direction) of the line.
     *
     * The return value is one of the following strings:
     * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
     *
     * The function returns 'N' if the two endpoints of the line are coincident.
     */
    bearing() {
        return this.start.bearing(this.end);
    }
    /**
     * Returns the point on the line that lies closest to point `p`.
     */
    closestPoint(p) {
        return this.pointAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the length of the line up to the point that lies closest to point `p`.
     */
    closestPointLength(p) {
        return this.closestPointNormalizedLength(p) * this.length();
    }
    /**
     * Returns a line that is tangent to the line at the point that lies closest
     * to point `p`.
     */
    closestPointTangent(p) {
        return this.tangentAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the normalized length (distance from the start of the line / total
     * line length) of the line up to the point that lies closest to point.
     */
    closestPointNormalizedLength(p) {
        const product = this.vector().dot(new Line(this.start, p).vector());
        const normalized = Math.min(1, Math.max(0, product / this.squaredLength()));
        // normalized returns `NaN` if this line has zero length
        if (Number.isNaN(normalized)) {
            return 0;
        }
        return normalized;
    }
    /**
     * Returns a point on the line that lies `rate` (normalized length) away from
     * the beginning of the line.
     */
    pointAt(ratio) {
        const start = this.start;
        const end = this.end;
        if (ratio <= 0) {
            return start.clone();
        }
        if (ratio >= 1) {
            return end.clone();
        }
        return start.lerp(end, ratio);
    }
    /**
     * Returns a point on the line that lies length away from the beginning of
     * the line.
     */
    pointAtLength(length) {
        const start = this.start;
        const end = this.end;
        let fromStart = true;
        if (length < 0) {
            fromStart = false; // start calculation from end point
            length = -length; // eslint-disable-line
        }
        const total = this.length();
        if (length >= total) {
            return fromStart ? end.clone() : start.clone();
        }
        const rate = (fromStart ? length : total - length) / total;
        return this.pointAt(rate);
    }
    /**
     * Divides the line into two lines at the point that lies `rate` (normalized
     * length) away from the beginning of the line.
     */
    divideAt(ratio) {
        const dividerPoint = this.pointAt(ratio);
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end),
        ];
    }
    /**
     * Divides the line into two lines at the point that lies length away from
     * the beginning of the line.
     */
    divideAtLength(length) {
        const dividerPoint = this.pointAtLength(length);
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end),
        ];
    }
    /**
     * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
     */
    containsPoint(p) {
        const start = this.start;
        const end = this.end;
        // cross product of 0 indicates that this line and
        // the vector to `p` are collinear.
        if (start.cross(p, end) !== 0) {
            return false;
        }
        const length = this.length();
        if (new Line(start, p).length() > length) {
            return false;
        }
        if (new Line(p, end).length() > length) {
            return false;
        }
        return true;
    }
    intersect(shape, options) {
        const ret = shape.intersectsWithLine(this, options);
        if (ret) {
            return Array.isArray(ret) ? ret : [ret];
        }
        return null;
    }
    /**
     * Returns the intersection point of the line with another line. Returns
     * `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);
        const pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);
        const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
        const deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);
        const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
        const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
        if (det === 0 || alpha * det < 0 || beta * det < 0) {
            return null;
        }
        if (det > 0) {
            if (alpha > det || beta > det) {
                return null;
            }
        }
        else if (alpha < det || beta < det) {
            return null;
        }
        return new Point(this.start.x + (alpha * pt1Dir.x) / det, this.start.y + (alpha * pt1Dir.y) / det);
    }
    /**
     * Returns `true` if a tangent line can be found for the line.
     *
     * Tangents cannot be found if both of the line endpoints are coincident
     * (the line appears to be a point).
     */
    isDifferentiable() {
        return !this.start.equals(this.end);
    }
    /**
     * Returns the perpendicular distance between the line and point. The
     * distance is positive if the point lies to the right of the line, negative
     * if the point lies to the left of the line, and `0` if the point lies on
     * the line.
     */
    pointOffset(p) {
        const ref = Point.clone(p);
        const start = this.start;
        const end = this.end;
        const determinant = (end.x - start.x) * (ref.y - start.y) -
            (end.y - start.y) * (ref.x - start.x);
        return determinant / this.length();
    }
    pointSquaredDistance(x, y) {
        const p = Point.create(x, y);
        return this.closestPoint(p).squaredDistance(p);
    }
    pointDistance(x, y) {
        const p = Point.create(x, y);
        return this.closestPoint(p).distance(p);
    }
    /**
     * Returns a line tangent to the line at point that lies `rate` (normalized
     * length) away from the beginning of the line.
     */
    tangentAt(ratio) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const start = this.start;
        const end = this.end;
        const tangentStart = this.pointAt(ratio);
        const tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
        return tangentLine;
    }
    /**
     * Returns a line tangent to the line at point that lies `length` away from
     * the beginning of the line.
     */
    tangentAtLength(length) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const start = this.start;
        const end = this.end;
        const tangentStart = this.pointAtLength(length);
        const tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
        return tangentLine;
    }
    relativeCcw(x, y) {
        const ref = Point.create(x, y);
        let dx1 = ref.x - this.start.x;
        let dy1 = ref.y - this.start.y;
        const dx2 = this.end.x - this.start.x;
        const dy2 = this.end.y - this.start.y;
        let ccw = dx1 * dy2 - dy1 * dx2;
        if (ccw === 0) {
            ccw = dx1 * dx2 + dy1 * dy2;
            if (ccw > 0.0) {
                dx1 -= dx2;
                dy1 -= dy2;
                ccw = dx1 * dx2 + dy1 * dy2;
                if (ccw < 0.0) {
                    ccw = 0.0;
                }
            }
        }
        return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;
    }
    /**
     * Return `true` if the line equals the other line.
     */
    equals(l) {
        return (l != null &&
            this.start.x === l.start.x &&
            this.start.y === l.start.y &&
            this.end.x === l.end.x &&
            this.end.y === l.end.y);
    }
    /**
     * Returns another line which is a clone of the line.
     */
    clone() {
        return new Line(this.start, this.end);
    }
    toJSON() {
        return { start: this.start.toJSON(), end: this.end.toJSON() };
    }
    serialize() {
        return [this.start.serialize(), this.end.serialize()].join(' ');
    }
}
(function (Line) {
    Line.toStringTag = `X6.Geometry.${Line.name}`;
    function isLine(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Line) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const line = instance;
        try {
            if ((tag == null || tag === Line.toStringTag) &&
                Point.isPoint(line.start) &&
                Point.isPoint(line.end) &&
                typeof line.vector === 'function' &&
                typeof line.bearing === 'function' &&
                typeof line.parallel === 'function' &&
                typeof line.intersect === 'function') {
                return true;
            }
        }
        catch (e) {
            return false;
        }
        return false;
    }
    Line.isLine = isLine;
})(Line || (Line = {}));

let Ellipse$2 = class Ellipse extends Geometry {
    constructor(x, y, a, b) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
        this.a = a == null ? 0 : a;
        this.b = b == null ? 0 : b;
    }
    get [Symbol.toStringTag]() {
        return Ellipse.toStringTag;
    }
    get center() {
        return new Point(this.x, this.y);
    }
    /**
     * Returns a rectangle that is the bounding box of the ellipse.
     */
    bbox() {
        return Rectangle.fromEllipse(this);
    }
    /**
     * Returns a point that is the center of the ellipse.
     */
    getCenter() {
        return this.center;
    }
    inflate(dx, dy) {
        const w = dx;
        const h = dy != null ? dy : dx;
        this.a += 2 * w;
        this.b += 2 * h;
        return this;
    }
    normalizedDistance(x, y) {
        const ref = Point.create(x, y);
        const dx = ref.x - this.x;
        const dy = ref.y - this.y;
        const a = this.a;
        const b = this.b;
        return (dx * dx) / (a * a) + (dy * dy) / (b * b);
    }
    containsPoint(x, y) {
        return this.normalizedDistance(x, y) <= 1;
    }
    /**
     * Returns an array of the intersection points of the ellipse and the line.
     * Returns `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const intersections = [];
        const rx = this.a;
        const ry = this.b;
        const a1 = line.start;
        const a2 = line.end;
        const dir = line.vector();
        const diff = a1.diff(new Point(this.x, this.y));
        const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));
        const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));
        const a = dir.dot(mDir);
        const b = dir.dot(mDiff);
        const c = diff.dot(mDiff) - 1.0;
        const d = b * b - a * c;
        if (d < 0) {
            return null;
        }
        if (d > 0) {
            const root = Math.sqrt(d);
            const ta = (-b - root) / a;
            const tb = (-b + root) / a;
            if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {
                // outside
                return null;
            }
            if (ta >= 0 && ta <= 1) {
                intersections.push(a1.lerp(a2, ta));
            }
            if (tb >= 0 && tb <= 1) {
                intersections.push(a1.lerp(a2, tb));
            }
        }
        else {
            const t = -b / a;
            if (t >= 0 && t <= 1) {
                intersections.push(a1.lerp(a2, t));
            }
            else {
                // outside
                return null;
            }
        }
        return intersections;
    }
    /**
     * Returns the point on the boundary of the ellipse that is the
     * intersection of the ellipse with a line starting in the center
     * of the ellipse ending in the point `p`.
     *
     * If angle is specified, the intersection will take into account
     * the rotation of the ellipse by angle degrees around its center.
     */
    intersectsWithLineFromCenterToPoint(p, angle = 0) {
        const ref = Point.clone(p);
        if (angle) {
            ref.rotate(angle, this.getCenter());
        }
        const dx = ref.x - this.x;
        const dy = ref.y - this.y;
        let result;
        if (dx === 0) {
            result = this.bbox().getNearestPointToPoint(ref);
            if (angle) {
                return result.rotate(-angle, this.getCenter());
            }
            return result;
        }
        const m = dy / dx;
        const mSquared = m * m;
        const aSquared = this.a * this.a;
        const bSquared = this.b * this.b;
        let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
        x = dx < 0 ? -x : x;
        const y = m * x;
        result = new Point(this.x + x, this.y + y);
        if (angle) {
            return result.rotate(-angle, this.getCenter());
        }
        return result;
    }
    /**
     * Returns the angle between the x-axis and the tangent from a point. It is
     * valid for points lying on the ellipse boundary only.
     */
    tangentTheta(p) {
        const ref = Point.clone(p);
        const x0 = ref.x;
        const y0 = ref.y;
        const a = this.a;
        const b = this.b;
        const center = this.bbox().center;
        const cx = center.x;
        const cy = center.y;
        const refPointDelta = 30;
        const q1 = x0 > center.x + a / 2;
        const q3 = x0 < center.x - a / 2;
        let x;
        let y;
        if (q1 || q3) {
            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
            x =
                (a * a) / (x0 - cx) -
                    (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +
                    cx;
        }
        else {
            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
            y =
                (b * b) / (y0 - cy) -
                    (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +
                    cy;
        }
        return new Point(x, y).theta(ref);
    }
    scale(sx, sy) {
        this.a *= sx;
        this.b *= sy;
        return this;
    }
    rotate(angle, origin) {
        const rect = Rectangle.fromEllipse(this);
        rect.rotate(angle, origin);
        const ellipse = Ellipse.fromRect(rect);
        this.a = ellipse.a;
        this.b = ellipse.b;
        this.x = ellipse.x;
        this.y = ellipse.y;
        return this;
    }
    translate(dx, dy) {
        const p = Point.create(dx, dy);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    equals(ellipse) {
        return (ellipse != null &&
            ellipse.x === this.x &&
            ellipse.y === this.y &&
            ellipse.a === this.a &&
            ellipse.b === this.b);
    }
    clone() {
        return new Ellipse(this.x, this.y, this.a, this.b);
    }
    toJSON() {
        return { x: this.x, y: this.y, a: this.a, b: this.b };
    }
    serialize() {
        return `${this.x} ${this.y} ${this.a} ${this.b}`;
    }
};
(function (Ellipse) {
    Ellipse.toStringTag = `X6.Geometry.${Ellipse.name}`;
    function isEllipse(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Ellipse) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const ellipse = instance;
        if ((tag == null || tag === Ellipse.toStringTag) &&
            typeof ellipse.x === 'number' &&
            typeof ellipse.y === 'number' &&
            typeof ellipse.a === 'number' &&
            typeof ellipse.b === 'number' &&
            typeof ellipse.inflate === 'function' &&
            typeof ellipse.normalizedDistance === 'function') {
            return true;
        }
        return false;
    }
    Ellipse.isEllipse = isEllipse;
})(Ellipse$2 || (Ellipse$2 = {}));
(function (Ellipse) {
    function create(x, y, a, b) {
        if (x == null || typeof x === 'number') {
            return new Ellipse(x, y, a, b);
        }
        return parse(x);
    }
    Ellipse.create = create;
    function parse(e) {
        if (Ellipse.isEllipse(e)) {
            return e.clone();
        }
        if (Array.isArray(e)) {
            return new Ellipse(e[0], e[1], e[2], e[3]);
        }
        return new Ellipse(e.x, e.y, e.a, e.b);
    }
    Ellipse.parse = parse;
    function fromRect(rect) {
        const center = rect.center;
        return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);
    }
    Ellipse.fromRect = fromRect;
})(Ellipse$2 || (Ellipse$2 = {}));

let Polyline$2 = class Polyline extends Geometry {
    constructor(points) {
        super();
        if (points != null) {
            if (typeof points === 'string') {
                return Polyline.parse(points);
            }
            this.points = points.map((p) => Point.create(p));
        }
        else {
            this.points = [];
        }
    }
    get [Symbol.toStringTag]() {
        return Polyline.toStringTag;
    }
    get start() {
        if (this.points.length === 0) {
            return null;
        }
        return this.points[0];
    }
    get end() {
        if (this.points.length === 0) {
            return null;
        }
        return this.points[this.points.length - 1];
    }
    scale(sx, sy, origin = new Point()) {
        this.points.forEach((p) => p.scale(sx, sy, origin));
        return this;
    }
    rotate(angle, origin) {
        this.points.forEach((p) => p.rotate(angle, origin));
        return this;
    }
    translate(dx, dy) {
        const t = Point.create(dx, dy);
        this.points.forEach((p) => p.translate(t.x, t.y));
        return this;
    }
    bbox() {
        if (this.points.length === 0) {
            return new Rectangle();
        }
        let x1 = Infinity;
        let x2 = -Infinity;
        let y1 = Infinity;
        let y2 = -Infinity;
        const points = this.points;
        for (let i = 0, ii = points.length; i < ii; i += 1) {
            const point = points[i];
            const x = point.x;
            const y = point.y;
            if (x < x1)
                x1 = x;
            if (x > x2)
                x2 = x;
            if (y < y1)
                y1 = y;
            if (y > y2)
                y2 = y;
        }
        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    }
    closestPoint(p) {
        const cpLength = this.closestPointLength(p);
        return this.pointAtLength(cpLength);
    }
    closestPointLength(p) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return 0;
        }
        let length = 0;
        let cpLength = 0;
        let minSqrDistance = Infinity;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const line = new Line(points[i], points[i + 1]);
            const lineLength = line.length();
            const cpNormalizedLength = line.closestPointNormalizedLength(p);
            const cp = line.pointAt(cpNormalizedLength);
            const sqrDistance = cp.squaredDistance(p);
            if (sqrDistance < minSqrDistance) {
                minSqrDistance = sqrDistance;
                cpLength = length + cpNormalizedLength * lineLength;
            }
            length += lineLength;
        }
        return cpLength;
    }
    closestPointNormalizedLength(p) {
        const cpLength = this.closestPointLength(p);
        if (cpLength === 0) {
            return 0;
        }
        const length = this.length();
        if (length === 0) {
            return 0;
        }
        return cpLength / length;
    }
    closestPointTangent(p) {
        const cpLength = this.closestPointLength(p);
        return this.tangentAtLength(cpLength);
    }
    containsPoint(p) {
        if (this.points.length === 0) {
            return false;
        }
        const ref = Point.clone(p);
        const x = ref.x;
        const y = ref.y;
        const points = this.points;
        const count = points.length;
        let startIndex = count - 1;
        let intersectionCount = 0;
        for (let endIndex = 0; endIndex < count; endIndex += 1) {
            const start = points[startIndex];
            const end = points[endIndex];
            if (ref.equals(start)) {
                return true;
            }
            const segment = new Line(start, end);
            if (segment.containsPoint(p)) {
                return true;
            }
            // do we have an intersection?
            if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {
                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
                // (when `y === start.y === end.y`)
                // this conditional branch IS entered when `segment` touches `ray` at only one point
                // (e.g. when `y === start.y !== end.y`)
                // since this branch is entered again for the following segment, the two touches cancel out
                const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
                if (xDifference >= 0) {
                    // segment lies at least partially to the right of `p`
                    const rayEnd = new Point(x + xDifference, y); // right
                    const ray = new Line(p, rayEnd);
                    if (segment.intersectsWithLine(ray)) {
                        // an intersection was detected to the right of `p`
                        intersectionCount += 1;
                    }
                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)
            }
            // move to check the next polyline segment
            startIndex = endIndex;
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return intersectionCount % 2 === 1;
    }
    intersectsWithLine(line) {
        const intersections = [];
        for (let i = 0, n = this.points.length - 1; i < n; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            const int = line.intersectsWithLine(new Line(a, b));
            if (int) {
                intersections.push(int);
            }
        }
        return intersections.length > 0 ? intersections : null;
    }
    isDifferentiable() {
        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            const line = new Line(a, b);
            if (line.isDifferentiable()) {
                return true;
            }
        }
        return false;
    }
    length() {
        let len = 0;
        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            len += a.distance(b);
        }
        return len;
    }
    pointAt(ratio) {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return null;
        }
        if (count === 1) {
            return points[0].clone();
        }
        if (ratio <= 0) {
            return points[0].clone();
        }
        if (ratio >= 1) {
            return points[count - 1].clone();
        }
        const total = this.length();
        const length = total * ratio;
        return this.pointAtLength(length);
    }
    pointAtLength(length) {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return null;
        }
        if (count === 1) {
            return points[0].clone();
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        let tmp = 0;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const a = points[index];
            const b = points[index + 1];
            const l = new Line(a, b);
            const d = a.distance(b);
            if (length <= tmp + d) {
                return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));
            }
            tmp += d;
        }
        const lastPoint = fromStart ? points[count - 1] : points[0];
        return lastPoint.clone();
    }
    tangentAt(ratio) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return null;
        }
        if (ratio < 0) {
            ratio = 0; // eslint-disable-line
        }
        if (ratio > 1) {
            ratio = 1; // eslint-disable-line
        }
        const total = this.length();
        const length = total * ratio;
        return this.tangentAtLength(length);
    }
    tangentAtLength(length) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        let lastValidLine;
        let tmp = 0;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const a = points[index];
            const b = points[index + 1];
            const l = new Line(a, b);
            const d = a.distance(b);
            if (l.isDifferentiable()) {
                // has a tangent line (line length is not 0)
                if (length <= tmp + d) {
                    return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));
                }
                lastValidLine = l;
            }
            tmp += d;
        }
        if (lastValidLine) {
            const ratio = fromStart ? 1 : 0;
            return lastValidLine.tangentAt(ratio);
        }
        return null;
    }
    simplify(
    // TODO: Accept startIndex and endIndex to specify where to start and end simplification
    options = {}) {
        const points = this.points;
        // we need at least 3 points
        if (points.length < 3) {
            return this;
        }
        const threshold = options.threshold || 0;
        // start at the beginning of the polyline and go forward
        let currentIndex = 0;
        // we need at least one intermediate point (3 points) in every iteration
        // as soon as that stops being true, we know we reached the end of the polyline
        while (points[currentIndex + 2]) {
            const firstIndex = currentIndex;
            const middleIndex = currentIndex + 1;
            const lastIndex = currentIndex + 2;
            const firstPoint = points[firstIndex];
            const middlePoint = points[middleIndex];
            const lastPoint = points[lastIndex];
            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point
            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point
            const closestPointDistance = closestPoint.distance(middlePoint);
            if (closestPointDistance <= threshold) {
                // middle point is close enough to the chord = simplify
                // 1) remove middle point:
                points.splice(middleIndex, 1);
                // 2) in next iteration, investigate the newly-created triplet of points
                //    - do not change `currentIndex`
                //    = (first point stays, point after removed point becomes middle point)
            }
            else {
                // middle point is far from the chord
                // 1) preserve middle point
                // 2) in next iteration, move `currentIndex` by one step:
                currentIndex += 1;
                //    = (point after first point becomes first point)
            }
        }
        // `points` array was modified in-place
        return this;
    }
    toHull() {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return new Polyline();
        }
        // Step 1: find the starting point -- point with
        // the lowest y (if equality, highest x).
        let startPoint = points[0];
        for (let i = 1; i < count; i += 1) {
            if (points[i].y < startPoint.y) {
                startPoint = points[i];
            }
            else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
                startPoint = points[i];
            }
        }
        // Step 2: sort the list of points by angle between line
        // from start point to current point and the x-axis (theta).
        // Step 2a: create the point records = [point, originalIndex, angle]
        const sortedRecords = [];
        for (let i = 0; i < count; i += 1) {
            let angle = startPoint.theta(points[i]);
            if (angle === 0) {
                // Give highest angle to start point.
                // The start point will end up at end of sorted list.
                // The start point will end up at beginning of hull points list.
                angle = 360;
            }
            sortedRecords.push([points[i], i, angle]);
        }
        // Step 2b: sort the list in place
        sortedRecords.sort((record1, record2) => {
            let ret = record1[2] - record2[2];
            if (ret === 0) {
                ret = record2[1] - record1[1];
            }
            return ret;
        });
        // Step 2c: duplicate start record from the top of
        // the stack to the bottom of the stack.
        if (sortedRecords.length > 2) {
            const startPoint = sortedRecords[sortedRecords.length - 1];
            sortedRecords.unshift(startPoint);
        }
        // Step 3
        // ------
        // Step 3a: go through sorted points in order and find those with
        // right turns, and we want to get our results in clockwise order.
        // Dictionary of points with left turns - cannot be on the hull.
        const insidePoints = {};
        // Stack of records with right turns - hull point candidates.
        const hullRecords = [];
        const getKey = (record) => `${record[0].toString()}@${record[1]}`;
        while (sortedRecords.length !== 0) {
            const currentRecord = sortedRecords.pop();
            const currentPoint = currentRecord[0];
            // Check if point has already been discarded.
            if (insidePoints[getKey(currentRecord)]) {
                continue;
            }
            let correctTurnFound = false;
            while (!correctTurnFound) {
                if (hullRecords.length < 2) {
                    // Not enough points for comparison, just add current point.
                    hullRecords.push(currentRecord);
                    correctTurnFound = true;
                }
                else {
                    const lastHullRecord = hullRecords.pop();
                    const lastHullPoint = lastHullRecord[0];
                    const secondLastHullRecord = hullRecords.pop();
                    const secondLastHullPoint = secondLastHullRecord[0];
                    const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
                    if (crossProduct < 0) {
                        // Found a right turn.
                        hullRecords.push(secondLastHullRecord);
                        hullRecords.push(lastHullRecord);
                        hullRecords.push(currentRecord);
                        correctTurnFound = true;
                    }
                    else if (crossProduct === 0) {
                        // the three points are collinear
                        // three options:
                        // there may be a 180 or 0 degree angle at lastHullPoint
                        // or two of the three points are coincident
                        // we have to take rounding errors into account
                        const THRESHOLD = 1e-10;
                        const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
                        if (Math.abs(angleBetween - 180) < THRESHOLD) {
                            // rouding around 180 to 180
                            // if the cross product is 0 because the angle is 180 degrees
                            // discard last hull point (add to insidePoints)
                            // insidePoints.unshift(lastHullPoint);
                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // do not do anything with current point
                            // correct turn not found
                        }
                        else if (lastHullPoint.equals(currentPoint) ||
                            secondLastHullPoint.equals(lastHullPoint)) {
                            // if the cross product is 0 because two points are the same
                            // discard last hull point (add to insidePoints)
                            // insidePoints.unshift(lastHullPoint);
                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // do not do anything with current point
                            // correct turn not found
                        }
                        else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {
                            // rounding around 0 and 360 to 0
                            // if the cross product is 0 because the angle is 0 degrees
                            // remove last hull point from hull BUT do not discard it
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // put last hull point back into the sorted point records list
                            sortedRecords.push(lastHullRecord);
                            // we are switching the order of the 0deg and 180deg points
                            // correct turn not found
                        }
                    }
                    else {
                        // found a left turn
                        // discard last hull point (add to insidePoints)
                        // insidePoints.unshift(lastHullPoint);
                        insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                        // reenter second-to-last hull point (will be last at next iter of loop)
                        hullRecords.push(secondLastHullRecord);
                        // do not do anything with current point
                        // correct turn not found
                    }
                }
            }
        }
        // At this point, hullPointRecords contains the output points in clockwise order
        // the points start with lowest-y,highest-x startPoint, and end at the same point
        // Step 3b: remove duplicated startPointRecord from the end of the array
        if (hullRecords.length > 2) {
            hullRecords.pop();
        }
        // Step 4: find the lowest originalIndex record and put it at the beginning of hull
        let lowestHullIndex; // the lowest originalIndex on the hull
        let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex
        for (let i = 0, n = hullRecords.length; i < n; i += 1) {
            const currentHullIndex = hullRecords[i][1];
            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
                lowestHullIndex = currentHullIndex;
                indexOfLowestHullIndexRecord = i;
            }
        }
        let hullPointRecordsReordered = [];
        if (indexOfLowestHullIndexRecord > 0) {
            const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
            const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
        }
        else {
            hullPointRecordsReordered = hullRecords;
        }
        const hullPoints = [];
        for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {
            hullPoints.push(hullPointRecordsReordered[i][0]);
        }
        return new Polyline(hullPoints);
    }
    equals(p) {
        if (p == null) {
            return false;
        }
        if (p.points.length !== this.points.length) {
            return false;
        }
        return p.points.every((a, i) => a.equals(this.points[i]));
    }
    clone() {
        return new Polyline(this.points.map((p) => p.clone()));
    }
    toJSON() {
        return this.points.map((p) => p.toJSON());
    }
    serialize() {
        return this.points.map((p) => `${p.x}, ${p.y}`).join(' ');
    }
};
(function (Polyline) {
    Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;
    function isPolyline(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Polyline) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const polyline = instance;
        if ((tag == null || tag === Polyline.toStringTag) &&
            typeof polyline.toHull === 'function' &&
            typeof polyline.simplify === 'function') {
            return true;
        }
        return false;
    }
    Polyline.isPolyline = isPolyline;
})(Polyline$2 || (Polyline$2 = {}));
(function (Polyline) {
    function parse(svgString) {
        const str = svgString.trim();
        if (str === '') {
            return new Polyline();
        }
        const points = [];
        const coords = str.split(/\s*,\s*|\s+/);
        for (let i = 0, ii = coords.length; i < ii; i += 2) {
            points.push({ x: +coords[i], y: +coords[i + 1] });
        }
        return new Polyline(points);
    }
    Polyline.parse = parse;
})(Polyline$2 || (Polyline$2 = {}));

class Curve extends Geometry {
    constructor(start, controlPoint1, controlPoint2, end) {
        super();
        this.PRECISION = 3;
        this.start = Point.create(start);
        this.controlPoint1 = Point.create(controlPoint1);
        this.controlPoint2 = Point.create(controlPoint2);
        this.end = Point.create(end);
    }
    get [Symbol.toStringTag]() {
        return Curve.toStringTag;
    }
    bbox() {
        const start = this.start;
        const controlPoint1 = this.controlPoint1;
        const controlPoint2 = this.controlPoint2;
        const end = this.end;
        const x0 = start.x;
        const y0 = start.y;
        const x1 = controlPoint1.x;
        const y1 = controlPoint1.y;
        const x2 = controlPoint2.x;
        const y2 = controlPoint2.y;
        const x3 = end.x;
        const y3 = end.y;
        const points = []; // local extremes
        const tvalues = []; // t values of local extremes
        const bounds = [[], []];
        let a;
        let b;
        let c;
        let t;
        let t1;
        let t2;
        let b2ac;
        let sqrtb2ac;
        for (let i = 0; i < 2; i += 1) {
            if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            }
            else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (t > 0 && t < 1)
                    tvalues.push(t);
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = Math.sqrt(b2ac);
            if (b2ac < 0)
                continue;
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (t1 > 0 && t1 < 1)
                tvalues.push(t1);
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (t2 > 0 && t2 < 1)
                tvalues.push(t2);
        }
        let x;
        let y;
        let mt;
        let j = tvalues.length;
        const jlen = j;
        while (j) {
            j -= 1;
            t = tvalues[j];
            mt = 1 - t;
            x =
                mt * mt * mt * x0 +
                    3 * mt * mt * t * x1 +
                    3 * mt * t * t * x2 +
                    t * t * t * x3;
            bounds[0][j] = x;
            y =
                mt * mt * mt * y0 +
                    3 * mt * mt * t * y1 +
                    3 * mt * t * t * y2 +
                    t * t * t * y3;
            bounds[1][j] = y;
            points[j] = { X: x, Y: y };
        }
        tvalues[jlen] = 0;
        tvalues[jlen + 1] = 1;
        points[jlen] = { X: x0, Y: y0 };
        points[jlen + 1] = { X: x3, Y: y3 };
        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        tvalues.length = jlen + 2;
        bounds[0].length = jlen + 2;
        bounds[1].length = jlen + 2;
        points.length = jlen + 2;
        const left = Math.min.apply(null, bounds[0]);
        const top = Math.min.apply(null, bounds[1]);
        const right = Math.max.apply(null, bounds[0]);
        const bottom = Math.max.apply(null, bounds[1]);
        return new Rectangle(left, top, right - left, bottom - top);
    }
    closestPoint(p, options = {}) {
        return this.pointAtT(this.closestPointT(p, options));
    }
    closestPointLength(p, options = {}) {
        const opts = this.getOptions(options);
        return this.lengthAtT(this.closestPointT(p, opts), opts);
    }
    closestPointNormalizedLength(p, options = {}) {
        const opts = this.getOptions(options);
        const cpLength = this.closestPointLength(p, opts);
        if (!cpLength) {
            return 0;
        }
        const length = this.length(opts);
        if (length === 0) {
            return 0;
        }
        return cpLength / length;
    }
    closestPointT(p, options = {}) {
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        let investigatedSubdivision = null;
        let investigatedSubdivisionStartT = 0;
        let investigatedSubdivisionEndT = 0;
        let distFromStart = 0;
        let distFromEnd = 0;
        let chordLength = 0;
        let minSumDist = null;
        const count = subdivisions.length;
        let piece = count > 0 ? 1 / count : 0;
        subdivisions.forEach((division, i) => {
            const startDist = division.start.distance(p);
            const endDist = division.end.distance(p);
            const sumDist = startDist + endDist;
            if (minSumDist == null || sumDist < minSumDist) {
                investigatedSubdivision = division;
                investigatedSubdivisionStartT = i * piece;
                investigatedSubdivisionEndT = (i + 1) * piece;
                distFromStart = startDist;
                distFromEnd = endDist;
                minSumDist = sumDist;
                chordLength = division.endpointDistance();
            }
        });
        // Recursively divide investigated subdivision, until distance between
        // baselinePoint and closest path endpoint is within `10^(-precision)`,
        // then return the closest endpoint of that final subdivision.
        // eslint-disable-next-line
        while (true) {
            // check if we have reached at least one required observed precision
            // - calculated as: the difference in distances from point to start and end divided by the distance
            // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
            // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
            // - this criterion works well for points lying far away from the curve
            const startPrecisionRatio = distFromStart
                ? Math.abs(distFromStart - distFromEnd) / distFromStart
                : 0;
            const endPrecisionRatio = distFromEnd != null
                ? Math.abs(distFromStart - distFromEnd) / distFromEnd
                : 0;
            const hasRequiredPrecision = startPrecisionRatio < precisionRatio ||
                endPrecisionRatio < precisionRatio;
            // check if we have reached at least one required minimal distance
            // - calculated as: the subdivision chord length multiplied by precisionRatio
            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
            // - this is a backup criterion that works well for points lying "almost at" the curve
            const hasMiniStartDistance = distFromStart
                ? distFromStart < chordLength * precisionRatio
                : true;
            const hasMiniEndDistance = distFromEnd
                ? distFromEnd < chordLength * precisionRatio
                : true;
            const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;
            if (hasRequiredPrecision || hasMiniDistance) {
                return distFromStart <= distFromEnd
                    ? investigatedSubdivisionStartT
                    : investigatedSubdivisionEndT;
            }
            // otherwise, set up for next iteration
            const divided = investigatedSubdivision.divide(0.5);
            piece /= 2;
            const startDist1 = divided[0].start.distance(p);
            const endDist1 = divided[0].end.distance(p);
            const sumDist1 = startDist1 + endDist1;
            const startDist2 = divided[1].start.distance(p);
            const endDist2 = divided[1].end.distance(p);
            const sumDist2 = startDist2 + endDist2;
            if (sumDist1 <= sumDist2) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= piece;
                distFromStart = startDist1;
                distFromEnd = endDist1;
            }
            else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += piece;
                distFromStart = startDist2;
                distFromEnd = endDist2;
            }
        }
    }
    closestPointTangent(p, options = {}) {
        return this.tangentAtT(this.closestPointT(p, options));
    }
    containsPoint(p, options = {}) {
        const polyline = this.toPolyline(options);
        return polyline.containsPoint(p);
    }
    divideAt(ratio, options = {}) {
        if (ratio <= 0) {
            return this.divideAtT(0);
        }
        if (ratio >= 1) {
            return this.divideAtT(1);
        }
        const t = this.tAt(ratio, options);
        return this.divideAtT(t);
    }
    divideAtLength(length, options = {}) {
        const t = this.tAtLength(length, options);
        return this.divideAtT(t);
    }
    divide(t) {
        return this.divideAtT(t);
    }
    divideAtT(t) {
        const start = this.start;
        const controlPoint1 = this.controlPoint1;
        const controlPoint2 = this.controlPoint2;
        const end = this.end;
        if (t <= 0) {
            return [
                new Curve(start, start, start, start),
                new Curve(start, controlPoint1, controlPoint2, end),
            ];
        }
        if (t >= 1) {
            return [
                new Curve(start, controlPoint1, controlPoint2, end),
                new Curve(end, end, end, end),
            ];
        }
        const dividerPoints = this.getSkeletonPoints(t);
        const startControl1 = dividerPoints.startControlPoint1;
        const startControl2 = dividerPoints.startControlPoint2;
        const divider = dividerPoints.divider;
        const dividerControl1 = dividerPoints.dividerControlPoint1;
        const dividerControl2 = dividerPoints.dividerControlPoint2;
        return [
            new Curve(start, startControl1, startControl2, divider),
            new Curve(divider, dividerControl1, dividerControl2, end),
        ];
    }
    endpointDistance() {
        return this.start.distance(this.end);
    }
    getSkeletonPoints(t) {
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        // shortcuts for `t` values that are out of range
        if (t <= 0) {
            return {
                startControlPoint1: start.clone(),
                startControlPoint2: start.clone(),
                divider: start.clone(),
                dividerControlPoint1: control1.clone(),
                dividerControlPoint2: control2.clone(),
            };
        }
        if (t >= 1) {
            return {
                startControlPoint1: control1.clone(),
                startControlPoint2: control2.clone(),
                divider: end.clone(),
                dividerControlPoint1: end.clone(),
                dividerControlPoint2: end.clone(),
            };
        }
        const midpoint1 = new Line(start, control1).pointAt(t);
        const midpoint2 = new Line(control1, control2).pointAt(t);
        const midpoint3 = new Line(control2, end).pointAt(t);
        const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);
        const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);
        const divideLine = new Line(subControl1, subControl2).pointAt(t);
        return {
            startControlPoint1: midpoint1,
            startControlPoint2: subControl1,
            divider: divideLine,
            dividerControlPoint1: subControl2,
            dividerControlPoint2: midpoint3,
        };
    }
    getSubdivisions(options = {}) {
        const precision = this.getPrecision(options);
        let subdivisions = [
            new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),
        ];
        if (precision === 0) {
            return subdivisions;
        }
        let previousLength = this.endpointDistance();
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        // Recursively divide curve at `t = 0.5`, until the difference between
        // observed length at subsequent iterations is lower than precision.
        let iteration = 0;
        // eslint-disable-next-line
        while (true) {
            iteration += 1;
            const divisions = [];
            subdivisions.forEach((c) => {
                // dividing at t = 0.5 (not at middle length!)
                const divided = c.divide(0.5);
                divisions.push(divided[0], divided[1]);
            });
            // measure new length
            const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);
            // check if we have reached required observed precision
            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
            // not a problem for further iterations because cubic curves cannot have more than two local extrema
            // (i.e. cubic curves cannot intersect the baseline more than once)
            // therefore two subsequent iterations cannot produce sampling with equal length
            const ratio = length !== 0 ? (length - previousLength) / length : 0;
            if (iteration > 1 && ratio < precisionRatio) {
                return divisions;
            }
            subdivisions = divisions;
            previousLength = length;
        }
    }
    length(options = {}) {
        const divisions = this.getDivisions(options);
        return divisions.reduce((memo, c) => {
            return memo + c.endpointDistance();
        }, 0);
    }
    lengthAtT(t, options = {}) {
        if (t <= 0) {
            return 0;
        }
        const precision = options.precision === undefined ? this.PRECISION : options.precision;
        const subCurve = this.divide(t)[0];
        return subCurve.length({ precision });
    }
    pointAt(ratio, options = {}) {
        if (ratio <= 0) {
            return this.start.clone();
        }
        if (ratio >= 1) {
            return this.end.clone();
        }
        const t = this.tAt(ratio, options);
        return this.pointAtT(t);
    }
    pointAtLength(length, options = {}) {
        const t = this.tAtLength(length, options);
        return this.pointAtT(t);
    }
    pointAtT(t) {
        if (t <= 0) {
            return this.start.clone();
        }
        if (t >= 1) {
            return this.end.clone();
        }
        return this.getSkeletonPoints(t).divider;
    }
    isDifferentiable() {
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        return !(start.equals(control1) &&
            control1.equals(control2) &&
            control2.equals(end));
    }
    tangentAt(ratio, options = {}) {
        if (!this.isDifferentiable())
            return null;
        if (ratio < 0) {
            ratio = 0; // eslint-disable-line
        }
        else if (ratio > 1) {
            ratio = 1; // eslint-disable-line
        }
        const t = this.tAt(ratio, options);
        return this.tangentAtT(t);
    }
    tangentAtLength(length, options = {}) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const t = this.tAtLength(length, options);
        return this.tangentAtT(t);
    }
    tangentAtT(t) {
        if (!this.isDifferentiable()) {
            return null;
        }
        if (t < 0) {
            t = 0; // eslint-disable-line
        }
        if (t > 1) {
            t = 1; // eslint-disable-line
        }
        const skeletonPoints = this.getSkeletonPoints(t);
        const p1 = skeletonPoints.startControlPoint2;
        const p2 = skeletonPoints.dividerControlPoint1;
        const tangentStart = skeletonPoints.divider;
        const tangentLine = new Line(p1, p2);
        // move so that tangent line starts at the point requested
        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
        return tangentLine;
    }
    getPrecision(options = {}) {
        return options.precision == null ? this.PRECISION : options.precision;
    }
    getDivisions(options = {}) {
        if (options.subdivisions != null) {
            return options.subdivisions;
        }
        const precision = this.getPrecision(options);
        return this.getSubdivisions({ precision });
    }
    getOptions(options = {}) {
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        return { precision, subdivisions };
    }
    tAt(ratio, options = {}) {
        if (ratio <= 0) {
            return 0;
        }
        if (ratio >= 1) {
            return 1;
        }
        const opts = this.getOptions(options);
        const total = this.length(opts);
        const length = total * ratio;
        return this.tAtLength(length, opts);
    }
    tAtLength(length, options = {}) {
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        const opts = { precision, subdivisions };
        let investigatedSubdivision = null;
        let investigatedSubdivisionStartT;
        let investigatedSubdivisionEndT;
        let baselinePointDistFromStart = 0;
        let baselinePointDistFromEnd = 0;
        let memo = 0;
        const count = subdivisions.length;
        let piece = count > 0 ? 1 / count : 0;
        for (let i = 0; i < count; i += 1) {
            const index = fromStart ? i : count - 1 - i;
            const division = subdivisions[i];
            const dist = division.endpointDistance();
            if (length <= memo + dist) {
                investigatedSubdivision = division;
                investigatedSubdivisionStartT = index * piece;
                investigatedSubdivisionEndT = (index + 1) * piece;
                baselinePointDistFromStart = fromStart
                    ? length - memo
                    : dist + memo - length;
                baselinePointDistFromEnd = fromStart
                    ? dist + memo - length
                    : length - memo;
                break;
            }
            memo += dist;
        }
        if (investigatedSubdivision == null) {
            return fromStart ? 1 : 0;
        }
        // note that precision affects what length is recorded
        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1
        const total = this.length(opts);
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        // recursively divide investigated subdivision:
        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
        // then return the closest endpoint of that final subdivision
        // eslint-disable-next-line
        while (true) {
            let ratio;
            ratio = total !== 0 ? baselinePointDistFromStart / total : 0;
            if (ratio < precisionRatio) {
                return investigatedSubdivisionStartT;
            }
            ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;
            if (ratio < precisionRatio) {
                return investigatedSubdivisionEndT;
            }
            // otherwise, set up for next iteration
            let newBaselinePointDistFromStart;
            let newBaselinePointDistFromEnd;
            const divided = investigatedSubdivision.divide(0.5);
            piece /= 2;
            const baseline1Length = divided[0].endpointDistance();
            const baseline2Length = divided[1].endpointDistance();
            if (baselinePointDistFromStart <= baseline1Length) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= piece;
                newBaselinePointDistFromStart = baselinePointDistFromStart;
                newBaselinePointDistFromEnd =
                    baseline1Length - newBaselinePointDistFromStart;
            }
            else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += piece;
                newBaselinePointDistFromStart =
                    baselinePointDistFromStart - baseline1Length;
                newBaselinePointDistFromEnd =
                    baseline2Length - newBaselinePointDistFromStart;
            }
            baselinePointDistFromStart = newBaselinePointDistFromStart;
            baselinePointDistFromEnd = newBaselinePointDistFromEnd;
        }
    }
    toPoints(options = {}) {
        const subdivisions = this.getDivisions(options);
        const points = [subdivisions[0].start.clone()];
        subdivisions.forEach((c) => points.push(c.end.clone()));
        return points;
    }
    toPolyline(options = {}) {
        return new Polyline$2(this.toPoints(options));
    }
    scale(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.start.rotate(angle, origin);
        this.controlPoint1.rotate(angle, origin);
        this.controlPoint2.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.start.translate(tx, ty);
            this.controlPoint1.translate(tx, ty);
            this.controlPoint2.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.start.translate(tx);
            this.controlPoint1.translate(tx);
            this.controlPoint2.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    equals(c) {
        return (c != null &&
            this.start.equals(c.start) &&
            this.controlPoint1.equals(c.controlPoint1) &&
            this.controlPoint2.equals(c.controlPoint2) &&
            this.end.equals(c.end));
    }
    clone() {
        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
    toJSON() {
        return {
            start: this.start.toJSON(),
            controlPoint1: this.controlPoint1.toJSON(),
            controlPoint2: this.controlPoint2.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        return [
            this.start.serialize(),
            this.controlPoint1.serialize(),
            this.controlPoint2.serialize(),
            this.end.serialize(),
        ].join(' ');
    }
}
(function (Curve) {
    Curve.toStringTag = `X6.Geometry.${Curve.name}`;
    function isCurve(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Curve) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const curve = instance;
        try {
            if ((tag == null || tag === Curve.toStringTag) &&
                Point.isPoint(curve.start) &&
                Point.isPoint(curve.controlPoint1) &&
                Point.isPoint(curve.controlPoint2) &&
                Point.isPoint(curve.end) &&
                typeof curve.toPoints === 'function' &&
                typeof curve.toPolyline === 'function') {
                return true;
            }
        }
        catch (e) {
            return false;
        }
        return false;
    }
    Curve.isCurve = isCurve;
})(Curve || (Curve = {}));
(function (Curve) {
    function getFirstControlPoints(rhs) {
        const n = rhs.length;
        const x = []; // `x` is a solution vector.
        const tmp = [];
        let b = 2.0;
        x[0] = rhs[0] / b;
        // Decomposition and forward substitution.
        for (let i = 1; i < n; i += 1) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
        }
        for (let i = 1; i < n; i += 1) {
            // Backsubstitution.
            x[n - i - 1] -= tmp[n - i] * x[n - i];
        }
        return x;
    }
    function getCurveControlPoints(points) {
        const knots = points.map((p) => Point.clone(p));
        const firstControlPoints = [];
        const secondControlPoints = [];
        const n = knots.length - 1;
        // Special case: Bezier curve should be a straight line.
        if (n === 1) {
            // 3P1 = 2P0 + P3
            firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            // P2 = 2P1  P0
            secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [firstControlPoints, secondControlPoints];
        }
        // Calculate first Bezier control points.
        // Right hand side vector.
        const rhs = [];
        // Set right hand side X values.
        for (let i = 1; i < n - 1; i += 1) {
            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
        }
        rhs[0] = knots[0].x + 2 * knots[1].x;
        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;
        // Get first control points X-values.
        const x = getFirstControlPoints(rhs);
        // Set right hand side Y values.
        for (let i = 1; i < n - 1; i += 1) {
            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
        }
        rhs[0] = knots[0].y + 2 * knots[1].y;
        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;
        // Get first control points Y-values.
        const y = getFirstControlPoints(rhs);
        // Fill output arrays.
        for (let i = 0; i < n; i += 1) {
            // First control point.
            firstControlPoints.push(new Point(x[i], y[i]));
            // Second control point.
            if (i < n - 1) {
                secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
            }
            else {
                secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
            }
        }
        return [firstControlPoints, secondControlPoints];
    }
    function throughPoints(points) {
        if (points == null || (Array.isArray(points) && points.length < 2)) {
            throw new Error('At least 2 points are required');
        }
        const controlPoints = getCurveControlPoints(points);
        const curves = [];
        for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
            const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);
            const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);
            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
        }
        return curves;
    }
    Curve.throughPoints = throughPoints;
})(Curve || (Curve = {}));

class Segment extends Geometry {
    constructor() {
        super(...arguments);
        this.isVisible = true;
        this.isSegment = true;
        this.isSubpathStart = false;
    }
    get end() {
        return this.endPoint;
    }
    get start() {
        if (this.previousSegment == null) {
            throw new Error('Missing previous segment. (This segment cannot be the ' +
                'first segment of a path, or segment has not yet been ' +
                'added to a path.)');
        }
        return this.previousSegment.end;
    }
    closestPointT(p, options) {
        if (this.closestPointNormalizedLength) {
            return this.closestPointNormalizedLength(p);
        }
        throw new Error('Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.');
    }
    // eslint-disable-next-line
    lengthAtT(t, options) {
        if (t <= 0) {
            return 0;
        }
        const length = this.length();
        if (t >= 1) {
            return length;
        }
        return length * t;
    }
    divideAtT(t) {
        if (this.divideAt) {
            return this.divideAt(t);
        }
        throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.');
    }
    pointAtT(t) {
        if (this.pointAt) {
            return this.pointAt(t);
        }
        throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.');
    }
    tangentAtT(t) {
        if (this.tangentAt) {
            return this.tangentAt(t);
        }
        throw new Error('Neither `tangentAtT` nor `tangentAt` method is implemented.');
    }
}

class LineTo extends Segment {
    constructor(x, y) {
        super();
        if (Line.isLine(x)) {
            this.endPoint = x.end.clone().round(2);
        }
        else {
            this.endPoint = Point.create(x, y).round(2);
        }
    }
    get type() {
        return 'L';
    }
    get line() {
        return new Line(this.start, this.end);
    }
    bbox() {
        return this.line.bbox();
    }
    closestPoint(p) {
        return this.line.closestPoint(p);
    }
    closestPointLength(p) {
        return this.line.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.line.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.line.closestPointTangent(p);
    }
    length() {
        return this.line.length();
    }
    divideAt(ratio) {
        const divided = this.line.divideAt(ratio);
        return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
    divideAtLength(length) {
        const divided = this.line.divideAtLength(length);
        return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.line.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.line.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.line.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.line.tangentAtLength(length);
    }
    isDifferentiable() {
        if (this.previousSegment == null) {
            return false;
        }
        return !this.start.equals(this.end);
    }
    clone() {
        return new LineTo(this.end);
    }
    scale(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.end.translate(tx, ty);
        }
        else {
            this.end.translate(tx);
        }
        return this;
    }
    equals(s) {
        return (this.type === s.type &&
            this.start.equals(s.start) &&
            this.end.equals(s.end));
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const end = this.end;
        return `${this.type} ${end.x} ${end.y}`;
    }
}
(function (LineTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // line provided
        if (Line.isLine(arg0)) {
            return new LineTo(arg0);
        }
        // points provided
        if (Point.isPointLike(arg0)) {
            if (len === 1) {
                return new LineTo(arg0);
            }
            // poly-line segment
            return args.map((arg) => new LineTo(arg));
        }
        // coordinates provided
        if (len === 2) {
            return new LineTo(+args[0], +args[1]);
        }
        // poly-line segment
        const segments = [];
        for (let i = 0; i < len; i += 2) {
            const x = +args[i];
            const y = +args[i + 1];
            segments.push(new LineTo(x, y));
        }
        return segments;
    }
    LineTo.create = create;
})(LineTo || (LineTo = {}));

class Close extends Segment {
    get end() {
        if (!this.subpathStartSegment) {
            throw new Error('Missing subpath start segment. (This segment needs a subpath ' +
                'start segment (e.g. MoveTo), or segment has not yet been added' +
                ' to a path.)');
        }
        return this.subpathStartSegment.end;
    }
    get type() {
        return 'Z';
    }
    get line() {
        return new Line(this.start, this.end);
    }
    bbox() {
        return this.line.bbox();
    }
    closestPoint(p) {
        return this.line.closestPoint(p);
    }
    closestPointLength(p) {
        return this.line.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.line.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.line.closestPointTangent(p);
    }
    length() {
        return this.line.length();
    }
    divideAt(ratio) {
        const divided = this.line.divideAt(ratio);
        return [
            // do not actually cut into the segment, first divided part can stay as Z
            divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
            new LineTo(divided[1]),
        ];
    }
    divideAtLength(length) {
        const divided = this.line.divideAtLength(length);
        return [
            divided[1].isDifferentiable() ? new LineTo(divided[0]) : this.clone(),
            new LineTo(divided[1]),
        ];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.line.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.line.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.line.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.line.tangentAtLength(length);
    }
    isDifferentiable() {
        if (!this.previousSegment || !this.subpathStartSegment) {
            return false;
        }
        return !this.start.equals(this.end);
    }
    scale() {
        return this;
    }
    rotate() {
        return this;
    }
    translate() {
        return this;
    }
    equals(s) {
        return (this.type === s.type &&
            this.start.equals(s.start) &&
            this.end.equals(s.end));
    }
    clone() {
        return new Close();
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        return this.type;
    }
}
(function (Close) {
    function create() {
        return new Close();
    }
    Close.create = create;
})(Close || (Close = {}));

class MoveTo extends Segment {
    constructor(x, y) {
        super();
        this.isVisible = false;
        this.isSubpathStart = true;
        if (Line.isLine(x) || Curve.isCurve(x)) {
            this.endPoint = x.end.clone().round(2);
        }
        else {
            this.endPoint = Point.create(x, y).round(2);
        }
    }
    get start() {
        throw new Error('Illegal access. Moveto segments should not need a start property.');
    }
    get type() {
        return 'M';
    }
    bbox() {
        return null;
    }
    closestPoint() {
        return this.end.clone();
    }
    closestPointLength() {
        return 0;
    }
    closestPointNormalizedLength() {
        return 0;
    }
    closestPointT() {
        return 1;
    }
    closestPointTangent() {
        return null;
    }
    length() {
        return 0;
    }
    lengthAtT() {
        return 0;
    }
    divideAt() {
        return [this.clone(), this.clone()];
    }
    divideAtLength() {
        return [this.clone(), this.clone()];
    }
    getSubdivisions() {
        return [];
    }
    pointAt() {
        return this.end.clone();
    }
    pointAtLength() {
        return this.end.clone();
    }
    pointAtT() {
        return this.end.clone();
    }
    tangentAt() {
        return null;
    }
    tangentAtLength() {
        return null;
    }
    tangentAtT() {
        return null;
    }
    isDifferentiable() {
        return false;
    }
    scale(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.end.translate(tx, ty);
        }
        else {
            this.end.translate(tx);
        }
        return this;
    }
    clone() {
        return new MoveTo(this.end);
    }
    equals(s) {
        return this.type === s.type && this.end.equals(s.end);
    }
    toJSON() {
        return {
            type: this.type,
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const end = this.end;
        return `${this.type} ${end.x} ${end.y}`;
    }
}
(function (MoveTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // line provided
        if (Line.isLine(arg0)) {
            return new MoveTo(arg0);
        }
        // curve provided
        if (Curve.isCurve(arg0)) {
            return new MoveTo(arg0);
        }
        // points provided
        if (Point.isPointLike(arg0)) {
            if (len === 1) {
                return new MoveTo(arg0);
            }
            // this is a moveto-with-subsequent-poly-line segment
            const segments = [];
            // points come one by one
            for (let i = 0; i < len; i += 1) {
                if (i === 0) {
                    segments.push(new MoveTo(args[i]));
                }
                else {
                    segments.push(new LineTo(args[i]));
                }
            }
            return segments;
        }
        // coordinates provided
        if (len === 2) {
            return new MoveTo(+args[0], +args[1]);
        }
        // this is a moveto-with-subsequent-poly-line segment
        const segments = [];
        for (let i = 0; i < len; i += 2) {
            const x = +args[i];
            const y = +args[i + 1];
            if (i === 0) {
                segments.push(new MoveTo(x, y));
            }
            else {
                segments.push(new LineTo(x, y));
            }
        }
        return segments;
    }
    MoveTo.create = create;
})(MoveTo || (MoveTo = {}));

class CurveTo extends Segment {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5) {
        super();
        if (Curve.isCurve(arg0)) {
            this.controlPoint1 = arg0.controlPoint1.clone().round(2);
            this.controlPoint2 = arg0.controlPoint2.clone().round(2);
            this.endPoint = arg0.end.clone().round(2);
        }
        else if (typeof arg0 === 'number') {
            this.controlPoint1 = new Point(arg0, arg1).round(2);
            this.controlPoint2 = new Point(arg2, arg3).round(2);
            this.endPoint = new Point(arg4, arg5).round(2);
        }
        else {
            this.controlPoint1 = Point.create(arg0).round(2);
            this.controlPoint2 = Point.create(arg1).round(2);
            this.endPoint = Point.create(arg2).round(2);
        }
    }
    get type() {
        return 'C';
    }
    get curve() {
        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
    bbox() {
        return this.curve.bbox();
    }
    closestPoint(p) {
        return this.curve.closestPoint(p);
    }
    closestPointLength(p) {
        return this.curve.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.curve.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.curve.closestPointTangent(p);
    }
    length() {
        return this.curve.length();
    }
    divideAt(ratio, options = {}) {
        // TODO: fix options
        const divided = this.curve.divideAt(ratio, options);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    divideAtLength(length, options = {}) {
        // TODO: fix options
        const divided = this.curve.divideAtLength(length, options);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    divideAtT(t) {
        const divided = this.curve.divideAtT(t);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.curve.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.curve.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.curve.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.curve.tangentAtLength(length);
    }
    isDifferentiable() {
        if (!this.previousSegment) {
            return false;
        }
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        return !(start.equals(control1) &&
            control1.equals(control2) &&
            control2.equals(end));
    }
    scale(sx, sy, origin) {
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.controlPoint1.rotate(angle, origin);
        this.controlPoint2.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.controlPoint1.translate(tx, ty);
            this.controlPoint2.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.controlPoint1.translate(tx);
            this.controlPoint2.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    equals(s) {
        return (this.start.equals(s.start) &&
            this.end.equals(s.end) &&
            this.controlPoint1.equals(s.controlPoint1) &&
            this.controlPoint2.equals(s.controlPoint2));
    }
    clone() {
        return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            controlPoint1: this.controlPoint1.toJSON(),
            controlPoint2: this.controlPoint2.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const c1 = this.controlPoint1;
        const c2 = this.controlPoint2;
        const end = this.end;
        return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');
    }
}
(function (CurveTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // curve provided
        if (Curve.isCurve(arg0)) {
            return new CurveTo(arg0);
        }
        // points provided
        if (Point.isPointLike(arg0)) {
            if (len === 3) {
                return new CurveTo(args[0], args[1], args[2]);
            }
            // this is a poly-bezier segment
            const segments = [];
            for (let i = 0; i < len; i += 3) {
                segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]));
            }
            return segments;
        }
        // coordinates provided
        if (len === 6) {
            return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);
        }
        // this is a poly-bezier segment
        const segments = [];
        for (let i = 0; i < len; i += 6) {
            segments.push(new CurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));
        }
        return segments;
    }
    CurveTo.create = create;
})(CurveTo || (CurveTo = {}));

function rotate$1(x, y, rad) {
    return {
        x: x * Math.cos(rad) - y * Math.sin(rad),
        y: x * Math.sin(rad) + y * Math.cos(rad),
    };
}
function q2c(x1, y1, ax, ay, x2, y2) {
    const v13 = 1 / 3;
    const v23 = 2 / 3;
    return [
        v13 * x1 + v23 * ax,
        v13 * y1 + v23 * ay,
        v13 * x2 + v23 * ax,
        v13 * y2 + v23 * ay,
        x2,
        y2,
    ];
}
function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    const v120 = (Math.PI * 120) / 180;
    const rad = (Math.PI / 180) * (+angle || 0);
    let res = [];
    let xy;
    let f1;
    let f2;
    let cx;
    let cy;
    if (!recursive) {
        xy = rotate$1(x1, y1, -rad);
        x1 = xy.x; // eslint-disable-line
        y1 = xy.y; // eslint-disable-line
        xy = rotate$1(x2, y2, -rad);
        x2 = xy.x; // eslint-disable-line
        y2 = xy.y; // eslint-disable-line
        const x = (x1 - x2) / 2;
        const y = (y1 - y2) / 2;
        let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
        if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx; // eslint-disable-line
            ry = h * ry; // eslint-disable-line
        }
        const rx2 = rx * rx;
        const ry2 = ry * ry;
        const k = (largeArcFlag === sweepFlag ? -1 : 1) *
            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
        cx = (k * rx * y) / ry + (x1 + x2) / 2;
        cy = (k * -ry * x) / rx + (y1 + y2) / 2;
        f1 = Math.asin((y1 - cy) / ry);
        f2 = Math.asin((y2 - cy) / ry);
        f1 = x1 < cx ? Math.PI - f1 : f1;
        f2 = x2 < cx ? Math.PI - f2 : f2;
        if (f1 < 0) {
            f1 = Math.PI * 2 + f1;
        }
        if (f2 < 0) {
            f2 = Math.PI * 2 + f2;
        }
        if (sweepFlag && f1 > f2) {
            f1 -= Math.PI * 2;
        }
        if (!sweepFlag && f2 > f1) {
            f2 -= Math.PI * 2;
        }
    }
    else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
    }
    let df = f2 - f1;
    if (Math.abs(df) > v120) {
        const f2old = f2;
        const x2old = x2;
        const y2old = y2;
        f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2); // eslint-disable-line
        y2 = cy + ry * Math.sin(f2); // eslint-disable-line
        res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [
            f2,
            f2old,
            cx,
            cy,
        ]);
    }
    df = f2 - f1;
    const c1 = Math.cos(f1);
    const s1 = Math.sin(f1);
    const c2 = Math.cos(f2);
    const s2 = Math.sin(f2);
    const t = Math.tan(df / 4);
    const hx = (4 / 3) * (rx * t);
    const hy = (4 / 3) * (ry * t);
    const m1 = [x1, y1];
    const m2 = [x1 + hx * s1, y1 - hy * c1];
    const m3 = [x2 + hx * s2, y2 - hy * c2];
    const m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
        return [m2, m3, m4].concat(res);
    }
    {
        res = [m2, m3, m4].concat(res).join().split(',');
        const newres = [];
        const ii = res.length;
        for (let i = 0; i < ii; i += 1) {
            newres[i] =
                i % 2
                    ? rotate$1(+res[i - 1], +res[i], rad).y
                    : rotate$1(+res[i], +res[i + 1], rad).x;
        }
        return newres;
    }
}
function parse(pathData) {
    if (!pathData) {
        return null;
    }
    const spaces = '\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029';
    // https://regexper.com/#%28%5Ba-z%5D%29%5B%5Cs%2C%5D*%28%28-%3F%5Cd*%5C.%3F%5C%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*%29%2B%29
    const segmentReg = new RegExp(`([a-z])[${spaces},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${spaces}]*,?[${spaces}]*)+)`, // eslint-disable-line
    'ig');
    // https://regexper.com/#%28-%3F%5Cd*%5C.%3F%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%29%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*
    const commandParamReg = new RegExp(
    // eslint-disable-next-line
    `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${spaces}]*,?[${spaces}]*`, 'ig');
    const paramsCount = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0,
    };
    const segmetns = [];
    pathData.replace(segmentReg, (input, cmd, args) => {
        const params = [];
        let command = cmd.toLowerCase();
        args.replace(commandParamReg, (a, b) => {
            if (b) {
                params.push(+b);
            }
            return a;
        });
        if (command === 'm' && params.length > 2) {
            segmetns.push([cmd, ...params.splice(0, 2)]);
            command = 'l';
            cmd = cmd === 'm' ? 'l' : 'L'; // eslint-disable-line
        }
        const count = paramsCount[command];
        while (params.length >= count) {
            segmetns.push([cmd, ...params.splice(0, count)]);
            if (!count) {
                break;
            }
        }
        return input;
    });
    return segmetns;
}
function abs(pathString) {
    const pathArray = parse(pathString);
    // if invalid string, return 'M 0 0'
    if (!pathArray || !pathArray.length) {
        return [['M', 0, 0]];
    }
    let x = 0;
    let y = 0;
    let mx = 0;
    let my = 0;
    const segments = [];
    for (let i = 0, ii = pathArray.length; i < ii; i += 1) {
        const r = [];
        segments.push(r);
        const segment = pathArray[i];
        const command = segment[0];
        if (command !== command.toUpperCase()) {
            r[0] = command.toUpperCase();
            switch (r[0]) {
                case 'A':
                    r[1] = segment[1];
                    r[2] = segment[2];
                    r[3] = segment[3];
                    r[4] = segment[4];
                    r[5] = segment[5];
                    r[6] = +segment[6] + x;
                    r[7] = +segment[7] + y;
                    break;
                case 'V':
                    r[1] = +segment[1] + y;
                    break;
                case 'H':
                    r[1] = +segment[1] + x;
                    break;
                case 'M':
                    mx = +segment[1] + x;
                    my = +segment[2] + y;
                    for (let j = 1, jj = segment.length; j < jj; j += 1) {
                        r[j] = +segment[j] + (j % 2 ? x : y);
                    }
                    break;
                default:
                    for (let j = 1, jj = segment.length; j < jj; j += 1) {
                        r[j] = +segment[j] + (j % 2 ? x : y);
                    }
                    break;
            }
        }
        else {
            for (let j = 0, jj = segment.length; j < jj; j += 1) {
                r[j] = segment[j];
            }
        }
        switch (r[0]) {
            case 'Z':
                x = +mx;
                y = +my;
                break;
            case 'H':
                x = r[1];
                break;
            case 'V':
                y = r[1];
                break;
            case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                x = r[r.length - 2];
                y = r[r.length - 1];
                break;
            default:
                x = r[r.length - 2];
                y = r[r.length - 1];
                break;
        }
    }
    return segments;
}
function normalize$2(path) {
    const pathArray = abs(path);
    const attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
    function processPath(path, d, pcom) {
        let nx;
        let ny;
        if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }
        if (!(path[0] in { T: 1, Q: 1 })) {
            d.qx = null;
            d.qy = null;
        }
        switch (path[0]) {
            case 'M':
                d.X = path[1];
                d.Y = path[2];
                break;
            case 'A':
                if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
                    // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
                    // "If either rx or ry is 0, then this arc is treated as a
                    // straight line segment (a "lineto") joining the endpoints."
                    return ['L', path[6], path[7]];
                }
                return ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
            case 'S':
                if (pcom === 'C' || pcom === 'S') {
                    // In 'S' case we have to take into account, if the previous command is C/S.
                    nx = d.x * 2 - d.bx; // And reflect the previous
                    ny = d.y * 2 - d.by; // command's control point relative to the current point.
                }
                else {
                    // or some else or nothing
                    nx = d.x;
                    ny = d.y;
                }
                return ['C', nx, ny].concat(path.slice(1));
            case 'T':
                if (pcom === 'Q' || pcom === 'T') {
                    // In 'T' case we have to take into account, if the previous command is Q/T.
                    d.qx = d.x * 2 - d.qx; // And make a reflection similar
                    d.qy = d.y * 2 - d.qy; // to case 'S'.
                }
                else {
                    // or something else or nothing
                    d.qx = d.x;
                    d.qy = d.y;
                }
                return ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
            case 'Q':
                d.qx = path[1];
                d.qy = path[2];
                return ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
            case 'H':
                return ['L'].concat(path[1], d.y);
            case 'V':
                return ['L'].concat(d.x, path[1]);
            case 'L':
                break;
            case 'Z':
                break;
            default:
                break;
        }
        return path;
    }
    function fixArc(pp, i) {
        if (pp[i].length > 7) {
            pp[i].shift();
            const pi = pp[i];
            while (pi.length) {
                // if created multiple 'C's, their original seg is saved
                commands[i] = 'A';
                i += 1; // eslint-disable-line
                pp.splice(i, 0, ['C'].concat(pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = pathArray.length;
        }
    }
    const commands = []; // path commands of original path p
    let prevCommand = ''; // holder for previous path command of original path
    let ii = pathArray.length;
    for (let i = 0; i < ii; i += 1) {
        let command = ''; // temporary holder for original path command
        if (pathArray[i]) {
            command = pathArray[i][0]; // save current path command
        }
        if (command !== 'C') {
            // C is not saved yet, because it may be result of conversion
            commands[i] = command; // Save current path command
            if (i > 0) {
                prevCommand = commands[i - 1]; // Get previous path command pcom
            }
        }
        // Previous path command is inputted to processPath
        pathArray[i] = processPath(pathArray[i], attrs, prevCommand);
        if (commands[i] !== 'A' && command === 'C') {
            commands[i] = 'C'; // 'A' is the only command
        }
        // which may produce multiple 'C's
        // so we have to make sure that 'C' is also 'C' in original path
        fixArc(pathArray, i); // fixArc adds also the right amount of 'A's to pcoms
        const seg = pathArray[i];
        const seglen = seg.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    }
    // make sure normalized path data string starts with an M segment
    if (!pathArray[0][0] || pathArray[0][0] !== 'M') {
        pathArray.unshift(['M', 0, 0]);
    }
    return pathArray;
}
/**
 * Converts provided SVG path data string into a normalized path data string.
 *
 * The normalization uses a restricted subset of path commands; all segments
 * are translated into lineto, curveto, moveto, and closepath segments.
 *
 * Relative path commands are changed into their absolute counterparts,
 * and chaining of coordinates is disallowed.
 *
 * The function will always return a valid path data string; if an input
 * string cannot be normalized, 'M 0 0' is returned.
 */
function normalizePathData(pathData) {
    return normalize$2(pathData)
        .map((segment) => segment.map((item) => (typeof item === 'string' ? item : round$1(item, 2))))
        .join(',')
        .split(',')
        .join(' ');
}

const regexSupportedData = new RegExp(`^[\\s\\dLMCZz,.]*$`);
function isValid(data) {
    if (typeof data !== 'string') {
        return false;
    }
    return regexSupportedData.test(data);
}
/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */
function mod(n, m) {
    return ((n % m) + m) % m;
}
function draw(points, round, initialMove, close, exclude) {
    const data = [];
    const end = points[points.length - 1];
    const rounded = round != null && round > 0;
    const arcSize = round || 0;
    // Adds virtual waypoint in the center between start and end point
    if (close && rounded) {
        points = points.slice(); // eslint-disable-line
        const p0 = points[0];
        const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);
        points.splice(0, 0, wp);
    }
    let pt = points[0];
    let i = 1;
    // Draws the line segments
    if (initialMove) {
        data.push('M', pt.x, pt.y);
    }
    else {
        data.push('L', pt.x, pt.y);
    }
    while (i < (close ? points.length : points.length - 1)) {
        let tmp = points[mod(i, points.length)];
        let dx = pt.x - tmp.x;
        let dy = pt.y - tmp.y;
        if (rounded &&
            (dx !== 0 || dy !== 0) &&
            (exclude == null || exclude.indexOf(i - 1) < 0)) {
            // Draws a line from the last point to the current
            // point with a spacing of size off the current point
            // into direction of the last point
            let dist = Math.sqrt(dx * dx + dy * dy);
            const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;
            const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;
            const x1 = tmp.x + nx1;
            const y1 = tmp.y + ny1;
            data.push('L', x1, y1);
            // Draws a curve from the last point to the current
            // point with a spacing of size off the current point
            // into direction of the next point
            let next = points[mod(i + 1, points.length)];
            // Uses next non-overlapping point
            while (i < points.length - 2 &&
                Math.round(next.x - tmp.x) === 0 &&
                Math.round(next.y - tmp.y) === 0) {
                next = points[mod(i + 2, points.length)];
                i += 1;
            }
            dx = next.x - tmp.x;
            dy = next.y - tmp.y;
            dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
            const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;
            const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;
            const x2 = tmp.x + nx2;
            const y2 = tmp.y + ny2;
            data.push('Q', tmp.x, tmp.y, x2, y2);
            tmp = new Point(x2, y2);
        }
        else {
            data.push('L', tmp.x, tmp.y);
        }
        pt = tmp;
        i += 1;
    }
    if (close) {
        data.push('Z');
    }
    else {
        data.push('L', end.x, end.y);
    }
    return data.map((v) => (typeof v === 'string' ? v : +v.toFixed(3))).join(' ');
}
function drawPoints(points, options = {}) {
    const pts = [];
    if (points && points.length) {
        points.forEach((p) => {
            if (Array.isArray(p)) {
                pts.push({ x: p[0], y: p[1] });
            }
            else {
                pts.push({ x: p.x, y: p.y });
            }
        });
    }
    return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);
}
/**
 * Converts the given arc to a series of curves.
 */
function arcToCurves(x0, y0, r1, r2, angle = 0, largeArcFlag = 0, sweepFlag = 0, x, y) {
    if (r1 === 0 || r2 === 0) {
        return [];
    }
    x -= x0; // eslint-disable-line
    y -= y0; // eslint-disable-line
    r1 = Math.abs(r1); // eslint-disable-line
    r2 = Math.abs(r2); // eslint-disable-line
    const ctx = -x / 2;
    const cty = -y / 2;
    const cpsi = Math.cos((angle * Math.PI) / 180);
    const spsi = Math.sin((angle * Math.PI) / 180);
    const rxd = cpsi * ctx + spsi * cty;
    const ryd = -1 * spsi * ctx + cpsi * cty;
    const rxdd = rxd * rxd;
    const rydd = ryd * ryd;
    const r1x = r1 * r1;
    const r2y = r2 * r2;
    const lamda = rxdd / r1x + rydd / r2y;
    let sds;
    if (lamda > 1) {
        r1 = Math.sqrt(lamda) * r1; // eslint-disable-line
        r2 = Math.sqrt(lamda) * r2; // eslint-disable-line
        sds = 0;
    }
    else {
        let seif = 1;
        if (largeArcFlag === sweepFlag) {
            seif = -1;
        }
        sds =
            seif *
                Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
    }
    const txd = (sds * r1 * ryd) / r2;
    const tyd = (-1 * sds * r2 * rxd) / r1;
    const tx = cpsi * txd - spsi * tyd + x / 2;
    const ty = spsi * txd + cpsi * tyd + y / 2;
    let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
    let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
    rad =
        Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -
            Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
    let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
    if (sweepFlag === 0 && dr > 0) {
        dr -= 2 * Math.PI;
    }
    else if (sweepFlag !== 0 && dr < 0) {
        dr += 2 * Math.PI;
    }
    const sse = (dr * 2) / Math.PI;
    const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
    const segr = dr / seg;
    const t = ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2);
    const cpsir1 = cpsi * r1;
    const cpsir2 = cpsi * r2;
    const spsir1 = spsi * r1;
    const spsir2 = spsi * r2;
    let mc = Math.cos(s1);
    let ms = Math.sin(s1);
    let x2 = -t * (cpsir1 * ms + spsir2 * mc);
    let y2 = -t * (spsir1 * ms - cpsir2 * mc);
    let x3 = 0;
    let y3 = 0;
    const result = [];
    for (let n = 0; n < seg; n += 1) {
        s1 += segr;
        mc = Math.cos(s1);
        ms = Math.sin(s1);
        x3 = cpsir1 * mc - spsir2 * ms + tx;
        y3 = spsir1 * mc + cpsir2 * ms + ty;
        const dx = -t * (cpsir1 * ms + spsir2 * mc);
        const dy = -t * (spsir1 * ms - cpsir2 * mc);
        // CurveTo updates x0, y0 so need to restore it
        const index = n * 6;
        result[index] = Number(x2 + x0);
        result[index + 1] = Number(y2 + y0);
        result[index + 2] = Number(x3 - dx + x0);
        result[index + 3] = Number(y3 - dy + y0);
        result[index + 4] = Number(x3 + x0);
        result[index + 5] = Number(y3 + y0);
        x2 = x3 + dx;
        y2 = y3 + dy;
    }
    return result.map((num) => +num.toFixed(2));
}
function drawArc(startX, startY, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0, stopX, stopY) {
    const data = [];
    const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);
    if (points != null) {
        for (let i = 0, ii = points.length; i < ii; i += 6) {
            data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
        }
    }
    return data.join(' ');
}

let Path$2 = class Path extends Geometry {
    constructor(args) {
        super();
        this.PRECISION = 3;
        this.segments = [];
        if (Array.isArray(args)) {
            if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {
                let previousObj = null;
                const arr = args;
                arr.forEach((o, i) => {
                    if (i === 0) {
                        this.appendSegment(Path.createSegment('M', o.start));
                    }
                    if (previousObj != null && !previousObj.end.equals(o.start)) {
                        this.appendSegment(Path.createSegment('M', o.start));
                    }
                    if (Line.isLine(o)) {
                        this.appendSegment(Path.createSegment('L', o.end));
                    }
                    else if (Curve.isCurve(o)) {
                        this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));
                    }
                    previousObj = o;
                });
            }
            else {
                const arr = args;
                arr.forEach((s) => {
                    if (s.isSegment) {
                        this.appendSegment(s);
                    }
                });
            }
        }
        else if (args != null) {
            if (Line.isLine(args)) {
                this.appendSegment(Path.createSegment('M', args.start));
                this.appendSegment(Path.createSegment('L', args.end));
            }
            else if (Curve.isCurve(args)) {
                this.appendSegment(Path.createSegment('M', args.start));
                this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));
            }
            else if (Polyline$2.isPolyline(args)) {
                if (args.points && args.points.length) {
                    args.points.forEach((point, index) => {
                        const segment = index === 0
                            ? Path.createSegment('M', point)
                            : Path.createSegment('L', point);
                        this.appendSegment(segment);
                    });
                }
            }
            else if (args.isSegment) {
                this.appendSegment(args);
            }
        }
    }
    get [Symbol.toStringTag]() {
        return Path.toStringTag;
    }
    get start() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                return segment.start;
            }
        }
        // if no visible segment, return last segment end point
        return segments[count - 1].end;
    }
    get end() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        for (let i = count - 1; i >= 0; i -= 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                return segment.end;
            }
        }
        // if no visible segment, return last segment end point
        return segments[count - 1].end;
    }
    moveTo(...args) {
        return this.appendSegment(MoveTo.create.call(null, ...args));
    }
    lineTo(...args) {
        return this.appendSegment(LineTo.create.call(null, ...args));
    }
    curveTo(...args) {
        return this.appendSegment(CurveTo.create.call(null, ...args));
    }
    arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {
        const start = this.end || new Point();
        const points = typeof endX === 'number'
            ? arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY)
            : arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);
        if (points != null) {
            for (let i = 0, ii = points.length; i < ii; i += 6) {
                this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
            }
        }
        return this;
    }
    quadTo(x1, y1, x, y) {
        const start = this.end || new Point();
        const data = ['M', start.x, start.y];
        if (typeof x1 === 'number') {
            data.push('Q', x1, y1, x, y);
        }
        else {
            const p = y1;
            data.push(`Q`, x1.x, x1.y, p.x, p.y);
        }
        const path = Path.parse(data.join(' '));
        this.appendSegment(path.segments.slice(1));
        return this;
    }
    close() {
        return this.appendSegment(Close.create());
    }
    drawPoints(points, options = {}) {
        const raw = drawPoints(points, options);
        const sub = Path.parse(raw);
        if (sub && sub.segments) {
            this.appendSegment(sub.segments);
        }
    }
    bbox() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        let bbox;
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                const segmentBBox = segment.bbox();
                if (segmentBBox != null) {
                    bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
                }
            }
        }
        if (bbox != null) {
            return bbox;
        }
        // if the path has only invisible elements, return end point of last segment
        const lastSegment = segments[count - 1];
        return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
    }
    appendSegment(seg) {
        const count = this.segments.length;
        let previousSegment = count !== 0 ? this.segments[count - 1] : null;
        let currentSegment;
        const nextSegment = null;
        if (Array.isArray(seg)) {
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.push(currentSegment);
                previousSegment = currentSegment;
            }
        }
        else if (seg != null && seg.isSegment) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.push(currentSegment);
        }
        return this;
    }
    insertSegment(index, seg) {
        const count = this.segments.length;
        if (index < 0) {
            index = count + index + 1; // eslint-disable-line
        }
        if (index > count || index < 0) {
            throw new Error('Index out of range.');
        }
        let currentSegment;
        let previousSegment = null;
        let nextSegment = null;
        if (count !== 0) {
            if (index >= 1) {
                previousSegment = this.segments[index - 1];
                nextSegment = previousSegment.nextSegment;
            }
            else {
                previousSegment = null;
                nextSegment = this.segments[0];
            }
        }
        if (!Array.isArray(seg)) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.splice(index, 0, currentSegment);
        }
        else {
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.splice(index + i, 0, currentSegment);
                previousSegment = currentSegment;
            }
        }
        return this;
    }
    removeSegment(index) {
        const idx = this.fixIndex(index);
        const removedSegment = this.segments.splice(idx, 1)[0];
        const previousSegment = removedSegment.previousSegment;
        const nextSegment = removedSegment.nextSegment;
        // link the previous and next segments together (if present)
        if (previousSegment) {
            previousSegment.nextSegment = nextSegment;
        }
        if (nextSegment) {
            nextSegment.previousSegment = previousSegment;
        }
        if (removedSegment.isSubpathStart && nextSegment) {
            this.updateSubpathStartSegment(nextSegment);
        }
        return removedSegment;
    }
    replaceSegment(index, seg) {
        const idx = this.fixIndex(index);
        let currentSegment;
        const replacedSegment = this.segments[idx];
        let previousSegment = replacedSegment.previousSegment;
        const nextSegment = replacedSegment.nextSegment;
        let updateSubpathStart = replacedSegment.isSubpathStart;
        if (!Array.isArray(seg)) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.splice(idx, 1, currentSegment);
            if (updateSubpathStart && currentSegment.isSubpathStart) {
                // already updated by `prepareSegment`
                updateSubpathStart = false;
            }
        }
        else {
            this.segments.splice(index, 1);
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.splice(index + i, 0, currentSegment);
                previousSegment = currentSegment;
                if (updateSubpathStart && currentSegment.isSubpathStart) {
                    updateSubpathStart = false;
                }
            }
        }
        if (updateSubpathStart && nextSegment) {
            this.updateSubpathStartSegment(nextSegment);
        }
    }
    getSegment(index) {
        const idx = this.fixIndex(index);
        return this.segments[idx];
    }
    fixIndex(index) {
        const length = this.segments.length;
        if (length === 0) {
            throw new Error('Path has no segments.');
        }
        let i = index;
        while (i < 0) {
            i = length + i;
        }
        if (i >= length || i < 0) {
            throw new Error('Index out of range.');
        }
        return i;
    }
    segmentAt(ratio, options = {}) {
        const index = this.segmentIndexAt(ratio, options);
        if (!index) {
            return null;
        }
        return this.getSegment(index);
    }
    segmentAtLength(length, options = {}) {
        const index = this.segmentIndexAtLength(length, options);
        if (!index)
            return null;
        return this.getSegment(index);
    }
    segmentIndexAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = clamp(ratio, 0, 1);
        const opt = this.getOptions(options);
        const len = this.length(opt);
        const length = len * rate;
        return this.segmentIndexAtLength(length, opt);
    }
    segmentIndexAtLength(length, options = {}) {
        const count = this.segments.length;
        if (count === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let memo = 0;
        let lastVisibleIndex = null;
        for (let i = 0; i < count; i += 1) {
            const index = fromStart ? i : count - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const len = segment.length({ precision, subdivisions });
            if (segment.isVisible) {
                if (length <= memo + len) {
                    return index;
                }
                lastVisibleIndex = index;
            }
            memo += len;
        }
        // If length requested is higher than the length of the path, return
        // last visible segment index. If no visible segment, return null.
        return lastVisibleIndex;
    }
    getSegmentSubdivisions(options = {}) {
        const precision = this.getPrecision(options);
        const segmentSubdivisions = [];
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segment.getSubdivisions({ precision });
            segmentSubdivisions.push(subdivisions);
        }
        return segmentSubdivisions;
    }
    updateSubpathStartSegment(segment) {
        let previous = segment.previousSegment;
        let current = segment;
        while (current && !current.isSubpathStart) {
            // assign previous segment's subpath start segment to this segment
            if (previous != null) {
                current.subpathStartSegment = previous.subpathStartSegment;
            }
            else {
                current.subpathStartSegment = null;
            }
            previous = current;
            current = current.nextSegment;
        }
    }
    prepareSegment(segment, previousSegment, nextSegment) {
        segment.previousSegment = previousSegment;
        segment.nextSegment = nextSegment;
        if (previousSegment != null) {
            previousSegment.nextSegment = segment;
        }
        if (nextSegment != null) {
            nextSegment.previousSegment = segment;
        }
        let updateSubpathStart = segment;
        if (segment.isSubpathStart) {
            // move to
            segment.subpathStartSegment = segment;
            updateSubpathStart = nextSegment;
        }
        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments
        if (updateSubpathStart != null) {
            this.updateSubpathStartSegment(updateSubpathStart);
        }
        return segment;
    }
    closestPoint(p, options = {}) {
        const t = this.closestPointT(p, options);
        if (!t) {
            return null;
        }
        return this.pointAtT(t);
    }
    closestPointLength(p, options = {}) {
        const opts = this.getOptions(options);
        const t = this.closestPointT(p, opts);
        if (!t) {
            return 0;
        }
        return this.lengthAtT(t, opts);
    }
    closestPointNormalizedLength(p, options = {}) {
        const opts = this.getOptions(options);
        const cpLength = this.closestPointLength(p, opts);
        if (cpLength === 0) {
            return 0;
        }
        const length = this.length(opts);
        if (length === 0) {
            return 0;
        }
        return cpLength / length;
    }
    closestPointT(p, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let closestPointT;
        let minSquaredDistance = Infinity;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            if (segment.isVisible) {
                const segmentClosestPointT = segment.closestPointT(p, {
                    precision,
                    subdivisions,
                });
                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                const squaredDistance = squaredLength(segmentClosestPoint, p);
                if (squaredDistance < minSquaredDistance) {
                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointT) {
            return closestPointT;
        }
        return { segmentIndex: this.segments.length - 1, value: 1 };
    }
    closestPointTangent(p, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let closestPointTangent;
        let minSquaredDistance = Infinity;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            if (segment.isDifferentiable()) {
                const segmentClosestPointT = segment.closestPointT(p, {
                    precision,
                    subdivisions,
                });
                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                const squaredDistance = squaredLength(segmentClosestPoint, p);
                if (squaredDistance < minSquaredDistance) {
                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointTangent) {
            return closestPointTangent;
        }
        return null;
    }
    containsPoint(p, options = {}) {
        const polylines = this.toPolylines(options);
        if (!polylines) {
            return false;
        }
        let numIntersections = 0;
        for (let i = 0, ii = polylines.length; i < ii; i += 1) {
            const polyline = polylines[i];
            if (polyline.containsPoint(p)) {
                numIntersections += 1;
            }
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return numIntersections % 2 === 1;
    }
    pointAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        if (ratio <= 0) {
            return this.start.clone();
        }
        if (ratio >= 1) {
            return this.end.clone();
        }
        const opts = this.getOptions(options);
        const pathLength = this.length(opts);
        const length = pathLength * ratio;
        return this.pointAtLength(length, opts);
    }
    pointAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        if (length === 0) {
            return this.start.clone();
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let lastVisibleSegment;
        let memo = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const d = segment.length({
                precision,
                subdivisions,
            });
            if (segment.isVisible) {
                if (length <= memo + d) {
                    return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {
                        precision,
                        subdivisions,
                    });
                }
                lastVisibleSegment = segment;
            }
            memo += d;
        }
        // if length requested is higher than the length of the path,
        // return last visible segment endpoint
        if (lastVisibleSegment) {
            return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
        }
        // if no visible segment, return last segment end point
        const lastSegment = this.segments[this.segments.length - 1];
        return lastSegment.end.clone();
    }
    pointAtT(t) {
        const segments = this.segments;
        const numSegments = segments.length;
        if (numSegments === 0)
            return null; // if segments is an empty array
        const segmentIndex = t.segmentIndex;
        if (segmentIndex < 0)
            return segments[0].pointAtT(0);
        if (segmentIndex >= numSegments) {
            return segments[numSegments - 1].pointAtT(1);
        }
        const tValue = clamp(t.value, 0, 1);
        return segments[segmentIndex].pointAtT(tValue);
    }
    divideAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = clamp(ratio, 0, 1);
        const opts = this.getOptions(options);
        const len = this.length(opts);
        const length = len * rate;
        return this.divideAtLength(length, opts);
    }
    divideAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let memo = 0;
        let divided;
        let dividedSegmentIndex;
        let lastValidSegment;
        let lastValidSegmentIndex;
        let t;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.getSegment(index);
            const subdivisions = segmentSubdivisions[index];
            const opts = { precision, subdivisions };
            const len = segment.length(opts);
            if (segment.isDifferentiable()) {
                lastValidSegment = segment;
                lastValidSegmentIndex = index;
                if (length <= memo + len) {
                    dividedSegmentIndex = index;
                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);
                    break;
                }
            }
            memo += len;
        }
        if (!lastValidSegment) {
            return null;
        }
        if (!divided) {
            dividedSegmentIndex = lastValidSegmentIndex;
            t = fromStart ? 1 : 0;
            divided = lastValidSegment.divideAtT(t);
        }
        // create a copy of this path and replace the identified segment with its two divided parts:
        const pathCopy = this.clone();
        const index = dividedSegmentIndex;
        pathCopy.replaceSegment(index, divided);
        const divisionStartIndex = index;
        let divisionMidIndex = index + 1;
        let divisionEndIndex = index + 2;
        // do not insert the part if it looks like a point
        if (!divided[0].isDifferentiable()) {
            pathCopy.removeSegment(divisionStartIndex);
            divisionMidIndex -= 1;
            divisionEndIndex -= 1;
        }
        // insert a Moveto segment to ensure secondPath will be valid:
        const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));
        divisionEndIndex += 1;
        // do not insert the part if it looks like a point
        if (!divided[1].isDifferentiable()) {
            pathCopy.removeSegment(divisionEndIndex - 1);
            divisionEndIndex -= 1;
        }
        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:
        const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
        for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {
            const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
            const segment = pathCopy.getSegment(i);
            if (segment.type === 'Z' &&
                !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
                // pathCopy segment's subpathStartSegment is different from original segment's one
                // convert this Closepath segment to a Lineto and replace it in pathCopy
                const convertedSegment = Path.createSegment('L', originalSegment.end);
                pathCopy.replaceSegment(i, convertedSegment);
            }
        }
        // distribute pathCopy segments into two paths and return those:
        const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));
        const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));
        return [firstPath, secondPath];
    }
    intersectsWithLine(line, options = {}) {
        const polylines = this.toPolylines(options);
        if (polylines == null) {
            return null;
        }
        let intersections = null;
        for (let i = 0, ii = polylines.length; i < ii; i += 1) {
            const polyline = polylines[i];
            const intersection = line.intersect(polyline);
            if (intersection) {
                if (intersections == null) {
                    intersections = [];
                }
                if (Array.isArray(intersection)) {
                    intersections.push(...intersection);
                }
                else {
                    intersections.push(intersection);
                }
            }
        }
        return intersections;
    }
    isDifferentiable() {
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            if (segment.isDifferentiable()) {
                return true;
            }
        }
        return false;
    }
    isValid() {
        const segments = this.segments;
        const isValid = segments.length === 0 || segments[0].type === 'M';
        return isValid;
    }
    length(options = {}) {
        if (this.segments.length === 0) {
            return 0;
        }
        const segmentSubdivisions = this.getSubdivisions(options);
        let length = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            length += segment.length({ subdivisions });
        }
        return length;
    }
    lengthAtT(t, options = {}) {
        const count = this.segments.length;
        if (count === 0) {
            return 0;
        }
        let segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) {
            return 0;
        }
        let tValue = clamp(t.value, 0, 1);
        if (segmentIndex >= count) {
            segmentIndex = count - 1;
            tValue = 1;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let length = 0;
        for (let i = 0; i < segmentIndex; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            length += segment.length({ precision, subdivisions });
        }
        const segment = this.segments[segmentIndex];
        const subdivisions = segmentSubdivisions[segmentIndex];
        length += segment.lengthAtT(tValue, { precision, subdivisions });
        return length;
    }
    tangentAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = clamp(ratio, 0, 1);
        const opts = this.getOptions(options);
        const len = this.length(opts);
        const length = len * rate;
        return this.tangentAtLength(length, opts);
    }
    tangentAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let lastValidSegment;
        let memo = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const len = segment.length({ precision, subdivisions });
            if (segment.isDifferentiable()) {
                if (length <= memo + len) {
                    return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {
                        precision,
                        subdivisions,
                    });
                }
                lastValidSegment = segment;
            }
            memo += len;
        }
        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment
        if (lastValidSegment) {
            const t = fromStart ? 1 : 0;
            return lastValidSegment.tangentAtT(t);
        }
        // if no valid segment, return null
        return null;
    }
    tangentAtT(t) {
        const count = this.segments.length;
        if (count === 0) {
            return null;
        }
        const segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) {
            return this.segments[0].tangentAtT(0);
        }
        if (segmentIndex >= count) {
            return this.segments[count - 1].tangentAtT(1);
        }
        const tValue = clamp(t.value, 0, 1);
        return this.segments[segmentIndex].tangentAtT(tValue);
    }
    getPrecision(options = {}) {
        return options.precision == null ? this.PRECISION : options.precision;
    }
    getSubdivisions(options = {}) {
        if (options.segmentSubdivisions == null) {
            const precision = this.getPrecision(options);
            return this.getSegmentSubdivisions({ precision });
        }
        return options.segmentSubdivisions;
    }
    getOptions(options = {}) {
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        return { precision, segmentSubdivisions };
    }
    toPoints(options = {}) {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        const segmentSubdivisions = this.getSubdivisions(options);
        const points = [];
        let partialPoints = [];
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                const divisions = segmentSubdivisions[i];
                if (divisions.length > 0) {
                    // eslint-disable-next-line no-loop-func
                    divisions.forEach((c) => partialPoints.push(c.start));
                }
                else {
                    partialPoints.push(segment.start);
                }
            }
            else if (partialPoints.length > 0) {
                partialPoints.push(segments[i - 1].end);
                points.push(partialPoints);
                partialPoints = [];
            }
        }
        if (partialPoints.length > 0) {
            partialPoints.push(this.end);
            points.push(partialPoints);
        }
        return points;
    }
    toPolylines(options = {}) {
        const points = this.toPoints(options);
        if (!points) {
            return null;
        }
        return points.map((arr) => new Polyline$2(arr));
    }
    scale(sx, sy, origin) {
        this.segments.forEach((s) => s.scale(sx, sy, origin));
        return this;
    }
    rotate(angle, origin) {
        this.segments.forEach((segment) => segment.rotate(angle, origin));
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.segments.forEach((s) => s.translate(tx, ty));
        }
        else {
            this.segments.forEach((s) => s.translate(tx));
        }
        return this;
    }
    clone() {
        const path = new Path();
        this.segments.forEach((s) => path.appendSegment(s.clone()));
        return path;
    }
    equals(p) {
        if (p == null) {
            return false;
        }
        const segments = this.segments;
        const otherSegments = p.segments;
        const count = segments.length;
        if (otherSegments.length !== count) {
            return false;
        }
        for (let i = 0; i < count; i += 1) {
            const a = segments[i];
            const b = otherSegments[i];
            if (a.type !== b.type || !a.equals(b)) {
                return false;
            }
        }
        return true;
    }
    toJSON() {
        return this.segments.map((s) => s.toJSON());
    }
    serialize() {
        if (!this.isValid()) {
            throw new Error('Invalid path segments.');
        }
        return this.segments.map((s) => s.serialize()).join(' ');
    }
    toString() {
        return this.serialize();
    }
};
(function (Path) {
    Path.toStringTag = `X6.Geometry.${Path.name}`;
    function isPath(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Path) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const path = instance;
        if ((tag == null || tag === Path.toStringTag) &&
            Array.isArray(path.segments) &&
            typeof path.moveTo === 'function' &&
            typeof path.lineTo === 'function' &&
            typeof path.curveTo === 'function') {
            return true;
        }
        return false;
    }
    Path.isPath = isPath;
})(Path$2 || (Path$2 = {}));
(function (Path) {
    function parse(pathData) {
        if (!pathData) {
            return new Path();
        }
        const path = new Path();
        const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
        const commands = Path.normalize(pathData).match(commandRe);
        if (commands != null) {
            for (let i = 0, ii = commands.length; i < ii; i += 1) {
                const command = commands[i];
                const argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
                // args = [type, coordinate1, coordinate2...]
                const args = command.match(argRe);
                if (args != null) {
                    const type = args[0];
                    const coords = args.slice(1).map((a) => +a);
                    const segment = createSegment.call(null, type, ...coords);
                    path.appendSegment(segment);
                }
            }
        }
        return path;
    }
    Path.parse = parse;
    function createSegment(type, ...args) {
        if (type === 'M') {
            return MoveTo.create.call(null, ...args);
        }
        if (type === 'L') {
            return LineTo.create.call(null, ...args);
        }
        if (type === 'C') {
            return CurveTo.create.call(null, ...args);
        }
        if (type === 'z' || type === 'Z') {
            return Close.create();
        }
        throw new Error(`Invalid path segment type "${type}"`);
    }
    Path.createSegment = createSegment;
})(Path$2 || (Path$2 = {}));
(function (Path) {
    Path.normalize = normalizePathData;
    Path.isValid = isValid;
    Path.drawArc = drawArc;
    Path.drawPoints = drawPoints;
    Path.arcToCurves = arcToCurves;
})(Path$2 || (Path$2 = {}));

class Vector {
    constructor(elem, attrs, children) {
        if (!elem) {
            throw new TypeError('Invalid element to create vector');
        }
        let node;
        if (Vector.isVector(elem)) {
            node = elem.node;
        }
        else if (typeof elem === 'string') {
            if (elem.toLowerCase() === 'svg') {
                node = createSvgDocument();
            }
            else if (elem[0] === '<') {
                const doc = createSvgDocument(elem);
                // only import the first child
                node = document.importNode(doc.firstChild, true);
            }
            else {
                node = document.createElementNS(ns.svg, elem);
            }
        }
        else {
            node = elem;
        }
        this.node = node;
        if (attrs) {
            this.setAttributes(attrs);
        }
        if (children) {
            this.append(children);
        }
    }
    get [Symbol.toStringTag]() {
        return Vector.toStringTag;
    }
    get type() {
        return this.node.nodeName;
    }
    get id() {
        return this.node.id;
    }
    set id(id) {
        this.node.id = id;
    }
    transform(matrix, options) {
        if (matrix == null) {
            return transform$1(this.node);
        }
        transform$1(this.node, matrix, options);
        return this;
    }
    translate(tx, ty = 0, options = {}) {
        if (tx == null) {
            return translate(this.node);
        }
        translate(this.node, tx, ty, options);
        return this;
    }
    rotate(angle, cx, cy, options = {}) {
        if (angle == null) {
            return rotate(this.node);
        }
        rotate(this.node, angle, cx, cy, options);
        return this;
    }
    scale(sx, sy) {
        if (sx == null) {
            return scale(this.node);
        }
        scale(this.node, sx, sy);
        return this;
    }
    /**
     * Returns an SVGMatrix that specifies the transformation necessary
     * to convert this coordinate system into `target` coordinate system.
     */
    getTransformToElement(target) {
        const ref = Vector.toNode(target);
        return getTransformToElement(this.node, ref);
    }
    removeAttribute(name) {
        removeAttribute(this.node, name);
        return this;
    }
    getAttribute(name) {
        return getAttribute(this.node, name);
    }
    setAttribute(name, value) {
        setAttribute(this.node, name, value);
        return this;
    }
    setAttributes(attrs) {
        setAttributes(this.node, attrs);
        return this;
    }
    attr(name, value) {
        if (name == null) {
            return attr$1(this.node);
        }
        if (typeof name === 'string' && value === undefined) {
            return attr$1(this.node, name);
        }
        if (typeof name === 'object') {
            attr$1(this.node, name);
        }
        else {
            attr$1(this.node, name, value);
        }
        return this;
    }
    svg() {
        return this.node instanceof SVGSVGElement
            ? this
            : Vector.create(this.node.ownerSVGElement);
    }
    defs() {
        const context = this.svg() || this;
        const defsNode = context.node.getElementsByTagName('defs')[0];
        if (defsNode) {
            return Vector.create(defsNode);
        }
        return Vector.create('defs').appendTo(context);
    }
    text(content, options = {}) {
        text$3(this.node, content, options);
        return this;
    }
    tagName() {
        return tagName(this.node);
    }
    clone() {
        return Vector.create(this.node.cloneNode(true));
    }
    remove() {
        remove(this.node);
        return this;
    }
    empty() {
        empty(this.node);
        return this;
    }
    append(elems) {
        append(this.node, Vector.toNodes(elems));
        return this;
    }
    appendTo(target) {
        appendTo(this.node, Vector.isVector(target) ? target.node : target);
        return this;
    }
    prepend(elems) {
        prepend(this.node, Vector.toNodes(elems));
        return this;
    }
    before(elems) {
        before(this.node, Vector.toNodes(elems));
        return this;
    }
    replace(elem) {
        if (this.node.parentNode) {
            this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);
        }
        return Vector.create(elem);
    }
    first() {
        return this.node.firstChild
            ? Vector.create(this.node.firstChild)
            : null;
    }
    last() {
        return this.node.lastChild
            ? Vector.create(this.node.lastChild)
            : null;
    }
    get(index) {
        const child = this.node.childNodes[index];
        return child ? Vector.create(child) : null;
    }
    indexOf(elem) {
        const children = Array.prototype.slice.call(this.node.childNodes);
        return children.indexOf(Vector.toNode(elem));
    }
    find(selector) {
        const vels = [];
        const nodes = find(this.node, selector);
        if (nodes) {
            for (let i = 0, ii = nodes.length; i < ii; i += 1) {
                vels.push(Vector.create(nodes[i]));
            }
        }
        return vels;
    }
    findOne(selector) {
        const found = findOne(this.node, selector);
        return found ? Vector.create(found) : null;
    }
    findParentByClass(className, terminator) {
        const node = findParentByClass(this.node, className, terminator);
        return node ? Vector.create(node) : null;
    }
    matches(selector) {
        const node = this.node;
        const matches = this.node.matches;
        const matcher = node.matches ||
            node.matchesSelector ||
            node.msMatchesSelector ||
            node.mozMatchesSelector ||
            node.webkitMatchesSelector ||
            node.oMatchesSelector ||
            null;
        return matcher && matcher.call(node, selector);
    }
    contains(child) {
        return contains(this.node, Vector.isVector(child) ? child.node : child);
    }
    wrap(node) {
        const vel = Vector.create(node);
        const parentNode = this.node.parentNode;
        if (parentNode != null) {
            parentNode.insertBefore(vel.node, this.node);
        }
        return vel.append(this);
    }
    parent(type) {
        let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias
        // check for parent
        if (parent.node.parentNode == null) {
            return null;
        }
        // get parent element
        parent = Vector.create(parent.node.parentNode);
        if (type == null) {
            return parent;
        }
        // loop trough ancestors if type is given
        do {
            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {
                return parent;
            }
        } while ((parent = Vector.create(parent.node.parentNode)));
        return parent;
    }
    children() {
        const children = this.node.childNodes;
        const vels = [];
        for (let i = 0; i < children.length; i += 1) {
            const currentChild = children[i];
            if (currentChild.nodeType === 1) {
                vels.push(Vector.create(children[i]));
            }
        }
        return vels;
    }
    eachChild(fn, deep) {
        const children = this.children();
        for (let i = 0, l = children.length; i < l; i += 1) {
            fn.call(children[i], children[i], i, children);
            if (deep) {
                children[i].eachChild(fn, deep);
            }
        }
        return this;
    }
    index() {
        return index$4(this.node);
    }
    hasClass(className) {
        return hasClass(this.node, className);
    }
    addClass(className) {
        addClass(this.node, className);
        return this;
    }
    removeClass(className) {
        removeClass(this.node, className);
        return this;
    }
    toggleClass(className, stateVal) {
        toggleClass(this.node, className, stateVal);
        return this;
    }
    toLocalPoint(x, y) {
        return toLocalPoint(this.node, x, y);
    }
    toGeometryShape() {
        return toGeometryShape(this.node);
    }
    translateCenterToPoint(p) {
        const bbox = this.getBBox({ target: this.svg() });
        const center = bbox.getCenter();
        this.translate(p.x - center.x, p.y - center.y);
        return this;
    }
    translateAndAutoOrient(position, reference, target) {
        translateAndAutoOrient(this.node, position, reference, target);
        return this;
    }
    animate(options) {
        return animate(this.node, options);
    }
    animateTransform(options) {
        return animateTransform(this.node, options);
    }
    animateAlongPath(options, path) {
        return animateAlongPath(this.node, options, path);
    }
    /**
     * Normalize this element's d attribute. SVGPathElements without
     * a path data attribute obtain a value of 'M 0 0'.
     */
    normalizePath() {
        const tagName = this.tagName();
        if (tagName === 'path') {
            this.attr('d', Path$2.normalize(this.attr('d')));
        }
        return this;
    }
    /**
     * Returns the bounding box of the element after transformations are applied.
     * If `withoutTransformations` is `true`, transformations of the element
     * will not be considered when computing the bounding box. If `target` is
     * specified, bounding box will be computed relatively to the target element.
     */
    bbox(withoutTransformations, target) {
        return bbox$1(this.node, withoutTransformations, target);
    }
    getBBox(options = {}) {
        return getBBox(this.node, {
            recursive: options.recursive,
            target: options.target ? Vector.toNode(options.target) : null,
        });
    }
    /**
     * Samples the underlying SVG element (it currently works only on
     * paths - where it is most useful anyway). Returns an array of objects
     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
     * objects represent a point on the path. This basically creates a discrete
     * representation of the path (which is possible a curve). The sampling
     * interval defines the accuracy of the sampling. In other words, we travel
     * from the beginning of the path to the end by interval distance (on the
     * path, not between the resulting points) and collect the discrete points
     * on the path. This is very useful in many situations. For example, SVG
     * does not provide a built-in mechanism to find intersections between two
     * paths. Using sampling, we can just generate bunch of points for each of
     * the path and find the closest ones from each set.
     */
    sample(interval = 1) {
        if (this.node instanceof SVGPathElement) {
            return sample(this.node, interval);
        }
        return [];
    }
    toPath() {
        return Vector.create(toPath(this.node));
    }
    toPathData() {
        return toPathData(this.node);
    }
}
(function (Vector) {
    Vector.toStringTag = `X6.${Vector.name}`;
    function isVector(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Vector) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const vector = instance;
        if ((tag == null || tag === Vector.toStringTag) &&
            vector.node instanceof SVGElement &&
            typeof vector.animate === 'function' &&
            typeof vector.sample === 'function' &&
            typeof vector.normalizePath === 'function' &&
            typeof vector.toPath === 'function') {
            return true;
        }
        return false;
    }
    Vector.isVector = isVector;
    function create(elem, attrs, children) {
        return new Vector(elem, attrs, children);
    }
    Vector.create = create;
    function createVectors(markup) {
        if (markup[0] === '<') {
            const svgDoc = createSvgDocument(markup);
            const vels = [];
            for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
                const childNode = svgDoc.childNodes[i];
                vels.push(create(document.importNode(childNode, true)));
            }
            return vels;
        }
        return [create(markup)];
    }
    Vector.createVectors = createVectors;
    function toNode(elem) {
        if (isVector(elem)) {
            return elem.node;
        }
        return elem;
    }
    Vector.toNode = toNode;
    function toNodes(elems) {
        if (Array.isArray(elems)) {
            return elems.map((elem) => toNode(elem));
        }
        return [toNode(elems)];
    }
    Vector.toNodes = toNodes;
})(Vector || (Vector = {}));

/* eslint-disable no-control-regex */
function createTextPathNode(attrs, elem) {
    const vel = Vector.create(elem);
    const textPath = Vector.create('textPath');
    const d = attrs.d;
    if (d && attrs['xlink:href'] === undefined) {
        const path = Vector.create('path').attr('d', d).appendTo(vel.defs());
        textPath.attr('xlink:href', `#${path.id}`);
    }
    if (typeof attrs === 'object') {
        textPath.attr(attrs);
    }
    return textPath.node;
}
function annotateTextLine(lineNode, lineAnnotations, options) {
    const eol = options.eol;
    const baseSize = options.baseSize;
    const lineHeight = options.lineHeight;
    let maxFontSize = 0;
    let tspanNode;
    const fontMetrics = {};
    const lastJ = lineAnnotations.length - 1;
    for (let j = 0; j <= lastJ; j += 1) {
        let annotation = lineAnnotations[j];
        let fontSize = null;
        if (typeof annotation === 'object') {
            const annotationAttrs = annotation.attrs;
            const vTSpan = Vector.create('tspan', annotationAttrs);
            tspanNode = vTSpan.node;
            let t = annotation.t;
            if (eol && j === lastJ) {
                t += eol;
            }
            tspanNode.textContent = t;
            // Per annotation className
            const annotationClass = annotationAttrs.class;
            if (annotationClass) {
                vTSpan.addClass(annotationClass);
            }
            // set the list of indices of all the applied annotations
            // in the `annotations` attribute. This list is a comma
            // separated list of indices.
            if (options.includeAnnotationIndices) {
                vTSpan.attr('annotations', annotation.annotations.join(','));
            }
            // Check for max font size
            fontSize = parseFloat(annotationAttrs['font-size']);
            if (fontSize === undefined)
                fontSize = baseSize;
            if (fontSize && fontSize > maxFontSize)
                maxFontSize = fontSize;
        }
        else {
            if (eol && j === lastJ) {
                annotation += eol;
            }
            tspanNode = document.createTextNode(annotation || ' ');
            if (baseSize && baseSize > maxFontSize) {
                maxFontSize = baseSize;
            }
        }
        lineNode.appendChild(tspanNode);
    }
    if (maxFontSize) {
        fontMetrics.maxFontSize = maxFontSize;
    }
    if (lineHeight) {
        fontMetrics.lineHeight = lineHeight;
    }
    else if (maxFontSize) {
        fontMetrics.lineHeight = maxFontSize * 1.2;
    }
    return fontMetrics;
}
const emRegex = /em$/;
function emToPx(em, fontSize) {
    const numerical = parseFloat(em);
    if (emRegex.test(em)) {
        return numerical * fontSize;
    }
    return numerical;
}
function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
    if (!Array.isArray(linesMetrics)) {
        return 0;
    }
    const n = linesMetrics.length;
    if (!n)
        return 0;
    let lineMetrics = linesMetrics[0];
    const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
    let rLineHeights = 0;
    const lineHeightPx = emToPx(lineHeight, baseSizePx);
    for (let i = 1; i < n; i += 1) {
        lineMetrics = linesMetrics[i];
        const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
        rLineHeights += iLineHeight;
    }
    const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
    let dy;
    switch (alignment) {
        case 'middle':
            dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
            break;
        case 'bottom':
            dy = -(0.25 * llMaxFont) - rLineHeights;
            break;
        default:
        case 'top':
            dy = 0.8 * flMaxFont;
            break;
    }
    return dy;
}
function text$3(elem, content, options = {}) {
    content = sanitize$1(content); // eslint-disable-line
    const eol = options.eol;
    let textPath = options.textPath;
    const verticalAnchor = options.textVerticalAnchor;
    const namedVerticalAnchor = verticalAnchor === 'middle' ||
        verticalAnchor === 'bottom' ||
        verticalAnchor === 'top';
    // Horizontal shift applied to all the lines but the first.
    let x = options.x;
    if (x === undefined) {
        x = elem.getAttribute('x') || 0;
    }
    // Annotations
    const iai = options.includeAnnotationIndices;
    let annotations = options.annotations;
    if (annotations && !Array.isArray(annotations)) {
        annotations = [annotations];
    }
    // Shift all the <tspan> but first by one line (`1em`)
    const defaultLineHeight = options.lineHeight;
    const autoLineHeight = defaultLineHeight === 'auto';
    const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
    empty(elem);
    attr$1(elem, {
        // Preserve spaces, do not consecutive spaces to get collapsed to one.
        'xml:space': 'preserve',
        // An empty text gets rendered into the DOM in webkit-based browsers.
        // In order to unify this behaviour across all browsers
        // we rather hide the text element when it's empty.
        display: content || options.displayEmpty ? null : 'none',
    });
    // Set default font-size if none
    const strFontSize = attr$1(elem, 'font-size');
    let fontSize = parseFloat(strFontSize);
    if (!fontSize) {
        fontSize = 16;
        if ((namedVerticalAnchor || annotations) && !strFontSize) {
            attr$1(elem, 'font-size', `${fontSize}`);
        }
    }
    let containerNode;
    if (textPath) {
        // Now all the `<tspan>`s will be inside the `<textPath>`.
        if (typeof textPath === 'string') {
            textPath = { d: textPath };
        }
        containerNode = createTextPathNode(textPath, elem);
    }
    else {
        containerNode = document.createDocumentFragment();
    }
    let dy;
    let offset = 0;
    let annotatedY;
    const lines = content.split('\n');
    const linesMetrics = [];
    const lastI = lines.length - 1;
    for (let i = 0; i <= lastI; i += 1) {
        dy = lineHeight;
        let lineClassName = 'v-line';
        const lineNode = createSvgElement('tspan');
        let lineMetrics;
        let line = lines[i];
        if (line) {
            if (annotations) {
                // Find the *compacted* annotations for this line.
                const lineAnnotations = annotate$1(line, annotations, {
                    offset: -offset,
                    includeAnnotationIndices: iai,
                });
                lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
                    eol: i !== lastI && eol,
                    baseSize: fontSize,
                    lineHeight: autoLineHeight ? null : lineHeight,
                    includeAnnotationIndices: iai,
                });
                // Get the line height based on the biggest font size
                // in the annotations for this line.
                const iLineHeight = lineMetrics.lineHeight;
                if (iLineHeight && autoLineHeight && i !== 0) {
                    dy = iLineHeight;
                }
                if (i === 0) {
                    annotatedY = lineMetrics.maxFontSize * 0.8;
                }
            }
            else {
                if (eol && i !== lastI) {
                    line += eol;
                }
                lineNode.textContent = line;
            }
        }
        else {
            // Make sure the textContent is never empty. If it is, add a dummy
            // character and make it invisible, making the following lines correctly
            // relatively positioned. `dy=1em` won't work with empty lines otherwise.
            lineNode.textContent = '-';
            lineClassName += ' v-empty-line';
            const lineNodeStyle = lineNode.style;
            lineNodeStyle.fillOpacity = 0;
            lineNodeStyle.strokeOpacity = 0;
            if (annotations) {
                lineMetrics = {};
            }
        }
        if (lineMetrics) {
            linesMetrics.push(lineMetrics);
        }
        if (i > 0) {
            lineNode.setAttribute('dy', dy);
        }
        // Firefox requires 'x' to be set on the first line
        if (i > 0 || textPath) {
            lineNode.setAttribute('x', x);
        }
        lineNode.className.baseVal = lineClassName;
        containerNode.appendChild(lineNode);
        offset += line.length + 1; // + 1 = newline character.
    }
    // Y Alignment calculation
    if (namedVerticalAnchor) {
        if (annotations) {
            dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
        }
        else if (verticalAnchor === 'top') {
            // A shortcut for top alignment. It does not depend on font-size nor line-height
            dy = '0.8em';
        }
        else {
            let rh; // remaining height
            if (lastI > 0) {
                rh = parseFloat(lineHeight) || 1;
                rh *= lastI;
                if (!emRegex.test(lineHeight))
                    rh /= fontSize;
            }
            else {
                // Single-line text
                rh = 0;
            }
            switch (verticalAnchor) {
                case 'middle':
                    dy = `${0.3 - rh / 2}em`;
                    break;
                case 'bottom':
                    dy = `${-rh - 0.3}em`;
                    break;
                default:
                    break;
            }
        }
    }
    else if (verticalAnchor === 0) {
        dy = '0em';
    }
    else if (verticalAnchor) {
        dy = verticalAnchor;
    }
    else {
        // No vertical anchor is defined
        dy = 0;
        // Backwards compatibility - we change the `y` attribute instead of `dy`.
        if (elem.getAttribute('y') == null) {
            elem.setAttribute('y', `${annotatedY || '0.8em'}`);
        }
    }
    const firstLine = containerNode.firstChild;
    firstLine.setAttribute('dy', dy);
    elem.appendChild(containerNode);
}
function splitText(text, separator, eol, hyphen) {
    const words = [];
    const separators = [];
    if (separator != null) {
        const parts = text.split(separator);
        words.push(...parts);
        if (typeof separator === 'string') {
            for (let i = 0, l = parts.length - 1; i < l; i += 1) {
                separators.push(separator);
            }
        }
        else {
            const seps = text.match(new RegExp(separator, 'g'));
            for (let i = 0, l = parts.length - 1; i < l; i += 1) {
                separators.push(seps ? seps[i] : '');
            }
        }
    }
    else {
        let word = '';
        for (let i = 0, l = text.length; i < l; i += 1) {
            const char = text[i];
            if (char === ' ') {
                words.push(word);
                separators.push(' ');
                word = '';
            }
            else if (char.match(/[^\x00-\xff]/)) {
                // split double byte character
                if (word.length) {
                    words.push(word);
                    separators.push('');
                }
                words.push(char);
                separators.push('');
                word = '';
            }
            else {
                word += char;
            }
        }
        if (word.length) {
            words.push(word);
        }
    }
    // end-of-line
    for (let i = 0; i < words.length; i += 1) {
        const word = words[i];
        if (word.indexOf(eol) >= 0 && word.length > 1) {
            const parts = word.split(eol);
            for (let j = 0, k = parts.length - 1; j < k; j += 1) {
                parts.splice(2 * j + 1, 0, eol);
            }
            const valids = parts.filter((part) => part !== '');
            words.splice(i, 1, ...valids);
            const seps = valids.map(() => '');
            seps.pop();
            separators.splice(i, 0, ...seps);
        }
    }
    // hyphen
    for (let i = 0; i < words.length; i += 1) {
        const word = words[i];
        const index = word.search(hyphen);
        if (index > 0 && index < word.length - 1) {
            words.splice(i, 1, word.substring(0, index + 1), word.substring(index + 1));
            separators.splice(i, 0, '');
        }
    }
    return { words, separators };
}
function breakText(text, size, styles = {}, options = {}) {
    const width = size.width;
    const height = size.height;
    const svgDocument = options.svgDocument || createSvgElement('svg');
    const telem = createSvgElement('text');
    const tspan = createSvgElement('tspan');
    const tnode = document.createTextNode('');
    attr$1(telem, styles);
    telem.appendChild(tspan);
    // Prevent flickering
    telem.style.opacity = '0';
    // Prevent FF from throwing an uncaught exception when `getBBox()`
    // called on element that is not in the render tree (is not measurable).
    // <tspan>.getComputedTextLength() returns always 0 in this case.
    // Note that the `textElement` resp. `textSpan` can become hidden
    // when it's appended to the DOM and a `display: none` CSS stylesheet
    // rule gets applied.
    telem.style.display = 'block';
    tspan.style.display = 'block';
    tspan.appendChild(tnode);
    svgDocument.appendChild(telem);
    const shouldAppend = svgDocument.parentNode == null;
    if (shouldAppend) {
        document.body.appendChild(svgDocument);
    }
    const eol = options.eol || '\n';
    const separator = options.separator || ' ';
    const hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\w\d]/;
    const breakWord = options.breakWord !== false;
    const full = [];
    const lineSeprators = {};
    let lines = [];
    let partIndex;
    // let hyphenIndex
    let lineHeight;
    let currentSeparator;
    const { words, separators } = splitText(text, options.separator, eol, hyphen);
    for (let wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {
        const word = words[wordIndex];
        // empty word
        if (!word) {
            continue;
        }
        // end of line
        if (word === eol) {
            full[lineIndex] = true;
            // start a new line
            lineIndex += 1;
            lines[lineIndex] = '';
            continue;
        }
        if (lines[lineIndex] != null) {
            currentSeparator = separators[wordIndex - 1] || '';
            tnode.data = `${lines[lineIndex]}${currentSeparator}${word}`;
        }
        else {
            tnode.data = word;
        }
        if (tspan.getComputedTextLength() <= width) {
            // update line
            lines[lineIndex] = tnode.data;
            lineSeprators[lineIndex] = separators[wordIndex];
            // when is partitioning, put rest of the word onto next line
            if (partIndex) {
                full[lineIndex] = true;
                lineIndex += 1;
                partIndex = 0;
            }
        }
        else {
            if (breakWord) {
                // word is too long to put in one line or is partitioning
                if (!lines[lineIndex] || partIndex) {
                    const isPartition = !!partIndex;
                    const isCharacter = word.length === 1;
                    partIndex = word.length - 1;
                    if (isPartition || isCharacter) {
                        // word has only one character.
                        if (isCharacter) {
                            if (!lines[lineIndex]) {
                                // can't fit this text within our rect
                                lines = [];
                                break;
                            }
                            // partitioning didn't help on the non-empty line
                            // try again, but this time start with a new line
                            // cancel partitions created
                            words.splice(wordIndex, 2, word + words[wordIndex + 1]);
                            separators.splice(wordIndex + 1, 1);
                            full[lineIndex] = true;
                            lineIndex += 1;
                            wordCount -= 1;
                            wordIndex -= 1;
                            continue;
                        }
                        // update the partitioning words
                        words[wordIndex] = word.substring(0, partIndex);
                        words[wordIndex + 1] =
                            word.substring(partIndex) + words[wordIndex + 1];
                    }
                    else {
                        // partitioning the long word into two words
                        words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));
                        separators.splice(wordIndex, 0, '');
                        wordCount += 1;
                        // if the previous line is not full
                        if (lineIndex && !full[lineIndex - 1]) {
                            lineIndex -= 1;
                        }
                    }
                    wordIndex -= 1;
                    continue;
                }
            }
            else if (!lines[lineIndex]) {
                lines[lineIndex] = word;
                full[lineIndex] = true;
                lineIndex += 1;
                continue;
            }
            lineIndex += 1;
            wordIndex -= 1;
        }
        // check whether the height of the entire text exceeds the rect height
        if (height != null) {
            // ensure line height
            if (lineHeight == null) {
                let heightValue;
                // use the same defaults as in V.prototype.text
                if (styles.lineHeight === 'auto') {
                    heightValue = { value: 1.5, unit: 'em' };
                }
                else {
                    heightValue = parseCssNumeric(styles.lineHeight, [
                        'em',
                    ]) || {
                        value: 1,
                        unit: 'em',
                    };
                }
                lineHeight = heightValue.value;
                if (heightValue.unit === 'em') {
                    if (Platform.IS_FIREFOX) {
                        lineHeight *= tspan.getBBox().height;
                    }
                    else {
                        lineHeight *= telem.getBBox().height;
                    }
                }
            }
            if (lineHeight * lines.length > height) {
                // remove overflowing lines
                const lastLineIndex = Math.floor(height / lineHeight) - 1;
                const lastLine = lines[lastLineIndex];
                const overflowLine = lines[lastLineIndex + 1];
                lines.splice(lastLineIndex + 1);
                if (lastLine == null) {
                    break;
                }
                // add ellipsis
                let ellipsis = options.ellipsis;
                if (!ellipsis) {
                    break;
                }
                if (typeof ellipsis !== 'string') {
                    ellipsis = '\u2026';
                }
                let fullLastLine = lastLine;
                if (overflowLine && breakWord) {
                    fullLastLine += currentSeparator + overflowLine;
                }
                let lastCharIndex = fullLastLine.length;
                let fixedLastLine;
                let lastChar;
                do {
                    lastChar = fullLastLine[lastCharIndex];
                    fixedLastLine = fullLastLine.substring(0, lastCharIndex);
                    if (!lastChar) {
                        fixedLastLine += lineSeprators[lastLineIndex];
                    }
                    else if (lastChar.match(separator)) {
                        fixedLastLine += lastChar;
                    }
                    fixedLastLine += ellipsis;
                    tnode.data = fixedLastLine;
                    if (tspan.getComputedTextLength() <= width) {
                        lines[lastLineIndex] = fixedLastLine;
                        break;
                    }
                    lastCharIndex -= 1;
                } while (lastCharIndex >= 0);
                break;
            }
        }
    }
    if (shouldAppend) {
        remove(svgDocument);
    }
    else {
        remove(telem);
    }
    return lines.join(eol);
}

const KAPPA = 0.551784;
function getNumbericAttribute(elem, attr, defaultValue = NaN) {
    const v = elem.getAttribute(attr);
    if (v == null) {
        return defaultValue;
    }
    const n = parseFloat(v);
    return Number.isNaN(n) ? defaultValue : n;
}
function sample(elem, interval = 1) {
    const length = elem.getTotalLength();
    const samples = [];
    let distance = 0;
    let sample;
    while (distance < length) {
        sample = elem.getPointAtLength(distance);
        samples.push({ distance, x: sample.x, y: sample.y });
        distance += interval;
    }
    return samples;
}
function lineToPathData(line) {
    return [
        'M',
        getNumbericAttribute(line, 'x1'),
        getNumbericAttribute(line, 'y1'),
        'L',
        getNumbericAttribute(line, 'x2'),
        getNumbericAttribute(line, 'y2'),
    ].join(' ');
}
function polygonToPathData(polygon) {
    const points = getPointsFromSvgElement(polygon);
    if (points.length === 0) {
        return null;
    }
    return `${svgPointsToPath(points)} Z`;
}
function polylineToPathData(polyline) {
    const points = getPointsFromSvgElement(polyline);
    if (points.length === 0) {
        return null;
    }
    return svgPointsToPath(points);
}
function svgPointsToPath(points) {
    const arr = points.map((p) => `${p.x} ${p.y}`);
    return `M ${arr.join(' L')}`;
}
function getPointsFromSvgElement(elem) {
    const points = [];
    const nodePoints = elem.points;
    if (nodePoints) {
        for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
            points.push(nodePoints.getItem(i));
        }
    }
    return points;
}
function circleToPathData(circle) {
    const cx = getNumbericAttribute(circle, 'cx', 0);
    const cy = getNumbericAttribute(circle, 'cy', 0);
    const r = getNumbericAttribute(circle, 'r');
    const cd = r * KAPPA; // Control distance.
    return [
        'M',
        cx,
        cy - r,
        'C',
        cx + cd,
        cy - r,
        cx + r,
        cy - cd,
        cx + r,
        cy,
        'C',
        cx + r,
        cy + cd,
        cx + cd,
        cy + r,
        cx,
        cy + r,
        'C',
        cx - cd,
        cy + r,
        cx - r,
        cy + cd,
        cx - r,
        cy,
        'C',
        cx - r,
        cy - cd,
        cx - cd,
        cy - r,
        cx,
        cy - r,
        'Z',
    ].join(' ');
}
function ellipseToPathData(ellipse) {
    const cx = getNumbericAttribute(ellipse, 'cx', 0);
    const cy = getNumbericAttribute(ellipse, 'cy', 0);
    const rx = getNumbericAttribute(ellipse, 'rx');
    const ry = getNumbericAttribute(ellipse, 'ry') || rx;
    const cdx = rx * KAPPA; // Control distance x.
    const cdy = ry * KAPPA; // Control distance y.
    const d = [
        'M',
        cx,
        cy - ry,
        'C',
        cx + cdx,
        cy - ry,
        cx + rx,
        cy - cdy,
        cx + rx,
        cy,
        'C',
        cx + rx,
        cy + cdy,
        cx + cdx,
        cy + ry,
        cx,
        cy + ry,
        'C',
        cx - cdx,
        cy + ry,
        cx - rx,
        cy + cdy,
        cx - rx,
        cy,
        'C',
        cx - rx,
        cy - cdy,
        cx - cdx,
        cy - ry,
        cx,
        cy - ry,
        'Z',
    ].join(' ');
    return d;
}
function rectangleToPathData(rect) {
    return rectToPathData({
        x: getNumbericAttribute(rect, 'x', 0),
        y: getNumbericAttribute(rect, 'y', 0),
        width: getNumbericAttribute(rect, 'width', 0),
        height: getNumbericAttribute(rect, 'height', 0),
        rx: getNumbericAttribute(rect, 'rx', 0),
        ry: getNumbericAttribute(rect, 'ry', 0),
    });
}
function rectToPathData(r) {
    let d;
    const x = r.x;
    const y = r.y;
    const width = r.width;
    const height = r.height;
    const topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);
    const bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);
    const topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);
    const bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);
    if (topRx || bottomRx || topRy || bottomRy) {
        d = [
            'M',
            x,
            y + topRy,
            'v',
            height - topRy - bottomRy,
            'a',
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            bottomRy,
            'h',
            width - 2 * bottomRx,
            'a',
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            -bottomRy,
            'v',
            -(height - bottomRy - topRy),
            'a',
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            -topRy,
            'h',
            -(width - 2 * topRx),
            'a',
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            topRy,
            'Z',
        ];
    }
    else {
        d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];
    }
    return d.join(' ');
}
function toPath(elem) {
    const path = createSvgElement('path');
    attr$1(path, attr$1(elem));
    const d = toPathData(elem);
    if (d) {
        path.setAttribute('d', d);
    }
    return path;
}
function toPathData(elem) {
    const tagName = elem.tagName.toLowerCase();
    switch (tagName) {
        case 'path':
            return elem.getAttribute('d');
        case 'line':
            return lineToPathData(elem);
        case 'polygon':
            return polygonToPathData(elem);
        case 'polyline':
            return polylineToPathData(elem);
        case 'ellipse':
            return ellipseToPathData(elem);
        case 'circle':
            return circleToPathData(elem);
        case 'rect':
            return rectangleToPathData(elem);
        default:
            break;
    }
    throw new Error(`"${tagName}" cannot be converted to svg path element.`);
}
// Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js
function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {
    const svgArcMax = 2 * Math.PI - 1e-6;
    const r0 = innerRadius;
    const r1 = outerRadius;
    let a0 = startAngle;
    let a1 = endAngle;
    if (a1 < a0) {
        const tmp = a0;
        a0 = a1;
        a1 = tmp;
    }
    const da = a1 - a0;
    const df = da < Math.PI ? '0' : '1';
    const c0 = Math.cos(a0);
    const s0 = Math.sin(a0);
    const c1 = Math.cos(a1);
    const s1 = Math.sin(a1);
    return da >= svgArcMax
        ? r0
            ? // eslint-disable-next-line
                `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}M0,${r0}A${r0},${r0} 0 1,0 0,${-r0}A${r0},${r0} 0 1,0 0,${r0}Z`
            : // eslint-disable-next-line
                `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}Z`
        : r0
            ? // eslint-disable-next-line
                `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L${r0 * c1},${r0 * s1}A${r0},${r0} 0 ${df},0 ${r0 * c0},${r0 * s0}Z`
            : // eslint-disable-next-line
                `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L0,0` +
                    `Z`;
}

const svgDocument = createSvgElement('svg');
const transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
const transformSeparatorRegex = /[ ,]+/;
const transformationListRegex = /^(\w+)\((.*)\)/;
/**
 * Returns a SVG point object initialized with the `x` and `y` coordinates.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint
 */
function createSVGPoint(x, y) {
    const p = svgDocument.createSVGPoint();
    p.x = x;
    p.y = y;
    return p;
}
/**
 * Returns the SVG transformation matrix initialized with the given matrix.
 *
 * The given matrix is an object of the form:
 * {
 *   a: number
 *   b: number
 *   c: number
 *   d: number
 *   e: number
 *   f: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */
function createSVGMatrix(matrix) {
    const mat = svgDocument.createSVGMatrix();
    if (matrix != null) {
        const source = matrix;
        const target = mat;
        // eslint-disable-next-line
        for (const key in source) {
            target[key] = source[key];
        }
    }
    return mat;
}
/**
 * Returns a SVG transform object.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform
 */
function createSVGTransform(matrix) {
    if (matrix != null) {
        if (!(matrix instanceof DOMMatrix)) {
            matrix = createSVGMatrix(matrix); // eslint-disable-line
        }
        return svgDocument.createSVGTransformFromMatrix(matrix);
    }
    return svgDocument.createSVGTransform();
}
/**
 * Returns the SVG transformation matrix built from the `transformString`.
 *
 * E.g. 'translate(10,10) scale(2,2)' will result in matrix:
 * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`
 */
function transformStringToMatrix(transform) {
    let mat = createSVGMatrix();
    const matches = transform != null && transform.match(transformRegex);
    if (!matches) {
        return mat;
    }
    for (let i = 0, n = matches.length; i < n; i += 1) {
        const transformationString = matches[i];
        const transformationMatch = transformationString.match(transformationListRegex);
        if (transformationMatch) {
            let sx;
            let sy;
            let tx;
            let ty;
            let angle;
            let ctm = createSVGMatrix();
            const args = transformationMatch[2].split(transformSeparatorRegex);
            switch (transformationMatch[1].toLowerCase()) {
                case 'scale':
                    sx = parseFloat(args[0]);
                    sy = args[1] === undefined ? sx : parseFloat(args[1]);
                    ctm = ctm.scaleNonUniform(sx, sy);
                    break;
                case 'translate':
                    tx = parseFloat(args[0]);
                    ty = parseFloat(args[1]);
                    ctm = ctm.translate(tx, ty);
                    break;
                case 'rotate':
                    angle = parseFloat(args[0]);
                    tx = parseFloat(args[1]) || 0;
                    ty = parseFloat(args[2]) || 0;
                    if (tx !== 0 || ty !== 0) {
                        ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
                    }
                    else {
                        ctm = ctm.rotate(angle);
                    }
                    break;
                case 'skewx':
                    angle = parseFloat(args[0]);
                    ctm = ctm.skewX(angle);
                    break;
                case 'skewy':
                    angle = parseFloat(args[0]);
                    ctm = ctm.skewY(angle);
                    break;
                case 'matrix':
                    ctm.a = parseFloat(args[0]);
                    ctm.b = parseFloat(args[1]);
                    ctm.c = parseFloat(args[2]);
                    ctm.d = parseFloat(args[3]);
                    ctm.e = parseFloat(args[4]);
                    ctm.f = parseFloat(args[5]);
                    break;
                default:
                    continue;
            }
            mat = mat.multiply(ctm);
        }
    }
    return mat;
}
function matrixToTransformString(matrix) {
    const m = matrix || {};
    const a = m.a != null ? m.a : 1;
    const b = m.b != null ? m.b : 0;
    const c = m.c != null ? m.c : 0;
    const d = m.d != null ? m.d : 1;
    const e = m.e != null ? m.e : 0;
    const f = m.f != null ? m.f : 0;
    return `matrix(${a},${b},${c},${d},${e},${f})`;
}
function parseTransformString(transform) {
    let translation;
    let rotation;
    let scale;
    if (transform) {
        const separator = transformSeparatorRegex;
        // Allow reading transform string with a single matrix
        if (transform.trim().indexOf('matrix') >= 0) {
            const matrix = transformStringToMatrix(transform);
            const decomposedMatrix = decomposeMatrix(matrix);
            translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
            rotation = [decomposedMatrix.rotation];
            scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
            const transformations = [];
            if (translation[0] !== 0 || translation[1] !== 0) {
                transformations.push(`translate(${translation.join(',')})`);
            }
            if (scale[0] !== 1 || scale[1] !== 1) {
                transformations.push(`scale(${scale.join(',')})`);
            }
            if (rotation[0] !== 0) {
                transformations.push(`rotate(${rotation[0]})`);
            }
            transform = transformations.join(' '); // eslint-disable-line
        }
        else {
            const translateMatch = transform.match(/translate\((.*?)\)/);
            if (translateMatch) {
                translation = translateMatch[1].split(separator);
            }
            const rotateMatch = transform.match(/rotate\((.*?)\)/);
            if (rotateMatch) {
                rotation = rotateMatch[1].split(separator);
            }
            const scaleMatch = transform.match(/scale\((.*?)\)/);
            if (scaleMatch) {
                scale = scaleMatch[1].split(separator);
            }
        }
    }
    const sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
    return {
        raw: transform || '',
        translation: {
            tx: translation && translation[0]
                ? parseInt(translation[0], 10)
                : 0,
            ty: translation && translation[1]
                ? parseInt(translation[1], 10)
                : 0,
        },
        rotation: {
            angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
            cx: rotation && rotation[1]
                ? parseInt(rotation[1], 10)
                : undefined,
            cy: rotation && rotation[2]
                ? parseInt(rotation[2], 10)
                : undefined,
        },
        scale: {
            sx,
            sy: scale && scale[1] ? parseFloat(scale[1]) : sx,
        },
    };
}
function deltaTransformPoint(matrix, point) {
    const dx = point.x * matrix.a + point.y * matrix.c + 0;
    const dy = point.x * matrix.b + point.y * matrix.d + 0;
    return { x: dx, y: dy };
}
/**
 * Decomposes the SVG transformation matrix into separate transformations.
 *
 * Returns an object of the form:
 * {
 *   translateX: number
 *   translateY: number
 *   scaleX: number
 *   scaleY: number
 *   skewX: number
 *   skewY: number
 *   rotation: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */
function decomposeMatrix(matrix) {
    // @see https://gist.github.com/2052247
    const px = deltaTransformPoint(matrix, { x: 0, y: 1 });
    const py = deltaTransformPoint(matrix, { x: 1, y: 0 });
    const skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90;
    const skewY = (180 / Math.PI) * Math.atan2(py.y, py.x);
    return {
        skewX,
        skewY,
        translateX: matrix.e,
        translateY: matrix.f,
        scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
        scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
        rotation: skewX,
    };
}
function matrixToScale(matrix) {
    let a;
    let b;
    let c;
    let d;
    if (matrix) {
        a = matrix.a == null ? 1 : matrix.a;
        d = matrix.d == null ? 1 : matrix.d;
        b = matrix.b;
        c = matrix.c;
    }
    else {
        a = d = 1;
    }
    return {
        sx: b ? Math.sqrt(a * a + b * b) : a,
        sy: c ? Math.sqrt(c * c + d * d) : d,
    };
}
function matrixToRotation(matrix) {
    let p = { x: 0, y: 1 };
    if (matrix) {
        p = deltaTransformPoint(matrix, p);
    }
    return {
        angle: Angle.normalize(Angle.toDeg(Math.atan2(p.y, p.x)) - 90),
    };
}
function matrixToTranslation(matrix) {
    return {
        tx: (matrix && matrix.e) || 0,
        ty: (matrix && matrix.f) || 0,
    };
}
/**
 * Transforms point by an SVG transformation represented by `matrix`.
 */
function transformPoint(point, matrix) {
    const ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);
    return new Point(ret.x, ret.y);
}
/**
 * Transforms line by an SVG transformation represented by `matrix`.
 */
function transformLine(line, matrix) {
    return new Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));
}
/**
 * Transforms polyline by an SVG transformation represented by `matrix`.
 */
function transformPolyline(polyline, matrix) {
    let points = polyline instanceof Polyline$2 ? polyline.points : polyline;
    if (!Array.isArray(points)) {
        points = [];
    }
    return new Polyline$2(points.map((p) => transformPoint(p, matrix)));
}
function transformRectangle(rect, matrix) {
    const p = svgDocument.createSVGPoint();
    p.x = rect.x;
    p.y = rect.y;
    const corner1 = p.matrixTransform(matrix);
    p.x = rect.x + rect.width;
    p.y = rect.y;
    const corner2 = p.matrixTransform(matrix);
    p.x = rect.x + rect.width;
    p.y = rect.y + rect.height;
    const corner3 = p.matrixTransform(matrix);
    p.x = rect.x;
    p.y = rect.y + rect.height;
    const corner4 = p.matrixTransform(matrix);
    const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
    const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
    const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
    const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
    return new Rectangle(minX, minY, maxX - minX, maxY - minY);
}

var __rest$x = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Returns the bounding box of the element after transformations are
 * applied. If `withoutTransformations` is `true`, transformations of
 * the element will not be considered when computing the bounding box.
 * If `target` is specified, bounding box will be computed relatively
 * to the `target` element.
 */
function bbox$1(elem, withoutTransformations, target) {
    let box;
    const ownerSVGElement = elem.ownerSVGElement;
    // If the element is not in the live DOM, it does not have a bounding
    // box defined and so fall back to 'zero' dimension element.
    if (!ownerSVGElement) {
        return new Rectangle(0, 0, 0, 0);
    }
    try {
        box = elem.getBBox();
    }
    catch (e) {
        // Fallback for IE.
        box = {
            x: elem.clientLeft,
            y: elem.clientTop,
            width: elem.clientWidth,
            height: elem.clientHeight,
        };
    }
    if (withoutTransformations) {
        return Rectangle.create(box);
    }
    const matrix = getTransformToElement(elem, target || ownerSVGElement);
    return transformRectangle(box, matrix);
}
/**
 * Returns the bounding box of the element after transformations are
 * applied. Unlike `bbox()`, this function fixes a browser implementation
 * bug to return the correct bounding box if this elemenent is a group of
 * svg elements (if `options.recursive` is specified).
 */
function getBBox(elem, options = {}) {
    let outputBBox;
    const ownerSVGElement = elem.ownerSVGElement;
    // If the element is not in the live DOM, it does not have a bounding box
    // defined and so fall back to 'zero' dimension element.
    // If the element is not an SVGGraphicsElement, we could not measure the
    // bounding box either
    if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {
        if (isHTMLElement(elem)) {
            // If the element is a HTMLElement, return the position relative to the body
            const { left, top, width, height } = getBoundingOffsetRect(elem);
            return new Rectangle(left, top, width, height);
        }
        return new Rectangle(0, 0, 0, 0);
    }
    let target = options.target;
    const recursive = options.recursive;
    if (!recursive) {
        try {
            outputBBox = elem.getBBox();
        }
        catch (e) {
            outputBBox = {
                x: elem.clientLeft,
                y: elem.clientTop,
                width: elem.clientWidth,
                height: elem.clientHeight,
            };
        }
        if (!target) {
            return Rectangle.create(outputBBox);
        }
        // transform like target
        const matrix = getTransformToElement(elem, target);
        return transformRectangle(outputBBox, matrix);
    }
    // recursive
    {
        const children = elem.childNodes;
        const n = children.length;
        if (n === 0) {
            return getBBox(elem, { target });
        }
        if (!target) {
            target = elem; // eslint-disable-line
        }
        for (let i = 0; i < n; i += 1) {
            const child = children[i];
            let childBBox;
            if (child.childNodes.length === 0) {
                childBBox = getBBox(child, { target });
            }
            else {
                // if child is a group element, enter it with a recursive call
                childBBox = getBBox(child, { target, recursive: true });
            }
            if (!outputBBox) {
                outputBBox = childBBox;
            }
            else {
                outputBBox = outputBBox.union(childBBox);
            }
        }
        return outputBBox;
    }
}
// BBox is calculated by the attribute on the node
function getBBoxByElementAttr(elem) {
    let node = elem;
    let tagName = node ? node.tagName.toLowerCase() : '';
    // find shape node
    while (tagName === 'g') {
        node = node.firstElementChild;
        tagName = node ? node.tagName.toLowerCase() : '';
    }
    const attr = (name) => {
        const s = node.getAttribute(name);
        const v = s ? parseFloat(s) : 0;
        return Number.isNaN(v) ? 0 : v;
    };
    let r;
    let bbox;
    switch (tagName) {
        case 'rect':
            bbox = new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));
            break;
        case 'circle':
            r = attr('r');
            bbox = new Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r);
            break;
        default:
            break;
    }
    return bbox;
}
// Matrix is calculated by the transform attribute on the node
function getMatrixByElementAttr(elem, target) {
    let matrix = createSVGMatrix();
    if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
        let node = elem;
        const matrixList = [];
        while (node && node !== target) {
            const transform = node.getAttribute('transform') || null;
            const nodeMatrix = transformStringToMatrix(transform);
            matrixList.push(nodeMatrix);
            node = node.parentNode;
        }
        matrixList.reverse().forEach((m) => {
            matrix = matrix.multiply(m);
        });
    }
    return matrix;
}
/**
 * Returns an DOMMatrix that specifies the transformation necessary
 * to convert `elem` coordinate system into `target` coordinate system.
 */
function getTransformToElement(elem, target) {
    if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
        const targetCTM = target.getScreenCTM();
        const nodeCTM = elem.getScreenCTM();
        if (targetCTM && nodeCTM) {
            return targetCTM.inverse().multiply(nodeCTM);
        }
    }
    // Could not get actual transformation matrix
    return createSVGMatrix();
}
/**
 * Converts a global point with coordinates `x` and `y` into the
 * coordinate space of the element.
 */
function toLocalPoint(elem, x, y) {
    const svg = elem instanceof SVGSVGElement
        ? elem
        : elem.ownerSVGElement;
    const p = svg.createSVGPoint();
    p.x = x;
    p.y = y;
    try {
        const ctm = svg.getScreenCTM();
        const globalPoint = p.matrixTransform(ctm.inverse());
        const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();
        return globalPoint.matrixTransform(globalToLocalMatrix);
    }
    catch (e) {
        return p;
    }
}
/**
 * Convert the SVGElement to an equivalent geometric shape. The element's
 * transformations are not taken into account.
 *
 * SVGRectElement      => Rectangle
 *
 * SVGLineElement      => Line
 *
 * SVGCircleElement    => Ellipse
 *
 * SVGEllipseElement   => Ellipse
 *
 * SVGPolygonElement   => Polyline
 *
 * SVGPolylineElement  => Polyline
 *
 * SVGPathElement      => Path
 *
 * others              => Rectangle
 */
function toGeometryShape(elem) {
    const attr = (name) => {
        const s = elem.getAttribute(name);
        const v = s ? parseFloat(s) : 0;
        return Number.isNaN(v) ? 0 : v;
    };
    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
        case 'rect':
            return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));
        case 'circle':
            return new Ellipse$2(attr('cx'), attr('cy'), attr('r'), attr('r'));
        case 'ellipse':
            return new Ellipse$2(attr('cx'), attr('cy'), attr('rx'), attr('ry'));
        case 'polyline': {
            const points = getPointsFromSvgElement(elem);
            return new Polyline$2(points);
        }
        case 'polygon': {
            const points = getPointsFromSvgElement(elem);
            if (points.length > 1) {
                points.push(points[0]);
            }
            return new Polyline$2(points);
        }
        case 'path': {
            let d = elem.getAttribute('d');
            if (!Path$2.isValid(d)) {
                d = Path$2.normalize(d);
            }
            return Path$2.parse(d);
        }
        case 'line': {
            return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));
        }
        default:
            break;
    }
    // Anything else is a rectangle
    return getBBox(elem);
}
function getIntersection(elem, ref, target) {
    const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
    target = target || svg; // eslint-disable-line
    const bbox = getBBox(target);
    const center = bbox.getCenter();
    if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {
        return null;
    }
    let spot = null;
    const tagName = elem.tagName.toLowerCase();
    // Little speed up optimization for `<rect>` element. We do not do convert
    // to path element and sampling but directly calculate the intersection
    // through a transformed geometrical rectangle.
    if (tagName === 'rect') {
        const gRect = new Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0'));
        // Get the rect transformation matrix with regards to the SVG document.
        const rectMatrix = getTransformToElement(elem, target);
        const rectMatrixComponents = decomposeMatrix(rectMatrix);
        // Rotate the rectangle back so that we can use
        // `intersectsWithLineFromCenterToPoint()`.
        const reseted = svg.createSVGTransform();
        reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);
        const rect = transformRectangle(gRect, reseted.matrix.multiply(rectMatrix));
        spot = Rectangle.create(rect).intersectsWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
    }
    else if (tagName === 'path' ||
        tagName === 'polygon' ||
        tagName === 'polyline' ||
        tagName === 'circle' ||
        tagName === 'ellipse') {
        const pathNode = tagName === 'path' ? elem : toPath(elem);
        const samples = sample(pathNode);
        let minDistance = Infinity;
        let closestSamples = [];
        for (let i = 0, ii = samples.length; i < ii; i += 1) {
            const sample = samples[i];
            // Convert the sample point in the local coordinate system
            // to the global coordinate system.
            let gp = createSVGPoint(sample.x, sample.y);
            gp = gp.matrixTransform(getTransformToElement(elem, target));
            const ggp = Point.create(gp);
            const centerDistance = ggp.distance(center);
            // Penalize a higher distance to the reference point by 10%.
            // This gives better results. This is due to
            // inaccuracies introduced by rounding errors and getPointAtLength() returns.
            const refDistance = ggp.distance(ref) * 1.1;
            const distance = centerDistance + refDistance;
            if (distance < minDistance) {
                minDistance = distance;
                closestSamples = [{ sample, refDistance }];
            }
            else if (distance < minDistance + 1) {
                closestSamples.push({ sample, refDistance });
            }
        }
        closestSamples.sort((a, b) => a.refDistance - b.refDistance);
        if (closestSamples[0]) {
            spot = Point.create(closestSamples[0].sample);
        }
    }
    return spot;
}
function animate(elem, options) {
    return createAnimation(elem, options, 'animate');
}
function animateTransform(elem, options) {
    return createAnimation(elem, options, 'animateTransform');
}
function createAnimation(elem, options, type) {
    // @see
    // https://www.w3.org/TR/SVG11/animate.html#AnimateElement
    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement
    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement
    const animate = createSvgElement(type);
    elem.appendChild(animate);
    try {
        return setupAnimation(animate, options);
    }
    catch (error) {
        // pass
    }
    return () => { };
}
function setupAnimation(animate, options) {
    const { start, complete, repeat } = options, attrs = __rest$x(options, ["start", "complete", "repeat"]);
    attr$1(animate, attrs);
    start && animate.addEventListener('beginEvent', start);
    complete && animate.addEventListener('endEvent', complete);
    repeat && animate.addEventListener('repeatEvent', repeat);
    const ani = animate;
    setTimeout(() => {
        ani.beginElement();
    });
    return () => ani.endElement();
}
/**
 * Animate the element along the path SVG element (or Vector object).
 * `attrs` contain Animation Timing attributes describing the animation.
 */
function animateAlongPath(elem, options, path) {
    const id = ensureId(path);
    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement
    const animate = createSvgElement('animateMotion');
    const mpath = createSvgElement('mpath');
    attr$1(mpath, { 'xlink:href': `#${id}` });
    animate.appendChild(mpath);
    elem.appendChild(animate);
    try {
        return setupAnimation(animate, options);
    }
    catch (e) {
        // Fallback for IE 9.
        if (document.documentElement.getAttribute('smiling') === 'fake') {
            // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)
            const ani = animate;
            ani.animators = [];
            const win = window;
            const animationID = ani.getAttribute('id');
            if (animationID) {
                win.id2anim[animationID] = ani;
            }
            const targets = win.getTargets(ani);
            for (let i = 0, ii = targets.length; i < ii; i += 1) {
                const target = targets[i];
                const animator = new win.Animator(ani, target, i);
                win.animators.push(animator);
                ani.animators[i] = animator;
                animator.register();
            }
        }
    }
    return () => { };
}
function getBoundingOffsetRect(elem) {
    let left = 0;
    let top = 0;
    let width = 0;
    let height = 0;
    if (elem) {
        let current = elem;
        while (current) {
            left += current.offsetLeft;
            top += current.offsetTop;
            current = current.offsetParent;
            if (current) {
                left += parseInt(getComputedStyle$1(current, 'borderLeft'), 10);
                top += parseInt(getComputedStyle$1(current, 'borderTop'), 10);
            }
        }
        width = elem.offsetWidth;
        height = elem.offsetHeight;
    }
    return { left, top, width, height };
}

function transform$1(elem, matrix, options = {}) {
    if (matrix == null) {
        return transformStringToMatrix(attr$1(elem, 'transform'));
    }
    if (options.absolute) {
        elem.setAttribute('transform', matrixToTransformString(matrix));
        return;
    }
    const transformList = elem.transform;
    const svgTransform = createSVGTransform(matrix);
    transformList.baseVal.appendItem(svgTransform);
}
function translate(elem, tx, ty = 0, options = {}) {
    let transformAttr = attr$1(elem, 'transform');
    const transform = parseTransformString(transformAttr);
    if (tx == null) {
        return transform.translation;
    }
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
    const newTx = options.absolute ? tx : transform.translation.tx + tx;
    const newTy = options.absolute ? ty : transform.translation.ty + ty;
    const newTranslate = `translate(${newTx},${newTy})`;
    // Note that `translate()` is always the first transformation. This is
    // usually the desired case.
    elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());
}
function rotate(elem, angle, cx, cy, options = {}) {
    let transformAttr = attr$1(elem, 'transform');
    const transform = parseTransformString(transformAttr);
    if (angle == null) {
        return transform.rotation;
    }
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
    angle %= 360; // eslint-disable-line
    const newAngle = options.absolute ? angle : transform.rotation.angle + angle;
    const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';
    const newRotate = `rotate(${newAngle}${newOrigin})`;
    elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());
}
function scale(elem, sx, sy) {
    let transformAttr = attr$1(elem, 'transform');
    const transform = parseTransformString(transformAttr);
    if (sx == null) {
        return transform.scale;
    }
    sy = sy == null ? sx : sy; // eslint-disable-line
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
    const newScale = `scale(${sx},${sy})`;
    elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());
}
function translateAndAutoOrient(elem, position, reference, target) {
    const pos = Point.create(position);
    const ref = Point.create(reference);
    if (!target) {
        const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
        target = svg; // eslint-disable-line
    }
    // Clean-up previously set transformations except the scale.
    // If we didn't clean up the previous transformations then they'd
    // add up with the old ones. Scale is an exception as it doesn't
    // add up, consider: `this.scale(2).scale(2).scale(2)`. The result
    // is that the element is scaled by the factor 2, not 8.
    const s = scale(elem);
    elem.setAttribute('transform', '');
    const bbox = getBBox(elem, { target }).scale(s.sx, s.sy);
    // 1. Translate to origin.
    const translateToOrigin = createSVGTransform();
    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);
    // 2. Rotate around origin.
    const rotateAroundOrigin = createSVGTransform();
    const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));
    if (angle)
        rotateAroundOrigin.setRotate(angle, 0, 0);
    // 3. Translate to the `position` + the offset (half my width)
    //    towards the `reference` point.
    const translateFromOrigin = createSVGTransform();
    const finalPosition = pos.clone().move(ref, bbox.width / 2);
    translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);
    // 4. Get the current transformation matrix of this node
    const ctm = getTransformToElement(elem, target);
    // 5. Apply transformations and the scale
    const transform = createSVGTransform();
    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
    elem.setAttribute('transform', matrixToTransformString(transform.matrix));
}

class MouseWheelHandle {
    constructor(target, onWheelCallback, onWheelGuard) {
        this.animationFrameId = 0;
        this.deltaX = 0;
        this.deltaY = 0;
        this.eventName = Platform.isEventSupported('wheel')
            ? 'wheel'
            : 'mousewheel';
        this.target = target;
        this.onWheelCallback = onWheelCallback;
        this.onWheelGuard = onWheelGuard;
        this.onWheel = this.onWheel.bind(this);
        this.didWheel = this.didWheel.bind(this);
    }
    enable() {
        if (Platform.SUPPORT_PASSIVE) {
            this.target.addEventListener(this.eventName, this.onWheel, {
                passive: false,
            });
        }
        else {
            JQuery(this.target).on('mousewheel', this.onWheel);
        }
    }
    disable() {
        if (Platform.SUPPORT_PASSIVE) {
            this.target.removeEventListener(this.eventName, this.onWheel);
        }
        else {
            JQuery(this.target).off('mousewheel');
        }
    }
    onWheel(e) {
        if (this.onWheelGuard != null && !this.onWheelGuard(e)) {
            return;
        }
        this.deltaX += e.deltaX;
        this.deltaY += e.deltaY;
        e.preventDefault();
        let changed;
        if (this.deltaX !== 0 || this.deltaY !== 0) {
            e.stopPropagation();
            changed = true;
        }
        if (changed === true && this.animationFrameId === 0) {
            this.animationFrameId = requestAnimationFrame(() => {
                this.didWheel(e);
            });
        }
    }
    didWheel(e) {
        this.animationFrameId = 0;
        this.onWheelCallback(e, this.deltaX, this.deltaY);
        this.deltaX = 0;
        this.deltaY = 0;
    }
}

/**
 * **Deprecation Notice:** `Dom.isVector` is deprecated and will be moved in next
 * major release. Use `Vector.isVector()` instead.
 *
 * @deprecated
 */
const isVector = Vector.isVector;
/**
 * **Deprecation Notice:** `Dom.createVector` is deprecated and will be moved
 * in next major release. Use `Vector.create()` instead.
 *
 * @deprecated
 */
const createVector = Vector.create;
/**
 * **Deprecation Notice:** `Dom.createVectors` is deprecated and will be moved
 * in next major release. Use `Vector.createVectors()` instead.
 *
 * @deprecated
 */
const createVectors = Vector.createVectors;

var main$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	CASE_SENSITIVE_ATTR: CASE_SENSITIVE_ATTR,
	KAPPA: KAPPA,
	MouseWheelHandle: MouseWheelHandle,
	addClass: addClass,
	animate: animate,
	animateAlongPath: animateAlongPath,
	animateTransform: animateTransform,
	append: append,
	appendTo: appendTo,
	attr: attr$1,
	bbox: bbox$1,
	before: before,
	breakText: breakText,
	cancelAnimationFrame: cancelAnimationFrame$1,
	circleToPathData: circleToPathData,
	clearSelection: clearSelection,
	clickable: clickable,
	contains: contains,
	createElement: createElement,
	createElementNS: createElementNS,
	createSVGMatrix: createSVGMatrix,
	createSVGPoint: createSVGPoint,
	createSVGTransform: createSVGTransform,
	createSlicePathData: createSlicePathData,
	createSvgDocument: createSvgDocument,
	createSvgElement: createSvgElement,
	createVector: createVector,
	createVectors: createVectors,
	decomposeMatrix: decomposeMatrix,
	ellipseToPathData: ellipseToPathData,
	empty: empty,
	ensureId: ensureId,
	find: find,
	findOne: findOne,
	findParentByClass: findParentByClass,
	getAttribute: getAttribute,
	getBBox: getBBox,
	getBBoxByElementAttr: getBBoxByElementAttr,
	getBoundingOffsetRect: getBoundingOffsetRect,
	getClass: getClass,
	getComputedStyle: getComputedStyle$1,
	getIntersection: getIntersection,
	getMatrixByElementAttr: getMatrixByElementAttr,
	getPointsFromSvgElement: getPointsFromSvgElement,
	getTransformToElement: getTransformToElement,
	getVendorPrefixedName: getVendorPrefixedName,
	hasClass: hasClass,
	hasScrollbars: hasScrollbars,
	index: index$4,
	isHTMLElement: isHTMLElement,
	isInputElement: isInputElement,
	isSVGGraphicsElement: isSVGGraphicsElement,
	isVector: isVector,
	kebablizeAttrs: kebablizeAttrs,
	lineToPathData: lineToPathData,
	matrixToRotation: matrixToRotation,
	matrixToScale: matrixToScale,
	matrixToTransformString: matrixToTransformString,
	matrixToTranslation: matrixToTranslation,
	mergeAttrs: mergeAttrs,
	ns: ns,
	parseTransformString: parseTransformString,
	parseXML: parseXML,
	polygonToPathData: polygonToPathData,
	polylineToPathData: polylineToPathData,
	prepend: prepend,
	qualifyAttr: qualifyAttr,
	rectToPathData: rectToPathData,
	rectangleToPathData: rectangleToPathData,
	remove: remove,
	removeAttribute: removeAttribute,
	removeClass: removeClass,
	requestAnimationFrame: requestAnimationFrame$1,
	rotate: rotate,
	sample: sample,
	scale: scale,
	setAttribute: setAttribute,
	setAttributes: setAttributes,
	setPrefixedStyle: setPrefixedStyle,
	styleToObject: styleToObject,
	svgVersion: svgVersion,
	tagName: tagName,
	text: text$3,
	toGeometryShape: toGeometryShape,
	toLocalPoint: toLocalPoint,
	toPath: toPath,
	toPathData: toPathData,
	toggleClass: toggleClass,
	transform: transform$1,
	transformLine: transformLine,
	transformPoint: transformPoint,
	transformPolyline: transformPolyline,
	transformRectangle: transformRectangle,
	transformStringToMatrix: transformStringToMatrix,
	translate: translate,
	translateAndAutoOrient: translateAndAutoOrient,
	uniqueId: uniqueId
});

function debounce(fn, delay = 60) {
    let timer = null;
    return (...args) => {
        if (timer) {
            clearTimeout(timer);
        }
        timer = window.setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
}

function createSensor$2(element) {
    let sensor = null;
    let listeners = [];
    const create = () => {
        if (getComputedStyle(element).position === 'static') {
            const style = element.style;
            style.position = 'relative';
        }
        const obj = document.createElement('object');
        obj.onload = () => {
            obj.contentDocument.defaultView.addEventListener('resize', trigger);
            trigger();
        };
        obj.style.display = 'block';
        obj.style.position = 'absolute';
        obj.style.top = '0';
        obj.style.left = '0';
        obj.style.height = '100%';
        obj.style.width = '100%';
        obj.style.overflow = 'hidden';
        obj.style.pointerEvents = 'none';
        obj.style.zIndex = '-1';
        obj.style.opacity = '0';
        obj.setAttribute('tabindex', '-1');
        obj.type = 'text/html';
        element.appendChild(obj);
        // for ie, should set data attribute delay, or will be white screen
        obj.data = 'about:blank';
        return obj;
    };
    const trigger = debounce(() => {
        listeners.forEach((listener) => listener(element));
    });
    const bind = (listener) => {
        if (!sensor) {
            sensor = create();
        }
        if (listeners.indexOf(listener) === -1) {
            listeners.push(listener);
        }
    };
    const destroy = () => {
        if (sensor && sensor.parentNode) {
            if (sensor.contentDocument) {
                sensor.contentDocument.defaultView.removeEventListener('resize', trigger);
            }
            sensor.parentNode.removeChild(sensor);
            sensor = null;
            listeners = [];
        }
    };
    const unbind = (listener) => {
        const idx = listeners.indexOf(listener);
        if (idx !== -1) {
            listeners.splice(idx, 1);
        }
        // no listener, and sensor is exist then destroy the sensor
        if (listeners.length === 0 && sensor) {
            destroy();
        }
    };
    return {
        element,
        bind,
        destroy,
        unbind,
    };
}

function createSensor$1(element) {
    let sensor = null;
    let listeners = [];
    const trigger = debounce(() => {
        listeners.forEach((listener) => {
            listener(element);
        });
    });
    const create = () => {
        const s = new ResizeObserver(trigger);
        s.observe(element);
        trigger();
        return s;
    };
    const bind = (listener) => {
        if (!sensor) {
            sensor = create();
        }
        if (listeners.indexOf(listener) === -1) {
            listeners.push(listener);
        }
    };
    const destroy = () => {
        if (sensor) {
            sensor.disconnect();
            listeners = [];
            sensor = null;
        }
    };
    const unbind = (listener) => {
        const idx = listeners.indexOf(listener);
        if (idx !== -1) {
            listeners.splice(idx, 1);
        }
        // no listener, and sensor is exist then destroy the sensor
        if (listeners.length === 0 && sensor) {
            destroy();
        }
    };
    return {
        element,
        bind,
        destroy,
        unbind,
    };
}

const createSensor = typeof ResizeObserver !== 'undefined'
    ? createSensor$1
    : createSensor$2;

var SizeSensor;
(function (SizeSensor) {
    const cache = new WeakMap();
    function get(element) {
        let sensor = cache.get(element);
        if (sensor) {
            return sensor;
        }
        sensor = createSensor(element);
        cache.set(element, sensor);
        return sensor;
    }
    function remove(sensor) {
        sensor.destroy();
        cache.delete(sensor.element);
    }
    SizeSensor.bind = (element, cb) => {
        const sensor = get(element);
        sensor.bind(cb);
        return () => sensor.unbind(cb);
    };
    SizeSensor.clear = (element) => {
        const sensor = get(element);
        remove(sensor);
    };
})(SizeSensor || (SizeSensor = {}));

var Scheduler;
(function (Scheduler) {
    const queue = [];
    const threshold = 1000 / 60;
    const unit = [];
    let deadline = 0;
    const getTime = () => performance.now();
    const peek = (queue) => queue[0];
    const schedule = (cb) => unit.push(cb) === 1 && postMessage();
    const postMessage = (() => {
        const cb = () => { var _a, _b; return (_b = (_a = unit.splice(0, unit.length))[0]) === null || _b === void 0 ? void 0 : _b.call(_a); };
        if (typeof MessageChannel !== 'undefined') {
            const { port1, port2 } = new MessageChannel();
            port1.onmessage = cb;
            return () => port2.postMessage(null);
        }
        return () => setTimeout(cb);
    })();
    const flushTask = () => {
        deadline = getTime() + threshold;
        let job = peek(queue);
        while (job && !Scheduler.shouldYield()) {
            const { callback, data } = job;
            job.callback = null;
            const next = callback && callback(data);
            if (next) {
                job.callback = next;
            }
            else {
                queue.shift();
            }
            job = peek(queue);
        }
        job && schedule(flushTask);
    };
    Scheduler.scheduleTask = (callback, data) => {
        const task = {
            callback,
            data,
        };
        queue.push(task);
        schedule(flushTask);
    };
    Scheduler.shouldYield = () => {
        var _a, _b;
        return (((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline);
    };
})(Scheduler || (Scheduler = {}));

class Registry {
    constructor(options) {
        this.options = Object.assign({}, options);
        this.data = this.options.data || {};
        this.register = this.register.bind(this);
        this.unregister = this.unregister.bind(this);
    }
    get names() {
        return Object.keys(this.data);
    }
    register(name, options, force = false) {
        if (typeof name === 'object') {
            Object.keys(name).forEach((key) => {
                this.register(key, name[key], options);
            });
            return;
        }
        if (this.exist(name) && !force && !Platform.isApplyingHMR()) {
            this.onDuplicated(name);
        }
        const process = this.options.process;
        const entity = process
            ? call(process, this, name, options)
            : options;
        this.data[name] = entity;
        return entity;
    }
    unregister(name) {
        const entity = name ? this.data[name] : null;
        delete this.data[name];
        return entity;
    }
    get(name) {
        return name ? this.data[name] : null;
    }
    exist(name) {
        return name ? this.data[name] != null : false;
    }
    onDuplicated(name) {
        // eslint-disable-next-line no-useless-catch
        try {
            // race
            if (this.options.onConflict) {
                call(this.options.onConflict, this, name);
            }
            throw new Error(`${upperFirst(this.options.type)} with name '${name}' already registered.`);
        }
        catch (err) {
            throw err;
        }
    }
    onNotFound(name, prefix) {
        throw new Error(this.getSpellingSuggestion(name, prefix));
    }
    getSpellingSuggestion(name, prefix) {
        const suggestion = this.getSpellingSuggestionForName(name);
        const prefixed = prefix
            ? `${prefix} ${lowerFirst(this.options.type)}`
            : this.options.type;
        return (
        // eslint-disable-next-line
        `${upperFirst(prefixed)} with name '${name}' does not exist.${suggestion ? ` Did you mean '${suggestion}'?` : ''}`);
    }
    getSpellingSuggestionForName(name) {
        return getSpellingSuggestion(name, Object.keys(this.data), (candidate) => candidate);
    }
}
(function (Registry) {
    function create(options) {
        return new Registry(options);
    }
    Registry.create = create;
})(Registry || (Registry = {}));

const raw = {
    xlinkHref: 'xlink:href',
    xlinkShow: 'xlink:show',
    xlinkRole: 'xlink:role',
    xlinkType: 'xlink:type',
    xlinkArcrole: 'xlink:arcrole',
    xlinkTitle: 'xlink:title',
    xlinkActuate: 'xlink:actuate',
    xmlSpace: 'xml:space',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    preserveAspectRatio: 'preserveAspectRatio',
    requiredExtension: 'requiredExtension',
    requiredFeatures: 'requiredFeatures',
    systemLanguage: 'systemLanguage',
    externalResourcesRequired: 'externalResourceRequired',
};

const ref = {
// We do not set `ref` attribute directly on an element.
// The attribute itself does not qualify for relative positioning.
};
// if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
// otherwise, `refX` is the left coordinate of the bounding box
const refX = {
    position: positionWrapper('x', 'width', 'origin'),
};
const refY = {
    position: positionWrapper('y', 'height', 'origin'),
};
// `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom
// coordinate of the reference element.
const refDx = {
    position: positionWrapper('x', 'width', 'corner'),
};
const refDy = {
    position: positionWrapper('y', 'height', 'corner'),
};
// 'ref-width'/'ref-height' defines the width/height of the subelement relatively to
// the reference element size
// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20
const refWidth = {
    set: setWrapper('width', 'width'),
};
const refHeight = {
    set: setWrapper('height', 'height'),
};
const refRx = {
    set: setWrapper('rx', 'width'),
};
const refRy = {
    set: setWrapper('ry', 'height'),
};
const refRInscribed = {
    set: ((attrName) => {
        const widthFn = setWrapper(attrName, 'width');
        const heightFn = setWrapper(attrName, 'height');
        return function (value, options) {
            const refBBox = options.refBBox;
            const fn = refBBox.height > refBBox.width ? widthFn : heightFn;
            return call(fn, this, value, options);
        };
    })('r'),
};
const refRCircumscribed = {
    set(val, { refBBox }) {
        let value = parseFloat(val);
        const percentage = isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
        let rValue;
        if (Number.isFinite(value)) {
            if (percentage || (value >= 0 && value <= 1)) {
                rValue = value * diagonalLength;
            }
            else {
                rValue = Math.max(value + diagonalLength, 0);
            }
        }
        return { r: rValue };
    },
};
const refCx = {
    set: setWrapper('cx', 'width'),
};
const refCy = {
    set: setWrapper('cy', 'height'),
};
const refDResetOffset = {
    set: dWrapper({ resetOffset: true }),
};
const refDKeepOffset = {
    set: dWrapper({ resetOffset: false }),
};
const refPointsResetOffset = {
    set: pointsWrapper({ resetOffset: true }),
};
const refPointsKeepOffset = {
    set: pointsWrapper({ resetOffset: false }),
};
// aliases
// -------
const refR = refRInscribed;
const refD = refDResetOffset;
const refPoints = refPointsResetOffset;
// Allows to combine both absolute and relative positioning
// refX: 50%, refX2: 20
const refX2 = refX;
const refY2 = refY;
const refWidth2 = refWidth;
const refHeight2 = refHeight;
// utils
// -----
function positionWrapper(axis, dimension, origin) {
    return (val, { refBBox }) => {
        if (val == null) {
            return null;
        }
        let value = parseFloat(val);
        const percentage = isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        let delta;
        if (Number.isFinite(value)) {
            const refOrigin = refBBox[origin];
            if (percentage || (value > 0 && value < 1)) {
                delta = refOrigin[axis] + refBBox[dimension] * value;
            }
            else {
                delta = refOrigin[axis] + value;
            }
        }
        const point = new Point();
        point[axis] = delta || 0;
        return point;
    };
}
function setWrapper(attrName, dimension) {
    return function (val, { refBBox }) {
        let value = parseFloat(val);
        const percentage = isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        const attrs = {};
        if (Number.isFinite(value)) {
            const attrValue = percentage || (value >= 0 && value <= 1)
                ? value * refBBox[dimension]
                : Math.max(value + refBBox[dimension], 0);
            attrs[attrName] = attrValue;
        }
        return attrs;
    };
}
function shapeWrapper(shapeConstructor, options) {
    const cacheName = 'x6-shape';
    const resetOffset = options && options.resetOffset;
    return function (value, { view, elem, refBBox }) {
        const $elem = view.$(elem);
        let cache = $elem.data(cacheName);
        if (!cache || cache.value !== value) {
            // only recalculate if value has changed
            const cachedShape = shapeConstructor(value);
            cache = {
                value,
                shape: cachedShape,
                shapeBBox: cachedShape.bbox(),
            };
            $elem.data(cacheName, cache);
        }
        const shape = cache.shape.clone();
        const shapeBBox = cache.shapeBBox.clone();
        const shapeOrigin = shapeBBox.getOrigin();
        const refOrigin = refBBox.getOrigin();
        shapeBBox.x = refOrigin.x;
        shapeBBox.y = refOrigin.y;
        const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin);
        // `maxRectScaleToFit` can give Infinity if width or height is 0
        const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
        const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
        shape.scale(sx, sy, shapeOrigin);
        if (resetOffset) {
            shape.translate(-shapeOrigin.x, -shapeOrigin.y);
        }
        return shape;
    };
}
// `d` attribute for SVGPaths
function dWrapper(options) {
    function pathConstructor(value) {
        return Path$2.parse(value);
    }
    const shape = shapeWrapper(pathConstructor, options);
    return (value, args) => {
        const path = shape(value, args);
        return {
            d: path.serialize(),
        };
    };
}
// `points` attribute for SVGPolylines and SVGPolygons
function pointsWrapper(options) {
    const shape = shapeWrapper((points) => new Polyline$2(points), options);
    return (value, args) => {
        const polyline = shape(value, args);
        return {
            points: polyline.serialize(),
        };
    };
}

const fill = {
    qualify: isPlainObject,
    set(fill, { view }) {
        return `url(#${view.graph.defineGradient(fill)})`;
    },
};

const stroke$1 = {
    qualify: isPlainObject,
    set(stroke, { view }) {
        const cell = view.cell;
        const options = Object.assign({}, stroke);
        if (cell.isEdge() && options.type === 'linearGradient') {
            const edgeView = view;
            const source = edgeView.sourcePoint;
            const target = edgeView.targetPoint;
            options.id = `gradient-${options.type}-${cell.id}`;
            options.attrs = Object.assign(Object.assign({}, options.attrs), { x1: source.x, y1: source.y, x2: target.x, y2: target.y, gradientUnits: 'userSpaceOnUse' });
            view.graph.defs.remove(options.id);
        }
        return `url(#${view.graph.defineGradient(options)})`;
    },
};

const text$2 = {
    qualify(text, { attrs }) {
        return attrs.textWrap == null || !isPlainObject(attrs.textWrap);
    },
    set(text, { view, elem, attrs }) {
        const cacheName = 'x6-text';
        const $elem = view.$(elem);
        const cache = $elem.data(cacheName);
        const json = (str) => {
            try {
                return JSON.parse(str);
            }
            catch (error) {
                return str;
            }
        };
        const options = {
            x: attrs.x,
            eol: attrs.eol,
            annotations: json(attrs.annotations),
            textPath: json(attrs['text-path'] || attrs.textPath),
            textVerticalAnchor: (attrs['text-vertical-anchor'] ||
                attrs.textVerticalAnchor),
            displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',
            lineHeight: (attrs['line-height'] || attrs.lineHeight),
        };
        const fontSize = (attrs['font-size'] || attrs.fontSize);
        const textHash = JSON.stringify([text, options]);
        if (fontSize) {
            elem.setAttribute('font-size', fontSize);
        }
        // Updates the text only if there was a change in the string
        // or any of its attributes.
        if (cache == null || cache !== textHash) {
            // Text Along Path Selector
            const textPath = options.textPath;
            if (textPath != null && typeof textPath === 'object') {
                const selector = textPath.selector;
                if (typeof selector === 'string') {
                    const pathNode = view.find(selector)[0];
                    if (pathNode instanceof SVGPathElement) {
                        ensureId(pathNode);
                        options.textPath = Object.assign({ 'xlink:href': `#${pathNode.id}` }, textPath);
                    }
                }
            }
            text$3(elem, `${text}`, options);
            $elem.data(cacheName, textHash);
        }
    },
};
const textWrap = {
    qualify: isPlainObject,
    set(val, { view, elem, attrs, refBBox }) {
        const info = val;
        // option `width`
        const width = info.width || 0;
        if (isPercentage(width)) {
            refBBox.width *= parseFloat(width) / 100;
        }
        else if (width <= 0) {
            refBBox.width += width;
        }
        else {
            refBBox.width = width;
        }
        // option `height`
        const height = info.height || 0;
        if (isPercentage(height)) {
            refBBox.height *= parseFloat(height) / 100;
        }
        else if (height <= 0) {
            refBBox.height += height;
        }
        else {
            refBBox.height = height;
        }
        // option `text`
        let wrappedText;
        let txt = info.text;
        if (txt == null) {
            txt = attrs.text;
        }
        if (txt != null) {
            wrappedText = breakText(`${txt}`, refBBox, {
                'font-weight': attrs['font-weight'] || attrs.fontWeight,
                'font-size': attrs['font-size'] || attrs.fontSize,
                'font-family': attrs['font-family'] || attrs.fontFamily,
                lineHeight: attrs.lineHeight,
            }, {
                svgDocument: view.graph.view.svg,
                ellipsis: info.ellipsis,
                hyphen: info.hyphen,
                breakWord: info.breakWord,
            });
        }
        else {
            wrappedText = '';
        }
        call(text$2.set, this, wrappedText, {
            view,
            elem,
            attrs,
            refBBox,
            cell: view.cell,
        });
    },
};
const isTextInUse = (val, { attrs }) => {
    return attrs.text !== undefined;
};
const lineHeight = {
    qualify: isTextInUse,
};
const textVerticalAnchor = {
    qualify: isTextInUse,
};
const textPath = {
    qualify: isTextInUse,
};
const annotations = {
    qualify: isTextInUse,
};
const eol = {
    qualify: isTextInUse,
};
const displayEmpty = {
    qualify: isTextInUse,
};

const title = {
    qualify(title, { elem }) {
        // HTMLElement title is specified via an attribute (i.e. not an element)
        return elem instanceof SVGElement;
    },
    set(val, { view, elem }) {
        const cacheName = 'x6-title';
        const title = `${val}`;
        const $elem = view.$(elem);
        const cache = $elem.data(cacheName);
        if (cache == null || cache !== title) {
            $elem.data(cacheName, title);
            // Generally SVGTitleElement should be the first child
            // element of its parent.
            const firstChild = elem.firstChild;
            if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {
                // Update an existing title
                const titleElem = firstChild;
                titleElem.textContent = title;
            }
            else {
                // Create a new title
                const titleNode = document.createElementNS(elem.namespaceURI, 'title');
                titleNode.textContent = title;
                elem.insertBefore(titleNode, firstChild);
            }
        }
    },
};

// `x-align` when set to `middle` causes centering of the subelement around its new x coordinate.
// `x-align` when set to `right` uses the x coordinate as referenced to the right of the bbox.
const xAlign = {
    offset: offsetWrapper('x', 'width', 'right'),
};
// `y-align` when set to `middle` causes centering of the subelement around its new y coordinate.
// `y-align` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.
const yAlign = {
    offset: offsetWrapper('y', 'height', 'bottom'),
};
const resetOffset = {
    offset(val, { refBBox }) {
        return val ? { x: -refBBox.x, y: -refBBox.y } : { x: 0, y: 0 };
    },
};
function offsetWrapper(axis, dimension, corner) {
    return (value, { refBBox }) => {
        const point = new Point();
        let delta;
        if (value === 'middle') {
            delta = refBBox[dimension] / 2;
        }
        else if (value === corner) {
            delta = refBBox[dimension];
        }
        else if (typeof value === 'number' && Number.isFinite(value)) {
            delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value;
        }
        else if (isPercentage(value)) {
            delta = (refBBox[dimension] * parseFloat(value)) / 100;
        }
        else {
            delta = 0;
        }
        point[axis] = -(refBBox[axis] + delta);
        return point;
    };
}

const style$1 = {
    qualify: isPlainObject,
    set(styles, { view, elem }) {
        view.$(elem).css(styles);
    },
};

const html$1 = {
    set(html, { view, elem }) {
        view.$(elem).html(`${html}`);
    },
};

const filter = {
    qualify: isPlainObject,
    set(filter, { view }) {
        return `url(#${view.graph.defineFilter(filter)})`;
    },
};

const port = {
    set(port) {
        if (port != null && typeof port === 'object' && port.id) {
            return port.id;
        }
        return port;
    },
};

function normalize$1(d, offset1, offset2) {
    let offsetX;
    let offsetY;
    if (typeof offset1 === 'object') {
        offsetX = offset1.x;
        offsetY = offset1.y;
    }
    else {
        offsetX = offset1;
        offsetY = offset2;
    }
    const path = Path$2.parse(d);
    const bbox = path.bbox();
    if (bbox) {
        let ty = -bbox.height / 2 - bbox.y;
        let tx = -bbox.width / 2 - bbox.x;
        if (typeof offsetX === 'number') {
            tx -= offsetX;
        }
        if (typeof offsetY === 'number') {
            ty -= offsetY;
        }
        path.translate(tx, ty);
    }
    return path.serialize();
}

var __rest$w = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const block = (_a) => {
    var { size, width, height, offset, open } = _a, attrs = __rest$w(_a, ["size", "width", "height", "offset", "open"]);
    return createClassicMarker({ size, width, height, offset }, open === true, true, undefined, attrs);
};
const classic = (_a) => {
    var { size, width, height, offset, factor } = _a, attrs = __rest$w(_a, ["size", "width", "height", "offset", "factor"]);
    return createClassicMarker({ size, width, height, offset }, false, false, factor, attrs);
};
function createClassicMarker(options, open, full, factor = 3 / 4, attrs = {}) {
    const size = options.size || 10;
    const width = options.width || size;
    const height = options.height || size;
    const path = new Path$2();
    const localAttrs = {};
    if (open) {
        path
            .moveTo(width, 0)
            .lineTo(0, height / 2)
            .lineTo(width, height);
        localAttrs.fill = 'none';
    }
    else {
        path.moveTo(0, height / 2);
        path.lineTo(width, 0);
        if (!full) {
            const f = clamp$1(factor, 0, 1);
            path.lineTo(width * f, height / 2);
        }
        path.lineTo(width, height);
        path.close();
    }
    return Object.assign(Object.assign(Object.assign({}, localAttrs), attrs), { tagName: 'path', d: normalize$1(path.serialize(), {
            x: options.offset != null ? options.offset : -width / 2,
        }) });
}

var __rest$v = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const diamond = (_a) => {
    var { size, width, height, offset } = _a, attrs = __rest$v(_a, ["size", "width", "height", "offset"]);
    const s = size || 10;
    const w = width || s;
    const h = height || s;
    const path = new Path$2();
    path
        .moveTo(0, h / 2)
        .lineTo(w / 2, 0)
        .lineTo(w, h / 2)
        .lineTo(w / 2, h)
        .close();
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', d: normalize$1(path.serialize(), offset == null ? -w / 2 : offset) });
};

var __rest$u = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const path$3 = (_a) => {
    var { d, offsetX, offsetY } = _a, attrs = __rest$u(_a, ["d", "offsetX", "offsetY"]);
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', d: normalize$1(d, offsetX, offsetY) });
};

var __rest$t = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const cross = (_a) => {
    var { size, width, height, offset } = _a, attrs = __rest$t(_a, ["size", "width", "height", "offset"]);
    const s = size || 10;
    const w = width || s;
    const h = height || s;
    const path = new Path$2();
    path.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0);
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', fill: 'none', d: normalize$1(path.serialize(), offset || -w / 2) });
};

var __rest$s = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const async$1 = (_a) => {
    var { width, height, offset, open, flip } = _a, attrs = __rest$s(_a, ["width", "height", "offset", "open", "flip"]);
    let h = height || 6;
    const w = width || 10;
    const opened = open === true;
    const fliped = flip === true;
    const result = Object.assign(Object.assign({}, attrs), { tagName: 'path' });
    if (fliped) {
        h = -h;
    }
    const path = new Path$2();
    path.moveTo(0, h).lineTo(w, 0);
    if (!opened) {
        path.lineTo(w, h);
        path.close();
    }
    else {
        result.fill = 'none';
    }
    result.d = normalize$1(path.serialize(), {
        x: offset || -w / 2,
        y: h / 2,
    });
    return result;
};

var __rest$r = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const circle = (_a) => {
    var { r } = _a, attrs = __rest$r(_a, ["r"]);
    const radius = r || 5;
    return Object.assign(Object.assign({ cx: radius }, attrs), { tagName: 'circle', r: radius });
};
const circlePlus = (_a) => {
    var { r } = _a, attrs = __rest$r(_a, ["r"]);
    const radius = r || 5;
    const path = new Path$2();
    path.moveTo(radius, 0).lineTo(radius, radius * 2);
    path.moveTo(0, radius).lineTo(radius * 2, radius);
    return {
        children: [
            Object.assign(Object.assign({}, circle({ r: radius })), { fill: 'none' }),
            Object.assign(Object.assign({}, attrs), { tagName: 'path', d: normalize$1(path.serialize(), -radius) }),
        ],
    };
};

var __rest$q = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ellipse$2 = (_a) => {
    var { rx, ry } = _a, attrs = __rest$q(_a, ["rx", "ry"]);
    const radiusX = rx || 5;
    const radiusy = ry || 5;
    return Object.assign(Object.assign({ cx: radiusX }, attrs), { tagName: 'ellipse', rx: radiusX, ry: radiusy });
};

var markers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	async: async$1,
	block: block,
	circle: circle,
	circlePlus: circlePlus,
	classic: classic,
	cross: cross,
	diamond: diamond,
	ellipse: ellipse$2,
	path: path$3
});

var Marker;
(function (Marker) {
    Marker.presets = markers;
    Marker.registry = Registry.create({
        type: 'marker',
    });
    Marker.registry.register(Marker.presets, true);
})(Marker || (Marker = {}));
(function (Marker) {
    Marker.normalize = normalize$1;
})(Marker || (Marker = {}));

var __rest$p = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function qualify(value) {
    return typeof value === 'string' || isPlainObject(value);
}
const sourceMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-start', marker, view, attrs);
    },
};
const targetMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-end', marker, view, attrs, {
            transform: 'rotate(180)',
        });
    },
};
const vertexMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-mid', marker, view, attrs);
    },
};
function createMarker(type, marker, view, attrs, manual = {}) {
    const def = typeof marker === 'string' ? { name: marker } : marker;
    const { name, args } = def, others = __rest$p(def, ["name", "args"]);
    let preset = others;
    if (name && typeof name === 'string') {
        const fn = Marker.registry.get(name);
        if (fn) {
            preset = fn(Object.assign(Object.assign({}, others), args));
        }
        else {
            return Marker.registry.onNotFound(name);
        }
    }
    const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);
    return {
        [type]: `url(#${view.graph.defineMarker(options)})`,
    };
}
function normalizeAttr(attr, type) {
    const result = {};
    // The context 'fill' is disregared here. The usual case is to use the
    // marker with a connection(for which 'fill' attribute is set to 'none').
    const stroke = attr.stroke;
    if (typeof stroke === 'string') {
        result.stroke = stroke;
        result.fill = stroke;
    }
    // Again the context 'fill-opacity' is ignored.
    let strokeOpacity = attr.strokeOpacity;
    if (strokeOpacity == null) {
        strokeOpacity = attr['stroke-opacity'];
    }
    if (strokeOpacity == null) {
        strokeOpacity = attr.opacity;
    }
    if (strokeOpacity != null) {
        result['stroke-opacity'] = strokeOpacity;
        result['fill-opacity'] = strokeOpacity;
    }
    if (type !== 'marker-mid') {
        const strokeWidth = parseFloat((attr.strokeWidth || attr['stroke-width']));
        if (Number.isFinite(strokeWidth) && strokeWidth > 1) {
            const offset = Math.ceil(strokeWidth / 2);
            result.refX = type === 'marker-start' ? offset : -offset;
        }
    }
    return result;
}

const isEdgeView = (val, { view }) => {
    return view.cell.isEdge();
};
const connection = {
    qualify: isEdgeView,
    set(val, args) {
        var _a, _b, _c, _d;
        const view = args.view;
        const reverse = (val.reverse || false);
        const stubs = (val.stubs || 0);
        let d;
        if (Number.isFinite(stubs) && stubs !== 0) {
            if (!reverse) {
                let offset;
                if (stubs < 0) {
                    const len = view.getConnectionLength() || 0;
                    offset = (len + stubs) / 2;
                }
                else {
                    offset = stubs;
                }
                const path = view.getConnection();
                if (path) {
                    const sourceParts = path.divideAtLength(offset);
                    const targetParts = path.divideAtLength(-offset);
                    if (sourceParts && targetParts) {
                        d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
                    }
                }
            }
            else {
                let offset;
                let length;
                const len = view.getConnectionLength() || 0;
                if (stubs < 0) {
                    offset = (len + stubs) / 2;
                    length = -stubs;
                }
                else {
                    offset = stubs;
                    length = len - stubs * 2;
                }
                const path = view.getConnection();
                d = (_d = (_c = (_b = (_a = path === null || path === void 0 ? void 0 : path.divideAtLength(offset)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.divideAtLength(length)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.serialize();
            }
        }
        return { d: d || view.getConnectionPathData() };
    },
};
const atConnectionLengthKeepGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtLength', { rotate: true }),
};
const atConnectionLengthIgnoreGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtLength', { rotate: false }),
};
const atConnectionRatioKeepGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtRatio', { rotate: true }),
};
const atConnectionRatioIgnoreGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtRatio', { rotate: false }),
};
// aliases
// -------
const atConnectionLength = atConnectionLengthKeepGradient;
const atConnectionRatio = atConnectionRatioKeepGradient;
// utils
// -----
function atConnectionWrapper(method, options) {
    const zeroVector = { x: 1, y: 0 };
    return (value, args) => {
        let p;
        let angle;
        const view = args.view;
        const tangent = view[method](Number(value));
        if (tangent) {
            angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
            p = tangent.start;
        }
        else {
            p = view.path.start;
            angle = 0;
        }
        if (angle === 0) {
            return { transform: `translate(${p.x},${p.y}')` };
        }
        return {
            transform: `translate(${p.x},${p.y}') rotate(${angle})`,
        };
    };
}

var attrs = /*#__PURE__*/Object.freeze({
	__proto__: null,
	annotations: annotations,
	atConnectionLength: atConnectionLength,
	atConnectionLengthIgnoreGradient: atConnectionLengthIgnoreGradient,
	atConnectionLengthKeepGradient: atConnectionLengthKeepGradient,
	atConnectionRatio: atConnectionRatio,
	atConnectionRatioIgnoreGradient: atConnectionRatioIgnoreGradient,
	atConnectionRatioKeepGradient: atConnectionRatioKeepGradient,
	connection: connection,
	displayEmpty: displayEmpty,
	eol: eol,
	fill: fill,
	filter: filter,
	html: html$1,
	lineHeight: lineHeight,
	port: port,
	ref: ref,
	refCx: refCx,
	refCy: refCy,
	refD: refD,
	refDKeepOffset: refDKeepOffset,
	refDResetOffset: refDResetOffset,
	refDx: refDx,
	refDy: refDy,
	refHeight: refHeight,
	refHeight2: refHeight2,
	refPoints: refPoints,
	refPointsKeepOffset: refPointsKeepOffset,
	refPointsResetOffset: refPointsResetOffset,
	refR: refR,
	refRCircumscribed: refRCircumscribed,
	refRInscribed: refRInscribed,
	refRx: refRx,
	refRy: refRy,
	refWidth: refWidth,
	refWidth2: refWidth2,
	refX: refX,
	refX2: refX2,
	refY: refY,
	refY2: refY2,
	resetOffset: resetOffset,
	sourceMarker: sourceMarker,
	stroke: stroke$1,
	style: style$1,
	targetMarker: targetMarker,
	text: text$2,
	textPath: textPath,
	textVerticalAnchor: textVerticalAnchor,
	textWrap: textWrap,
	title: title,
	vertexMarker: vertexMarker,
	xAlign: xAlign,
	yAlign: yAlign
});

var Attr;
(function (Attr) {
    function isValidDefinition(def, val, options) {
        if (def != null) {
            if (typeof def === 'string') {
                return true;
            }
            if (typeof def.qualify !== 'function' ||
                call(def.qualify, this, val, options)) {
                return true;
            }
        }
        return false;
    }
    Attr.isValidDefinition = isValidDefinition;
})(Attr || (Attr = {}));
(function (Attr) {
    Attr.presets = Object.assign(Object.assign({}, raw), attrs);
    Attr.registry = Registry.create({
        type: 'attribute definition',
    });
    Attr.registry.register(Attr.presets, true);
})(Attr || (Attr = {}));

const dot = {
    color: '#aaaaaa',
    thickness: 1,
    markup: 'rect',
    update(elem, options) {
        const width = options.thickness * options.sx;
        const height = options.thickness * options.sy;
        attr$1(elem, {
            width,
            height,
            rx: width,
            ry: height,
            fill: options.color,
        });
    },
};

const fixedDot = {
    color: '#aaaaaa',
    thickness: 1,
    markup: 'rect',
    update(elem, options) {
        const size = options.sx <= 1 ? options.thickness * options.sx : options.thickness;
        attr$1(elem, {
            width: size,
            height: size,
            rx: size,
            ry: size,
            fill: options.color,
        });
    },
};

const mesh = {
    color: 'rgba(224,224,224,1)',
    thickness: 1,
    markup: 'path',
    update(elem, options) {
        let d;
        const width = options.width;
        const height = options.height;
        const thickness = options.thickness;
        if (width - thickness >= 0 && height - thickness >= 0) {
            d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
        }
        else {
            d = 'M 0 0 0 0';
        }
        attr$1(elem, {
            d,
            stroke: options.color,
            'stroke-width': options.thickness,
        });
    },
};

const doubleMesh = [
    {
        color: 'rgba(224,224,224,1)',
        thickness: 1,
        markup: 'path',
        update(elem, options) {
            let d;
            const width = options.width;
            const height = options.height;
            const thickness = options.thickness;
            if (width - thickness >= 0 && height - thickness >= 0) {
                d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
            }
            else {
                d = 'M 0 0 0 0';
            }
            attr$1(elem, {
                d,
                stroke: options.color,
                'stroke-width': options.thickness,
            });
        },
    },
    {
        color: 'rgba(224,224,224,0.2)',
        thickness: 3,
        factor: 4,
        markup: 'path',
        update(elem, options) {
            let d;
            const factor = options.factor || 1;
            const width = options.width * factor;
            const height = options.height * factor;
            const thickness = options.thickness;
            if (width - thickness >= 0 && height - thickness >= 0) {
                d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
            }
            else {
                d = 'M 0 0 0 0';
            }
            // update wrapper size
            options.width = width;
            options.height = height;
            attr$1(elem, {
                d,
                stroke: options.color,
                'stroke-width': options.thickness,
            });
        },
    },
];

var patterns$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	dot: dot,
	doubleMesh: doubleMesh,
	fixedDot: fixedDot,
	mesh: mesh
});

class Grid {
    constructor() {
        this.patterns = {};
        this.root = Vector.create(createSvgDocument(), {
            width: '100%',
            height: '100%',
        }, [createSvgElement('defs')]).node;
    }
    add(id, elem) {
        const firstChild = this.root.childNodes[0];
        if (firstChild) {
            firstChild.appendChild(elem);
        }
        this.patterns[id] = elem;
        Vector.create('rect', {
            width: '100%',
            height: '100%',
            fill: `url(#${id})`,
        }).appendTo(this.root);
    }
    get(id) {
        return this.patterns[id];
    }
    has(id) {
        return this.patterns[id] != null;
    }
}
(function (Grid) {
    Grid.presets = patterns$1;
    Grid.registry = Registry.create({
        type: 'grid',
    });
    Grid.registry.register(Grid.presets, true);
})(Grid || (Grid = {}));

function getString(value, defaultValue) {
    return value != null ? value : defaultValue;
}
function getNumber(num, defaultValue) {
    return num != null && Number.isFinite(num) ? num : defaultValue;
}

function outline(args = {}) {
    const color = getString(args.color, 'blue');
    const width = getNumber(args.width, 1);
    const margin = getNumber(args.margin, 2);
    const opacity = getNumber(args.opacity, 1);
    const innerRadius = margin;
    const outerRadius = margin + width;
    return `
    <filter>
      <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}

function highlight(args = {}) {
    const color = getString(args.color, 'red');
    const blur = getNumber(args.blur, 0);
    const width = getNumber(args.width, 1);
    const opacity = getNumber(args.opacity, 1);
    return `
      <filter>
        <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}

function blur(args = {}) {
    const x = getNumber(args.x, 2);
    const stdDeviation = args.y != null && Number.isFinite(args.y) ? [x, args.y] : x;
    return `
    <filter>
      <feGaussianBlur stdDeviation="${stdDeviation}"/>
    </filter>
  `.trim();
}

function dropShadow(args = {}) {
    const dx = getNumber(args.dx, 0);
    const dy = getNumber(args.dy, 0);
    const color = getString(args.color, 'black');
    const blur = getNumber(args.blur, 4);
    const opacity = getNumber(args.opacity, 1);
    return 'SVGFEDropShadowElement' in window
        ? `<filter>
         <feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}" />
       </filter>`.trim()
        : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${blur}" />
         <feOffset dx="${dx}" dy="${dy}" result="offsetblur" />
         <feFlood flood-color="${color}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${opacity}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}

function grayScale(args = {}) {
    const amount = getNumber(args.amount, 1);
    const a = 0.2126 + 0.7874 * (1 - amount);
    const b = 0.7152 - 0.7152 * (1 - amount);
    const c = 0.0722 - 0.0722 * (1 - amount);
    const d = 0.2126 - 0.2126 * (1 - amount);
    const e = 0.7152 + 0.2848 * (1 - amount);
    const f = 0.0722 - 0.0722 * (1 - amount);
    const g = 0.2126 - 0.2126 * (1 - amount);
    const h = 0.0722 + 0.9278 * (1 - amount);
    return `
    <filter>
      <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}

function sepia(args = {}) {
    const amount = getNumber(args.amount, 1);
    const a = 0.393 + 0.607 * (1 - amount);
    const b = 0.769 - 0.769 * (1 - amount);
    const c = 0.189 - 0.189 * (1 - amount);
    const d = 0.349 - 0.349 * (1 - amount);
    const e = 0.686 + 0.314 * (1 - amount);
    const f = 0.168 - 0.168 * (1 - amount);
    const g = 0.272 - 0.272 * (1 - amount);
    const h = 0.534 - 0.534 * (1 - amount);
    const i = 0.131 + 0.869 * (1 - amount);
    return `
      <filter>
        <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}

function saturate(args = {}) {
    const amount = getNumber(args.amount, 1);
    return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - amount}"/>
      </filter>
    `.trim();
}

function hueRotate(args = {}) {
    const angle = getNumber(args.angle, 0);
    return `
      <filter>
        <feColorMatrix type="hueRotate" values="${angle}"/>
      </filter>
    `.trim();
}

function invert(args = {}) {
    const amount = getNumber(args.amount, 1);
    const amount2 = 1 - amount;
    return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${amount} ${amount2}"/>
          <feFuncG type="table" tableValues="${amount} ${amount2}"/>
          <feFuncB type="table" tableValues="${amount} ${amount2}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}

function brightness(args = {}) {
    const amount = getNumber(args.amount, 1);
    return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}"/>
        <feFuncG type="linear" slope="${amount}"/>
        <feFuncB type="linear" slope="${amount}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

function contrast(args = {}) {
    const amount = getNumber(args.amount, 1);
    const amount2 = 0.5 - amount / 2;
    return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncG type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncB type="linear" slope="${amount}" intercept="${amount2}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

var filters = /*#__PURE__*/Object.freeze({
	__proto__: null,
	blur: blur,
	brightness: brightness,
	contrast: contrast,
	dropShadow: dropShadow,
	grayScale: grayScale,
	highlight: highlight,
	hueRotate: hueRotate,
	invert: invert,
	outline: outline,
	saturate: saturate,
	sepia: sepia
});

var Filter;
(function (Filter) {
    Filter.presets = filters;
    Filter.registry = Registry.create({
        type: 'filter',
    });
    Filter.registry.register(Filter.presets, true);
})(Filter || (Filter = {}));

const flipX = function (img) {
    // d b
    // d b
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = width * 2;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    // left image
    ctx.drawImage(img, 0, 0, width, height);
    // flipped right image
    ctx.translate(2 * width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};

const flipY = function (img) {
    // d d
    // q q
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = width;
    canvas.height = height * 2;
    const ctx = canvas.getContext('2d');
    // top image
    ctx.drawImage(img, 0, 0, width, height);
    // flipped bottom image
    ctx.translate(0, 2 * height);
    ctx.scale(1, -1);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};

const flipXY = function (img) {
    // d b
    // q p
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = 2 * width;
    canvas.height = 2 * height;
    const ctx = canvas.getContext('2d');
    // top-left image
    ctx.drawImage(img, 0, 0, width, height);
    // xy-flipped bottom-right image
    ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, width, height);
    // x-flipped top-right image
    ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
    ctx.drawImage(img, 0, 0, width, height);
    // y-flipped bottom-left image
    ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};

const watermark = function (img, options) {
    const width = img.width;
    const height = img.height;
    const canvas = document.createElement('canvas');
    canvas.width = width * 3;
    canvas.height = height * 3;
    const ctx = canvas.getContext('2d');
    const angle = options.angle != null ? -options.angle : -20;
    const radians = Angle.toRad(angle);
    const stepX = canvas.width / 4;
    const stepY = canvas.height / 4;
    for (let i = 0; i < 4; i += 1) {
        for (let j = 0; j < 4; j += 1) {
            if ((i + j) % 2 > 0) {
                ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
                ctx.rotate(radians);
                ctx.drawImage(img, -width / 2, -height / 2, width, height);
            }
        }
    }
    return canvas;
};

var patterns = /*#__PURE__*/Object.freeze({
	__proto__: null,
	flipX: flipX,
	flipXY: flipXY,
	flipY: flipY,
	watermark: watermark
});

var Background;
(function (Background) {
    Background.presets = Object.assign({}, patterns);
    Background.presets['flip-x'] = flipX;
    Background.presets['flip-y'] = flipY;
    Background.presets['flip-xy'] = flipXY;
    Background.registry = Registry.create({
        type: 'background pattern',
    });
    Background.registry.register(Background.presets, true);
})(Background || (Background = {}));

const Config = {
    prefixCls: 'x6',
    autoInsertCSS: true,
    useCSSSelector: true,
    trackable: false,
    trackInfo: {},
    /**
     * Turn on/off collect information of user client.
     *
     * In order to serve the users better, x6 will send the URL and version
     * information back to the AntV server:https://kcart.alipay.com/web/bi.do
     *
     * Except for URL and G2 version information, no other information will
     * be collected.
     *
     * @param enabled Specifies if seed client information to AntV server.
     */
    track(enabled) {
        Config.trackable = enabled;
    },
};

var Util$3;
(function (Util) {
    Util.snapToGrid = snapToGrid;
    Util.normalizeMarker = normalize$1;
    function prefix(suffix) {
        return `${Config.prefixCls}-${suffix}`;
    }
    Util.prefix = prefix;
})(Util$3 || (Util$3 = {}));
(function (Util) {
    function makeTree(parent, options, parentNode, collector = []) {
        const children = typeof options.children === 'function'
            ? options.children(parent)
            : parent[options.children || 'children'];
        if (!parentNode) {
            parentNode = options.createNode(parent); // eslint-disable-line
            collector.push(parentNode);
        }
        if (Array.isArray(children)) {
            children.forEach((child) => {
                const node = options.createNode(child);
                const edge = options.createEdge(parentNode, node);
                collector.push(node, edge);
                this.makeTree(child, options, node, collector);
            });
        }
        return collector;
    }
    Util.makeTree = makeTree;
})(Util$3 || (Util$3 = {}));

const defaultClassName = Util$3.prefix('highlighted');
const className$1 = {
    highlight(cellView, magnet, options) {
        const cls = (options && options.className) || defaultClassName;
        addClass(magnet, cls);
    },
    unhighlight(cellView, magnet, options) {
        const cls = (options && options.className) || defaultClassName;
        removeClass(magnet, cls);
    },
};

const className = Util$3.prefix('highlight-opacity');
const opacity = {
    highlight(cellView, magnet) {
        addClass(magnet, className);
    },
    unhighlight(cellView, magnetEl) {
        removeClass(magnetEl, className);
    },
};

const defaultOptions = {
    padding: 3,
    rx: 0,
    ry: 0,
    attrs: {
        'stroke-width': 3,
        stroke: '#FEB663',
    },
};
const stroke = {
    highlight(cellView, magnet, options) {
        const id = Private$8.getHighlighterId(magnet, options);
        if (Private$8.hasCache(id)) {
            return;
        }
        // eslint-disable-next-line
        options = defaultsDeep({}, options, defaultOptions);
        const magnetVel = Vector.create(magnet);
        let pathData;
        let magnetBBox;
        try {
            pathData = magnetVel.toPathData();
        }
        catch (error) {
            // Failed to get path data from magnet element.
            // Draw a rectangle around the entire cell view instead.
            magnetBBox = magnetVel.bbox(true /* without transforms */);
            pathData = rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));
        }
        const path = createSvgElement('path');
        attr$1(path, Object.assign({ d: pathData, 'pointer-events': 'none', 'vector-effect': 'non-scaling-stroke', fill: 'none' }, (options.attrs ? kebablizeAttrs(options.attrs) : null)));
        // const highlightVel = v.create('path').attr()
        if (cellView.isEdgeElement(magnet)) {
            attr$1(path, 'd', cellView.getConnectionPathData());
        }
        else {
            let highlightMatrix = magnetVel.getTransformToElement(cellView.container);
            // Add padding to the highlight element.
            const padding = options.padding;
            if (padding) {
                if (magnetBBox == null) {
                    magnetBBox = magnetVel.bbox(true);
                }
                const cx = magnetBBox.x + magnetBBox.width / 2;
                const cy = magnetBBox.y + magnetBBox.height / 2;
                magnetBBox = transformRectangle(magnetBBox, highlightMatrix);
                const width = Math.max(magnetBBox.width, 1);
                const height = Math.max(magnetBBox.height, 1);
                const sx = (width + padding) / width;
                const sy = (height + padding) / height;
                const paddingMatrix = createSVGMatrix({
                    a: sx,
                    b: 0,
                    c: 0,
                    d: sy,
                    e: cx - sx * cx,
                    f: cy - sy * cy,
                });
                highlightMatrix = highlightMatrix.multiply(paddingMatrix);
            }
            transform$1(path, highlightMatrix);
        }
        addClass(path, Util$3.prefix('highlight-stroke'));
        const cell = cellView.cell;
        const removeHandler = () => Private$8.removeHighlighter(id);
        cell.on('removed', removeHandler);
        if (cell.model) {
            cell.model.on('reseted', removeHandler);
        }
        cellView.container.appendChild(path);
        Private$8.setCache(id, path);
    },
    unhighlight(cellView, magnet, opt) {
        Private$8.removeHighlighter(Private$8.getHighlighterId(magnet, opt));
    },
};
var Private$8;
(function (Private) {
    function getHighlighterId(magnet, options) {
        ensureId(magnet);
        return magnet.id + JSON.stringify(options);
    }
    Private.getHighlighterId = getHighlighterId;
    const cache = {};
    function setCache(id, elem) {
        cache[id] = elem;
    }
    Private.setCache = setCache;
    function hasCache(id) {
        return cache[id] != null;
    }
    Private.hasCache = hasCache;
    function removeHighlighter(id) {
        const elem = cache[id];
        if (elem) {
            remove(elem);
            delete cache[id];
        }
    }
    Private.removeHighlighter = removeHighlighter;
})(Private$8 || (Private$8 = {}));

var highlighters = /*#__PURE__*/Object.freeze({
	__proto__: null,
	className: className$1,
	opacity: opacity,
	stroke: stroke
});

var Highlighter;
(function (Highlighter) {
    function check(name, highlighter) {
        if (typeof highlighter.highlight !== 'function') {
            throw new Error(`Highlighter '${name}' is missing required \`highlight()\` method`);
        }
        if (typeof highlighter.unhighlight !== 'function') {
            throw new Error(`Highlighter '${name}' is missing required \`unhighlight()\` method`);
        }
    }
    Highlighter.check = check;
})(Highlighter || (Highlighter = {}));
(function (Highlighter) {
    Highlighter.presets = highlighters;
    Highlighter.registry = Registry.create({
        type: 'highlighter',
    });
    Highlighter.registry.register(Highlighter.presets, true);
})(Highlighter || (Highlighter = {}));

function normalizePoint$1(bbox, args = {}) {
    return new Point(normalizePercentage(args.x, bbox.width), normalizePercentage(args.y, bbox.height));
}
function toResult$1(point, angle, rawArgs) {
    return Object.assign({ angle, position: point.toJSON() }, rawArgs);
}

const absolute = (portsPositionArgs, elemBBox) => {
    return portsPositionArgs.map(({ x, y, angle }) => toResult$1(normalizePoint$1(elemBBox, { x, y }), angle || 0));
};

const ellipse$1 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const startAngle = groupPositionArgs.start || 0;
    const stepAngle = groupPositionArgs.step || 20;
    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index, count) => (index + 0.5 - count / 2) * stepAngle);
};
const ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const startAngle = groupPositionArgs.start || 0;
    const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;
    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index) => {
        return index * stepAngle;
    });
};
function ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {
    const center = elemBBox.getCenter();
    const start = elemBBox.getTopCenter();
    const ratio = elemBBox.width / elemBBox.height;
    const ellipse = Ellipse$2.fromRect(elemBBox);
    const count = portsPositionArgs.length;
    return portsPositionArgs.map((item, index) => {
        const angle = startAngle + stepFn(index, count);
        const p = start.clone().rotate(-angle, center).scale(ratio, 1, center);
        const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;
        if (item.dx || item.dy) {
            p.translate(item.dx || 0, item.dy || 0);
        }
        if (item.dr) {
            p.move(center, item.dr);
        }
        return toResult$1(p.round(), theta, item);
    });
}

var __rest$o = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const line$1 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const start = normalizePoint$1(elemBBox, groupPositionArgs.start || elemBBox.getOrigin());
    const end = normalizePoint$1(elemBBox, groupPositionArgs.end || elemBBox.getCorner());
    return lineLayout(portsPositionArgs, start, end, groupPositionArgs);
};
const left$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getBottomLeft(), groupPositionArgs);
};
const right$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopRight(), elemBBox.getBottomRight(), groupPositionArgs);
};
const top$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getTopRight(), groupPositionArgs);
};
const bottom$2 = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getBottomLeft(), elemBBox.getBottomRight(), groupPositionArgs);
};
function lineLayout(portsPositionArgs, p1, p2, groupPositionArgs) {
    const line = new Line(p1, p2);
    const length = portsPositionArgs.length;
    return portsPositionArgs.map((_a, index) => {
        var { strict } = _a, offset = __rest$o(_a, ["strict"]);
        const ratio = strict || groupPositionArgs.strict
            ? (index + 1) / (length + 1)
            : (index + 0.5) / length;
        const p = line.pointAt(ratio);
        if (offset.dx || offset.dy) {
            p.translate(offset.dx || 0, offset.dy || 0);
        }
        return toResult$1(p.round(), 0, offset);
    });
}

var layouts$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	absolute: absolute,
	bottom: bottom$2,
	ellipse: ellipse$1,
	ellipseSpread: ellipseSpread,
	left: left$2,
	line: line$1,
	right: right$2,
	top: top$2
});

var PortLayout;
(function (PortLayout) {
    PortLayout.presets = layouts$1;
    PortLayout.registry = Registry.create({
        type: 'port layout',
    });
    PortLayout.registry.register(PortLayout.presets, true);
})(PortLayout || (PortLayout = {}));

const defaults$2 = {
    position: { x: 0, y: 0 },
    angle: 0,
    attrs: {
        '.': {
            y: '0',
            'text-anchor': 'start',
        },
    },
};
function toResult(preset, args) {
    const { x, y, angle, attrs } = args || {};
    return defaultsDeep({}, { angle, attrs, position: { x, y } }, preset, defaults$2);
}

const manual = (portPosition, elemBBox, args) => toResult({ position: elemBBox.getTopLeft() }, args);
const left$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: -15, y: 0 },
    attrs: { '.': { y: '.3em', 'text-anchor': 'end' } },
}, args);
const right$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: 15, y: 0 },
    attrs: { '.': { y: '.3em', 'text-anchor': 'start' } },
}, args);
const top$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: 0, y: -15 },
    attrs: { '.': { 'text-anchor': 'middle' } },
}, args);
const bottom$1 = (portPosition, elemBBox, args) => toResult({
    position: { x: 0, y: 15 },
    attrs: { '.': { y: '.6em', 'text-anchor': 'middle' } },
}, args);

const outside = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, false, args);
const outsideOriented = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, true, args);
const inside = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, false, args);
const insideOriented = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, true, args);
function outsideLayout(portPosition, elemBBox, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 15;
    const angle = elemBBox.getCenter().theta(portPosition);
    const bboxAngles = getBBoxAngles(elemBBox);
    let y;
    let tx;
    let ty;
    let textAnchor;
    let orientAngle = 0;
    if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    }
    else if (angle < bboxAngles[0]) {
        y = '0';
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    else if (angle < bboxAngles[3]) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    }
    else {
        y = '.6em';
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    return toResult({
        position: {
            x: Math.round(tx),
            y: Math.round(ty),
        },
        angle: orientAngle,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}
function insideLayout(portPosition, elemBBox, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 15;
    const angle = elemBBox.getCenter().theta(portPosition);
    const bboxAngles = getBBoxAngles(elemBBox);
    let y;
    let tx;
    let ty;
    let textAnchor;
    let orientAngle = 0;
    if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    }
    else if (angle < bboxAngles[0]) {
        y = '.6em';
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    else if (angle < bboxAngles[3]) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    }
    else {
        y = '0em';
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    return toResult({
        position: {
            x: Math.round(tx),
            y: Math.round(ty),
        },
        angle: orientAngle,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}
function getBBoxAngles(elemBBox) {
    const center = elemBBox.getCenter();
    const tl = center.theta(elemBBox.getTopLeft());
    const bl = center.theta(elemBBox.getBottomLeft());
    const br = center.theta(elemBBox.getBottomRight());
    const tr = center.theta(elemBBox.getTopRight());
    return [tl, tr, br, bl];
}

const radial = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), false, args);
const radialOriented = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), true, args);
function radialLayout(portCenterOffset, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 20;
    const origin = new Point(0, 0);
    const angle = -portCenterOffset.theta(origin);
    const pos = portCenterOffset
        .clone()
        .move(origin, offset)
        .diff(portCenterOffset)
        .round();
    let y = '.3em';
    let textAnchor;
    let orientAngle = angle;
    if ((angle + 90) % 180 === 0) {
        textAnchor = autoOrient ? 'end' : 'middle';
        if (!autoOrient && angle === -270) {
            y = '0em';
        }
    }
    else if (angle > -270 && angle < -90) {
        textAnchor = 'start';
        orientAngle = angle - 180;
    }
    else {
        textAnchor = 'end';
    }
    return toResult({
        position: pos.round().toJSON(),
        angle: autoOrient ? orientAngle : 0,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}

var layouts = /*#__PURE__*/Object.freeze({
	__proto__: null,
	bottom: bottom$1,
	inside: inside,
	insideOriented: insideOriented,
	left: left$1,
	manual: manual,
	outside: outside,
	outsideOriented: outsideOriented,
	radial: radial,
	radialOriented: radialOriented,
	right: right$1,
	top: top$1
});

var PortLabelLayout;
(function (PortLabelLayout) {
    PortLabelLayout.presets = layouts;
    PortLabelLayout.registry = Registry.create({
        type: 'port label layout',
    });
    PortLabelLayout.registry.register(PortLabelLayout.presets, true);
})(PortLabelLayout || (PortLabelLayout = {}));

class Color {
    constructor(color, g, b, a) {
        if (color == null) {
            return this.set(255, 255, 255, 1);
        }
        if (typeof color === 'number') {
            return this.set(color, g, b, a);
        }
        if (typeof color === 'string') {
            return Color.fromString(color) || this;
        }
        if (Array.isArray(color)) {
            return this.set(color);
        }
        this.set(color.r, color.g, color.b, color.a == null ? 1 : color.a);
    }
    blend(start, end, weight) {
        this.set(start.r + (end.r - start.r) * weight, start.g + (end.g - start.g) * weight, start.b + (end.b - start.b) * weight, start.a + (end.a - start.a) * weight);
    }
    lighten(amount) {
        const rgba = Color.lighten(this.toArray(), amount);
        this.r = rgba[0];
        this.g = rgba[1];
        this.b = rgba[2];
        this.a = rgba[3];
    }
    darken(amount) {
        this.lighten(-amount);
    }
    set(arg0, arg1, arg2, arg3) {
        const r = Array.isArray(arg0) ? arg0[0] : arg0;
        const g = Array.isArray(arg0) ? arg0[1] : arg1;
        const b = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        this.r = Math.round(clamp$1(r, 0, 255));
        this.g = Math.round(clamp$1(g, 0, 255));
        this.b = Math.round(clamp$1(b, 0, 255));
        this.a = a == null ? 1 : clamp$1(a, 0, 1);
        return this;
    }
    toHex() {
        const hex = ['r', 'g', 'b'].map((key) => {
            const str = this[key].toString(16);
            return str.length < 2 ? `0${str}` : str;
        });
        return `#${hex.join('')}`;
    }
    toRGBA() {
        return this.toArray();
    }
    toHSLA() {
        return Color.rgba2hsla(this.r, this.g, this.b, this.a);
    }
    toCSS(ignoreAlpha) {
        const rgb = `${this.r},${this.g},${this.b},`;
        return ignoreAlpha ? `rgb(${rgb})` : `rgba(${rgb},${this.a})`;
    }
    toGrey() {
        return Color.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
    }
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    toString() {
        return this.toCSS();
    }
}
(function (Color) {
    function fromArray(arr) {
        return new Color(arr);
    }
    Color.fromArray = fromArray;
    function fromHex(color) {
        return new Color([...hex2rgb(color), 1]);
    }
    Color.fromHex = fromHex;
    function fromRGBA(color) {
        const matches = color.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
        if (matches) {
            const arr = matches[1].split(/\s*,\s*/).map((v) => parseInt(v, 10));
            return new Color(arr);
        }
        return null;
    }
    Color.fromRGBA = fromRGBA;
    function hue2rgb(m1, m2, h) {
        if (h < 0) {
            ++h; // eslint-disable-line
        }
        if (h > 1) {
            --h; // eslint-disable-line
        }
        const h6 = 6 * h;
        if (h6 < 1) {
            return m1 + (m2 - m1) * h6;
        }
        if (2 * h < 1) {
            return m2;
        }
        if (3 * h < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        return m1;
    }
    function fromHSLA(color) {
        const matches = color.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
        if (matches) {
            const arr = matches[2].split(/\s*,\s*/);
            const h = (((parseFloat(arr[0]) % 360) + 360) % 360) / 360;
            const s = parseFloat(arr[1]) / 100;
            const l = parseFloat(arr[2]) / 100;
            const a = arr[3] == null ? 1 : parseInt(arr[3], 10);
            return new Color(hsla2rgba(h, s, l, a));
        }
        return null;
    }
    Color.fromHSLA = fromHSLA;
    function fromString(color) {
        if (color.startsWith('#')) {
            return fromHex(color);
        }
        if (color.startsWith('rgb')) {
            return fromRGBA(color);
        }
        const preset = Color.named[color];
        if (preset) {
            return fromHex(preset);
        }
        return fromHSLA(color);
    }
    Color.fromString = fromString;
    function makeGrey(g, a) {
        return Color.fromArray([g, g, g, a]);
    }
    Color.makeGrey = makeGrey;
    function rgba2hsla(arg0, arg1, arg2, arg3) {
        const r = Array.isArray(arg0) ? arg0[0] : arg0;
        const g = Array.isArray(arg0) ? arg0[1] : arg1;
        const b = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        let h = 0;
        let s = 0;
        if (min !== max) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                default:
                    break;
            }
            h /= 6;
        }
        return [h, s, l, a == null ? 1 : a];
    }
    Color.rgba2hsla = rgba2hsla;
    function hsla2rgba(arg0, arg1, arg2, arg3) {
        const h = Array.isArray(arg0) ? arg0[0] : arg0;
        const s = Array.isArray(arg0) ? arg0[1] : arg1;
        const l = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        const m1 = 2 * l - m2;
        return [
            hue2rgb(m1, m2, h + 1 / 3) * 256,
            hue2rgb(m1, m2, h) * 256,
            hue2rgb(m1, m2, h - 1 / 3) * 256,
            a == null ? 1 : a,
        ];
    }
    Color.hsla2rgba = hsla2rgba;
    function random(ignoreAlpha) {
        return new Color(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), ignoreAlpha ? undefined : parseFloat(Math.random().toFixed(2)));
    }
    Color.random = random;
    function randomHex() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i += 1) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    Color.randomHex = randomHex;
    function randomRGBA(ignoreAlpha) {
        return random(ignoreAlpha).toString();
    }
    Color.randomRGBA = randomRGBA;
    function invert(color, bw) {
        if (typeof color === 'string') {
            const pound = color[0] === '#';
            const [r, g, b] = hex2rgb(color);
            if (bw) {
                // http://stackoverflow.com/a/3943023/112731
                return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#ffffff';
            }
            return `${pound ? '#' : ''}${rgb2hex(255 - r, 255 - g, 255 - b)}`;
        }
        const r = color[0];
        const g = color[1];
        const b = color[2];
        const a = color[3];
        if (bw) {
            return r * 0.299 + g * 0.587 + b * 0.114 > 186
                ? [0, 0, 0, a]
                : [255, 255, 255, a];
        }
        return [255 - r, 255 - g, 255 - b, a];
    }
    Color.invert = invert;
    function hex2rgb(hex) {
        const color = hex.indexOf('#') === 0 ? hex : `#${hex}`;
        let val = Number(`0x${color.substr(1)}`);
        if (!(color.length === 4 || color.length === 7) || Number.isNaN(val)) {
            throw new Error('Invalid hex color.');
        }
        const bits = color.length === 4 ? 4 : 8;
        const mask = (1 << bits) - 1;
        const bgr = ['b', 'g', 'r'].map(() => {
            const c = val & mask;
            val >>= bits;
            return bits === 4 ? 17 * c : c;
        });
        return [bgr[2], bgr[1], bgr[0]];
    }
    function rgb2hex(r, g, b) {
        const pad = (hex) => (hex.length < 2 ? `0${hex}` : hex);
        return `${pad(r.toString(16))}${pad(g.toString(16))}${pad(b.toString(16))}`;
    }
    function lighten(color, amt) {
        return lum(color, amt);
    }
    Color.lighten = lighten;
    function darken(color, amt) {
        return lum(color, -amt);
    }
    Color.darken = darken;
    function lum(color, amt) {
        if (typeof color === 'string') {
            const pound = color[0] === '#';
            const num = parseInt(pound ? color.substr(1) : color, 16);
            const r = clamp$1((num >> 16) + amt, 0, 255);
            const g = clamp$1(((num >> 8) & 0x00ff) + amt, 0, 255);
            const b = clamp$1((num & 0x0000ff) + amt, 0, 255);
            return `${pound ? '#' : ''}${(b | (g << 8) | (r << 16)).toString(16)}`;
        }
        const hex = rgb2hex(color[0], color[1], color[2]);
        const arr = hex2rgb(lum(hex, amt));
        return [arr[0], arr[1], arr[2], color[3]];
    }
})(Color || (Color = {}));
(function (Color) {
    Color.named = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        burntsienna: '#ea7e5d',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32',
    };
})(Color || (Color = {}));

class Events {
    constructor() {
        this.listeners = {};
    }
    on(name, handler, context) {
        if (handler == null) {
            return this;
        }
        if (!this.listeners[name]) {
            this.listeners[name] = [];
        }
        const cache = this.listeners[name];
        cache.push(handler, context);
        return this;
    }
    once(name, handler, context) {
        const cb = (...args) => {
            this.off(name, cb);
            return Private$7.call([handler, context], args);
        };
        return this.on(name, cb, this);
    }
    off(name, handler, context) {
        // remove all events.
        if (!(name || handler || context)) {
            this.listeners = {};
            return this;
        }
        const listeners = this.listeners;
        const names = name ? [name] : Object.keys(listeners);
        names.forEach((n) => {
            const cache = listeners[n];
            if (!cache) {
                return;
            }
            // remove all events with specified name.
            if (!(handler || context)) {
                delete listeners[n];
                return;
            }
            for (let i = cache.length - 2; i >= 0; i -= 2) {
                if (!((handler && cache[i] !== handler) ||
                    (context && cache[i + 1] !== context))) {
                    cache.splice(i, 2);
                }
            }
        });
        return this;
    }
    trigger(name, ...args) {
        let returned = true;
        if (name !== '*') {
            const list = this.listeners[name];
            if (list != null) {
                returned = Private$7.call([...list], args);
            }
        }
        const list = this.listeners['*'];
        if (list != null) {
            return toAsyncBoolean([
                returned,
                Private$7.call([...list], [name, ...args]),
            ]);
        }
        return returned;
    }
    emit(name, ...args) {
        return this.trigger(name, ...args);
    }
}
var Private$7;
(function (Private) {
    function call(list, args) {
        const results = [];
        for (let i = 0; i < list.length; i += 2) {
            const handler = list[i];
            const context = list[i + 1];
            const params = Array.isArray(args) ? args : [args];
            const ret = apply(handler, context, params);
            results.push(ret);
        }
        return toAsyncBoolean(results);
    }
    Private.call = call;
})(Private$7 || (Private$7 = {}));

/* eslint-disable no-underscore-dangle */
class Disposable {
    get disposed() {
        return this._disposed === true;
    }
    dispose() {
        this._disposed = true;
    }
}
(function (Disposable) {
    function dispose() {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            const proto = target.__proto__; // eslint-disable-line
            descriptor.value = function () {
                if (this.disposed) {
                    return;
                }
                raw.call(this);
                proto.dispose.call(this);
            };
        };
    }
    Disposable.dispose = dispose;
})(Disposable || (Disposable = {}));
/**
 * A disposable object which delegates to a callback function.
 */
class DisposableDelegate {
    /**
     * Construct a new disposable delegate.
     *
     * @param callback - The callback function to invoke on dispose.
     */
    constructor(callback) {
        this.callback = callback;
    }
    /**
     * Test whether the delegate has been disposed.
     */
    get disposed() {
        return !this.callback;
    }
    /**
     * Dispose of the delegate and invoke the callback function.
     */
    dispose() {
        if (!this.callback) {
            return;
        }
        const callback = this.callback;
        this.callback = null;
        callback();
    }
}
/**
 * An object which manages a collection of disposable items.
 */
class DisposableSet {
    constructor() {
        this.isDisposed = false; // eslint-disable-line:variable-name
        this.items = new Set();
    }
    /**
     * Test whether the set has been disposed.
     */
    get disposed() {
        return this.isDisposed;
    }
    /**
     * Dispose of the set and the items it contains.
     *
     * #### Notes
     * Items are disposed in the order they are added to the set.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this.items.forEach((item) => {
            item.dispose();
        });
        this.items.clear();
    }
    /**
     * Test whether the set contains a specific item.
     *
     * @param item - The item of interest.
     *
     * @returns `true` if the set contains the item, `false` otherwise.
     */
    contains(item) {
        return this.items.has(item);
    }
    /**
     * Add a disposable item to the set.
     *
     * @param item - The item to add to the set.
     *
     * #### Notes
     * If the item is already contained in the set, this is a no-op.
     */
    add(item) {
        this.items.add(item);
    }
    /**
     * Remove a disposable item from the set.
     *
     * @param item - The item to remove from the set.
     *
     * #### Notes
     * If the item is not contained in the set, this is a no-op.
     */
    remove(item) {
        this.items.delete(item);
    }
    /**
     * Remove all items from the set.
     */
    clear() {
        this.items.clear();
    }
}
(function (DisposableSet) {
    /**
     * Create a disposable set from an iterable of items.
     *
     * @param items - The iterable or array-like object of interest.
     *
     * @returns A new disposable initialized with the given items.
     */
    function from(items) {
        const set = new DisposableSet();
        items.forEach((item) => {
            set.add(item);
        });
        return set;
    }
    DisposableSet.from = from;
})(DisposableSet || (DisposableSet = {}));

class Basecoat extends Events {
}
(function (Basecoat) {
    Basecoat.dispose = Disposable.dispose;
})(Basecoat || (Basecoat = {}));
applyMixins(Basecoat, Disposable);

/* eslint-disable no-underscore-dangle */
class Disablable extends Basecoat {
    get disabled() {
        return this._disabled === true;
    }
    enable() {
        delete this._disabled;
    }
    disable() {
        this._disabled = true;
    }
}

var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Dictionary extends Disposable {
    constructor() {
        super();
        this.clear();
    }
    clear() {
        this.map = new WeakMap();
        this.arr = [];
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        return this.map.get(key);
    }
    set(key, value) {
        this.map.set(key, value);
        this.arr.push(key);
    }
    delete(key) {
        const index = this.arr.indexOf(key);
        if (index >= 0) {
            this.arr.splice(index, 1);
        }
        const ret = this.map.get(key);
        this.map.delete(key);
        return ret;
    }
    each(iterator) {
        this.arr.forEach((key) => {
            const value = this.map.get(key);
            iterator(value, key);
        });
    }
    dispose() {
        this.clear();
    }
}
__decorate$t([
    Disposable.dispose()
], Dictionary.prototype, "dispose", null);

/**
 * An implementation of the Priority Queue abstract data type.
 *
 * @see: http://en.wikipedia.org/wiki/Priority_queue
 *
 * It is like a normal stack or queue, but where each item has assigned a
 * priority (a number). Items with higher priority are served before items
 * with lower priority. This implementation uses binary heap as an internal
 * representation of the queue. The time complexity of all the methods is as
 * follows:
 *
 * - create: `O(n)`
 * - insert: `O(log n)`
 * - remove: `O(log n)`
 * - peek: `O(1)`
 * - isEmpty: `O(1)`
 * - peekPriority: `O(1)`
 */
class PriorityQueue {
    constructor(options = {}) {
        this.comparator = options.comparator || PriorityQueue.defaultComparator;
        this.index = {};
        this.data = options.data || [];
        this.heapify();
    }
    /**
     * Returns `true` if the priority queue is empty, `false` otherwise.
     */
    isEmpty() {
        return this.data.length === 0;
    }
    /**
     * Inserts a value with priority to the queue. Optionally pass a unique
     * id of this item. Passing unique IDs for each item you insert allows
     * you to use the `updatePriority()` operation.
     * @param priority
     * @param value
     * @param id
     */
    insert(priority, value, id) {
        const item = { priority, value };
        const index = this.data.length;
        if (id) {
            item.id = id;
            this.index[id] = index;
        }
        this.data.push(item);
        this.bubbleUp(index);
        return this;
    }
    /**
     * Returns the value of an item with the highest priority.
     */
    peek() {
        return this.data[0] ? this.data[0].value : null;
    }
    /**
     * Returns the highest priority in the queue.
     */
    peekPriority() {
        return this.data[0] ? this.data[0].priority : null;
    }
    updatePriority(id, priority) {
        const index = this.index[id];
        if (typeof index === 'undefined') {
            throw new Error(`Node with id '${id}' was not found in the heap.`);
        }
        const data = this.data;
        const oldPriority = data[index].priority;
        const comp = this.comparator(priority, oldPriority);
        if (comp < 0) {
            data[index].priority = priority;
            this.bubbleUp(index);
        }
        else if (comp > 0) {
            data[index].priority = priority;
            this.bubbleDown(index);
        }
    }
    /**
     * Removes the item with the highest priority from the queue
     *
     * @returns The value of the removed item.
     */
    remove() {
        const data = this.data;
        const peek = data[0];
        const last = data.pop();
        if (peek.id) {
            delete this.index[peek.id];
        }
        if (data.length > 0) {
            data[0] = last;
            if (last.id) {
                this.index[last.id] = 0;
            }
            this.bubbleDown(0);
        }
        return peek ? peek.value : null;
    }
    heapify() {
        for (let i = 0; i < this.data.length; i += 1) {
            this.bubbleUp(i);
        }
    }
    bubbleUp(index) {
        const data = this.data;
        let tmp;
        let parent;
        let current = index;
        while (current > 0) {
            parent = (current - 1) >>> 1;
            if (this.comparator(data[current].priority, data[parent].priority) < 0) {
                tmp = data[parent];
                data[parent] = data[current];
                let id = data[current].id;
                if (id != null) {
                    this.index[id] = parent;
                }
                data[current] = tmp;
                id = data[current].id;
                if (id != null) {
                    this.index[id] = current;
                }
                current = parent;
            }
            else {
                break;
            }
        }
    }
    bubbleDown(index) {
        const data = this.data;
        const last = data.length - 1;
        let current = index;
        // eslint-disable-next-line
        while (true) {
            const left = (current << 1) + 1;
            const right = left + 1;
            let minIndex = current;
            if (left <= last &&
                this.comparator(data[left].priority, data[minIndex].priority) < 0) {
                minIndex = left;
            }
            if (right <= last &&
                this.comparator(data[right].priority, data[minIndex].priority) < 0) {
                minIndex = right;
            }
            if (minIndex !== current) {
                const tmp = data[minIndex];
                data[minIndex] = data[current];
                let id = data[current].id;
                if (id != null) {
                    this.index[id] = minIndex;
                }
                data[current] = tmp;
                id = data[current].id;
                if (id != null) {
                    this.index[id] = current;
                }
                current = minIndex;
            }
            else {
                break;
            }
        }
    }
}
(function (PriorityQueue) {
    PriorityQueue.defaultComparator = (a, b) => a - b;
})(PriorityQueue || (PriorityQueue = {}));

var Dijkstra;
(function (Dijkstra) {
    function run(adjacencyList, source, weight = (u, v) => 1) {
        const dist = {};
        const previous = {};
        const scanned = {};
        const queue = new PriorityQueue();
        dist[source] = 0;
        Object.keys(adjacencyList).forEach((v) => {
            if (v !== source) {
                dist[v] = Infinity;
            }
            queue.insert(dist[v], v, v);
        });
        while (!queue.isEmpty()) {
            const u = queue.remove();
            scanned[u] = true;
            const neighbours = adjacencyList[u] || [];
            for (let i = 0; i < neighbours.length; i += 1) {
                const v = neighbours[i];
                if (!scanned[v]) {
                    const alt = dist[u] + weight(u, v);
                    if (alt < dist[v]) {
                        dist[v] = alt;
                        previous[v] = u;
                        queue.updatePriority(v, alt);
                    }
                }
            }
        }
        return previous;
    }
    Dijkstra.run = run;
})(Dijkstra || (Dijkstra = {}));

var Timing;
(function (Timing) {
    Timing.linear = (t) => t;
    Timing.quad = (t) => t * t;
    Timing.cubic = (t) => t * t * t;
    Timing.inout = (t) => {
        if (t <= 0) {
            return 0;
        }
        if (t >= 1) {
            return 1;
        }
        const t2 = t * t;
        const t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    };
    Timing.exponential = (t) => {
        return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
    };
    Timing.bounce = ((t) => {
        // eslint-disable-next-line
        for (let a = 0, b = 1; 1; a += b, b /= 2) {
            if (t >= (7 - 4 * a) / 11) {
                const q = (11 - 6 * a - 11 * t) / 4;
                return -q * q + b * b;
            }
        }
    });
})(Timing || (Timing = {}));
(function (Timing) {
    Timing.decorators = {
        reverse(f) {
            return (t) => 1 - f(1 - t);
        },
        reflect(f) {
            return (t) => 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
        },
        clamp(f, n = 0, x = 1) {
            return (t) => {
                const r = f(t);
                return r < n ? n : r > x ? x : r;
            };
        },
        back(s = 1.70158) {
            return (t) => t * t * ((s + 1) * t - s);
        },
        elastic(x = 1.5) {
            return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(((20 * Math.PI * x) / 3) * t); // eslint-disable-line
        },
    };
})(Timing || (Timing = {}));
(function (Timing) {
    // Slight acceleration from zero to full speed
    function easeInSine(t) {
        return -1 * Math.cos(t * (Math.PI / 2)) + 1;
    }
    Timing.easeInSine = easeInSine;
    // Slight deceleration at the end
    function easeOutSine(t) {
        return Math.sin(t * (Math.PI / 2));
    }
    Timing.easeOutSine = easeOutSine;
    // Slight acceleration at beginning and slight deceleration at end
    function easeInOutSine(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    }
    Timing.easeInOutSine = easeInOutSine;
    // Accelerating from zero velocity
    function easeInQuad(t) {
        return t * t;
    }
    Timing.easeInQuad = easeInQuad;
    // Decelerating to zero velocity
    function easeOutQuad(t) {
        return t * (2 - t);
    }
    Timing.easeOutQuad = easeOutQuad;
    // Acceleration until halfway, then deceleration
    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    Timing.easeInOutQuad = easeInOutQuad;
    // Accelerating from zero velocity
    function easeInCubic(t) {
        return t * t * t;
    }
    Timing.easeInCubic = easeInCubic;
    // Decelerating to zero velocity
    function easeOutCubic(t) {
        const t1 = t - 1;
        return t1 * t1 * t1 + 1;
    }
    Timing.easeOutCubic = easeOutCubic;
    // Acceleration until halfway, then deceleration
    function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }
    Timing.easeInOutCubic = easeInOutCubic;
    // Accelerating from zero velocity
    function easeInQuart(t) {
        return t * t * t * t;
    }
    Timing.easeInQuart = easeInQuart;
    // Decelerating to zero velocity
    function easeOutQuart(t) {
        const t1 = t - 1;
        return 1 - t1 * t1 * t1 * t1;
    }
    Timing.easeOutQuart = easeOutQuart;
    // Acceleration until halfway, then deceleration
    function easeInOutQuart(t) {
        const t1 = t - 1;
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;
    }
    Timing.easeInOutQuart = easeInOutQuart;
    // Accelerating from zero velocity
    function easeInQuint(t) {
        return t * t * t * t * t;
    }
    Timing.easeInQuint = easeInQuint;
    // Decelerating to zero velocity
    function easeOutQuint(t) {
        const t1 = t - 1;
        return 1 + t1 * t1 * t1 * t1 * t1;
    }
    Timing.easeOutQuint = easeOutQuint;
    // Acceleration until halfway, then deceleration
    function easeInOutQuint(t) {
        const t1 = t - 1;
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;
    }
    Timing.easeInOutQuint = easeInOutQuint;
    // Accelerate exponentially until finish
    function easeInExpo(t) {
        if (t === 0) {
            return 0;
        }
        return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
    }
    Timing.easeInExpo = easeInExpo;
    // Initial exponential acceleration slowing to stop
    function easeOutExpo(t) {
        if (t === 1) {
            return 1;
        }
        return -Math.pow(2, -10 * t) + 1; // eslint-disable-line
    }
    Timing.easeOutExpo = easeOutExpo;
    // Exponential acceleration and deceleration
    function easeInOutExpo(t) {
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 1;
        if (scaledTime < 1) {
            return 0.5 * Math.pow(2, 10 * scaledTime1); // eslint-disable-line
        }
        return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2); // eslint-disable-line
    }
    Timing.easeInOutExpo = easeInOutExpo;
    // Increasing velocity until stop
    function easeInCirc(t) {
        const scaledTime = t / 1;
        return -1 * (Math.sqrt(1 - scaledTime * t) - 1);
    }
    Timing.easeInCirc = easeInCirc;
    // Start fast, decreasing velocity until stop
    function easeOutCirc(t) {
        const t1 = t - 1;
        return Math.sqrt(1 - t1 * t1);
    }
    Timing.easeOutCirc = easeOutCirc;
    // Fast increase in velocity, fast decrease in velocity
    function easeInOutCirc(t) {
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 2;
        if (scaledTime < 1) {
            return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);
        }
        return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);
    }
    Timing.easeInOutCirc = easeInOutCirc;
    // Slow movement backwards then fast snap to finish
    function easeInBack(t, magnitude = 1.70158) {
        return t * t * ((magnitude + 1) * t - magnitude);
    }
    Timing.easeInBack = easeInBack;
    // Fast snap to backwards point then slow resolve to finish
    function easeOutBack(t, magnitude = 1.70158) {
        const scaledTime = t / 1 - 1;
        return (scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1);
    }
    Timing.easeOutBack = easeOutBack;
    // Slow movement backwards, fast snap to past finish, slow resolve to finish
    function easeInOutBack(t, magnitude = 1.70158) {
        const scaledTime = t * 2;
        const scaledTime2 = scaledTime - 2;
        const s = magnitude * 1.525;
        if (scaledTime < 1) {
            return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);
        }
        return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);
    }
    Timing.easeInOutBack = easeInOutBack;
    // Bounces slowly then quickly to finish
    function easeInElastic(t, magnitude = 0.7) {
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t / 1;
        const scaledTime1 = scaledTime - 1;
        const p = 1 - magnitude;
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        return -(Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
            Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p));
    }
    Timing.easeInElastic = easeInElastic;
    // Fast acceleration, bounces to zero
    function easeOutElastic(t, magnitude = 0.7) {
        const p = 1 - magnitude;
        const scaledTime = t * 2;
        if (t === 0 || t === 1) {
            return t;
        }
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        return (Math.pow(2, -10 * scaledTime) * // eslint-disable-line
            Math.sin(((scaledTime - s) * (2 * Math.PI)) / p) +
            1);
    }
    Timing.easeOutElastic = easeOutElastic;
    // Slow start and end, two bounces sandwich a fast motion
    function easeInOutElastic(t, magnitude = 0.65) {
        const p = 1 - magnitude;
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 1;
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        if (scaledTime < 1) {
            return (-0.5 *
                (Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
                    Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p)));
        }
        return (Math.pow(2, -10 * scaledTime1) * // eslint-disable-line
            Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p) *
            0.5 +
            1);
    }
    Timing.easeInOutElastic = easeInOutElastic;
    // Bounce to completion
    function easeOutBounce(t) {
        const scaledTime = t / 1;
        if (scaledTime < 1 / 2.75) {
            return 7.5625 * scaledTime * scaledTime;
        }
        if (scaledTime < 2 / 2.75) {
            const scaledTime2 = scaledTime - 1.5 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.75;
        }
        if (scaledTime < 2.5 / 2.75) {
            const scaledTime2 = scaledTime - 2.25 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.9375;
        }
        {
            const scaledTime2 = scaledTime - 2.625 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.984375;
        }
    }
    Timing.easeOutBounce = easeOutBounce;
    // Bounce increasing in velocity until completion
    function easeInBounce(t) {
        return 1 - easeOutBounce(1 - t);
    }
    Timing.easeInBounce = easeInBounce;
    // Bounce in and bounce out
    function easeInOutBounce(t) {
        if (t < 0.5) {
            return easeInBounce(t * 2) * 0.5;
        }
        return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
    }
    Timing.easeInOutBounce = easeInOutBounce;
})(Timing || (Timing = {}));

var Interp;
(function (Interp) {
    Interp.number = (a, b) => {
        const d = b - a;
        return (t) => {
            return a + d * t;
        };
    };
    Interp.object = (a, b) => {
        const keys = Object.keys(a);
        return (t) => {
            const ret = {};
            for (let i = keys.length - 1; i !== -1; i -= 1) {
                const key = keys[i];
                ret[key] = a[key] + (b[key] - a[key]) * t;
            }
            return ret;
        };
    };
    Interp.unit = (a, b) => {
        const reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
        const ma = reg.exec(a);
        const mb = reg.exec(b);
        const pb = mb ? mb[1] : '';
        const aa = ma ? +ma[1] : 0;
        const bb = mb ? +mb[1] : 0;
        const index = pb.indexOf('.');
        const precision = index > 0 ? pb[1].length - index - 1 : 0;
        const d = bb - aa;
        const u = ma ? ma[2] : '';
        return (t) => {
            return (aa + d * t).toFixed(precision) + u;
        };
    };
    Interp.color = (a, b) => {
        const ca = parseInt(a.slice(1), 16);
        const cb = parseInt(b.slice(1), 16);
        const ra = ca & 0x0000ff;
        const rd = (cb & 0x0000ff) - ra;
        const ga = ca & 0x00ff00;
        const gd = (cb & 0x00ff00) - ga;
        const ba = ca & 0xff0000;
        const bd = (cb & 0xff0000) - ba;
        return (t) => {
            const r = (ra + rd * t) & 0x000000ff;
            const g = (ga + gd * t) & 0x0000ff00;
            const b = (ba + bd * t) & 0x00ff0000;
            return `#${((1 << 24) | r | g | b).toString(16).slice(1)}`;
        };
    };
})(Interp || (Interp = {}));

var LocalStorage;
(function (LocalStorage) {
    const prefix = `${Config.prefixCls}.storage`;
    function insert(collection, doc, cb) {
        const id = doc.id || uniqueId$1('doc-');
        const index = loadIndex(collection);
        index.keys.push(id);
        setItem(docKey(collection, id), doc);
        setItem(indexKey(collection), index);
        callback(cb, null, Object.assign(Object.assign({}, doc), { id }));
    }
    LocalStorage.insert = insert;
    function find(collection, query, cb) {
        const index = loadIndex(collection);
        const docs = [];
        if (query == null) {
            index.keys.forEach((id) => {
                const doc = getItem(docKey(collection, id));
                if (!doc) {
                    callback(cb, new Error(`No document found for an ID '${id}' from index.`));
                }
                else {
                    docs.push(doc);
                }
            });
            callback(cb, null, docs);
        }
        else if (query.id) {
            const doc = getItem(docKey(collection, query.id));
            callback(cb, null, doc ? [doc] : []);
        }
        else {
            callback(cb, null, []);
        }
    }
    LocalStorage.find = find;
    function remove(collection, query, cb) {
        const index = loadIndex(collection);
        if (query == null) {
            index.keys.forEach((id) => {
                localStorage.removeItem(docKey(collection, id));
            });
            localStorage.removeItem(indexKey(collection));
            callback(cb, null);
        }
        else if (query.id) {
            const idx = index.keys.indexOf(query.id);
            if (idx >= 0) {
                index.keys.splice(idx, 1);
            }
            localStorage.removeItem(docKey(collection, query.id));
            setItem(indexKey(collection), index);
            callback(cb, null);
        }
    }
    LocalStorage.remove = remove;
    // util
    // ----
    function callback(cb, err, ret) {
        if (cb) {
            defer(() => {
                cb(err, ret);
            });
        }
    }
    function setItem(key, item) {
        localStorage.setItem(key, JSON.stringify(item));
    }
    function getItem(key) {
        const item = localStorage.getItem(key);
        return item ? JSON.parse(item) : null;
    }
    function loadIndex(collection) {
        const index = getItem(indexKey(collection));
        if (index) {
            if (index.keys == null) {
                index.keys = [];
            }
            return index;
        }
        return { keys: [] };
    }
    function docKey(collection, id) {
        return `${prefix}.${collection}.docs.${id}`;
    }
    function indexKey(collection) {
        return `${prefix}.${collection}.index`;
    }
})(LocalStorage || (LocalStorage = {}));

class View extends Basecoat {
    constructor() {
        super();
        this.cid = Private$6.uniqueId();
        View.views[this.cid] = this;
    }
    get priority() {
        return 2;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    confirmUpdate(flag, options) {
        return 0;
    }
    $(elem) {
        return View.$(elem);
    }
    empty(elem = this.container) {
        this.$(elem).empty();
        return this;
    }
    unmount(elem = this.container) {
        this.$(elem).remove();
        return this;
    }
    remove(elem = this.container) {
        if (elem === this.container) {
            this.removeEventListeners(document);
            this.onRemove();
            delete View.views[this.cid];
        }
        this.unmount(elem);
        return this;
    }
    onRemove() { }
    setClass(className, elem = this.container) {
        elem.classList.value = Array.isArray(className)
            ? className.join(' ')
            : className;
    }
    addClass(className, elem = this.container) {
        this.$(elem).addClass(Array.isArray(className) ? className.join(' ') : className);
        return this;
    }
    removeClass(className, elem = this.container) {
        this.$(elem).removeClass(Array.isArray(className) ? className.join(' ') : className);
        return this;
    }
    setStyle(style, elem = this.container) {
        this.$(elem).css(style);
        return this;
    }
    setAttrs(attrs, elem = this.container) {
        if (attrs != null && elem != null) {
            if (elem instanceof SVGElement) {
                attr$1(elem, attrs);
            }
            else {
                this.$(elem).attr(attrs);
            }
        }
        return this;
    }
    /**
     * Returns the value of the specified attribute of `node`.
     *
     * If the node does not set a value for attribute, start recursing up
     * the DOM tree from node to lookup for attribute at the ancestors of
     * node. If the recursion reaches CellView's root node and attribute
     * is not found even there, return `null`.
     */
    findAttr(attrName, elem = this.container) {
        let current = elem;
        while (current && current.nodeType === 1) {
            const value = current.getAttribute(attrName);
            if (value != null) {
                return value;
            }
            if (current === this.container) {
                return null;
            }
            current = current.parentNode;
        }
        return null;
    }
    find(selector, rootElem = this.container, selectors = this.selectors) {
        return View.find(selector, rootElem, selectors).elems;
    }
    findOne(selector, rootElem = this.container, selectors = this.selectors) {
        const nodes = this.find(selector, rootElem, selectors);
        return nodes.length > 0 ? nodes[0] : null;
    }
    findByAttr(attrName, elem = this.container) {
        let node = elem;
        while (node && node.getAttribute) {
            const val = node.getAttribute(attrName);
            if ((val != null || node === this.container) && val !== 'false') {
                return node;
            }
            node = node.parentNode;
        }
        // If the overall cell has set `magnet === false`, then returns
        // `null` to announce there is no magnet found for this cell.
        // This is especially useful to set on cells that have 'ports'.
        // In this case, only the ports have set `magnet === true` and the
        // overall element has `magnet === false`.
        return null;
    }
    getSelector(elem, prevSelector) {
        let selector;
        if (elem === this.container) {
            if (typeof prevSelector === 'string') {
                selector = `> ${prevSelector}`;
            }
            return selector;
        }
        if (elem) {
            const nth = index$4(elem) + 1;
            selector = `${elem.tagName.toLowerCase()}:nth-child(${nth})`;
            if (prevSelector) {
                selector += ` > ${prevSelector}`;
            }
            selector = this.getSelector(elem.parentNode, selector);
        }
        return selector;
    }
    prefixClassName(className) {
        return Util$3.prefix(className);
    }
    delegateEvents(events, append) {
        if (events == null) {
            return this;
        }
        if (!append) {
            this.undelegateEvents();
        }
        const splitter = /^(\S+)\s*(.*)$/;
        Object.keys(events).forEach((key) => {
            const match = key.match(splitter);
            if (match == null) {
                return;
            }
            const method = this.getEventHandler(events[key]);
            if (typeof method === 'function') {
                this.delegateEvent(match[1], match[2], method);
            }
        });
        return this;
    }
    undelegateEvents() {
        this.$(this.container).off(this.getEventNamespace());
        return this;
    }
    delegateDocumentEvents(events, data) {
        this.addEventListeners(document, events, data);
        return this;
    }
    undelegateDocumentEvents() {
        this.removeEventListeners(document);
        return this;
    }
    delegateEvent(eventName, selector, listener) {
        this.$(this.container).on(eventName + this.getEventNamespace(), selector, listener);
        return this;
    }
    undelegateEvent(eventName, selector, listener) {
        const name = eventName + this.getEventNamespace();
        if (selector == null) {
            this.$(this.container).off(name);
        }
        else if (typeof selector === 'string') {
            this.$(this.container).off(name, selector, listener);
        }
        else {
            this.$(this.container).off(name, selector);
        }
        return this;
    }
    addEventListeners(elem, events, data) {
        if (events == null) {
            return this;
        }
        const ns = this.getEventNamespace();
        const $elem = this.$(elem);
        Object.keys(events).forEach((eventName) => {
            const method = this.getEventHandler(events[eventName]);
            if (typeof method === 'function') {
                $elem.on(eventName + ns, data, method);
            }
        });
        return this;
    }
    removeEventListeners(elem) {
        if (elem != null) {
            this.$(elem).off(this.getEventNamespace());
        }
        return this;
    }
    getEventNamespace() {
        return `.${Config.prefixCls}-event-${this.cid}`;
    }
    // eslint-disable-next-line
    getEventHandler(handler) {
        // eslint-disable-next-line
        let method;
        if (typeof handler === 'string') {
            const fn = this[handler];
            if (typeof fn === 'function') {
                method = (...args) => fn.call(this, ...args);
            }
        }
        else {
            method = (...args) => handler.call(this, ...args);
        }
        return method;
    }
    getEventTarget(e, options = {}) {
        // Touchmove/Touchend event's target is not reflecting the element
        // under the coordinates as mousemove does.
        // It holds the element when a touchstart triggered.
        const { target, type, clientX = 0, clientY = 0 } = e;
        if (options.fromPoint || type === 'touchmove' || type === 'touchend') {
            return document.elementFromPoint(clientX, clientY);
        }
        return target;
    }
    stopPropagation(e) {
        this.setEventData(e, { propagationStopped: true });
        return this;
    }
    isPropagationStopped(e) {
        return this.getEventData(e).propagationStopped === true;
    }
    getEventData(e) {
        return this.eventData(e);
    }
    setEventData(e, data) {
        return this.eventData(e, data);
    }
    eventData(e, data) {
        if (e == null) {
            throw new TypeError('Event object required');
        }
        let currentData = e.data;
        const key = `__${this.cid}__`;
        // get
        if (data == null) {
            if (currentData == null) {
                return {};
            }
            return currentData[key] || {};
        }
        // set
        if (currentData == null) {
            currentData = e.data = {};
        }
        if (currentData[key] == null) {
            currentData[key] = Object.assign({}, data);
        }
        else {
            currentData[key] = Object.assign(Object.assign({}, currentData[key]), data);
        }
        return currentData[key];
    }
    normalizeEvent(evt) {
        return View.normalizeEvent(evt);
    }
}
(function (View) {
    function $(elem) {
        return JQuery(elem);
    }
    View.$ = $;
    function createElement(tagName, isSvgElement) {
        return isSvgElement
            ? createSvgElement(tagName || 'g')
            : createElementNS(tagName || 'div');
    }
    View.createElement = createElement;
    function find(selector, rootElem, selectors) {
        if (!selector || selector === '.') {
            return { elems: [rootElem] };
        }
        if (selectors) {
            const nodes = selectors[selector];
            if (nodes) {
                return { elems: Array.isArray(nodes) ? nodes : [nodes] };
            }
        }
        if (Config.useCSSSelector) {
            return {
                isCSSSelector: true,
                // elems: Array.prototype.slice.call(rootElem.querySelectorAll(selector)),
                elems: $(rootElem).find(selector).toArray(),
            };
        }
        return { elems: [] };
    }
    View.find = find;
    function normalizeEvent(evt) {
        let normalizedEvent = evt;
        const originalEvent = evt.originalEvent;
        const touchEvt = originalEvent &&
            originalEvent.changedTouches &&
            originalEvent.changedTouches[0];
        if (touchEvt) {
            // eslint-disable-next-line no-restricted-syntax
            for (const key in evt) {
                // copy all the properties from the input event that are not
                // defined on the touch event (functions included).
                if (touchEvt[key] === undefined) {
                    touchEvt[key] = evt[key];
                }
            }
            normalizedEvent = touchEvt;
        }
        // IE: evt.target could be set to SVGElementInstance for SVGUseElement
        const target = normalizedEvent.target;
        if (target) {
            const useElement = target.correspondingUseElement;
            if (useElement) {
                normalizedEvent.target = useElement;
            }
        }
        return normalizedEvent;
    }
    View.normalizeEvent = normalizeEvent;
})(View || (View = {}));
(function (View) {
    View.views = {};
    function getView(cid) {
        return View.views[cid] || null;
    }
    View.getView = getView;
})(View || (View = {}));
var Private$6;
(function (Private) {
    let counter = 0;
    function uniqueId() {
        const id = `v${counter}`;
        counter += 1;
        return id;
    }
    Private.uniqueId = uniqueId;
})(Private$6 || (Private$6 = {}));

const noop = (terminal) => terminal;

function toPercentage(value, max) {
    if (max === 0) {
        return '0%';
    }
    return `${Math.round((value / max) * 100)}%`;
}
function pin(relative) {
    const strategy = (terminal, view, magnet, coords) => {
        return view.isEdgeElement(magnet)
            ? pinEdgeTerminal(relative, terminal, view, magnet, coords)
            : pinNodeTerminal(relative, terminal, view, magnet, coords);
    };
    return strategy;
}
function pinNodeTerminal(relative, data, view, magnet, coords) {
    const node = view.cell;
    const angle = node.getAngle();
    const bbox = view.getUnrotatedBBoxOfElement(magnet);
    const center = node.getBBox().getCenter();
    const pos = Point.create(coords).rotate(angle, center);
    let dx = pos.x - bbox.x;
    let dy = pos.y - bbox.y;
    if (relative) {
        dx = toPercentage(dx, bbox.width);
        dy = toPercentage(dy, bbox.height);
    }
    data.anchor = {
        name: 'topLeft',
        args: {
            dx,
            dy,
            rotate: true,
        },
    };
    return data;
}
function pinEdgeTerminal(relative, end, view, magnet, coords) {
    const connection = view.getConnection();
    if (!connection) {
        return end;
    }
    const length = connection.closestPointLength(coords);
    if (relative) {
        const totalLength = connection.length();
        end.anchor = {
            name: 'ratio',
            args: {
                ratio: length / totalLength,
            },
        };
    }
    else {
        end.anchor = {
            name: 'length',
            args: {
                length,
            },
        };
    }
    return end;
}
const pinRelative = pin(true);
const pinAbsolute = pin(false);

var strategies = /*#__PURE__*/Object.freeze({
	__proto__: null,
	noop: noop,
	pinAbsolute: pinAbsolute,
	pinRelative: pinRelative
});

var ConnectionStrategy;
(function (ConnectionStrategy) {
    ConnectionStrategy.presets = strategies;
    ConnectionStrategy.registry = Registry.create({
        type: 'connection strategy',
    });
    ConnectionStrategy.registry.register(ConnectionStrategy.presets, true);
})(ConnectionStrategy || (ConnectionStrategy = {}));

class Cache {
    constructor(view) {
        this.view = view;
        this.clean();
    }
    clean() {
        if (this.elemCache) {
            this.elemCache.dispose();
        }
        this.elemCache = new Dictionary();
        this.pathCache = {};
    }
    get(elem) {
        const cache = this.elemCache;
        if (!cache.has(elem)) {
            this.elemCache.set(elem, {});
        }
        return this.elemCache.get(elem);
    }
    getData(elem) {
        const meta = this.get(elem);
        if (!meta.data) {
            meta.data = {};
        }
        return meta.data;
    }
    getMatrix(elem) {
        const meta = this.get(elem);
        if (meta.matrix == null) {
            const target = this.view.rotatableNode || this.view.container;
            meta.matrix = getTransformToElement(elem, target);
        }
        return createSVGMatrix(meta.matrix);
    }
    getShape(elem) {
        const meta = this.get(elem);
        if (meta.shape == null) {
            meta.shape = toGeometryShape(elem);
        }
        return meta.shape.clone();
    }
    getBoundingRect(elem) {
        const meta = this.get(elem);
        if (meta.boundingRect == null) {
            meta.boundingRect = getBBox(elem);
        }
        return meta.boundingRect.clone();
    }
}

// eslint-disable-next-line
var Markup;
(function (Markup) {
    function isJSONMarkup(markup) {
        return markup != null && !isStringMarkup(markup);
    }
    Markup.isJSONMarkup = isJSONMarkup;
    function isStringMarkup(markup) {
        return markup != null && typeof markup === 'string';
    }
    Markup.isStringMarkup = isStringMarkup;
    function clone(markup) {
        return markup == null || isStringMarkup(markup)
            ? markup
            : cloneDeep(markup);
    }
    Markup.clone = clone;
    /**
     * Removes blank space in markup to prevent create empty text node.
     */
    function sanitize(markup) {
        return `${markup}`
            .trim()
            .replace(/[\r|\n]/g, ' ')
            .replace(/>\s+</g, '><');
    }
    Markup.sanitize = sanitize;
    function parseStringMarkup(markup) {
        const fragment = document.createDocumentFragment();
        const groups = {};
        const selectors = {};
        const sanitized = sanitize(markup);
        const nodes = sanitizeHTML(sanitized, { raw: true });
        nodes.forEach((node) => {
            fragment.appendChild(node);
        });
        return { fragment, selectors, groups };
    }
    Markup.parseStringMarkup = parseStringMarkup;
    function parseJSONMarkup(markup, options = { ns: ns.svg }) {
        const fragment = document.createDocumentFragment();
        const groups = {};
        const selectors = {};
        const queue = [
            {
                markup: Array.isArray(markup) ? markup : [markup],
                parent: fragment,
                ns: options.ns,
            },
        ];
        while (queue.length > 0) {
            const item = queue.pop();
            let ns$1 = item.ns || ns.svg;
            const defines = item.markup;
            const parentNode = item.parent;
            defines.forEach((define) => {
                // tagName
                const tagName = define.tagName;
                if (!tagName) {
                    throw new TypeError('Invalid tagName');
                }
                // ns
                if (define.ns) {
                    ns$1 = define.ns;
                }
                const svg = ns$1 === ns.svg;
                const node = ns$1
                    ? createElementNS(tagName, ns$1)
                    : createElement(tagName);
                // attrs
                const attrs = define.attrs;
                if (attrs) {
                    if (svg) {
                        attr$1(node, kebablizeAttrs(attrs));
                    }
                    else {
                        JQuery(node).attr(attrs);
                    }
                }
                // style
                const style = define.style;
                if (style) {
                    JQuery(node).css(style);
                }
                // classname
                const className = define.className;
                if (className != null) {
                    node.setAttribute('class', Array.isArray(className) ? className.join(' ') : className);
                }
                // textContent
                if (define.textContent) {
                    node.textContent = define.textContent;
                }
                // selector
                const selector = define.selector;
                if (selector != null) {
                    if (selectors[selector]) {
                        throw new TypeError('Selector must be unique');
                    }
                    selectors[selector] = node;
                }
                // group
                if (define.groupSelector) {
                    let nodeGroups = define.groupSelector;
                    if (!Array.isArray(nodeGroups)) {
                        nodeGroups = [nodeGroups];
                    }
                    nodeGroups.forEach((name) => {
                        if (!groups[name]) {
                            groups[name] = [];
                        }
                        groups[name].push(node);
                    });
                }
                parentNode.appendChild(node);
                // children
                const children = define.children;
                if (Array.isArray(children)) {
                    queue.push({ ns: ns$1, markup: children, parent: node });
                }
            });
        }
        Object.keys(groups).forEach((groupName) => {
            if (selectors[groupName]) {
                throw new Error('Ambiguous group selector');
            }
            selectors[groupName] = groups[groupName];
        });
        return { fragment, selectors, groups };
    }
    Markup.parseJSONMarkup = parseJSONMarkup;
    function createContainer(firstChild) {
        return firstChild instanceof SVGElement
            ? createSvgElement('g')
            : createElement('div');
    }
    function renderMarkup(markup) {
        if (isStringMarkup(markup)) {
            const nodes = Vector.createVectors(markup);
            const count = nodes.length;
            if (count === 1) {
                return {
                    elem: nodes[0].node,
                };
            }
            if (count > 1) {
                const elem = createContainer(nodes[0].node);
                nodes.forEach((node) => {
                    elem.appendChild(node.node);
                });
                return { elem };
            }
            return {};
        }
        const result = parseJSONMarkup(markup);
        const fragment = result.fragment;
        let elem = null;
        if (fragment.childNodes.length > 1) {
            elem = createContainer(fragment.firstChild);
            elem.appendChild(fragment);
        }
        else {
            elem = fragment.firstChild;
        }
        return { elem, selectors: result.selectors };
    }
    Markup.renderMarkup = renderMarkup;
    function parseLabelStringMarkup(markup) {
        const children = Vector.createVectors(markup);
        const fragment = document.createDocumentFragment();
        for (let i = 0, n = children.length; i < n; i += 1) {
            const currentChild = children[i].node;
            fragment.appendChild(currentChild);
        }
        return { fragment, selectors: {} };
    }
    Markup.parseLabelStringMarkup = parseLabelStringMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getSelector(elem, stop, prev) {
        if (elem != null) {
            let selector;
            const tagName = elem.tagName.toLowerCase();
            if (elem === stop) {
                if (typeof prev === 'string') {
                    selector = `> ${tagName} > ${prev}`;
                }
                else {
                    selector = `> ${tagName}`;
                }
                return selector;
            }
            const parent = elem.parentNode;
            if (parent && parent.childNodes.length > 1) {
                const nth = index$4(elem) + 1;
                selector = `${tagName}:nth-child(${nth})`;
            }
            else {
                selector = tagName;
            }
            if (prev) {
                selector += ` > ${prev}`;
            }
            return getSelector(elem.parentNode, stop, selector);
        }
        return prev;
    }
    Markup.getSelector = getSelector;
    function parseNode(node, root, ns$1) {
        if (node.nodeName === '#text') {
            return null;
        }
        let selector = null;
        let groupSelector = null;
        // let classNames: string | null = null
        let attrs = null;
        let isCSSSelector = false;
        const markup = {
            tagName: node.tagName,
        };
        if (node.attributes) {
            attrs = {};
            for (let i = 0, l = node.attributes.length; i < l; i += 1) {
                const attr = node.attributes[i];
                const name = attr.nodeName;
                const value = attr.nodeValue;
                if (name === 'selector') {
                    selector = value;
                }
                else if (name === 'groupSelector') {
                    groupSelector = value;
                }
                else if (name === 'class') {
                    markup.attrs = { class: value };
                }
                else {
                    attrs[name] = value;
                }
            }
        }
        if (selector == null) {
            isCSSSelector = true;
            selector = getSelector(node, root);
        }
        if (node.namespaceURI) {
            markup.ns = node.namespaceURI;
        }
        if (markup.ns == null) {
            if ([
                'body',
                'div',
                'section',
                'main',
                'nav',
                'footer',
                'span',
                'p',
                'h1',
                'h2',
                'h3',
                'h4',
                'h5',
                'h6',
                'ul',
                'ol',
                'dl',
                'center',
                'strong',
                'pre',
                'form',
                'select',
                'textarea',
                'fieldset',
                'marquee',
                'bgsound',
                'iframe',
                'frameset',
            ].includes(node.tagName)) {
                markup.ns = ns.xhtml;
            }
            else if (ns$1) {
                markup.ns = ns$1;
            }
        }
        if (selector) {
            markup.selector = selector;
        }
        if (groupSelector != null) {
            markup.groupSelector = groupSelector;
        }
        return {
            markup,
            attrs,
            isCSSSelector,
        };
    }
    function xml2json(xml) {
        const sanitized = Markup.sanitize(xml);
        const doc = parseXML(sanitized, { mimeType: 'image/svg+xml' });
        const nodes = Array.prototype.slice.call(doc.childNodes);
        const attrMap = {};
        const markupMap = new WeakMap();
        const parse = (node, root, ns) => {
            const data = parseNode(node, root, ns);
            if (data == null) {
                const parent = markupMap.get(node.parentNode);
                if (parent && node.textContent) {
                    parent.textContent = node.textContent;
                }
            }
            else {
                const { markup, attrs, isCSSSelector } = data;
                markupMap.set(node, markup);
                if (markup.selector && attrs != null) {
                    if (Object.keys(attrs).length) {
                        attrMap[markup.selector] = attrs;
                    }
                    if (isCSSSelector) {
                        delete markup.selector;
                    }
                }
                if (node.childNodes && node.childNodes.length > 0) {
                    for (let i = 0, l = node.childNodes.length; i < l; i += 1) {
                        const child = node.childNodes[i];
                        const childMarkup = parse(child, root, markup.ns);
                        if (childMarkup) {
                            if (markup.children == null) {
                                markup.children = [];
                            }
                            markup.children.push(childMarkup);
                        }
                    }
                }
                return markup;
            }
        };
        const markup = nodes
            .map((node) => parse(node, node))
            .filter((mk) => mk != null);
        return {
            markup,
            attrs: attrMap,
        };
    }
    Markup.xml2json = xml2json;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getPortContainerMarkup() {
        return 'g';
    }
    Markup.getPortContainerMarkup = getPortContainerMarkup;
    function getPortMarkup() {
        return {
            tagName: 'circle',
            selector: 'circle',
            attrs: {
                r: 10,
                fill: '#FFFFFF',
                stroke: '#000000',
            },
        };
    }
    Markup.getPortMarkup = getPortMarkup;
    function getPortLabelMarkup() {
        return {
            tagName: 'text',
            selector: 'text',
            attrs: {
                fill: '#000000',
            },
        };
    }
    Markup.getPortLabelMarkup = getPortLabelMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getEdgeMarkup() {
        return Markup.sanitize(`
    <path class="connection" stroke="black" d="M 0 0 0 0"/>
    <path class="source-marker" fill="black" stroke="black" d="M 0 0 0 0"/>
    <path class="target-marker" fill="black" stroke="black" d="M 0 0 0 0"/>
    <path class="connection-wrap" d="M 0 0 0 0"/>
    <g class="labels"/>
    <g class="vertices"/>
    <g class="arrowheads"/>
    <g class="tools"/>
  `);
    }
    Markup.getEdgeMarkup = getEdgeMarkup;
    function getEdgeToolMarkup() {
        return Markup.sanitize(`
    <g class="edge-tool">
      <g class="tool-remove" event="edge:remove">
        <circle r="11" />
        <path transform="scale(.8) translate(-16, -16)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z" />
        <title>Remove edge.</title>
      </g>
      <g class="tool-options" event="edge:options">
        <circle r="11" transform="translate(25)"/>
        <path fill="white" transform="scale(.55) translate(29, -16)" d="M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z"/>
        <title>Edge options.</title>
      </g>
    </g>
  `);
    }
    Markup.getEdgeToolMarkup = getEdgeToolMarkup;
    function getEdgeVertexMarkup() {
        return Markup.sanitize(`
    <g class="vertex-group" transform="translate(<%= x %>, <%= y %>)">
      <circle class="vertex" data-index="<%= index %>" r="10" />
      <path class="vertex-remove-area" data-index="<%= index %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>
      <path class="vertex-remove" data-index="<%= index %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">
      <title>Remove vertex.</title>
      </path>
    </g>
  `);
    }
    Markup.getEdgeVertexMarkup = getEdgeVertexMarkup;
    function getEdgeArrowheadMarkup() {
        return Markup.sanitize(`
    <g class="arrowhead-group arrowhead-group-<%= end %>">
      <path class="arrowhead" data-terminal="<%= end %>" d="M 26 0 L 0 13 L 26 26 z" />
    </g>
  `);
    }
    Markup.getEdgeArrowheadMarkup = getEdgeArrowheadMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getForeignObjectMarkup(bare = false) {
        return {
            tagName: 'foreignObject',
            selector: 'fo',
            children: [
                {
                    ns: ns.xhtml,
                    tagName: 'body',
                    selector: 'foBody',
                    attrs: {
                        xmlns: ns.xhtml,
                    },
                    style: {
                        width: '100%',
                        height: '100%',
                        background: 'transparent',
                    },
                    children: bare
                        ? []
                        : [
                            {
                                tagName: 'div',
                                selector: 'foContent',
                                style: {
                                    width: '100%',
                                    height: '100%',
                                },
                            },
                        ],
                },
            ],
        };
    }
    Markup.getForeignObjectMarkup = getForeignObjectMarkup;
})(Markup || (Markup = {}));

class AttrManager {
    constructor(view) {
        this.view = view;
    }
    get cell() {
        return this.view.cell;
    }
    getDefinition(attrName) {
        return this.cell.getAttrDefinition(attrName);
    }
    processAttrs(elem, raw) {
        let normal;
        let set;
        let offset;
        let position;
        let delay;
        const specials = [];
        // divide the attributes between normal and special
        Object.keys(raw).forEach((name) => {
            const val = raw[name];
            const definition = this.getDefinition(name);
            const isValid = call(Attr.isValidDefinition, this.view, definition, val, {
                elem,
                attrs: raw,
                cell: this.cell,
                view: this.view,
            });
            if (definition && isValid) {
                if (typeof definition === 'string') {
                    if (normal == null) {
                        normal = {};
                    }
                    normal[definition] = val;
                }
                else if (val !== null) {
                    specials.push({ name, definition });
                }
            }
            else {
                if (normal == null) {
                    normal = {};
                }
                const normalName = CASE_SENSITIVE_ATTR.includes(name)
                    ? name
                    : kebabCase(name);
                normal[normalName] = val;
            }
        });
        specials.forEach(({ name, definition }) => {
            const val = raw[name];
            const setDefine = definition;
            if (typeof setDefine.set === 'function') {
                if (!isHTMLElement(elem) &&
                    AttrManager.DELAY_ATTRS.includes(name)) {
                    if (delay == null) {
                        delay = {};
                    }
                    delay[name] = val;
                }
                else {
                    if (set == null) {
                        set = {};
                    }
                    set[name] = val;
                }
            }
            const offsetDefine = definition;
            if (typeof offsetDefine.offset === 'function') {
                if (offset == null) {
                    offset = {};
                }
                offset[name] = val;
            }
            const positionDefine = definition;
            if (typeof positionDefine.position === 'function') {
                if (position == null) {
                    position = {};
                }
                position[name] = val;
            }
        });
        return {
            raw,
            normal,
            set,
            offset,
            position,
            delay,
        };
    }
    mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {
        allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);
        allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);
        allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);
        // Handle also the special transform property.
        const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;
        if (transform != null && roProcessedAttrs.normal) {
            roProcessedAttrs.normal.transform = transform;
        }
        allProcessedAttrs.normal = roProcessedAttrs.normal;
    }
    findAttrs(cellAttrs, rootNode, selectorCache, selectors) {
        const merge$1 = [];
        const result = new Dictionary();
        Object.keys(cellAttrs).forEach((selector) => {
            const attrs = cellAttrs[selector];
            if (!isPlainObject(attrs)) {
                return;
            }
            const { isCSSSelector, elems } = View.find(selector, rootNode, selectors);
            selectorCache[selector] = elems;
            for (let i = 0, l = elems.length; i < l; i += 1) {
                const elem = elems[i];
                const unique = selectors && selectors[selector] === elem;
                const prev = result.get(elem);
                if (prev) {
                    if (!prev.array) {
                        merge$1.push(elem);
                        prev.array = true;
                        prev.attrs = [prev.attrs];
                        prev.priority = [prev.priority];
                    }
                    const attributes = prev.attrs;
                    const selectedLength = prev.priority;
                    if (unique) {
                        // node referenced by `selector`
                        attributes.unshift(attrs);
                        selectedLength.unshift(-1);
                    }
                    else {
                        // node referenced by `groupSelector` or CSSSelector
                        const sortIndex = sortedIndex(selectedLength, isCSSSelector ? -1 : l);
                        attributes.splice(sortIndex, 0, attrs);
                        selectedLength.splice(sortIndex, 0, l);
                    }
                }
                else {
                    result.set(elem, {
                        elem,
                        attrs,
                        priority: unique ? -1 : l,
                        array: false,
                    });
                }
            }
        });
        merge$1.forEach((node) => {
            const item = result.get(node);
            const arr = item.attrs;
            item.attrs = arr.reduceRight((memo, attrs) => merge(memo, attrs), {});
        });
        return result;
    }
    updateRelativeAttrs(elem, processedAttrs, refBBox, options) {
        const rawAttrs = processedAttrs.raw || {};
        let nodeAttrs = processedAttrs.normal || {};
        const setAttrs = processedAttrs.set;
        const positionAttrs = processedAttrs.position;
        const offsetAttrs = processedAttrs.offset;
        const delayAttrs = processedAttrs.delay;
        const getOptions = () => ({
            elem,
            cell: this.cell,
            view: this.view,
            attrs: rawAttrs,
            refBBox: refBBox.clone(),
        });
        if (setAttrs != null) {
            Object.keys(setAttrs).forEach((name) => {
                const val = setAttrs[name];
                const def = this.getDefinition(name);
                if (def != null) {
                    const ret = call(def.set, this.view, val, getOptions());
                    if (typeof ret === 'object') {
                        nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);
                    }
                    else if (ret != null) {
                        nodeAttrs[name] = ret;
                    }
                }
            });
        }
        if (isHTMLElement(elem)) {
            // TODO: setting the `transform` attribute on HTMLElements
            // via `node.style.transform = 'matrix(...)';` would introduce
            // a breaking change (e.g. basic.TextBlock).
            this.view.setAttrs(nodeAttrs, elem);
            return;
        }
        // The final translation of the subelement.
        const nodeTransform = nodeAttrs.transform;
        const transform = nodeTransform ? `${nodeTransform}` : null;
        const nodeMatrix = transformStringToMatrix(transform);
        const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);
        if (nodeTransform) {
            delete nodeAttrs.transform;
            nodeMatrix.e = 0;
            nodeMatrix.f = 0;
        }
        // Calculates node scale determined by the scalable group.
        let sx = 1;
        let sy = 1;
        if (positionAttrs || offsetAttrs) {
            const scale = this.view.getScaleOfElement(elem, options.scalableNode);
            sx = scale.sx;
            sy = scale.sy;
        }
        let positioned = false;
        if (positionAttrs != null) {
            Object.keys(positionAttrs).forEach((name) => {
                const val = positionAttrs[name];
                const def = this.getDefinition(name);
                if (def != null) {
                    const ts = call(def.position, this.view, val, getOptions());
                    if (ts != null) {
                        positioned = true;
                        nodePosition.translate(Point.create(ts).scale(sx, sy));
                    }
                }
            });
        }
        // The node bounding box could depend on the `size`
        // set from the previous loop.
        this.view.setAttrs(nodeAttrs, elem);
        let offseted = false;
        if (offsetAttrs != null) {
            // Check if the node is visible
            const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);
            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
                const nodeBBox = transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);
                Object.keys(offsetAttrs).forEach((name) => {
                    const val = offsetAttrs[name];
                    const def = this.getDefinition(name);
                    if (def != null) {
                        const ts = call(def.offset, this.view, val, {
                            elem,
                            cell: this.cell,
                            view: this.view,
                            attrs: rawAttrs,
                            refBBox: nodeBBox,
                        });
                        if (ts != null) {
                            offseted = true;
                            nodePosition.translate(Point.create(ts).scale(sx, sy));
                        }
                    }
                });
            }
        }
        if (nodeTransform != null || positioned || offseted) {
            nodePosition.round(1);
            nodeMatrix.e = nodePosition.x;
            nodeMatrix.f = nodePosition.y;
            elem.setAttribute('transform', matrixToTransformString(nodeMatrix));
        }
        // delay render
        const updateDelayAttrs = () => {
            if (delayAttrs != null) {
                Object.keys(delayAttrs).forEach((name) => {
                    const val = delayAttrs[name];
                    const def = this.getDefinition(name);
                    if (def != null) {
                        const ret = call(def.set, this.view, val, getOptions());
                        if (typeof ret === 'object') {
                            this.view.setAttrs(ret, elem);
                        }
                        else if (ret != null) {
                            this.view.setAttrs({
                                [name]: ret,
                            }, elem);
                        }
                    }
                });
            }
        };
        if (options.forceSync) {
            updateDelayAttrs();
        }
        else {
            Scheduler.scheduleTask(updateDelayAttrs);
        }
    }
    update(rootNode, attrs, options) {
        const selectorCache = {};
        const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);
        // `nodesAttrs` are different from all attributes, when
        // rendering only attributes sent to this method.
        const nodesAllAttrs = options.attrs
            ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)
            : nodesAttrs;
        const specialItems = [];
        nodesAttrs.each((data) => {
            const node = data.elem;
            const nodeAttrs = data.attrs;
            const processed = this.processAttrs(node, nodeAttrs);
            if (processed.set == null &&
                processed.position == null &&
                processed.offset == null &&
                processed.delay == null) {
                this.view.setAttrs(processed.normal, node);
            }
            else {
                const data = nodesAllAttrs.get(node);
                const nodeAllAttrs = data ? data.attrs : null;
                const refSelector = nodeAllAttrs && nodeAttrs.ref == null
                    ? nodeAllAttrs.ref
                    : nodeAttrs.ref;
                let refNode;
                if (refSelector) {
                    refNode = (selectorCache[refSelector] ||
                        this.view.find(refSelector, rootNode, options.selectors))[0];
                    if (!refNode) {
                        throw new Error(`"${refSelector}" reference does not exist.`);
                    }
                }
                else {
                    refNode = null;
                }
                const item = {
                    node,
                    refNode,
                    attributes: nodeAllAttrs,
                    processedAttributes: processed,
                };
                // If an element in the list is positioned relative to this one, then
                // we want to insert this one before it in the list.
                const index = specialItems.findIndex((item) => item.refNode === node);
                if (index > -1) {
                    specialItems.splice(index, 0, item);
                }
                else {
                    specialItems.push(item);
                }
            }
        });
        const bboxCache = new Dictionary();
        let rotatableMatrix;
        specialItems.forEach((item) => {
            const node = item.node;
            const refNode = item.refNode;
            let unrotatedRefBBox;
            const isRefNodeRotatable = refNode != null &&
                options.rotatableNode != null &&
                contains(options.rotatableNode, refNode);
            // Find the reference element bounding box. If no reference was
            // provided, we use the optional bounding box.
            if (refNode) {
                unrotatedRefBBox = bboxCache.get(refNode);
            }
            if (!unrotatedRefBBox) {
                const target = (isRefNodeRotatable ? options.rotatableNode : rootNode);
                unrotatedRefBBox = refNode
                    ? getBBox(refNode, { target })
                    : options.rootBBox;
                if (refNode) {
                    bboxCache.set(refNode, unrotatedRefBBox);
                }
            }
            let processedAttrs;
            if (options.attrs && item.attributes) {
                // If there was a special attribute affecting the position amongst
                // passed-in attributes we have to merge it with the rest of the
                // element's attributes as they are necessary to update the position
                // relatively (i.e `ref-x` && 'ref-dx').
                processedAttrs = this.processAttrs(node, item.attributes);
                this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);
            }
            else {
                processedAttrs = item.processedAttributes;
            }
            let refBBox = unrotatedRefBBox;
            if (isRefNodeRotatable &&
                options.rotatableNode != null &&
                !options.rotatableNode.contains(node)) {
                // If the referenced node is inside the rotatable group while the
                // updated node is outside, we need to take the rotatable node
                // transformation into account.
                if (!rotatableMatrix) {
                    rotatableMatrix = transformStringToMatrix(attr$1(options.rotatableNode, 'transform'));
                }
                refBBox = transformRectangle(unrotatedRefBBox, rotatableMatrix);
            }
            const caller = specialItems.find((item) => item.refNode === node);
            if (caller) {
                options.forceSync = true;
            }
            this.updateRelativeAttrs(node, processedAttrs, refBBox, options);
        });
    }
}
(function (AttrManager) {
    AttrManager.DELAY_ATTRS = [
        'text',
        'textWrap',
        'sourceMarker',
        'targetMarker',
    ];
})(AttrManager || (AttrManager = {}));

/* eslint-disable no-bitwise */
class FlagManager {
    constructor(view, actions, bootstrap = []) {
        this.view = view;
        const flags = {};
        const attrs = {};
        let shift = 0;
        Object.keys(actions).forEach((attr) => {
            let labels = actions[attr];
            if (!Array.isArray(labels)) {
                labels = [labels];
            }
            labels.forEach((label) => {
                let flag = flags[label];
                if (!flag) {
                    shift += 1;
                    flag = flags[label] = 1 << shift;
                }
                attrs[attr] |= flag;
            });
        });
        let labels = bootstrap;
        if (!Array.isArray(labels)) {
            labels = [labels];
        }
        labels.forEach((label) => {
            if (!flags[label]) {
                shift += 1;
                flags[label] = 1 << shift;
            }
        });
        // 26 - 30 are reserved for paper flags
        // 31+ overflows maximal number
        if (shift > 25) {
            throw new Error('Maximum number of flags exceeded.');
        }
        this.flags = flags;
        this.attrs = attrs;
        this.bootstrap = bootstrap;
    }
    get cell() {
        return this.view.cell;
    }
    getFlag(label) {
        const flags = this.flags;
        if (flags == null) {
            return 0;
        }
        if (Array.isArray(label)) {
            return label.reduce((memo, key) => memo | flags[key], 0);
        }
        return flags[label] | 0;
    }
    hasAction(flag, label) {
        return flag & this.getFlag(label);
    }
    removeAction(flag, label) {
        return flag ^ (flag & this.getFlag(label));
    }
    getBootstrapFlag() {
        return this.getFlag(this.bootstrap);
    }
    getChangedFlag() {
        let flag = 0;
        if (!this.attrs) {
            return flag;
        }
        Object.keys(this.attrs).forEach((attr) => {
            if (this.cell.hasChanged(attr)) {
                flag |= this.attrs[attr];
            }
        });
        return flag;
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
var __rest$n = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class CellView extends View {
    constructor(cell, options = {}) {
        super();
        this.cell = cell;
        this.options = this.ensureOptions(options);
        this.graph = this.options.graph;
        this.attr = new AttrManager(this);
        this.flag = new FlagManager(this, this.options.actions, this.options.bootstrap);
        this.cache = new Cache(this);
        this.setContainer(this.ensureContainer());
        this.setup();
        this.$(this.container).data('view', this);
        this.init();
    }
    static getDefaults() {
        return this.defaults;
    }
    static config(options) {
        this.defaults = this.getOptions(options);
    }
    static getOptions(options) {
        const mergeActions = (arr1, arr2) => {
            if (arr2 != null) {
                return uniq([
                    ...(Array.isArray(arr1) ? arr1 : [arr1]),
                    ...(Array.isArray(arr2) ? arr2 : [arr2]),
                ]);
            }
            return Array.isArray(arr1) ? [...arr1] : [arr1];
        };
        const ret = cloneDeep(this.getDefaults());
        const { bootstrap, actions, events, documentEvents } = options, others = __rest$n(options, ["bootstrap", "actions", "events", "documentEvents"]);
        if (bootstrap) {
            ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);
        }
        if (actions) {
            Object.keys(actions).forEach((key) => {
                const val = actions[key];
                const raw = ret.actions[key];
                if (val && raw) {
                    ret.actions[key] = mergeActions(raw, val);
                }
                else if (val) {
                    ret.actions[key] = mergeActions(val);
                }
            });
        }
        if (events) {
            ret.events = Object.assign(Object.assign({}, ret.events), events);
        }
        if (options.documentEvents) {
            ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);
        }
        return merge(ret, others);
    }
    get [Symbol.toStringTag]() {
        return CellView.toStringTag;
    }
    init() { }
    onRemove() {
        this.removeTools();
    }
    get priority() {
        return this.options.priority;
    }
    get rootSelector() {
        return this.options.rootSelector;
    }
    getConstructor() {
        return this.constructor;
    }
    ensureOptions(options) {
        return this.getConstructor().getOptions(options);
    }
    getContainerTagName() {
        return this.options.isSvgElement ? 'g' : 'div';
    }
    getContainerStyle() { }
    getContainerAttrs() {
        return {
            'data-cell-id': this.cell.id,
            'data-shape': this.cell.shape,
        };
    }
    getContainerClassName() {
        return this.prefixClassName('cell');
    }
    ensureContainer() {
        return View.createElement(this.getContainerTagName(), this.options.isSvgElement);
    }
    setContainer(container) {
        if (this.container !== container) {
            this.undelegateEvents();
            this.container = container;
            if (this.options.events != null) {
                this.delegateEvents(this.options.events);
            }
            const attrs = this.getContainerAttrs();
            if (attrs != null) {
                this.setAttrs(attrs, container);
            }
            const style = this.getContainerStyle();
            if (style != null) {
                this.setStyle(style, container);
            }
            const className = this.getContainerClassName();
            if (className != null) {
                this.addClass(className, container);
            }
        }
        return this;
    }
    isNodeView() {
        return false;
    }
    isEdgeView() {
        return false;
    }
    render() {
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    confirmUpdate(flag, options = {}) {
        return 0;
    }
    getBootstrapFlag() {
        return this.flag.getBootstrapFlag();
    }
    getFlag(actions) {
        return this.flag.getFlag(actions);
    }
    hasAction(flag, actions) {
        return this.flag.hasAction(flag, actions);
    }
    removeAction(flag, actions) {
        return this.flag.removeAction(flag, actions);
    }
    handleAction(flag, action, handle, additionalRemovedActions) {
        if (this.hasAction(flag, action)) {
            handle();
            const removedFlags = [action];
            if (additionalRemovedActions) {
                if (typeof additionalRemovedActions === 'string') {
                    removedFlags.push(additionalRemovedActions);
                }
                else {
                    removedFlags.push(...additionalRemovedActions);
                }
            }
            return this.removeAction(flag, removedFlags);
        }
        return flag;
    }
    setup() {
        this.cell.on('changed', ({ options }) => this.onAttrsChange(options));
    }
    onAttrsChange(options) {
        let flag = this.flag.getChangedFlag();
        if (options.updated || !flag) {
            return;
        }
        if (options.dirty && this.hasAction(flag, 'update')) {
            flag |= this.getFlag('render'); // eslint-disable-line no-bitwise
        }
        // tool changes should be sync render
        if (options.toolId) {
            options.async = false;
        }
        if (this.graph != null) {
            this.graph.renderer.requestViewUpdate(this, flag, this.priority, options);
        }
    }
    parseJSONMarkup(markup, rootElem) {
        const result = Markup.parseJSONMarkup(markup);
        const selectors = result.selectors;
        const rootSelector = this.rootSelector;
        if (rootElem && rootSelector) {
            if (selectors[rootSelector]) {
                throw new Error('Invalid root selector');
            }
            selectors[rootSelector] = rootElem;
        }
        return result;
    }
    can(feature) {
        let interacting = this.graph.options.interacting;
        if (typeof interacting === 'function') {
            interacting = call(interacting, this.graph, this);
        }
        if (typeof interacting === 'object') {
            let val = interacting[feature];
            if (typeof val === 'function') {
                val = call(val, this.graph, this);
            }
            return val !== false;
        }
        if (typeof interacting === 'boolean') {
            return interacting;
        }
        return false;
    }
    cleanCache() {
        this.cache.clean();
        return this;
    }
    getCache(elem) {
        return this.cache.get(elem);
    }
    getDataOfElement(elem) {
        return this.cache.getData(elem);
    }
    getMatrixOfElement(elem) {
        return this.cache.getMatrix(elem);
    }
    getShapeOfElement(elem) {
        return this.cache.getShape(elem);
    }
    getScaleOfElement(node, scalableNode) {
        let sx;
        let sy;
        if (scalableNode && scalableNode.contains(node)) {
            const scale$1 = scale(scalableNode);
            sx = 1 / scale$1.sx;
            sy = 1 / scale$1.sy;
        }
        else {
            sx = 1;
            sy = 1;
        }
        return { sx, sy };
    }
    getBoundingRectOfElement(elem) {
        return this.cache.getBoundingRect(elem);
    }
    getBBoxOfElement(elem) {
        const rect = this.getBoundingRectOfElement(elem);
        const matrix = this.getMatrixOfElement(elem);
        const rm = this.getRootRotatedMatrix();
        const tm = this.getRootTranslatedMatrix();
        return transformRectangle(rect, tm.multiply(rm).multiply(matrix));
    }
    getUnrotatedBBoxOfElement(elem) {
        const rect = this.getBoundingRectOfElement(elem);
        const matrix = this.getMatrixOfElement(elem);
        const tm = this.getRootTranslatedMatrix();
        return transformRectangle(rect, tm.multiply(matrix));
    }
    getBBox(options = {}) {
        let bbox;
        if (options.useCellGeometry) {
            const cell = this.cell;
            const angle = cell.isNode() ? cell.getAngle() : 0;
            bbox = cell.getBBox().bbox(angle);
        }
        else {
            bbox = this.getBBoxOfElement(this.container);
        }
        return this.graph.localToGraph(bbox);
    }
    getRootTranslatedMatrix() {
        const cell = this.cell;
        const pos = cell.isNode() ? cell.getPosition() : { x: 0, y: 0 };
        return createSVGMatrix().translate(pos.x, pos.y);
    }
    getRootRotatedMatrix() {
        let matrix = createSVGMatrix();
        const cell = this.cell;
        const angle = cell.isNode() ? cell.getAngle() : 0;
        if (angle) {
            const bbox = cell.getBBox();
            const cx = bbox.width / 2;
            const cy = bbox.height / 2;
            matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);
        }
        return matrix;
    }
    findMagnet(elem = this.container) {
        // If the overall cell has set `magnet === false`, then returns
        // `undefined` to announce there is no magnet found for this cell.
        // This is especially useful to set on cells that have 'ports'.
        // In this case, only the ports have set `magnet === true` and the
        // overall element has `magnet === false`.
        return this.findByAttr('magnet', elem);
    }
    updateAttrs(rootNode, attrs, options = {}) {
        if (options.rootBBox == null) {
            options.rootBBox = new Rectangle();
        }
        if (options.selectors == null) {
            options.selectors = this.selectors;
        }
        this.attr.update(rootNode, attrs, options);
    }
    isEdgeElement(magnet) {
        return this.cell.isEdge() && (magnet == null || magnet === this.container);
    }
    // #region highlight
    prepareHighlight(elem, options = {}) {
        const magnet = (elem && this.$(elem)[0]) || this.container;
        options.partial = magnet === this.container;
        return magnet;
    }
    highlight(elem, options = {}) {
        const magnet = this.prepareHighlight(elem, options);
        this.notify('cell:highlight', {
            magnet,
            options,
            view: this,
            cell: this.cell,
        });
        if (this.isEdgeView()) {
            this.notify('edge:highlight', {
                magnet,
                options,
                view: this,
                edge: this.cell,
                cell: this.cell,
            });
        }
        else if (this.isNodeView()) {
            this.notify('node:highlight', {
                magnet,
                options,
                view: this,
                node: this.cell,
                cell: this.cell,
            });
        }
        return this;
    }
    unhighlight(elem, options = {}) {
        const magnet = this.prepareHighlight(elem, options);
        this.notify('cell:unhighlight', {
            magnet,
            options,
            view: this,
            cell: this.cell,
        });
        if (this.isNodeView()) {
            this.notify('node:unhighlight', {
                magnet,
                options,
                view: this,
                node: this.cell,
                cell: this.cell,
            });
        }
        else if (this.isEdgeView()) {
            this.notify('edge:unhighlight', {
                magnet,
                options,
                view: this,
                edge: this.cell,
                cell: this.cell,
            });
        }
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    notifyUnhighlight(magnet, options) { }
    // #endregion
    getEdgeTerminal(magnet, x, y, edge, type) {
        const cell = this.cell;
        const portId = this.findAttr('port', magnet);
        const selector = magnet.getAttribute('data-selector');
        const terminal = { cell: cell.id };
        if (selector != null) {
            terminal.magnet = selector;
        }
        if (portId != null) {
            terminal.port = portId;
            if (cell.isNode()) {
                if (!cell.hasPort(portId) && selector == null) {
                    // port created via the `port` attribute (not API)
                    terminal.selector = this.getSelector(magnet);
                }
            }
        }
        else if (selector == null && this.container !== magnet) {
            terminal.selector = this.getSelector(magnet);
        }
        return this.customizeEdgeTerminal(terminal, magnet, x, y, edge, type);
    }
    customizeEdgeTerminal(terminal, magnet, x, y, edge, type) {
        const raw = edge.getStrategy() || this.graph.options.connecting.strategy;
        if (raw) {
            const name = typeof raw === 'string' ? raw : raw.name;
            const args = typeof raw === 'string' ? {} : raw.args || {};
            const registry = ConnectionStrategy.registry;
            if (name) {
                const fn = registry.get(name);
                if (fn == null) {
                    return registry.onNotFound(name);
                }
                const result = call(fn, this.graph, terminal, this, magnet, new Point(x, y), edge, type, args);
                if (result) {
                    return result;
                }
            }
        }
        return terminal;
    }
    getMagnetFromEdgeTerminal(terminal) {
        const cell = this.cell;
        const root = this.container;
        const portId = terminal.port;
        let selector = terminal.magnet;
        let magnet;
        if (portId != null && cell.isNode() && cell.hasPort(portId)) {
            magnet = this.findPortElem(portId, selector) || root;
        }
        else {
            if (!selector) {
                selector = terminal.selector;
            }
            if (!selector && portId != null) {
                selector = `[port="${portId}"]`;
            }
            magnet = this.findOne(selector, root, this.selectors);
        }
        return magnet;
    }
    // #region animate
    animate(elem, options) {
        const target = typeof elem === 'string' ? this.findOne(elem) : elem;
        if (target == null) {
            throw new Error('Invalid animation element.');
        }
        const parent = target.parentNode;
        const revert = () => {
            if (!parent) {
                remove(target);
            }
        };
        const vTarget = Vector.create(target);
        if (!parent) {
            vTarget.appendTo(this.graph.view.stage);
        }
        const onComplete = options.complete;
        options.complete = (e) => {
            revert();
            if (onComplete) {
                onComplete(e);
            }
        };
        return vTarget.animate(options);
    }
    animateTransform(elem, options) {
        const target = typeof elem === 'string' ? this.findOne(elem) : elem;
        if (target == null) {
            throw new Error('Invalid animation element.');
        }
        const parent = target.parentNode;
        const revert = () => {
            if (!parent) {
                remove(target);
            }
        };
        const vTarget = Vector.create(target);
        if (!parent) {
            vTarget.appendTo(this.graph.view.stage);
        }
        const onComplete = options.complete;
        options.complete = (e) => {
            revert();
            if (onComplete) {
                onComplete(e);
            }
        };
        return vTarget.animateTransform(options);
    }
    hasTools(name) {
        const tools = this.tools;
        if (tools == null) {
            return false;
        }
        if (name == null) {
            return true;
        }
        return tools.name === name;
    }
    addTools(config) {
        if (!this.can('toolsAddable')) {
            return this;
        }
        this.removeTools();
        if (config) {
            const tools = ToolsView.isToolsView(config)
                ? config
                : new ToolsView(config);
            this.tools = tools;
            this.graph.on('tools:hide', this.hideTools, this);
            this.graph.on('tools:show', this.showTools, this);
            this.graph.on('tools:remove', this.removeTools, this);
            tools.config({ view: this });
            tools.mount();
        }
        return this;
    }
    updateTools(options = {}) {
        if (this.tools) {
            this.tools.update(options);
        }
        return this;
    }
    removeTools() {
        if (this.tools) {
            this.tools.remove();
            this.graph.off('tools:hide', this.hideTools, this);
            this.graph.off('tools:show', this.showTools, this);
            this.graph.off('tools:remove', this.removeTools, this);
            this.tools = null;
        }
        return this;
    }
    hideTools() {
        if (this.tools) {
            this.tools.hide();
        }
        return this;
    }
    showTools() {
        if (this.tools) {
            this.tools.show();
        }
        return this;
    }
    renderTools() {
        const tools = this.cell.getTools();
        this.addTools(tools);
        return this;
    }
    notify(name, args) {
        this.trigger(name, args);
        this.graph.trigger(name, args);
        return this;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line @typescript-eslint/no-this-alias
        const cell = view.cell;
        if (x == null || y == null) {
            return { e, view, cell };
        }
        return { e, x, y, view, cell };
    }
    onClick(e, x, y) {
        this.notify('cell:click', this.getEventArgs(e, x, y));
    }
    onDblClick(e, x, y) {
        this.notify('cell:dblclick', this.getEventArgs(e, x, y));
    }
    onContextMenu(e, x, y) {
        this.notify('cell:contextmenu', this.getEventArgs(e, x, y));
    }
    onMouseDown(e, x, y) {
        if (this.cell.model) {
            this.cachedModelForMouseEvent = this.cell.model;
            this.cachedModelForMouseEvent.startBatch('mouse');
        }
        this.notify('cell:mousedown', this.getEventArgs(e, x, y));
    }
    onMouseUp(e, x, y) {
        this.notify('cell:mouseup', this.getEventArgs(e, x, y));
        if (this.cachedModelForMouseEvent) {
            this.cachedModelForMouseEvent.stopBatch('mouse', { cell: this.cell });
            this.cachedModelForMouseEvent = null;
        }
    }
    onMouseMove(e, x, y) {
        this.notify('cell:mousemove', this.getEventArgs(e, x, y));
    }
    onMouseOver(e) {
        this.notify('cell:mouseover', this.getEventArgs(e));
    }
    onMouseOut(e) {
        this.notify('cell:mouseout', this.getEventArgs(e));
    }
    onMouseEnter(e) {
        this.notify('cell:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        this.notify('cell:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        this.notify('cell:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onCustomEvent(e, name, x, y) {
        this.notify('cell:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
        this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));
    }
    onMagnetMouseDown(e, magnet, x, y) { }
    onMagnetDblClick(e, magnet, x, y) { }
    onMagnetContextMenu(e, magnet, x, y) { }
    onLabelMouseDown(e, x, y) { }
    checkMouseleave(e) {
        const graph = this.graph;
        if (graph.renderer.isAsync()) {
            // Do the updates of the current view synchronously now
            graph.renderer.dumpView(this);
        }
        const target = this.getEventTarget(e, { fromPoint: true });
        const view = graph.renderer.findViewByElem(target);
        if (view === this) {
            return;
        }
        // Leaving the current view
        this.onMouseLeave(e);
        if (!view) {
            return;
        }
        // Entering another view
        view.onMouseEnter(e);
    }
}
CellView.defaults = {
    isSvgElement: true,
    rootSelector: 'root',
    priority: 0,
    bootstrap: [],
    actions: {},
};
(function (CellView) {
    CellView.Flag = FlagManager;
    CellView.Attr = AttrManager;
})(CellView || (CellView = {}));
(function (CellView) {
    CellView.toStringTag = `X6.${CellView.name}`;
    function isCellView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof CellView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === CellView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function') {
            return true;
        }
        return false;
    }
    CellView.isCellView = isCellView;
})(CellView || (CellView = {}));
// decorators
// ----
(function (CellView) {
    function priority(value) {
        return function (ctor) {
            ctor.config({ priority: value });
        };
    }
    CellView.priority = priority;
    function bootstrap(actions) {
        return function (ctor) {
            ctor.config({ bootstrap: actions });
        };
    }
    CellView.bootstrap = bootstrap;
})(CellView || (CellView = {}));
(function (CellView) {
    CellView.registry = Registry.create({
        type: 'view',
    });
})(CellView || (CellView = {}));

class ToolsView extends View {
    constructor(options = {}) {
        super();
        this.svgContainer = this.createContainer(true, options);
        this.htmlContainer = this.createContainer(false, options);
        this.config(options);
    }
    get name() {
        return this.options.name;
    }
    get graph() {
        return this.cellView.graph;
    }
    get cell() {
        return this.cellView.cell;
    }
    get [Symbol.toStringTag]() {
        return ToolsView.toStringTag;
    }
    createContainer(svg, options) {
        const container = svg
            ? View.createElement('g', true)
            : View.createElement('div', false);
        addClass(container, this.prefixClassName('cell-tools'));
        if (options.className) {
            addClass(container, options.className);
        }
        return container;
    }
    config(options) {
        this.options = Object.assign(Object.assign({}, this.options), options);
        if (!CellView.isCellView(options.view) || options.view === this.cellView) {
            return this;
        }
        this.cellView = options.view;
        if (this.cell.isEdge()) {
            addClass(this.svgContainer, this.prefixClassName('edge-tools'));
            addClass(this.htmlContainer, this.prefixClassName('edge-tools'));
        }
        else if (this.cell.isNode()) {
            addClass(this.svgContainer, this.prefixClassName('node-tools'));
            addClass(this.htmlContainer, this.prefixClassName('node-tools'));
        }
        this.svgContainer.setAttribute('data-cell-id', this.cell.id);
        this.htmlContainer.setAttribute('data-cell-id', this.cell.id);
        if (this.name) {
            this.svgContainer.setAttribute('data-tools-name', this.name);
            this.htmlContainer.setAttribute('data-tools-name', this.name);
        }
        const tools = this.options.items;
        if (!Array.isArray(tools)) {
            return this;
        }
        this.tools = [];
        const normalizedTools = [];
        tools.forEach((meta) => {
            if (ToolsView.ToolItem.isToolItem(meta)) {
                if (meta.name === 'vertices') {
                    normalizedTools.unshift(meta);
                }
                else {
                    normalizedTools.push(meta);
                }
            }
            else {
                const name = typeof meta === 'object' ? meta.name : meta;
                if (name === 'vertices') {
                    normalizedTools.unshift(meta);
                }
                else {
                    normalizedTools.push(meta);
                }
            }
        });
        for (let i = 0; i < normalizedTools.length; i += 1) {
            const meta = normalizedTools[i];
            let tool;
            if (ToolsView.ToolItem.isToolItem(meta)) {
                tool = meta;
            }
            else {
                const name = typeof meta === 'object' ? meta.name : meta;
                const args = typeof meta === 'object' ? meta.args || {} : {};
                if (name) {
                    if (this.cell.isNode()) {
                        const ctor = NodeTool.registry.get(name);
                        if (ctor) {
                            tool = new ctor(args); // eslint-disable-line
                        }
                        else {
                            return NodeTool.registry.onNotFound(name);
                        }
                    }
                    else if (this.cell.isEdge()) {
                        const ctor = EdgeTool.registry.get(name);
                        if (ctor) {
                            tool = new ctor(args); // eslint-disable-line
                        }
                        else {
                            return EdgeTool.registry.onNotFound(name);
                        }
                    }
                }
            }
            if (tool) {
                tool.config(this.cellView, this);
                tool.render();
                const container = tool.options.isSVGElement !== false
                    ? this.svgContainer
                    : this.htmlContainer;
                container.appendChild(tool.container);
                this.tools.push(tool);
            }
        }
        return this;
    }
    update(options = {}) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (options.toolId !== tool.cid && tool.isVisible()) {
                    tool.update();
                }
            });
        }
        return this;
    }
    focus(focusedTool) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (focusedTool === tool) {
                    tool.show();
                }
                else {
                    tool.hide();
                }
            });
        }
        return this;
    }
    blur(blurredTool) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (tool !== blurredTool && !tool.isVisible()) {
                    tool.show();
                    tool.update();
                }
            });
        }
        return this;
    }
    hide() {
        return this.focus(null);
    }
    show() {
        return this.blur(null);
    }
    remove() {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => tool.remove());
            this.tools = null;
        }
        remove(this.svgContainer);
        remove(this.htmlContainer);
        return super.remove();
    }
    mount() {
        const tools = this.tools;
        const cellView = this.cellView;
        if (cellView && tools) {
            const hasSVG = tools.some((tool) => tool.options.isSVGElement !== false);
            const hasHTML = tools.some((tool) => tool.options.isSVGElement === false);
            if (hasSVG) {
                const parent = this.options.local
                    ? cellView.container
                    : cellView.graph.view.decorator;
                parent.appendChild(this.svgContainer);
            }
            if (hasHTML) {
                this.graph.container.appendChild(this.htmlContainer);
            }
        }
        return this;
    }
}
(function (ToolsView) {
    ToolsView.toStringTag = `X6.${ToolsView.name}`;
    function isToolsView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof ToolsView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === ToolsView.toStringTag) &&
            view.graph != null &&
            view.cell != null &&
            typeof view.config === 'function' &&
            typeof view.update === 'function' &&
            typeof view.focus === 'function' &&
            typeof view.blur === 'function' &&
            typeof view.show === 'function' &&
            typeof view.hide === 'function') {
            return true;
        }
        return false;
    }
    ToolsView.isToolsView = isToolsView;
})(ToolsView || (ToolsView = {}));
(function (ToolsView) {
    class ToolItem extends View {
        constructor(options = {}) {
            super();
            this.visible = true;
            this.options = this.getOptions(options);
            this.container = View.createElement(this.options.tagName || 'g', this.options.isSVGElement !== false);
            addClass(this.container, this.prefixClassName('cell-tool'));
            if (typeof this.options.className === 'string') {
                addClass(this.container, this.options.className);
            }
            this.init();
        }
        static getDefaults() {
            return this.defaults;
        }
        static config(options) {
            this.defaults = this.getOptions(options);
        }
        static getOptions(options) {
            return merge(cloneDeep(this.getDefaults()), options);
        }
        get graph() {
            return this.cellView.graph;
        }
        get cell() {
            return this.cellView.cell;
        }
        get name() {
            return this.options.name;
        }
        get [Symbol.toStringTag]() {
            return ToolItem.toStringTag;
        }
        init() { }
        getOptions(options) {
            const ctor = this.constructor;
            return ctor.getOptions(options);
        }
        delegateEvents() {
            if (this.options.events) {
                super.delegateEvents(this.options.events);
            }
            return this;
        }
        config(view, toolsView) {
            this.cellView = view;
            this.parent = toolsView;
            this.stamp(this.container);
            if (this.cell.isEdge()) {
                addClass(this.container, this.prefixClassName('edge-tool'));
            }
            else if (this.cell.isNode()) {
                addClass(this.container, this.prefixClassName('node-tool'));
            }
            if (this.name) {
                this.container.setAttribute('data-tool-name', this.name);
            }
            this.delegateEvents();
            return this;
        }
        render() {
            this.empty();
            const markup = this.options.markup;
            if (markup) {
                const meta = Markup.isStringMarkup(markup)
                    ? Markup.parseStringMarkup(markup)
                    : Markup.parseJSONMarkup(markup);
                this.container.appendChild(meta.fragment);
                this.childNodes = meta.selectors;
            }
            this.onRender();
            return this;
        }
        onRender() { }
        update() {
            return this;
        }
        stamp(elem) {
            if (elem) {
                elem.setAttribute('data-cell-id', this.cellView.cell.id);
            }
        }
        show() {
            this.container.style.display = '';
            this.visible = true;
            return this;
        }
        hide() {
            this.container.style.display = 'none';
            this.visible = false;
            return this;
        }
        isVisible() {
            return !!this.visible;
        }
        focus() {
            const opacity = this.options.focusOpacity;
            if (opacity != null && Number.isFinite(opacity)) {
                this.container.style.opacity = `${opacity}`;
            }
            this.parent.focus(this);
            return this;
        }
        blur() {
            this.container.style.opacity = '';
            this.parent.blur(this);
            return this;
        }
        guard(evt) {
            if (this.graph == null || this.cellView == null) {
                return true;
            }
            return this.graph.view.guard(evt, this.cellView);
        }
    }
    // #region static
    ToolItem.defaults = {
        isSVGElement: true,
        tagName: 'g',
    };
    ToolsView.ToolItem = ToolItem;
    (function (ToolItem) {
        let counter = 0;
        function getClassName(name) {
            if (name) {
                return pascalCase(name);
            }
            counter += 1;
            return `CustomTool${counter}`;
        }
        function define(options) {
            const tool = createClass(getClassName(options.name), this);
            tool.config(options);
            return tool;
        }
        ToolItem.define = define;
    })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
    (function (ToolItem) {
        ToolItem.toStringTag = `X6.${ToolItem.name}`;
        function isToolItem(instance) {
            if (instance == null) {
                return false;
            }
            if (instance instanceof ToolItem) {
                return true;
            }
            const tag = instance[Symbol.toStringTag];
            const view = instance;
            if ((tag == null || tag === ToolItem.toStringTag) &&
                view.graph != null &&
                view.cell != null &&
                typeof view.config === 'function' &&
                typeof view.update === 'function' &&
                typeof view.focus === 'function' &&
                typeof view.blur === 'function' &&
                typeof view.show === 'function' &&
                typeof view.hide === 'function' &&
                typeof view.isVisible === 'function') {
                return true;
            }
            return false;
        }
        ToolItem.isToolItem = isToolItem;
    })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
})(ToolsView || (ToolsView = {}));

function getAnchor(pos, terminalView, terminalMagnet, type) {
    const end = call(ConnectionStrategy.presets.pinRelative, this.graph, {}, terminalView, terminalMagnet, pos, this.cell, type, {});
    return end.anchor;
}
function getViewBBox(view, quick) {
    if (quick) {
        return view.cell.getBBox();
    }
    return view.cell.isEdge()
        ? view.getConnection().bbox()
        : view.getUnrotatedBBoxOfElement(view.container);
}

class Button extends ToolsView.ToolItem {
    onRender() {
        addClass(this.container, this.prefixClassName('cell-tool-button'));
        this.update();
    }
    update() {
        this.updatePosition();
        return this;
    }
    updatePosition() {
        const view = this.cellView;
        const matrix = view.cell.isEdge()
            ? this.getEdgeMatrix()
            : this.getNodeMatrix();
        transform$1(this.container, matrix, { absolute: true });
    }
    getNodeMatrix() {
        const view = this.cellView;
        const options = this.options;
        let { x = 0, y = 0 } = options;
        const { offset, useCellGeometry, rotate } = options;
        let bbox = getViewBBox(view, useCellGeometry);
        const angle = view.cell.getAngle();
        if (!rotate) {
            bbox = bbox.bbox(angle);
        }
        let offsetX = 0;
        let offsetY = 0;
        if (typeof offset === 'number') {
            offsetX = offset;
            offsetY = offset;
        }
        else if (typeof offset === 'object') {
            offsetX = offset.x;
            offsetY = offset.y;
        }
        x = normalizePercentage(x, bbox.width);
        y = normalizePercentage(y, bbox.height);
        let matrix = createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
        if (rotate) {
            matrix = matrix.rotate(angle);
        }
        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);
        return matrix;
    }
    getEdgeMatrix() {
        const view = this.cellView;
        const options = this.options;
        const { offset = 0, distance = 0, rotate } = options;
        let tangent;
        let position;
        let angle;
        const d = normalizePercentage(distance, 1);
        if (d >= 0 && d <= 1) {
            tangent = view.getTangentAtRatio(d);
        }
        else {
            tangent = view.getTangentAtLength(d);
        }
        if (tangent) {
            position = tangent.start;
            angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
        }
        else {
            position = view.getConnection().start;
            angle = 0;
        }
        let matrix = createSVGMatrix()
            .translate(position.x, position.y)
            .rotate(angle);
        if (typeof offset === 'object') {
            matrix = matrix.translate(offset.x || 0, offset.y || 0);
        }
        else {
            matrix = matrix.translate(0, offset);
        }
        if (!rotate) {
            matrix = matrix.rotate(-angle);
        }
        return matrix;
    }
    onMouseDown(e) {
        if (this.guard(e)) {
            return;
        }
        e.stopPropagation();
        e.preventDefault();
        const onClick = this.options.onClick;
        if (typeof onClick === 'function') {
            call(onClick, this.cellView, {
                e,
                view: this.cellView,
                cell: this.cellView.cell,
                btn: this,
            });
        }
    }
}
(function (Button) {
    Button.config({
        name: 'button',
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
    });
})(Button || (Button = {}));
(function (Button) {
    Button.Remove = Button.define({
        name: 'button-remove',
        markup: [
            {
                tagName: 'circle',
                selector: 'button',
                attrs: {
                    r: 7,
                    fill: '#FF1D00',
                    cursor: 'pointer',
                },
            },
            {
                tagName: 'path',
                selector: 'icon',
                attrs: {
                    d: 'M -3 -3 3 3 M -3 3 3 -3',
                    fill: 'none',
                    stroke: '#FFFFFF',
                    'stroke-width': 2,
                    'pointer-events': 'none',
                },
            },
        ],
        distance: 60,
        offset: 0,
        onClick({ view, btn }) {
            btn.parent.remove();
            view.cell.remove({ ui: true, toolId: btn.cid });
        },
    });
})(Button || (Button = {}));

var __rest$m = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Boundary extends ToolsView.ToolItem {
    onRender() {
        addClass(this.container, this.prefixClassName('cell-tool-boundary'));
        if (this.options.attrs) {
            const _a = this.options.attrs, { class: className } = _a, attrs = __rest$m(_a, ["class"]);
            attr$1(this.container, kebablizeAttrs(attrs));
            if (className) {
                addClass(this.container, className);
            }
        }
        this.update();
    }
    update() {
        const view = this.cellView;
        const options = this.options;
        const { useCellGeometry, rotate: rotate$1 } = options;
        const padding = normalizeSides(options.padding);
        let bbox = getViewBBox(view, useCellGeometry).moveAndExpand({
            x: -padding.left,
            y: -padding.top,
            width: padding.left + padding.right,
            height: padding.top + padding.bottom,
        });
        const cell = view.cell;
        if (cell.isNode()) {
            const angle = cell.getAngle();
            if (angle) {
                if (rotate$1) {
                    const origin = cell.getBBox().getCenter();
                    rotate(this.container, angle, origin.x, origin.y, {
                        absolute: true,
                    });
                }
                else {
                    bbox = bbox.bbox(angle);
                }
            }
        }
        attr$1(this.container, bbox.toJSON());
        return this;
    }
}
(function (Boundary) {
    Boundary.config({
        name: 'boundary',
        tagName: 'rect',
        padding: 10,
        attrs: {
            fill: 'none',
            stroke: '#333',
            'stroke-width': 0.5,
            'stroke-dasharray': '5, 5',
            'pointer-events': 'none',
        },
    });
})(Boundary || (Boundary = {}));

class Vertices extends ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.handles = [];
    }
    get vertices() {
        return this.cellView.cell.getVertices();
    }
    onRender() {
        this.addClass(this.prefixClassName('edge-tool-vertices'));
        if (this.options.addable) {
            this.updatePath();
        }
        this.resetHandles();
        this.renderHandles();
        return this;
    }
    update() {
        const vertices = this.vertices;
        if (vertices.length === this.handles.length) {
            this.updateHandles();
        }
        else {
            this.resetHandles();
            this.renderHandles();
        }
        if (this.options.addable) {
            this.updatePath();
        }
        return this;
    }
    resetHandles() {
        const handles = this.handles;
        this.handles = [];
        if (handles) {
            handles.forEach((handle) => {
                this.stopHandleListening(handle);
                handle.remove();
            });
        }
    }
    renderHandles() {
        const vertices = this.vertices;
        for (let i = 0, l = vertices.length; i < l; i += 1) {
            const vertex = vertices[i];
            const createHandle = this.options.createHandle;
            const processHandle = this.options.processHandle;
            const handle = createHandle({
                index: i,
                graph: this.graph,
                guard: (evt) => this.guard(evt),
                attrs: this.options.attrs || {},
            });
            if (processHandle) {
                processHandle(handle);
            }
            this.graph.hook.onToolItemCreated({
                name: 'vertices',
                cell: this.cell,
                view: this.cellView,
                tool: handle,
            });
            handle.updatePosition(vertex.x, vertex.y);
            this.stamp(handle.container);
            this.container.appendChild(handle.container);
            this.handles.push(handle);
            this.startHandleListening(handle);
        }
    }
    updateHandles() {
        const vertices = this.vertices;
        for (let i = 0, l = vertices.length; i < l; i += 1) {
            const vertex = vertices[i];
            const handle = this.handles[i];
            if (handle) {
                handle.updatePosition(vertex.x, vertex.y);
            }
        }
    }
    updatePath() {
        const connection = this.childNodes.connection;
        if (connection) {
            connection.setAttribute('d', this.cellView.getConnectionPathData());
        }
    }
    startHandleListening(handle) {
        const edgeView = this.cellView;
        if (edgeView.can('vertexMovable')) {
            handle.on('change', this.onHandleChange, this);
            handle.on('changing', this.onHandleChanging, this);
            handle.on('changed', this.onHandleChanged, this);
        }
        if (edgeView.can('vertexDeletable')) {
            handle.on('remove', this.onHandleRemove, this);
        }
    }
    stopHandleListening(handle) {
        const edgeView = this.cellView;
        if (edgeView.can('vertexMovable')) {
            handle.off('change', this.onHandleChange, this);
            handle.off('changing', this.onHandleChanging, this);
            handle.off('changed', this.onHandleChanged, this);
        }
        if (edgeView.can('vertexDeletable')) {
            handle.off('remove', this.onHandleRemove, this);
        }
    }
    getNeighborPoints(index) {
        const edgeView = this.cellView;
        const vertices = this.vertices;
        const prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor;
        const next = index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor;
        return {
            prev: Point.create(prev),
            next: Point.create(next),
        };
    }
    getMouseEventArgs(evt) {
        const e = this.normalizeEvent(evt);
        const { x, y } = this.graph.snapToGrid(e.clientX, e.clientY);
        return { e, x, y };
    }
    onHandleChange({ e }) {
        this.focus();
        const edgeView = this.cellView;
        edgeView.cell.startBatch('move-vertex', { ui: true, toolId: this.cid });
        if (!this.options.stopPropagation) {
            const { e: evt, x, y } = this.getMouseEventArgs(e);
            edgeView.notifyMouseDown(evt, x, y);
        }
    }
    onHandleChanging({ handle, e, }) {
        const edgeView = this.cellView;
        const index = handle.options.index;
        const { e: evt, x, y } = this.getMouseEventArgs(e);
        const vertex = { x, y };
        this.snapVertex(vertex, index);
        edgeView.cell.setVertexAt(index, vertex, { ui: true, toolId: this.cid });
        handle.updatePosition(vertex.x, vertex.y);
        if (!this.options.stopPropagation) {
            edgeView.notifyMouseMove(evt, x, y);
        }
    }
    onHandleChanged({ e }) {
        const options = this.options;
        const edgeView = this.cellView;
        if (options.addable) {
            this.updatePath();
        }
        if (!options.removeRedundancies) {
            return;
        }
        const verticesRemoved = edgeView.removeRedundantLinearVertices({
            ui: true,
            toolId: this.cid,
        });
        if (verticesRemoved) {
            this.render();
        }
        this.blur();
        edgeView.cell.stopBatch('move-vertex', { ui: true, toolId: this.cid });
        if (this.eventData(e).vertexAdded) {
            edgeView.cell.stopBatch('add-vertex', { ui: true, toolId: this.cid });
        }
        const { e: evt, x, y } = this.getMouseEventArgs(e);
        if (!this.options.stopPropagation) {
            edgeView.notifyMouseUp(evt, x, y);
        }
        edgeView.checkMouseleave(evt);
        options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
    }
    snapVertex(vertex, index) {
        const snapRadius = this.options.snapRadius || 0;
        if (snapRadius > 0) {
            const neighbors = this.getNeighborPoints(index);
            const prev = neighbors.prev;
            const next = neighbors.next;
            if (Math.abs(vertex.x - prev.x) < snapRadius) {
                vertex.x = prev.x;
            }
            else if (Math.abs(vertex.x - next.x) < snapRadius) {
                vertex.x = next.x;
            }
            if (Math.abs(vertex.y - prev.y) < snapRadius) {
                vertex.y = neighbors.prev.y;
            }
            else if (Math.abs(vertex.y - next.y) < snapRadius) {
                vertex.y = next.y;
            }
        }
    }
    onHandleRemove({ handle, e }) {
        if (this.options.removable) {
            const index = handle.options.index;
            const edgeView = this.cellView;
            edgeView.cell.removeVertexAt(index, { ui: true });
            if (this.options.addable) {
                this.updatePath();
            }
            edgeView.checkMouseleave(this.normalizeEvent(e));
        }
    }
    onPathMouseDown(evt) {
        const edgeView = this.cellView;
        if (this.guard(evt) ||
            !this.options.addable ||
            !edgeView.can('vertexAddable')) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        const e = this.normalizeEvent(evt);
        const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();
        edgeView.cell.startBatch('add-vertex', { ui: true, toolId: this.cid });
        const index = edgeView.getVertexIndex(vertex.x, vertex.y);
        this.snapVertex(vertex, index);
        edgeView.cell.insertVertex(vertex, index, {
            ui: true,
            toolId: this.cid,
        });
        this.render();
        const handle = this.handles[index];
        this.eventData(e, { vertexAdded: true });
        handle.onMouseDown(e);
    }
    onRemove() {
        this.resetHandles();
    }
}
(function (Vertices) {
    class Handle extends View {
        constructor(options) {
            super();
            this.options = options;
            this.render();
            this.delegateEvents({
                mousedown: 'onMouseDown',
                touchstart: 'onMouseDown',
                dblclick: 'onDoubleClick',
            });
        }
        get graph() {
            return this.options.graph;
        }
        render() {
            this.container = View.createElement('circle', true);
            const attrs = this.options.attrs;
            if (typeof attrs === 'function') {
                const defaults = Vertices.getDefaults();
                this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
            }
            else {
                this.setAttrs(attrs);
            }
            this.addClass(this.prefixClassName('edge-tool-vertex'));
        }
        updatePosition(x, y) {
            this.setAttrs({ cx: x, cy: y });
        }
        onMouseDown(evt) {
            if (this.options.guard(evt)) {
                return;
            }
            evt.stopPropagation();
            evt.preventDefault();
            this.graph.view.undelegateEvents();
            this.delegateDocumentEvents({
                mousemove: 'onMouseMove',
                touchmove: 'onMouseMove',
                mouseup: 'onMouseUp',
                touchend: 'onMouseUp',
                touchcancel: 'onMouseUp',
            }, evt.data);
            this.emit('change', { e: evt, handle: this });
        }
        onMouseMove(evt) {
            this.emit('changing', { e: evt, handle: this });
        }
        onMouseUp(evt) {
            this.emit('changed', { e: evt, handle: this });
            this.undelegateDocumentEvents();
            this.graph.view.delegateEvents();
        }
        onDoubleClick(evt) {
            this.emit('remove', { e: evt, handle: this });
        }
    }
    Vertices.Handle = Handle;
})(Vertices || (Vertices = {}));
(function (Vertices) {
    const pathClassName = Util$3.prefix('edge-tool-vertex-path');
    Vertices.config({
        name: 'vertices',
        snapRadius: 20,
        addable: true,
        removable: true,
        removeRedundancies: true,
        stopPropagation: true,
        attrs: {
            r: 6,
            fill: '#333',
            stroke: '#fff',
            cursor: 'move',
            'stroke-width': 2,
        },
        createHandle: (options) => new Vertices.Handle(options),
        markup: [
            {
                tagName: 'path',
                selector: 'connection',
                className: pathClassName,
                attrs: {
                    fill: 'none',
                    stroke: 'transparent',
                    'stroke-width': 10,
                    cursor: 'pointer',
                },
            },
        ],
        events: {
            [`mousedown .${pathClassName}`]: 'onPathMouseDown',
            [`touchstart .${pathClassName}`]: 'onPathMouseDown',
        },
    });
})(Vertices || (Vertices = {}));

class Segments extends ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.handles = [];
    }
    get vertices() {
        return this.cellView.cell.getVertices();
    }
    update() {
        this.render();
        return this;
    }
    onRender() {
        addClass(this.container, this.prefixClassName('edge-tool-segments'));
        this.resetHandles();
        const edgeView = this.cellView;
        const vertices = [...this.vertices];
        if (this.options.addRoutePoint === true && vertices.length === 0) {
            vertices.push(...edgeView.routePoints);
        }
        vertices.unshift(edgeView.sourcePoint);
        vertices.push(edgeView.targetPoint);
        for (let i = 0, l = vertices.length; i < l - 1; i += 1) {
            const vertex = vertices[i];
            const nextVertex = vertices[i + 1];
            const handle = this.renderHandle(vertex, nextVertex, i);
            this.stamp(handle.container);
            this.handles.push(handle);
        }
        return this;
    }
    renderHandle(vertex, nextVertex, index) {
        const handle = this.options.createHandle({
            index,
            graph: this.graph,
            guard: (evt) => this.guard(evt),
            attrs: this.options.attrs || {},
        });
        if (this.options.processHandle) {
            this.options.processHandle(handle);
        }
        this.graph.hook.onToolItemCreated({
            name: 'segments',
            cell: this.cell,
            view: this.cellView,
            tool: handle,
        });
        this.updateHandle(handle, vertex, nextVertex);
        this.container.appendChild(handle.container);
        this.startHandleListening(handle);
        return handle;
    }
    startHandleListening(handle) {
        handle.on('change', this.onHandleChange, this);
        handle.on('changing', this.onHandleChanging, this);
        handle.on('changed', this.onHandleChanged, this);
    }
    stopHandleListening(handle) {
        handle.off('change', this.onHandleChange, this);
        handle.off('changing', this.onHandleChanging, this);
        handle.off('changed', this.onHandleChanged, this);
    }
    resetHandles() {
        const handles = this.handles;
        this.handles = [];
        if (handles) {
            handles.forEach((handle) => {
                this.stopHandleListening(handle);
                handle.remove();
            });
        }
    }
    shiftHandleIndexes(delta) {
        const handles = this.handles;
        for (let i = 0, n = handles.length; i < n; i += 1) {
            handles[i].options.index += delta;
        }
    }
    resetAnchor(type, anchor) {
        const edge = this.cellView.cell;
        const options = {
            ui: true,
            toolId: this.cid,
        };
        if (anchor) {
            edge.prop([type, 'anchor'], anchor, options);
        }
        else {
            edge.removeProp([type, 'anchor'], options);
        }
    }
    snapHandle(handle, position, data) {
        const axis = handle.options.axis;
        const index = handle.options.index;
        const edgeView = this.cellView;
        const edge = edgeView.cell;
        const vertices = edge.getVertices();
        const prev = vertices[index - 2] || data.sourceAnchor;
        const next = vertices[index + 1] || data.targetAnchor;
        const snapRadius = this.options.snapRadius;
        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {
            position[axis] = prev[axis];
        }
        else if (Math.abs(position[axis] - next[axis]) < snapRadius) {
            position[axis] = next[axis];
        }
        return position;
    }
    onHandleChanging({ handle, e, }) {
        const graph = this.graph;
        const options = this.options;
        const edgeView = this.cellView;
        const anchorFn = options.anchor;
        const axis = handle.options.axis;
        const index = handle.options.index - 1;
        const data = this.getEventData(e);
        const evt = this.normalizeEvent(e);
        const coords = graph.snapToGrid(evt.clientX, evt.clientY);
        const position = this.snapHandle(handle, coords.clone(), data);
        const vertices = cloneDeep(this.vertices);
        let vertex = vertices[index];
        let nextVertex = vertices[index + 1];
        // First Segment
        const sourceView = edgeView.sourceView;
        const sourceBBox = edgeView.sourceBBox;
        let changeSourceAnchor = false;
        let deleteSourceAnchor = false;
        if (!vertex) {
            vertex = edgeView.sourceAnchor.toJSON();
            vertex[axis] = position[axis];
            if (sourceBBox.containsPoint(vertex)) {
                changeSourceAnchor = true;
            }
            else {
                vertices.unshift(vertex);
                this.shiftHandleIndexes(1);
                deleteSourceAnchor = true;
            }
        }
        else if (index === 0) {
            if (sourceBBox.containsPoint(vertex)) {
                vertices.shift();
                this.shiftHandleIndexes(-1);
                changeSourceAnchor = true;
            }
            else {
                vertex[axis] = position[axis];
                deleteSourceAnchor = true;
            }
        }
        else {
            vertex[axis] = position[axis];
        }
        if (typeof anchorFn === 'function' && sourceView) {
            if (changeSourceAnchor) {
                const sourceAnchorPosition = data.sourceAnchor.clone();
                sourceAnchorPosition[axis] = position[axis];
                const sourceAnchor = call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);
                this.resetAnchor('source', sourceAnchor);
            }
            if (deleteSourceAnchor) {
                this.resetAnchor('source', data.sourceAnchorDef);
            }
        }
        // Last segment
        const targetView = edgeView.targetView;
        const targetBBox = edgeView.targetBBox;
        let changeTargetAnchor = false;
        let deleteTargetAnchor = false;
        if (!nextVertex) {
            nextVertex = edgeView.targetAnchor.toJSON();
            nextVertex[axis] = position[axis];
            if (targetBBox.containsPoint(nextVertex)) {
                changeTargetAnchor = true;
            }
            else {
                vertices.push(nextVertex);
                deleteTargetAnchor = true;
            }
        }
        else if (index === vertices.length - 2) {
            if (targetBBox.containsPoint(nextVertex)) {
                vertices.pop();
                changeTargetAnchor = true;
            }
            else {
                nextVertex[axis] = position[axis];
                deleteTargetAnchor = true;
            }
        }
        else {
            nextVertex[axis] = position[axis];
        }
        if (typeof anchorFn === 'function' && targetView) {
            if (changeTargetAnchor) {
                const targetAnchorPosition = data.targetAnchor.clone();
                targetAnchorPosition[axis] = position[axis];
                const targetAnchor = call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);
                this.resetAnchor('target', targetAnchor);
            }
            if (deleteTargetAnchor) {
                this.resetAnchor('target', data.targetAnchorDef);
            }
        }
        if (!Point.equalPoints(vertices, this.vertices)) {
            this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid });
        }
        this.updateHandle(handle, vertex, nextVertex, 0);
        if (!options.stopPropagation) {
            edgeView.notifyMouseMove(evt, coords.x, coords.y);
        }
    }
    onHandleChange({ handle, e }) {
        const options = this.options;
        const handles = this.handles;
        const edgeView = this.cellView;
        const index = handle.options.index;
        if (!Array.isArray(handles)) {
            return;
        }
        for (let i = 0, n = handles.length; i < n; i += 1) {
            if (i !== index) {
                handles[i].hide();
            }
        }
        this.focus();
        this.setEventData(e, {
            sourceAnchor: edgeView.sourceAnchor.clone(),
            targetAnchor: edgeView.targetAnchor.clone(),
            sourceAnchorDef: cloneDeep(this.cell.prop(['source', 'anchor'])),
            targetAnchorDef: cloneDeep(this.cell.prop(['target', 'anchor'])),
        });
        this.cell.startBatch('move-segment', { ui: true, toolId: this.cid });
        if (!options.stopPropagation) {
            const normalizedEvent = this.normalizeEvent(e);
            const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
            edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);
        }
    }
    onHandleChanged({ e }) {
        const options = this.options;
        const edgeView = this.cellView;
        if (options.removeRedundancies) {
            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
        }
        const normalizedEvent = this.normalizeEvent(e);
        const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
        this.render();
        this.blur();
        this.cell.stopBatch('move-segment', { ui: true, toolId: this.cid });
        if (!options.stopPropagation) {
            edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);
        }
        edgeView.checkMouseleave(normalizedEvent);
        options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
    }
    updateHandle(handle, vertex, nextVertex, offset = 0) {
        const precision = this.options.precision || 0;
        const vertical = Math.abs(vertex.x - nextVertex.x) < precision;
        const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;
        if (vertical || horizontal) {
            const segmentLine = new Line(vertex, nextVertex);
            const length = segmentLine.length();
            if (length < this.options.threshold) {
                handle.hide();
            }
            else {
                const position = segmentLine.getCenter();
                const axis = vertical ? 'x' : 'y';
                position[axis] += offset || 0;
                const angle = segmentLine.vector().vectorAngle(new Point(1, 0));
                handle.updatePosition(position.x, position.y, angle, this.cellView);
                handle.show();
                handle.options.axis = axis;
            }
        }
        else {
            handle.hide();
        }
    }
    onRemove() {
        this.resetHandles();
    }
}
(function (Segments) {
    class Handle extends View {
        constructor(options) {
            super();
            this.options = options;
            this.render();
            this.delegateEvents({
                mousedown: 'onMouseDown',
                touchstart: 'onMouseDown',
            });
        }
        render() {
            this.container = View.createElement('rect', true);
            const attrs = this.options.attrs;
            if (typeof attrs === 'function') {
                const defaults = Segments.getDefaults();
                this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
            }
            else {
                this.setAttrs(attrs);
            }
            this.addClass(this.prefixClassName('edge-tool-segment'));
        }
        updatePosition(x, y, angle, view) {
            const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);
            let matrix = createSVGMatrix().translate(p.x, p.y);
            if (!p.equals({ x, y })) {
                const line = new Line(x, y, p.x, p.y);
                let deg = line.vector().vectorAngle(new Point(1, 0));
                if (deg !== 0) {
                    deg += 90;
                }
                matrix = matrix.rotate(deg);
            }
            else {
                matrix = matrix.rotate(angle);
            }
            this.setAttrs({
                transform: matrixToTransformString(matrix),
                cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize',
            });
        }
        onMouseDown(evt) {
            if (this.options.guard(evt)) {
                return;
            }
            this.trigger('change', { e: evt, handle: this });
            evt.stopPropagation();
            evt.preventDefault();
            this.options.graph.view.undelegateEvents();
            this.delegateDocumentEvents({
                mousemove: 'onMouseMove',
                touchmove: 'onMouseMove',
                mouseup: 'onMouseUp',
                touchend: 'onMouseUp',
                touchcancel: 'onMouseUp',
            }, evt.data);
        }
        onMouseMove(evt) {
            this.emit('changing', { e: evt, handle: this });
        }
        onMouseUp(evt) {
            this.emit('changed', { e: evt, handle: this });
            this.undelegateDocumentEvents();
            this.options.graph.view.delegateEvents();
        }
        show() {
            this.container.style.display = '';
        }
        hide() {
            this.container.style.display = 'none';
        }
    }
    Segments.Handle = Handle;
})(Segments || (Segments = {}));
(function (Segments) {
    Segments.config({
        name: 'segments',
        precision: 0.5,
        threshold: 40,
        snapRadius: 10,
        stopPropagation: true,
        removeRedundancies: true,
        attrs: {
            width: 20,
            height: 8,
            x: -10,
            y: -4,
            rx: 4,
            ry: 4,
            fill: '#333',
            stroke: '#fff',
            'stroke-width': 2,
        },
        createHandle: (options) => new Segments.Handle(options),
        anchor: getAnchor,
        addRoutePoint: false,
    });
})(Segments || (Segments = {}));

class Anchor extends ToolsView.ToolItem {
    get type() {
        return this.options.type;
    }
    onRender() {
        addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));
        this.toggleArea(false);
        this.update();
    }
    update() {
        const type = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(type);
        if (terminalView) {
            this.updateAnchor();
            this.updateArea();
            this.container.style.display = '';
        }
        else {
            this.container.style.display = 'none';
        }
        return this;
    }
    updateAnchor() {
        const childNodes = this.childNodes;
        if (!childNodes) {
            return;
        }
        const anchorNode = childNodes.anchor;
        if (!anchorNode) {
            return;
        }
        const type = this.type;
        const edgeView = this.cellView;
        const options = this.options;
        const position = edgeView.getTerminalAnchor(type);
        const customAnchor = edgeView.cell.prop([type, 'anchor']);
        anchorNode.setAttribute('transform', `translate(${position.x}, ${position.y})`);
        const anchorAttrs = customAnchor
            ? options.customAnchorAttrs
            : options.defaultAnchorAttrs;
        if (anchorAttrs) {
            Object.keys(anchorAttrs).forEach((attrName) => {
                anchorNode.setAttribute(attrName, anchorAttrs[attrName]);
            });
        }
    }
    updateArea() {
        const childNodes = this.childNodes;
        if (!childNodes) {
            return;
        }
        const areaNode = childNodes.area;
        if (!areaNode) {
            return;
        }
        const type = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(type);
        if (terminalView) {
            const terminalCell = terminalView.cell;
            const magnet = edgeView.getTerminalMagnet(type);
            let padding = this.options.areaPadding || 0;
            if (!Number.isFinite(padding)) {
                padding = 0;
            }
            let bbox;
            let angle;
            let center;
            if (terminalView.isEdgeElement(magnet)) {
                bbox = terminalView.getBBox();
                angle = 0;
                center = bbox.getCenter();
            }
            else {
                bbox = terminalView.getUnrotatedBBoxOfElement(magnet);
                angle = terminalCell.getAngle();
                center = bbox.getCenter();
                if (angle) {
                    center.rotate(-angle, terminalCell.getBBox().getCenter());
                }
            }
            bbox.inflate(padding);
            attr$1(areaNode, {
                x: -bbox.width / 2,
                y: -bbox.height / 2,
                width: bbox.width,
                height: bbox.height,
                transform: `translate(${center.x}, ${center.y}) rotate(${angle})`,
            });
        }
    }
    toggleArea(visible) {
        if (this.childNodes) {
            const elem = this.childNodes.area;
            if (elem) {
                elem.style.display = visible ? '' : 'none';
            }
        }
    }
    onMouseDown(evt) {
        if (this.guard(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        this.graph.view.undelegateEvents();
        if (this.options.documentEvents) {
            this.delegateDocumentEvents(this.options.documentEvents);
        }
        this.focus();
        this.toggleArea(this.options.restrictArea);
        this.cell.startBatch('move-anchor', {
            ui: true,
            toolId: this.cid,
        });
    }
    resetAnchor(anchor) {
        const type = this.type;
        const cell = this.cell;
        if (anchor) {
            cell.prop([type, 'anchor'], anchor, {
                rewrite: true,
                ui: true,
                toolId: this.cid,
            });
        }
        else {
            cell.removeProp([type, 'anchor'], {
                ui: true,
                toolId: this.cid,
            });
        }
    }
    onMouseMove(evt) {
        const terminalType = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(terminalType);
        if (terminalView == null) {
            return;
        }
        const e = this.normalizeEvent(evt);
        const terminalCell = terminalView.cell;
        const terminalMagnet = edgeView.getTerminalMagnet(terminalType);
        let coords = this.graph.clientToLocal(e.clientX, e.clientY);
        const snapFn = this.options.snap;
        if (typeof snapFn === 'function') {
            const tmp = call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
            coords = Point.create(tmp);
        }
        if (this.options.restrictArea) {
            if (terminalView.isEdgeElement(terminalMagnet)) {
                const pointAtConnection = terminalView.getClosestPoint(coords);
                if (pointAtConnection) {
                    coords = pointAtConnection;
                }
            }
            else {
                const bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);
                const angle = terminalCell.getAngle();
                const origin = terminalCell.getBBox().getCenter();
                const rotatedCoords = coords.clone().rotate(angle, origin);
                if (!bbox.containsPoint(rotatedCoords)) {
                    coords = bbox
                        .getNearestPointToPoint(rotatedCoords)
                        .rotate(-angle, origin);
                }
            }
        }
        let anchor;
        const anchorFn = this.options.anchor;
        if (typeof anchorFn === 'function') {
            anchor = call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
        }
        this.resetAnchor(anchor);
        this.update();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMouseUp(evt) {
        this.graph.view.delegateEvents();
        this.undelegateDocumentEvents();
        this.blur();
        this.toggleArea(false);
        const edgeView = this.cellView;
        if (this.options.removeRedundancies) {
            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
        }
        this.cell.stopBatch('move-anchor', { ui: true, toolId: this.cid });
    }
    onDblClick() {
        const anchor = this.options.resetAnchor;
        if (anchor) {
            this.resetAnchor(anchor === true ? undefined : anchor);
        }
        this.update();
    }
}
(function (Anchor) {
    Anchor.config({
        tagName: 'g',
        markup: [
            {
                tagName: 'circle',
                selector: 'anchor',
                attrs: {
                    cursor: 'pointer',
                },
            },
            {
                tagName: 'rect',
                selector: 'area',
                attrs: {
                    'pointer-events': 'none',
                    fill: 'none',
                    stroke: '#33334F',
                    'stroke-dasharray': '2,4',
                    rx: 5,
                    ry: 5,
                },
            },
        ],
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
            dblclick: 'onDblClick',
        },
        documentEvents: {
            mousemove: 'onMouseMove',
            touchmove: 'onMouseMove',
            mouseup: 'onMouseUp',
            touchend: 'onMouseUp',
            touchcancel: 'onMouseUp',
        },
        customAnchorAttrs: {
            'stroke-width': 4,
            stroke: '#33334F',
            fill: '#FFFFFF',
            r: 5,
        },
        defaultAnchorAttrs: {
            'stroke-width': 2,
            stroke: '#FFFFFF',
            fill: '#33334F',
            r: 6,
        },
        areaPadding: 6,
        snapRadius: 10,
        resetAnchor: true,
        restrictArea: true,
        removeRedundancies: true,
        anchor: getAnchor,
        snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {
            const snapRadius = toolView.options.snapRadius || 0;
            const isSource = terminalType === 'source';
            const refIndex = isSource ? 0 : -1;
            const ref = this.cell.getVertexAt(refIndex) ||
                this.getTerminalAnchor(isSource ? 'target' : 'source');
            if (ref) {
                if (Math.abs(ref.x - pos.x) < snapRadius)
                    pos.x = ref.x;
                if (Math.abs(ref.y - pos.y) < snapRadius)
                    pos.y = ref.y;
            }
            return pos;
        },
    });
})(Anchor || (Anchor = {}));
const SourceAnchor = Anchor.define({
    name: 'source-anchor',
    type: 'source',
});
const TargetAnchor = Anchor.define({
    name: 'target-anchor',
    type: 'target',
});

var __rest$l = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Arrowhead extends ToolsView.ToolItem {
    get type() {
        return this.options.type;
    }
    get ratio() {
        return this.options.ratio;
    }
    init() {
        if (this.options.attrs) {
            const _a = this.options.attrs, { class: className } = _a, attrs = __rest$l(_a, ["class"]);
            this.setAttrs(attrs, this.container);
            if (className) {
                addClass(this.container, className);
            }
        }
    }
    onRender() {
        addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`));
        this.update();
    }
    update() {
        const ratio = this.ratio;
        const edgeView = this.cellView;
        const tangent = edgeView.getTangentAtRatio(ratio);
        const position = tangent ? tangent.start : edgeView.getPointAtRatio(ratio);
        const angle = (tangent && tangent.vector().vectorAngle(new Point(1, 0))) || 0;
        if (!position) {
            return this;
        }
        const matrix = createSVGMatrix()
            .translate(position.x, position.y)
            .rotate(angle);
        transform$1(this.container, matrix, { absolute: true });
        return this;
    }
    onMouseDown(evt) {
        if (this.guard(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        const edgeView = this.cellView;
        if (edgeView.can('arrowheadMovable')) {
            edgeView.cell.startBatch('move-arrowhead', {
                ui: true,
                toolId: this.cid,
            });
            const coords = this.graph.snapToGrid(evt.clientX, evt.clientY);
            const data = edgeView.prepareArrowheadDragging(this.type, {
                x: coords.x,
                y: coords.y,
                options: {
                    toolId: this.cid,
                },
            });
            this.cellView.setEventData(evt, data);
            this.delegateDocumentEvents(this.options.documentEvents, evt.data);
            edgeView.graph.view.undelegateEvents();
            this.container.style.pointerEvents = 'none';
        }
        this.focus();
    }
    onMouseMove(evt) {
        const e = this.normalizeEvent(evt);
        const coords = this.graph.snapToGrid(e.clientX, e.clientY);
        this.cellView.onMouseMove(e, coords.x, coords.y);
        this.update();
    }
    onMouseUp(evt) {
        this.undelegateDocumentEvents();
        const e = this.normalizeEvent(evt);
        const edgeView = this.cellView;
        const coords = this.graph.snapToGrid(e.clientX, e.clientY);
        edgeView.onMouseUp(e, coords.x, coords.y);
        this.graph.view.delegateEvents();
        this.blur();
        this.container.style.pointerEvents = '';
        edgeView.cell.stopBatch('move-arrowhead', {
            ui: true,
            toolId: this.cid,
        });
    }
}
(function (Arrowhead) {
    Arrowhead.config({
        tagName: 'path',
        isSVGElement: true,
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
        documentEvents: {
            mousemove: 'onMouseMove',
            touchmove: 'onMouseMove',
            mouseup: 'onMouseUp',
            touchend: 'onMouseUp',
            touchcancel: 'onMouseUp',
        },
    });
})(Arrowhead || (Arrowhead = {}));
const SourceArrowhead = Arrowhead.define({
    name: 'source-arrowhead',
    type: 'source',
    ratio: 0,
    attrs: {
        d: 'M 10 -8 -10 0 10 8 Z',
        fill: '#333',
        stroke: '#fff',
        'stroke-width': 2,
        cursor: 'move',
    },
});
const TargetArrowhead = Arrowhead.define({
    name: 'target-arrowhead',
    type: 'target',
    ratio: 1,
    attrs: {
        d: 'M -10 -8 10 0 -10 8 Z',
        fill: '#333',
        stroke: '#fff',
        'stroke-width': 2,
        cursor: 'move',
    },
});

class CellEditor extends ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.labelIndex = -1;
        this.distance = 0.5;
    }
    render() {
        this.createElement();
        this.updateEditor();
        this.autoFocus();
        this.delegateDocumentEvents(this.options.documentEvents);
        return this;
    }
    createElement() {
        const { cell } = this;
        const classNames = [
            this.prefixClassName(`${cell.isEdge() ? 'edge' : 'node'}-tool-editor`),
            this.prefixClassName('cell-tool-editor'),
        ];
        this.editor = ToolsView.createElement('div', false);
        this.addClass(classNames, this.editor);
        this.editor.contentEditable = 'true';
        this.container.appendChild(this.editor);
    }
    updateEditor() {
        const { graph, cell, editor } = this;
        const style = editor.style;
        // set tool position
        let pos = new Point();
        let minWidth = 20;
        if (cell.isNode()) {
            pos = cell.getBBox().center;
            minWidth = cell.size().width - 4;
        }
        else if (cell.isEdge()) {
            const e = this.options.event;
            const target = e.target;
            const parent = target.parentElement;
            const isEdgeLabel = parent && hasClass(parent, this.prefixClassName('edge-label'));
            if (isEdgeLabel) {
                const index = parent.getAttribute('data-index') || '0';
                this.labelIndex = parseInt(index, 10);
                const matrix = parent.getAttribute('transform');
                const { translation } = parseTransformString(matrix);
                pos = new Point(translation.tx, translation.ty);
                minWidth = getBBox(target).width;
            }
            else {
                if (!this.options.labelAddable) {
                    return this;
                }
                pos = graph.clientToLocal(Point.create(e.clientX, e.clientY));
                const view = this.cellView;
                const d = view.path.closestPointLength(pos);
                this.distance = d;
            }
        }
        pos = graph.localToGraph(pos);
        style.left = `${pos.x}px`;
        style.top = `${pos.y}px`;
        style.minWidth = `${minWidth}px`;
        // set tool transform
        const scale = graph.scale();
        style.transform = `scale(${scale.sx}, ${scale.sy}) translate(-50%, -50%)`;
        // set font style
        const attrs = this.options.attrs;
        style.fontSize = `${attrs.fontSize}px`;
        style.fontFamily = attrs.fontFamily;
        style.color = attrs.color;
        style.backgroundColor = attrs.backgroundColor;
        // set init value
        const getText = this.options.getText;
        let text;
        if (typeof getText === 'function') {
            text = call(getText, this.cellView, {
                cell: this.cell,
                index: this.labelIndex,
            });
        }
        editor.innerText = text || '';
        return this;
    }
    onDocumentMouseDown(e) {
        if (e.target !== this.editor) {
            const cell = this.cell;
            const value = this.editor.innerText.replace(/\n$/, '') || '';
            // set value
            const setText = this.options.setText;
            if (typeof setText === 'function') {
                call(setText, this.cellView, {
                    cell: this.cell,
                    value,
                    index: this.labelIndex,
                    distance: this.distance,
                });
            }
            // remove tool
            cell.removeTool(cell.isEdge() ? 'edge-editor' : 'node-editor');
            this.undelegateDocumentEvents();
        }
    }
    onDblClick(e) {
        e.stopPropagation();
    }
    onMouseDown(e) {
        e.stopPropagation();
    }
    autoFocus() {
        setTimeout(() => {
            this.editor.focus();
            this.selectText();
        });
    }
    selectText() {
        if (window.getSelection) {
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(this.editor);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
}
(function (CellEditor) {
    CellEditor.config({
        tagName: 'div',
        isSVGElement: false,
        events: {
            dblclick: 'onDblClick',
            mousedown: 'onMouseDown',
        },
        documentEvents: {
            mousedown: 'onDocumentMouseDown',
        },
    });
})(CellEditor || (CellEditor = {}));
(function (CellEditor) {
    CellEditor.NodeEditor = CellEditor.define({
        attrs: {
            fontSize: 14,
            fontFamily: 'Arial, helvetica, sans-serif',
            color: '#000',
            backgroundColor: '#fff',
        },
        getText({ cell }) {
            return cell.attr('text/text');
        },
        setText({ cell, value }) {
            cell.attr('text/text', value);
        },
    });
    CellEditor.EdgeEditor = CellEditor.define({
        attrs: {
            fontSize: 14,
            fontFamily: 'Arial, helvetica, sans-serif',
            color: '#000',
            backgroundColor: '#fff',
        },
        labelAddable: true,
        getText({ cell, index }) {
            if (index === -1) {
                return '';
            }
            return cell.prop(`labels/${index}/attrs/label/text`);
        },
        setText({ cell, value, index, distance }) {
            const edge = cell;
            if (index === -1) {
                edge.appendLabel({
                    position: {
                        distance: distance,
                    },
                    attrs: {
                        label: {
                            text: value,
                        },
                    },
                });
            }
            else {
                if (value) {
                    edge.prop(`labels/${index}/attrs/label/text`, value);
                }
                else if (typeof index === 'number') {
                    edge.removeLabelAt(index);
                }
            }
        },
    });
})(CellEditor || (CellEditor = {}));

var __rest$k = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var NodeTool;
(function (NodeTool) {
    NodeTool.presets = {
        boundary: Boundary,
        button: Button,
        'button-remove': Button.Remove,
        'node-editor': CellEditor.NodeEditor,
    };
    NodeTool.registry = Registry.create({
        type: 'node tool',
        process(name, options) {
            if (typeof options === 'function') {
                return options;
            }
            let parent = ToolsView.ToolItem;
            const { inherit } = options, others = __rest$k(options, ["inherit"]);
            if (inherit) {
                const base = this.get(inherit);
                if (base == null) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            if (others.name == null) {
                others.name = name;
            }
            return parent.define.call(parent, others);
        },
    });
    NodeTool.registry.register(NodeTool.presets, true);
})(NodeTool || (NodeTool = {}));
var EdgeTool;
(function (EdgeTool) {
    EdgeTool.presets = {
        boundary: Boundary,
        vertices: Vertices,
        segments: Segments,
        button: Button,
        'button-remove': Button.Remove,
        'source-anchor': SourceAnchor,
        'target-anchor': TargetAnchor,
        'source-arrowhead': SourceArrowhead,
        'target-arrowhead': TargetArrowhead,
        'edge-editor': CellEditor.EdgeEditor,
    };
    EdgeTool.registry = Registry.create({
        type: 'edge tool',
        process(name, options) {
            if (typeof options === 'function') {
                return options;
            }
            let parent = ToolsView.ToolItem;
            const { inherit } = options, others = __rest$k(options, ["inherit"]);
            if (inherit) {
                const base = this.get(inherit);
                if (base == null) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            if (others.name == null) {
                others.name = name;
            }
            return parent.define.call(parent, others);
        },
    });
    EdgeTool.registry.register(EdgeTool.presets, true);
})(EdgeTool || (EdgeTool = {}));

const center = createBBoxAnchor('center');
const top = createBBoxAnchor('topCenter');
const bottom = createBBoxAnchor('bottomCenter');
const left = createBBoxAnchor('leftMiddle');
const right = createBBoxAnchor('rightMiddle');
const topLeft = createBBoxAnchor('topLeft');
const topRight = createBBoxAnchor('topRight');
const bottomLeft = createBBoxAnchor('bottomLeft');
const bottomRight = createBBoxAnchor('bottomRight');
function createBBoxAnchor(method) {
    return function (view, magnet, ref, options = {}) {
        const bbox = options.rotate
            ? view.getUnrotatedBBoxOfElement(magnet)
            : view.getBBoxOfElement(magnet);
        const result = bbox[method];
        result.x += normalizePercentage(options.dx, bbox.width);
        result.y += normalizePercentage(options.dy, bbox.height);
        const cell = view.cell;
        return options.rotate
            ? result.rotate(-cell.getAngle(), cell.getBBox().getCenter())
            : result;
    };
}

// eslint-disable-next-line
function resolve$1(fn) {
    return function (view, magnet, ref, options) {
        if (ref instanceof Element) {
            const refView = this.graph.renderer.findViewByElem(ref);
            let refPoint;
            if (refView) {
                if (refView.isEdgeElement(ref)) {
                    const distance = options.fixedAt != null ? options.fixedAt : '50%';
                    refPoint = getPointAtEdge(refView, distance);
                }
                else {
                    refPoint = refView.getBBoxOfElement(ref).getCenter();
                }
            }
            else {
                refPoint = new Point();
            }
            return fn.call(this, view, magnet, refPoint, options);
        }
        return fn.apply(this, arguments); // eslint-disable-line
    };
}
function getPointAtEdge(edgeView, value) {
    const isPercentage$1 = isPercentage(value);
    const num = typeof value === 'string' ? parseFloat(value) : value;
    if (isPercentage$1) {
        return edgeView.getPointAtRatio(num / 100);
    }
    return edgeView.getPointAtLength(num);
}

const orthogonal$1 = function (view, magnet, refPoint, options) {
    const angle = view.cell.getAngle();
    const bbox = view.getBBoxOfElement(magnet);
    const result = bbox.getCenter();
    const topLeft = bbox.getTopLeft();
    const bottomRight = bbox.getBottomRight();
    let padding = options.padding;
    if (!Number.isFinite(padding)) {
        padding = 0;
    }
    if (topLeft.y + padding <= refPoint.y &&
        refPoint.y <= bottomRight.y - padding) {
        const dy = refPoint.y - result.y;
        result.x +=
            angle === 0 || angle === 180
                ? 0
                : (dy * 1) / Math.tan(Angle.toRad(angle));
        result.y += dy;
    }
    else if (topLeft.x + padding <= refPoint.x &&
        refPoint.x <= bottomRight.x - padding) {
        const dx = refPoint.x - result.x;
        result.y +=
            angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));
        result.x += dx;
    }
    return result;
};
/**
 * Tries to place the anchor of the edge inside the view bbox so that the
 * edge is made orthogonal. The anchor is placed along two line segments
 * inside the view bbox (between the centers of the top and bottom side and
 * between the centers of the left and right sides). If it is not possible
 * to place the anchor so that the edge would be orthogonal, the anchor is
 * placed at the center of the view bbox instead.
 */
const orth$2 = resolve$1(orthogonal$1);

/**
 * Places the anchor of the edge at center of the node bbox.
 */
const nodeCenter = function (view, magnet, ref, options, endType) {
    const result = view.cell.getConnectionPoint(this.cell, endType);
    if (options.dx || options.dy) {
        result.translate(options.dx || 0, options.dy || 0);
    }
    return result;
};

const middleSide = function (view, magnet, refPoint, options) {
    let bbox;
    let angle = 0;
    let center;
    const node = view.cell;
    if (options.rotate) {
        bbox = view.getUnrotatedBBoxOfElement(magnet);
        center = node.getBBox().getCenter();
        angle = node.getAngle();
    }
    else {
        bbox = view.getBBoxOfElement(magnet);
    }
    const padding = options.padding;
    if (padding != null && Number.isFinite(padding)) {
        bbox.inflate(padding);
    }
    if (options.rotate) {
        refPoint.rotate(angle, center);
    }
    const side = bbox.getNearestSideToPoint(refPoint);
    let result;
    switch (side) {
        case 'left':
            result = bbox.getLeftMiddle();
            break;
        case 'right':
            result = bbox.getRightMiddle();
            break;
        case 'top':
            result = bbox.getTopCenter();
            break;
        case 'bottom':
            result = bbox.getBottomCenter();
            break;
        default:
            break;
    }
    const direction = options.direction;
    if (direction === 'H') {
        if (side === 'top' || side === 'bottom') {
            if (refPoint.x <= bbox.x + bbox.width) {
                result = bbox.getLeftMiddle();
            }
            else {
                result = bbox.getRightMiddle();
            }
        }
    }
    else if (direction === 'V') {
        if (refPoint.y <= bbox.y + bbox.height) {
            result = bbox.getTopCenter();
        }
        else {
            result = bbox.getBottomCenter();
        }
    }
    return options.rotate ? result.rotate(-angle, center) : result;
};
/**
 * Places the anchor of the edge in the middle of the side of view bbox
 * closest to the other endpoint.
 */
const midSide = resolve$1(middleSide);

var anchors$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	bottom: bottom,
	bottomLeft: bottomLeft,
	bottomRight: bottomRight,
	center: center,
	left: left,
	midSide: midSide,
	nodeCenter: nodeCenter,
	orth: orth$2,
	right: right,
	top: top,
	topLeft: topLeft,
	topRight: topRight
});

var NodeAnchor;
(function (NodeAnchor) {
    NodeAnchor.presets = anchors$1;
    NodeAnchor.registry = Registry.create({
        type: 'node endpoint',
    });
    NodeAnchor.registry.register(NodeAnchor.presets, true);
})(NodeAnchor || (NodeAnchor = {}));

const ratio = function (view, magnet, ref, options) {
    let ratio = options.ratio != null ? options.ratio : 0.5;
    if (ratio > 1) {
        ratio /= 100;
    }
    return view.getPointAtRatio(ratio);
};

const length = function (view, magnet, ref, options) {
    const length = options.length != null ? options.length : 20;
    return view.getPointAtLength(length);
};

const getClosestPoint = function (view, magnet, refPoint, options) {
    const closestPoint = view.getClosestPoint(refPoint);
    return closestPoint != null ? closestPoint : new Point();
};
const closest = resolve$1(getClosestPoint);

const orthogonal = function (view, magnet, refPoint, options) {
    const OFFSET = 1e6;
    const path = view.getConnection();
    const segmentSubdivisions = view.getConnectionSubdivisions();
    const vLine = new Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
    const hLine = new Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
    const vIntersections = vLine.intersect(path, {
        segmentSubdivisions,
    });
    const hIntersections = hLine.intersect(path, {
        segmentSubdivisions,
    });
    const intersections = [];
    if (vIntersections) {
        intersections.push(...vIntersections);
    }
    if (hIntersections) {
        intersections.push(...hIntersections);
    }
    if (intersections.length > 0) {
        return refPoint.closest(intersections);
    }
    if (options.fallbackAt != null) {
        return getPointAtEdge(view, options.fallbackAt);
    }
    return call(getClosestPoint, this, view, magnet, refPoint, options);
};
const orth$1 = resolve$1(orthogonal);

var anchors = /*#__PURE__*/Object.freeze({
	__proto__: null,
	closest: closest,
	length: length,
	orth: orth$1,
	ratio: ratio
});

var EdgeAnchor;
(function (EdgeAnchor) {
    EdgeAnchor.presets = anchors;
    EdgeAnchor.registry = Registry.create({
        type: 'edge endpoint',
    });
    EdgeAnchor.registry.register(EdgeAnchor.presets, true);
})(EdgeAnchor || (EdgeAnchor = {}));

function offset(p1, p2, offset) {
    let tx;
    if (typeof offset === 'object') {
        if (Number.isFinite(offset.y)) {
            const line = new Line(p2, p1);
            const { start, end } = line.parallel(offset.y);
            p2 = start; // eslint-disable-line
            p1 = end; // eslint-disable-line
        }
        tx = offset.x;
    }
    else {
        tx = offset;
    }
    if (tx == null || !Number.isFinite(tx)) {
        return p1;
    }
    const length = p1.distance(p2);
    if (tx === 0 && length > 0) {
        return p1;
    }
    return p1.move(p2, -Math.min(tx, length - 1));
}
function getStrokeWidth(magnet) {
    const stroke = magnet.getAttribute('stroke-width');
    if (stroke === null) {
        return 0;
    }
    return parseFloat(stroke) || 0;
}
function findShapeNode(magnet) {
    if (magnet == null) {
        return null;
    }
    let node = magnet;
    do {
        let tagName = node.tagName;
        if (typeof tagName !== 'string')
            return null;
        tagName = tagName.toUpperCase();
        if (tagName === 'G') {
            node = node.firstElementChild;
        }
        else if (tagName === 'TITLE') {
            node = node.nextElementSibling;
        }
        else
            break;
    } while (node);
    return node;
}

/**
 * Places the connection point at the intersection between the edge
 * path end segment and the target node bbox.
 */
const bbox = function (line, view, magnet, options) {
    const bbox = view.getBBoxOfElement(magnet);
    if (options.stroked) {
        bbox.inflate(getStrokeWidth(magnet) / 2);
    }
    const intersections = line.intersect(bbox);
    const p = intersections && intersections.length
        ? line.start.closest(intersections)
        : line.end;
    return offset(p, line.start, options.offset);
};

/**
 * Places the connection point at the intersection between the
 * link path end segment and the element's unrotated bbox.
 */
const rect = function (line, view, magnet, options, type) {
    const cell = view.cell;
    const angle = cell.isNode() ? cell.getAngle() : 0;
    if (angle === 0) {
        return call(bbox, this, line, view, magnet, options, type);
    }
    const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);
    if (options.stroked) {
        bboxRaw.inflate(getStrokeWidth(magnet) / 2);
    }
    const center = bboxRaw.getCenter();
    const lineRaw = line.clone().rotate(angle, center);
    const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);
    const p = intersections && intersections.length
        ? lineRaw.start.closest(intersections).rotate(-angle, center)
        : line.end;
    return offset(p, line.start, options.offset);
};

/**
 * Places the connection point at the intersection between the
 * edge path end segment and the actual shape of the target magnet.
 */
const boundary = function (line, view, magnet, options) {
    let node;
    let intersection;
    const anchor = line.end;
    const selector = options.selector;
    if (typeof selector === 'string') {
        node = view.findOne(selector);
    }
    else if (Array.isArray(selector)) {
        node = getByPath(magnet, selector);
    }
    else {
        node = findShapeNode(magnet);
    }
    if (!isSVGGraphicsElement(node)) {
        if (node === magnet || !isSVGGraphicsElement(magnet)) {
            return anchor;
        }
        node = magnet;
    }
    const localShape = view.getShapeOfElement(node);
    const magnetMatrix = view.getMatrixOfElement(node);
    const translateMatrix = view.getRootTranslatedMatrix();
    const rotateMatrix = view.getRootRotatedMatrix();
    const targetMatrix = translateMatrix
        .multiply(rotateMatrix)
        .multiply(magnetMatrix);
    const localMatrix = targetMatrix.inverse();
    const localLine = transformLine(line, localMatrix);
    const localRef = localLine.start.clone();
    const data = view.getDataOfElement(node);
    if (options.insideout === false) {
        if (data.shapeBBox == null) {
            data.shapeBBox = localShape.bbox();
        }
        const localBBox = data.shapeBBox;
        if (localBBox != null && localBBox.containsPoint(localRef)) {
            return anchor;
        }
    }
    if (options.extrapolate === true) {
        localLine.setLength(1e6);
    }
    // Caching segment subdivisions for paths
    let pathOptions;
    if (Path$2.isPath(localShape)) {
        const precision = options.precision || 2;
        if (data.segmentSubdivisions == null) {
            data.segmentSubdivisions = localShape.getSegmentSubdivisions({
                precision,
            });
        }
        pathOptions = {
            precision,
            segmentSubdivisions: data.segmentSubdivisions,
        };
        intersection = localLine.intersect(localShape, pathOptions);
    }
    else {
        intersection = localLine.intersect(localShape);
    }
    if (intersection) {
        if (Array.isArray(intersection)) {
            intersection = localRef.closest(intersection);
        }
    }
    else if (options.sticky === true) {
        // No intersection, find the closest point instead
        if (Rectangle.isRectangle(localShape)) {
            intersection = localShape.getNearestPointToPoint(localRef);
        }
        else if (Ellipse$2.isEllipse(localShape)) {
            intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);
        }
        else {
            intersection = localShape.closestPoint(localRef, pathOptions);
        }
    }
    const cp = intersection
        ? transformPoint(intersection, targetMatrix)
        : anchor;
    let cpOffset = options.offset || 0;
    if (options.stroked !== false) {
        if (typeof cpOffset === 'object') {
            cpOffset = Object.assign({}, cpOffset);
            if (cpOffset.x == null) {
                cpOffset.x = 0;
            }
            cpOffset.x += getStrokeWidth(node) / 2;
        }
        else {
            cpOffset += getStrokeWidth(node) / 2;
        }
    }
    return offset(cp, line.start, cpOffset);
};

function alignLine(line, type, offset = 0) {
    const { start, end } = line;
    let a;
    let b;
    let direction;
    let coordinate;
    switch (type) {
        case 'left':
            coordinate = 'x';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'right':
            coordinate = 'x';
            a = start;
            b = end;
            direction = 1;
            break;
        case 'top':
            coordinate = 'y';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'bottom':
            coordinate = 'y';
            a = start;
            b = end;
            direction = 1;
            break;
        default:
            return;
    }
    if (start[coordinate] < end[coordinate]) {
        a[coordinate] = b[coordinate];
    }
    else {
        b[coordinate] = a[coordinate];
    }
    if (Number.isFinite(offset)) {
        a[coordinate] += direction * offset;
        b[coordinate] += direction * offset;
    }
}
/**
 * Places the connection point at the edge's endpoint.
 */
const anchor = function (line, view, magnet, options) {
    const { alignOffset, align } = options;
    if (align) {
        alignLine(line, align, alignOffset);
    }
    return offset(line.end, line.start, options.offset);
};

var connectionPoints = /*#__PURE__*/Object.freeze({
	__proto__: null,
	anchor: anchor,
	bbox: bbox,
	boundary: boundary,
	rect: rect
});

var ConnectionPoint;
(function (ConnectionPoint) {
    ConnectionPoint.presets = connectionPoints;
    ConnectionPoint.registry = Registry.create({
        type: 'connection point',
    });
    ConnectionPoint.registry.register(ConnectionPoint.presets, true);
})(ConnectionPoint || (ConnectionPoint = {}));

const normal$1 = function (vertices) {
    return [...vertices];
};

/**
 * Routes the edge always to/from a certain side
 */
const oneSide = function (vertices, options, edgeView) {
    const side = options.side || 'bottom';
    const padding = normalizeSides(options.padding || 40);
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    const sourcePoint = sourceBBox.getCenter();
    const targetPoint = targetBBox.getCenter();
    let coord;
    let dim;
    let factor;
    switch (side) {
        case 'top':
            factor = -1;
            coord = 'y';
            dim = 'height';
            break;
        case 'left':
            factor = -1;
            coord = 'x';
            dim = 'width';
            break;
        case 'right':
            factor = 1;
            coord = 'x';
            dim = 'width';
            break;
        case 'bottom':
        default:
            factor = 1;
            coord = 'y';
            dim = 'height';
            break;
    }
    // Move the points from the center of the element to outside of it.
    sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side]);
    targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side]);
    // Make edge orthogonal (at least the first and last vertex).
    if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {
        targetPoint[coord] = sourcePoint[coord];
    }
    else {
        sourcePoint[coord] = targetPoint[coord];
    }
    return [sourcePoint.toJSON(), ...vertices, targetPoint.toJSON()];
};

function getPointBBox(p) {
    return new Rectangle(p.x, p.y, 0, 0);
}
function getPaddingBox(options = {}) {
    const sides = normalizeSides(options.padding || 20);
    return {
        x: -sides.left,
        y: -sides.top,
        width: sides.left + sides.right,
        height: sides.top + sides.bottom,
    };
}
function getSourceBBox$1(view, options = {}) {
    return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getTargetBBox$1(view, options = {}) {
    return view.targetBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getSourceAnchor(view, options = {}) {
    if (view.sourceAnchor) {
        return view.sourceAnchor;
    }
    const bbox = getSourceBBox$1(view, options);
    return bbox.getCenter();
}
function getTargetAnchor(view, options = {}) {
    if (view.targetAnchor) {
        return view.targetAnchor;
    }
    const bbox = getTargetBBox$1(view, options);
    return bbox.getCenter();
}

/**
 * Returns a route with orthogonal line segments.
 */
const orth = function (vertices, options, edgeView) {
    let sourceBBox = getSourceBBox$1(edgeView, options);
    let targetBBox = getTargetBBox$1(edgeView, options);
    const sourceAnchor = getSourceAnchor(edgeView, options);
    const targetAnchor = getTargetAnchor(edgeView, options);
    // If anchor lies outside of bbox, the bbox expands to include it
    sourceBBox = sourceBBox.union(getPointBBox(sourceAnchor));
    targetBBox = targetBBox.union(getPointBBox(targetAnchor));
    const points = vertices.map((p) => Point.create(p));
    points.unshift(sourceAnchor);
    points.push(targetAnchor);
    // bearing of previous route segment
    let bearing = null;
    const result = [];
    for (let i = 0, len = points.length - 1; i < len; i += 1) {
        let route = null;
        const from = points[i];
        const to = points[i + 1];
        const isOrthogonal = Private$5.getBearing(from, to) != null;
        if (i === 0) {
            // source
            if (i + 1 === len) {
                // source -> target
                // Expand one of the nodes by 1px to detect situations when the two
                // nodes are positioned next to each other with no gap in between.
                if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {
                    route = Private$5.insideNode(from, to, sourceBBox, targetBBox);
                }
                else if (!isOrthogonal) {
                    route = Private$5.nodeToNode(from, to, sourceBBox, targetBBox);
                }
            }
            else {
                // source -> vertex
                if (sourceBBox.containsPoint(to)) {
                    route = Private$5.insideNode(from, to, sourceBBox, getPointBBox(to).moveAndExpand(getPaddingBox(options)));
                }
                else if (!isOrthogonal) {
                    route = Private$5.nodeToVertex(from, to, sourceBBox);
                }
            }
        }
        else if (i + 1 === len) {
            // vertex -> target
            // prevent overlaps with previous line segment
            const isOrthogonalLoop = isOrthogonal && Private$5.getBearing(to, from) === bearing;
            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
                route = Private$5.insideNode(from, to, getPointBBox(from).moveAndExpand(getPaddingBox(options)), targetBBox, bearing);
            }
            else if (!isOrthogonal) {
                route = Private$5.vertexToNode(from, to, targetBBox, bearing);
            }
        }
        else if (!isOrthogonal) {
            // vertex -> vertex
            route = Private$5.vertexToVertex(from, to, bearing);
        }
        // set bearing for next iteration
        if (route) {
            result.push(...route.points);
            bearing = route.direction;
        }
        else {
            // orthogonal route and not looped
            bearing = Private$5.getBearing(from, to);
        }
        // push `to` point to identified orthogonal vertices array
        if (i + 1 < len) {
            result.push(to);
        }
    }
    return result;
};
var Private$5;
(function (Private) {
    /**
     * Bearing to opposite bearing map
     */
    const opposites = {
        N: 'S',
        S: 'N',
        E: 'W',
        W: 'E',
    };
    /**
     * Bearing to radians map
     */
    const radians = {
        N: (-Math.PI / 2) * 3,
        S: -Math.PI / 2,
        E: 0,
        W: Math.PI,
    };
    /**
     * Returns a point `p` where lines p,p1 and p,p2 are perpendicular
     * and p is not contained in the given box
     */
    function freeJoin(p1, p2, bbox) {
        let p = new Point(p1.x, p2.y);
        if (bbox.containsPoint(p)) {
            p = new Point(p2.x, p1.y);
        }
        // kept for reference
        // if (bbox.containsPoint(p)) {
        //   return null
        // }
        return p;
    }
    /**
     * Returns either width or height of a bbox based on the given bearing.
     */
    function getBBoxSize(bbox, bearing) {
        return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];
    }
    Private.getBBoxSize = getBBoxSize;
    function getBearing(from, to) {
        if (from.x === to.x) {
            return from.y > to.y ? 'N' : 'S';
        }
        if (from.y === to.y) {
            return from.x > to.x ? 'W' : 'E';
        }
        return null;
    }
    Private.getBearing = getBearing;
    function vertexToVertex(from, to, bearing) {
        const p1 = new Point(from.x, to.y);
        const p2 = new Point(to.x, from.y);
        const d1 = getBearing(from, p1);
        const d2 = getBearing(from, p2);
        const opposite = bearing ? opposites[bearing] : null;
        const p = d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))
            ? p1
            : p2;
        return { points: [p], direction: getBearing(p, to) };
    }
    Private.vertexToVertex = vertexToVertex;
    function nodeToVertex(from, to, fromBBox) {
        const p = freeJoin(from, to, fromBBox);
        return { points: [p], direction: getBearing(p, to) };
    }
    Private.nodeToVertex = nodeToVertex;
    function vertexToNode(from, to, toBBox, bearing) {
        const points = [new Point(from.x, to.y), new Point(to.x, from.y)];
        const freePoints = points.filter((p) => !toBBox.containsPoint(p));
        const freeBearingPoints = freePoints.filter((p) => getBearing(p, from) !== bearing);
        let p;
        if (freeBearingPoints.length > 0) {
            // Try to pick a point which bears the same direction as the previous segment.
            p = freeBearingPoints.filter((p) => getBearing(from, p) === bearing).pop();
            p = p || freeBearingPoints[0];
            return {
                points: [p],
                direction: getBearing(p, to),
            };
        }
        {
            // Here we found only points which are either contained in the element or they would create
            // a link segment going in opposite direction from the previous one.
            // We take the point inside element and move it outside the element in the direction the
            // route is going. Now we can join this point with the current end (using freeJoin).
            p = difference(points, freePoints)[0];
            const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
            const p1 = freeJoin(p2, from, toBBox);
            return {
                points: [p1, p2],
                direction: getBearing(p2, to),
            };
        }
    }
    Private.vertexToNode = vertexToNode;
    function nodeToNode(from, to, fromBBox, toBBox) {
        let route = nodeToVertex(to, from, toBBox);
        const p1 = route.points[0];
        if (fromBBox.containsPoint(p1)) {
            route = nodeToVertex(from, to, fromBBox);
            const p2 = route.points[0];
            if (toBBox.containsPoint(p2)) {
                const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
                const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
                const mid = new Line(fromBorder, toBorder).getCenter();
                const startRoute = nodeToVertex(from, mid, fromBBox);
                const endRoute = vertexToVertex(mid, to, startRoute.direction);
                route.points = [startRoute.points[0], endRoute.points[0]];
                route.direction = endRoute.direction;
            }
        }
        return route;
    }
    Private.nodeToNode = nodeToNode;
    // Finds route for situations where one node is inside the other.
    // Typically the route is directed outside the outer node first and
    // then back towards the inner node.
    function insideNode(from, to, fromBBox, toBBox, bearing) {
        const boundary = fromBBox.union(toBBox).inflate(1);
        // start from the point which is closer to the boundary
        const center = boundary.getCenter();
        const reversed = center.distance(to) > center.distance(from);
        const start = reversed ? to : from;
        const end = reversed ? from : to;
        let p1;
        let p2;
        let p3;
        if (bearing) {
            // Points on circle with radius equals 'W + H` are always outside the rectangle
            // with width W and height H if the center of that circle is the center of that rectangle.
            p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
            p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);
        }
        else {
            p1 = boundary.getNearestPointToPoint(start).move(start, 1);
        }
        p2 = freeJoin(p1, end, boundary);
        let points;
        if (p1.round().equals(p2.round())) {
            p2 = Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);
            p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();
            p3 = freeJoin(p1, p2, boundary);
            points = reversed ? [p2, p3, p1] : [p1, p3, p2];
        }
        else {
            points = reversed ? [p2, p1] : [p1, p2];
        }
        const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
        return {
            points,
            direction,
        };
    }
    Private.insideNode = insideNode;
})(Private$5 || (Private$5 = {}));

const defaults$1 = {
    step: 10,
    maxLoopCount: 2000,
    precision: 1,
    maxDirectionChange: 90,
    perpendicular: true,
    excludeTerminals: [],
    excludeShapes: [],
    excludeNodes: [],
    excludeHiddenNodes: false,
    startDirections: ['top', 'right', 'bottom', 'left'],
    endDirections: ['top', 'right', 'bottom', 'left'],
    directionMap: {
        top: { x: 0, y: -1 },
        right: { x: 1, y: 0 },
        bottom: { x: 0, y: 1 },
        left: { x: -1, y: 0 },
    },
    cost() {
        const step = resolve(this.step, this);
        return step;
    },
    directions() {
        const step = resolve(this.step, this);
        const cost = resolve(this.cost, this);
        return [
            { cost, offsetX: step, offsetY: 0 },
            { cost, offsetX: -step, offsetY: 0 },
            { cost, offsetX: 0, offsetY: step },
            { cost, offsetX: 0, offsetY: -step },
        ];
    },
    penalties() {
        const step = resolve(this.step, this);
        return {
            0: 0,
            45: step / 2,
            90: step / 2,
        };
    },
    paddingBox() {
        const step = resolve(this.step, this);
        return {
            x: -step,
            y: -step,
            width: 2 * step,
            height: 2 * step,
        };
    },
    fallbackRouter: orth,
    draggingRouter: null,
};
function resolve(input, options) {
    if (typeof input === 'function') {
        return input.call(options);
    }
    return input;
}
function resolveOptions(options) {
    const result = Object.keys(options).reduce((memo, key) => {
        const ret = memo;
        if (key === 'fallbackRouter' ||
            key === 'draggingRouter' ||
            key === 'fallbackRoute') {
            ret[key] = options[key];
        }
        else {
            ret[key] = resolve(options[key], options);
        }
        return memo;
    }, {});
    if (result.padding) {
        const sides = normalizeSides(result.padding);
        result.paddingBox = {
            x: -sides.left,
            y: -sides.top,
            width: sides.left + sides.right,
            height: sides.top + sides.bottom,
        };
    }
    result.directions.forEach((direction) => {
        const point1 = new Point(0, 0);
        const point2 = new Point(direction.offsetX, direction.offsetY);
        direction.angle = Angle.normalize(point1.theta(point2));
    });
    return result;
}

const OPEN = 1;
const CLOSE = 2;
class SortedSet {
    constructor() {
        this.items = [];
        this.hash = {};
        this.values = {};
    }
    add(item, value) {
        if (this.hash[item]) {
            // item removal
            this.items.splice(this.items.indexOf(item), 1);
        }
        else {
            this.hash[item] = OPEN;
        }
        this.values[item] = value;
        const index = sortedIndexBy(this.items, item, (key) => this.values[key]);
        this.items.splice(index, 0, item);
    }
    pop() {
        const item = this.items.shift();
        if (item) {
            this.hash[item] = CLOSE;
        }
        return item;
    }
    isOpen(item) {
        return this.hash[item] === OPEN;
    }
    isClose(item) {
        return this.hash[item] === CLOSE;
    }
    isEmpty() {
        return this.items.length === 0;
    }
}

/**
 * Helper structure to identify whether a point lies inside an obstacle.
 */
class ObstacleMap {
    constructor(options) {
        this.options = options;
        this.mapGridSize = 100;
        this.map = {};
    }
    /**
     * Builds a map of all nodes for quicker obstacle queries i.e. is a point
     * contained in any obstacle?
     *
     * A simplified grid search.
     */
    build(model, edge) {
        const options = this.options;
        // source or target node could be excluded from set of obstacles
        const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {
            const terminal = edge[type];
            if (terminal) {
                const cell = model.getCell(terminal.cell);
                if (cell) {
                    memo.push(cell);
                }
            }
            return memo;
        }, []);
        let excludedAncestors = [];
        const source = model.getCell(edge.getSourceCellId());
        if (source) {
            excludedAncestors = union(excludedAncestors, source.getAncestors().map((cell) => cell.id));
        }
        const target = model.getCell(edge.getTargetCellId());
        if (target) {
            excludedAncestors = union(excludedAncestors, target.getAncestors().map((cell) => cell.id));
        }
        // The graph is divided into smaller cells, where each holds information
        // about which node belong to it. When we query whether a point lies
        // inside an obstacle we don't need to go through all obstacles, we check
        // only those in a particular cell.
        const mapGridSize = this.mapGridSize;
        model.getNodes().reduce((map, node) => {
            const shape = node.shape;
            const excludeShapes = options.excludeShapes;
            const excType = shape ? excludeShapes.includes(shape) : false;
            const excTerminal = excludedTerminals.some((cell) => cell.id === node.id);
            const excludedNode = options.excludeNodes.some((item) => {
                if (typeof item === 'string') {
                    return node.id === item;
                }
                return item === node;
            });
            const excAncestor = excludedAncestors.includes(node.id);
            const excHidden = options.excludeHiddenNodes && !node.isVisible();
            const excluded = excType || excTerminal || excludedNode || excAncestor || excHidden;
            if (!excluded) {
                const bbox = node.getBBox().moveAndExpand(options.paddingBox);
                const origin = bbox.getOrigin().snapToGrid(mapGridSize);
                const corner = bbox.getCorner().snapToGrid(mapGridSize);
                for (let x = origin.x; x <= corner.x; x += mapGridSize) {
                    for (let y = origin.y; y <= corner.y; y += mapGridSize) {
                        const key = new Point(x, y).toString();
                        if (map[key] == null) {
                            map[key] = [];
                        }
                        map[key].push(bbox);
                    }
                }
            }
            return map;
        }, this.map);
        return this;
    }
    isAccessible(point) {
        const key = point.clone().snapToGrid(this.mapGridSize).toString();
        const rects = this.map[key];
        return rects ? rects.every((rect) => !rect.containsPoint(point)) : true;
    }
}

function getSourceBBox(view, options) {
    const bbox = view.sourceBBox.clone();
    if (options && options.paddingBox) {
        return bbox.moveAndExpand(options.paddingBox);
    }
    return bbox;
}
function getTargetBBox(view, options) {
    const bbox = view.targetBBox.clone();
    if (options && options.paddingBox) {
        return bbox.moveAndExpand(options.paddingBox);
    }
    return bbox;
}
function getSourceEndpoint(view, options) {
    if (view.sourceAnchor) {
        return view.sourceAnchor;
    }
    const sourceBBox = getSourceBBox(view, options);
    return sourceBBox.getCenter();
}
function getTargetEndpoint(view, options) {
    if (view.targetAnchor) {
        return view.targetAnchor;
    }
    const targetBBox = getTargetBBox(view, options);
    return targetBBox.getCenter();
}
// returns a direction index from start point to end point
// corrects for grid deformation between start and end
function getDirectionAngle(start, end, directionCount, grid, options) {
    const quadrant = 360 / directionCount;
    const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));
    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
    return quadrant * Math.floor(normalizedAngle / quadrant);
}
function fixAngleEnd(start, end, grid, options) {
    const step = options.step;
    const diffX = end.x - start.x;
    const diffY = end.y - start.y;
    const gridStepsX = diffX / grid.x;
    const gridStepsY = diffY / grid.y;
    const distanceX = gridStepsX * step;
    const distanceY = gridStepsY * step;
    return new Point(start.x + distanceX, start.y + distanceY);
}
/**
 * Returns the change in direction between two direction angles.
 */
function getDirectionChange(angle1, angle2) {
    const change = Math.abs(angle1 - angle2);
    return change > 180 ? 360 - change : change;
}
// fix direction offsets according to current grid
function getGridOffsets(grid, options) {
    const step = options.step;
    options.directions.forEach((direction) => {
        direction.gridOffsetX = (direction.offsetX / step) * grid.x;
        direction.gridOffsetY = (direction.offsetY / step) * grid.y;
    });
    return options.directions;
}
// get grid size in x and y dimensions, adapted to source and target positions
function getGrid(step, source, target) {
    return {
        source: source.clone(),
        x: getGridDimension(target.x - source.x, step),
        y: getGridDimension(target.y - source.y, step),
    };
}
function getGridDimension(diff, step) {
    // return step if diff = 0
    if (!diff) {
        return step;
    }
    const abs = Math.abs(diff);
    const count = Math.round(abs / step);
    // return `abs` if less than one step apart
    if (!count) {
        return abs;
    }
    // otherwise, return corrected step
    const roundedDiff = count * step;
    const remainder = abs - roundedDiff;
    const correction = remainder / count;
    return step + correction;
}
function snapGrid(point, grid) {
    const source = grid.source;
    const x = Util$3.snapToGrid(point.x - source.x, grid.x) + source.x;
    const y = Util$3.snapToGrid(point.y - source.y, grid.y) + source.y;
    return new Point(x, y);
}
function round(point, precision) {
    return point.round(precision);
}
function align(point, grid, precision) {
    return round(snapGrid(point.clone(), grid), precision);
}
function getKey(point) {
    return point.toString();
}
function normalizePoint(point) {
    return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
function getCost(from, anchors) {
    let min = Infinity;
    for (let i = 0, len = anchors.length; i < len; i += 1) {
        const dist = from.manhattanDistance(anchors[i]);
        if (dist < min) {
            min = dist;
        }
    }
    return min;
}
// Find points around the bbox taking given directions into account
// lines are drawn from anchor in given directions, intersections recorded
// if anchor is outside bbox, only those directions that intersect get a rect point
// the anchor itself is returned as rect point (representing some directions)
// (since those directions are unobstructed by the bbox)
function getRectPoints(anchor, bbox, directionList, grid, options) {
    const precision = options.precision;
    const directionMap = options.directionMap;
    const centerVector = anchor.diff(bbox.getCenter());
    const rectPoints = Object.keys(directionMap).reduce((res, key) => {
        if (directionList.includes(key)) {
            const direction = directionMap[key];
            // Create a line that is guaranteed to intersect the bbox if bbox
            // is in the direction even if anchor lies outside of bbox.
            const ending = new Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));
            const intersectionLine = new Line(anchor, ending);
            // Get the farther intersection, in case there are two
            // (that happens if anchor lies next to bbox)
            const intersections = intersectionLine.intersect(bbox) || [];
            let farthestIntersectionDistance;
            let farthestIntersection = null;
            for (let i = 0; i < intersections.length; i += 1) {
                const intersection = intersections[i];
                const distance = anchor.squaredDistance(intersection);
                if (farthestIntersectionDistance == null ||
                    distance > farthestIntersectionDistance) {
                    farthestIntersectionDistance = distance;
                    farthestIntersection = intersection;
                }
            }
            // If an intersection was found in this direction, it is our rectPoint
            if (farthestIntersection) {
                let target = align(farthestIntersection, grid, precision);
                // If the rectPoint lies inside the bbox, offset it by one more step
                if (bbox.containsPoint(target)) {
                    target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);
                }
                res.push(target);
            }
        }
        return res;
    }, []);
    // if anchor lies outside of bbox, add it to the array of points
    if (!bbox.containsPoint(anchor)) {
        rectPoints.push(align(anchor, grid, precision));
    }
    return rectPoints;
}
// reconstructs a route by concatenating points with their parents
function reconstructRoute(parents, points, tailPoint, from, to) {
    const route = [];
    let prevDiff = normalizePoint(to.diff(tailPoint));
    // tailPoint is assumed to be aligned already
    let currentKey = getKey(tailPoint);
    let parent = parents[currentKey];
    let point;
    while (parent) {
        // point is assumed to be aligned already
        point = points[currentKey];
        const diff = normalizePoint(point.diff(parent));
        if (!diff.equals(prevDiff)) {
            route.unshift(point);
            prevDiff = diff;
        }
        // parent is assumed to be aligned already
        currentKey = getKey(parent);
        parent = parents[currentKey];
    }
    // leadPoint is assumed to be aligned already
    const leadPoint = points[currentKey];
    const fromDiff = normalizePoint(leadPoint.diff(from));
    if (!fromDiff.equals(prevDiff)) {
        route.unshift(leadPoint);
    }
    return route;
}

/**
 * Finds the route between two points (`from`, `to`).
 */
function findRoute(edgeView, from, to, map, options) {
    const precision = options.precision;
    let sourceEndpoint;
    let targetEndpoint;
    if (Rectangle.isRectangle(from)) {
        sourceEndpoint = round(getSourceEndpoint(edgeView, options).clone(), precision);
    }
    else {
        sourceEndpoint = round(from.clone(), precision);
    }
    if (Rectangle.isRectangle(to)) {
        targetEndpoint = round(getTargetEndpoint(edgeView, options).clone(), precision);
    }
    else {
        targetEndpoint = round(to.clone(), precision);
    }
    // Get grid for this route.
    const grid = getGrid(options.step, sourceEndpoint, targetEndpoint);
    // Get pathfinding points.
    // -----------------------
    const startPoint = sourceEndpoint;
    const endPoint = targetEndpoint;
    let startPoints;
    let endPoints;
    if (Rectangle.isRectangle(from)) {
        startPoints = getRectPoints(startPoint, from, options.startDirections, grid, options);
    }
    else {
        startPoints = [startPoint];
    }
    if (Rectangle.isRectangle(to)) {
        endPoints = getRectPoints(targetEndpoint, to, options.endDirections, grid, options);
    }
    else {
        endPoints = [endPoint];
    }
    // take into account only accessible rect points (those not under obstacles)
    startPoints = startPoints.filter((p) => map.isAccessible(p));
    endPoints = endPoints.filter((p) => map.isAccessible(p));
    // There is an accessible route point on both sides.
    if (startPoints.length > 0 && endPoints.length > 0) {
        const openSet = new SortedSet();
        // Keeps the actual points for given nodes of the open set.
        const points = {};
        // Keeps the point that is immediate predecessor of given element.
        const parents = {};
        // Cost from start to a point along best known path.
        const costs = {};
        for (let i = 0, n = startPoints.length; i < n; i += 1) {
            // startPoint is assumed to be aligned already
            const startPoint = startPoints[i];
            const key = getKey(startPoint);
            openSet.add(key, getCost(startPoint, endPoints));
            points[key] = startPoint;
            costs[key] = 0;
        }
        const previousRouteDirectionAngle = options.previousDirectionAngle;
        // undefined for first route
        const isPathBeginning = previousRouteDirectionAngle === undefined;
        // directions
        let direction;
        let directionChange;
        const directions = getGridOffsets(grid, options);
        const numDirections = directions.length;
        const endPointsKeys = endPoints.reduce((res, endPoint) => {
            const key = getKey(endPoint);
            res.push(key);
            return res;
        }, []);
        // main route finding loop
        const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);
        let loopsRemaining = options.maxLoopCount;
        while (!openSet.isEmpty() && loopsRemaining > 0) {
            // Get the closest item and mark it CLOSED
            const currentKey = openSet.pop();
            const currentPoint = points[currentKey];
            const currentParent = parents[currentKey];
            const currentCost = costs[currentKey];
            const isStartPoint = currentPoint.equals(startPoint);
            const isRouteBeginning = currentParent == null;
            let previousDirectionAngle;
            if (!isRouteBeginning) {
                previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);
            }
            else if (!isPathBeginning) {
                // a vertex on the route
                previousDirectionAngle = previousRouteDirectionAngle;
            }
            else if (!isStartPoint) {
                // beginning of route on the path
                previousDirectionAngle = getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);
            }
            else {
                previousDirectionAngle = null;
            }
            // Check if we reached any endpoint
            const skipEndCheck = isRouteBeginning && sameStartEndPoints;
            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
                options.previousDirectionAngle = previousDirectionAngle;
                return reconstructRoute(parents, points, currentPoint, startPoint, endPoint);
            }
            // Go over all possible directions and find neighbors
            for (let i = 0; i < numDirections; i += 1) {
                direction = directions[i];
                const directionAngle = direction.angle;
                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);
                // Don't use the point changed rapidly.
                if (!(isPathBeginning && isStartPoint) &&
                    directionChange > options.maxDirectionChange) {
                    continue;
                }
                const neighborPoint = align(currentPoint
                    .clone()
                    .translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);
                const neighborKey = getKey(neighborPoint);
                // Closed points were already evaluated.
                if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {
                    continue;
                }
                // Neighbor is an end point.
                if (endPointsKeys.indexOf(neighborKey) >= 0) {
                    const isEndPoint = neighborPoint.equals(endPoint);
                    if (!isEndPoint) {
                        const endDirectionAngle = getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);
                        const endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
                        if (endDirectionChange > options.maxDirectionChange) {
                            continue;
                        }
                    }
                }
                // The current direction is ok.
                // ----------------------------
                const neighborCost = direction.cost;
                const neighborPenalty = isStartPoint
                    ? 0
                    : options.penalties[directionChange];
                const costFromStart = currentCost + neighborCost + neighborPenalty;
                // Neighbor point has not been processed yet or the cost of
                // the path from start is lower than previously calculated.
                if (!openSet.isOpen(neighborKey) ||
                    costFromStart < costs[neighborKey]) {
                    points[neighborKey] = neighborPoint;
                    parents[neighborKey] = currentPoint;
                    costs[neighborKey] = costFromStart;
                    openSet.add(neighborKey, costFromStart + getCost(neighborPoint, endPoints));
                }
            }
            loopsRemaining -= 1;
        }
    }
    if (options.fallbackRoute) {
        return call(options.fallbackRoute, this, startPoint, endPoint, options);
    }
    return null;
}
const router = function (vertices, optionsRaw, edgeView) {
    const options = resolveOptions(optionsRaw);
    const sourceBBox = getSourceBBox(edgeView, options);
    const targetBBox = getTargetBBox(edgeView, options);
    const sourceEndpoint = getSourceEndpoint(edgeView, options);
    // pathfinding
    const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);
    const oldVertices = vertices.map((p) => Point.create(p));
    const newVertices = [];
    // The origin of first route's grid, does not need snapping
    let tailPoint = sourceEndpoint;
    let from;
    let to;
    for (let i = 0, len = oldVertices.length; i <= len; i += 1) {
        let partialRoute = null;
        from = to || sourceBBox;
        to = oldVertices[i];
        // This is the last iteration
        if (to == null) {
            to = targetBBox;
            // If the target is a point, we should use dragging route
            // instead of main routing method if it has been provided.
            const edge = edgeView.cell;
            const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;
            if (isEndingAtPoint && typeof options.draggingRouter === 'function') {
                const dragFrom = from === sourceBBox ? sourceEndpoint : from;
                const dragTo = to.getOrigin();
                partialRoute = call(options.draggingRouter, edgeView, dragFrom, dragTo, options);
            }
        }
        // Find the partial route
        if (partialRoute == null) {
            partialRoute = findRoute(edgeView, from, to, map, options);
        }
        // Cannot found the partial route.
        if (partialRoute === null) {
            // eslint-next-line
            console.warn(`Unable to execute manhattan algorithm, use orth instead`);
            return call(options.fallbackRouter, this, vertices, options, edgeView);
        }
        // Remove the first point if the previous partial route has
        // the same point as last.
        const leadPoint = partialRoute[0];
        if (leadPoint && leadPoint.equals(tailPoint)) {
            partialRoute.shift();
        }
        // Save tailPoint for next iteration
        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
        newVertices.push(...partialRoute);
    }
    return newVertices;
};

const manhattan = function (vertices, options, edgeView) {
    return call(router, this, vertices, Object.assign(Object.assign({}, defaults$1), options), edgeView);
};

const defaults = {
    maxDirectionChange: 45,
    // an array of directions to find next points on the route
    // different from start/end directions
    directions() {
        const step = resolve(this.step, this);
        const cost = resolve(this.cost, this);
        const diagonalCost = Math.ceil(Math.sqrt((step * step) << 1)); // eslint-disable-line no-bitwise
        return [
            { cost, offsetX: step, offsetY: 0 },
            { cost: diagonalCost, offsetX: step, offsetY: step },
            { cost, offsetX: 0, offsetY: step },
            { cost: diagonalCost, offsetX: -step, offsetY: step },
            { cost, offsetX: -step, offsetY: 0 },
            { cost: diagonalCost, offsetX: -step, offsetY: -step },
            { cost, offsetX: 0, offsetY: -step },
            { cost: diagonalCost, offsetX: step, offsetY: -step },
        ];
    },
    // a simple route used in situations when main routing method fails
    // (exceed max number of loop iterations, inaccessible)
    fallbackRoute(from, to, options) {
        // Find a route which breaks by 45 degrees ignoring all obstacles.
        const theta = from.theta(to);
        const route = [];
        let a = { x: to.x, y: from.y };
        let b = { x: from.x, y: to.y };
        if (theta % 180 > 90) {
            const t = a;
            a = b;
            b = t;
        }
        const p1 = theta % 90 < 45 ? a : b;
        const l1 = new Line(from, p1);
        const alpha = 90 * Math.ceil(theta / 90);
        const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);
        const l2 = new Line(to, p2);
        const intersectionPoint = l1.intersectsWithLine(l2);
        const point = intersectionPoint || to;
        const directionFrom = intersectionPoint ? point : from;
        const quadrant = 360 / options.directions.length;
        const angleTheta = directionFrom.theta(to);
        const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
        const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
        options.previousDirectionAngle = directionAngle;
        if (point)
            route.push(point.round());
        route.push(to);
        return route;
    },
};
const metro = function (vertices, options, linkView) {
    return call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);
};

const er = function (vertices, options, edgeView) {
    const offsetRaw = options.offset || 32;
    const min = options.min == null ? 16 : options.min;
    let offset = 0;
    let direction = options.direction;
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    const sourcePoint = sourceBBox.getCenter();
    const targetPoint = targetBBox.getCenter();
    if (typeof offsetRaw === 'number') {
        offset = offsetRaw;
    }
    if (direction == null) {
        let dx = targetBBox.left - sourceBBox.right;
        let dy = targetBBox.top - sourceBBox.bottom;
        if (dx >= 0 && dy >= 0) {
            direction = dx >= dy ? 'L' : 'T';
        }
        else if (dx <= 0 && dy >= 0) {
            dx = sourceBBox.left - targetBBox.right;
            if (dx >= 0) {
                direction = dx >= dy ? 'R' : 'T';
            }
            else {
                direction = 'T';
            }
        }
        else if (dx >= 0 && dy <= 0) {
            dy = sourceBBox.top - targetBBox.bottom;
            if (dy >= 0) {
                direction = dx >= dy ? 'L' : 'B';
            }
            else {
                direction = 'L';
            }
        }
        else {
            dx = sourceBBox.left - targetBBox.right;
            dy = sourceBBox.top - targetBBox.bottom;
            if (dx >= 0 && dy >= 0) {
                direction = dx >= dy ? 'R' : 'B';
            }
            else if (dx <= 0 && dy >= 0) {
                direction = 'B';
            }
            else if (dx >= 0 && dy <= 0) {
                direction = 'R';
            }
            else {
                direction = Math.abs(dx) > Math.abs(dy) ? 'R' : 'B';
            }
        }
    }
    if (direction === 'H') {
        direction = targetPoint.x - sourcePoint.x >= 0 ? 'L' : 'R';
    }
    else if (direction === 'V') {
        direction = targetPoint.y - sourcePoint.y >= 0 ? 'T' : 'B';
    }
    if (offsetRaw === 'center') {
        if (direction === 'L') {
            offset = (targetBBox.left - sourceBBox.right) / 2;
        }
        else if (direction === 'R') {
            offset = (sourceBBox.left - targetBBox.right) / 2;
        }
        else if (direction === 'T') {
            offset = (targetBBox.top - sourceBBox.bottom) / 2;
        }
        else if (direction === 'B') {
            offset = (sourceBBox.top - targetBBox.bottom) / 2;
        }
    }
    let coord;
    let dim;
    let factor;
    const horizontal = direction === 'L' || direction === 'R';
    if (horizontal) {
        if (targetPoint.y === sourcePoint.y) {
            return [...vertices];
        }
        factor = direction === 'L' ? 1 : -1;
        coord = 'x';
        dim = 'width';
    }
    else {
        if (targetPoint.x === sourcePoint.x) {
            return [...vertices];
        }
        factor = direction === 'T' ? 1 : -1;
        coord = 'y';
        dim = 'height';
    }
    const source = sourcePoint.clone();
    const target = targetPoint.clone();
    source[coord] += factor * (sourceBBox[dim] / 2 + offset);
    target[coord] -= factor * (targetBBox[dim] / 2 + offset);
    if (horizontal) {
        const sourceX = source.x;
        const targetX = target.x;
        const sourceDelta = sourceBBox.width / 2 + min;
        const targetDelta = targetBBox.width / 2 + min;
        if (targetPoint.x > sourcePoint.x) {
            if (targetX <= sourceX) {
                source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
                target.x = Math.min(sourceX, targetPoint.x - targetDelta);
            }
        }
        else if (targetX >= sourceX) {
            source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
            target.x = Math.max(sourceX, targetPoint.x + targetDelta);
        }
    }
    else {
        const sourceY = source.y;
        const targetY = target.y;
        const sourceDelta = sourceBBox.height / 2 + min;
        const targetDelta = targetBBox.height / 2 + min;
        if (targetPoint.y > sourcePoint.y) {
            if (targetY <= sourceY) {
                source.y = Math.max(targetY, sourcePoint.y + sourceDelta);
                target.y = Math.min(sourceY, targetPoint.y - targetDelta);
            }
        }
        else if (targetY >= sourceY) {
            source.y = Math.min(targetY, sourcePoint.y - sourceDelta);
            target.y = Math.max(sourceY, targetPoint.y + targetDelta);
        }
    }
    return [source.toJSON(), ...vertices, target.toJSON()];
};

function rollup(points, merge) {
    if (merge != null && merge !== false) {
        const amount = typeof merge === 'boolean' ? 0 : merge;
        if (amount > 0) {
            const center1 = Point.create(points[1]).move(points[2], amount);
            const center2 = Point.create(points[1]).move(points[0], amount);
            return [center1.toJSON(), ...points, center2.toJSON()];
        }
        {
            const center = points[1];
            return [Object.assign({}, center), ...points, Object.assign({}, center)];
        }
    }
    return points;
}
const loop$1 = function (vertices, options, edgeView) {
    const width = options.width || 50;
    const height = options.height || 80;
    const halfHeight = height / 2;
    const angle = options.angle || 'auto';
    const sourceAnchor = edgeView.sourceAnchor;
    const targetAnchor = edgeView.targetAnchor;
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    if (sourceAnchor.equals(targetAnchor)) {
        const getVertices = (angle) => {
            const rad = Angle.toRad(angle);
            const sin = Math.sin(rad);
            const cos = Math.cos(rad);
            const center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);
            const ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);
            const p1 = ref.clone().rotate(-90, center);
            const p2 = ref.clone().rotate(90, center);
            return [p1.toJSON(), center.toJSON(), p2.toJSON()];
        };
        const validate = (end) => {
            const start = sourceAnchor.clone().move(end, -1);
            const line = new Line(start, end);
            return (!sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line));
        };
        const angles = [0, 90, 180, 270, 45, 135, 225, 315];
        if (typeof angle === 'number') {
            return rollup(getVertices(angle), options.merge);
        }
        const center = sourceBBox.getCenter();
        if (center.equals(sourceAnchor)) {
            return rollup(getVertices(0), options.merge);
        }
        const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));
        let ret = getVertices(deg);
        if (validate(ret[1])) {
            return rollup(ret, options.merge);
        }
        // return the best vertices
        for (let i = 1, l = angles.length; i < l; i += 1) {
            ret = getVertices(deg + angles[i]);
            if (validate(ret[1])) {
                return rollup(ret, options.merge);
            }
        }
        return rollup(ret, options.merge);
    }
    {
        const line = new Line(sourceAnchor, targetAnchor);
        let parallel = line.parallel(-width);
        let center = parallel.getCenter();
        let p1 = parallel.start.clone().move(parallel.end, halfHeight);
        let p2 = parallel.end.clone().move(parallel.start, halfHeight);
        const ref = line.parallel(-1);
        const line1 = new Line(ref.start, center);
        const line2 = new Line(ref.end, center);
        if (sourceBBox.containsPoint(center) ||
            targetBBox.containsPoint(center) ||
            sourceBBox.intersectsWithLine(line1) ||
            sourceBBox.intersectsWithLine(line2) ||
            targetBBox.intersectsWithLine(line1) ||
            targetBBox.intersectsWithLine(line2)) {
            parallel = line.parallel(width);
            center = parallel.getCenter();
            p1 = parallel.start.clone().move(parallel.end, halfHeight);
            p2 = parallel.end.clone().move(parallel.start, halfHeight);
        }
        if (options.merge) {
            const line = new Line(sourceAnchor, targetAnchor);
            const normal = new Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);
            const intersects1 = sourceBBox.intersectsWithLine(normal);
            const intersects2 = targetBBox.intersectsWithLine(normal);
            const intersects = intersects1
                ? Array.isArray(intersects1)
                    ? intersects1
                    : [intersects1]
                : [];
            if (intersects2) {
                if (Array.isArray(intersects2)) {
                    intersects.push(...intersects2);
                }
                else {
                    intersects.push(intersects2);
                }
            }
            const anchor = line.center.closest(intersects);
            if (anchor) {
                edgeView.sourceAnchor = anchor.clone();
                edgeView.targetAnchor = anchor.clone();
            }
            else {
                edgeView.sourceAnchor = line.center.clone();
                edgeView.targetAnchor = line.center.clone();
            }
        }
        return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);
    }
};

var routers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	er: er,
	loop: loop$1,
	manhattan: manhattan,
	metro: metro,
	normal: normal$1,
	oneSide: oneSide,
	orth: orth
});

var Router;
(function (Router) {
    Router.presets = routers;
    Router.registry = Registry.create({
        type: 'router',
    });
    Router.registry.register(Router.presets, true);
})(Router || (Router = {}));

const normal = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const points = [sourcePoint, ...routePoints, targetPoint];
    const polyline = new Polyline$2(points);
    const path = new Path$2(polyline);
    return options.raw ? path : path.serialize();
};

const loop = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const fix = routePoints.length === 3 ? 0 : 1;
    const p1 = Point.create(routePoints[0 + fix]);
    const p2 = Point.create(routePoints[2 + fix]);
    const center = Point.create(routePoints[1 + fix]);
    if (!Point.equals(sourcePoint, targetPoint)) {
        const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);
        const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center);
        if (angle > 1) {
            p1.rotate(180 - angle, middle);
            p2.rotate(180 - angle, middle);
            center.rotate(180 - angle, middle);
        }
    }
    const pathData = `
     M ${sourcePoint.x} ${sourcePoint.y}
     Q ${p1.x} ${p1.y} ${center.x} ${center.y}
     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}
  `;
    return options.raw ? Path$2.parse(pathData) : pathData;
};

const rounded = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const path = new Path$2();
    path.appendSegment(Path$2.createSegment('M', sourcePoint));
    const f13 = 1 / 3;
    const f23 = 2 / 3;
    const radius = options.radius || 10;
    let prevDistance;
    let nextDistance;
    for (let i = 0, ii = routePoints.length; i < ii; i += 1) {
        const curr = Point.create(routePoints[i]);
        const prev = routePoints[i - 1] || sourcePoint;
        const next = routePoints[i + 1] || targetPoint;
        prevDistance = nextDistance || curr.distance(prev) / 2;
        nextDistance = curr.distance(next) / 2;
        const startMove = -Math.min(radius, prevDistance);
        const endMove = -Math.min(radius, nextDistance);
        const roundedStart = curr.clone().move(prev, startMove).round();
        const roundedEnd = curr.clone().move(next, endMove).round();
        const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);
        const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);
        path.appendSegment(Path$2.createSegment('L', roundedStart));
        path.appendSegment(Path$2.createSegment('C', control1, control2, roundedEnd));
    }
    path.appendSegment(Path$2.createSegment('L', targetPoint));
    return options.raw ? path : path.serialize();
};

const smooth = function (sourcePoint, targetPoint, routePoints, options = {}) {
    let path;
    let direction = options.direction;
    if (routePoints && routePoints.length !== 0) {
        const points = [sourcePoint, ...routePoints, targetPoint];
        const curves = Curve.throughPoints(points);
        path = new Path$2(curves);
    }
    else {
        // If we have no route, use a default cubic bezier curve, cubic bezier
        // requires two control points, the control points have `x` midway
        // between source and target. This produces an S-like curve.
        path = new Path$2();
        path.appendSegment(Path$2.createSegment('M', sourcePoint));
        if (!direction) {
            direction =
                Math.abs(sourcePoint.x - targetPoint.x) >=
                    Math.abs(sourcePoint.y - targetPoint.y)
                    ? 'H'
                    : 'V';
        }
        if (direction === 'H') {
            const controlPointX = (sourcePoint.x + targetPoint.x) / 2;
            path.appendSegment(Path$2.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));
        }
        else {
            const controlPointY = (sourcePoint.y + targetPoint.y) / 2;
            path.appendSegment(Path$2.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));
        }
    }
    return options.raw ? path : path.serialize();
};

/* eslint-disable no-underscore-dangle */
// takes care of math. error for case when jump is too close to end of line
const CLOSE_PROXIMITY_PADDING = 1;
const F13 = 1 / 3;
const F23 = 2 / 3;
function setupUpdating(view) {
    let updateList = view.graph._jumpOverUpdateList;
    // first time setup for this paper
    if (updateList == null) {
        updateList = view.graph._jumpOverUpdateList = [];
        /**
         * Handler for a batch:stop event to force
         * update of all registered links with jump over connector
         */
        view.graph.on('cell:mouseup', () => {
            const list = view.graph._jumpOverUpdateList;
            for (let i = 0; i < list.length; i += 1) {
                list[i].update();
            }
        });
        view.graph.on('model:reseted', () => {
            updateList = view.graph._jumpOverUpdateList = [];
        });
    }
    // add this link to a list so it can be updated when some other link is updated
    if (updateList.indexOf(view) < 0) {
        updateList.push(view);
        // watch for change of connector type or removal of link itself
        // to remove the link from a list of jump over connectors
        const clean = () => updateList.splice(updateList.indexOf(view), 1);
        view.cell.once('change:connector', clean);
        view.cell.once('removed', clean);
    }
}
function createLines(sourcePoint, targetPoint, route = []) {
    const points = [sourcePoint, ...route, targetPoint];
    const lines = [];
    points.forEach((point, idx) => {
        const next = points[idx + 1];
        if (next != null) {
            lines.push(new Line(point, next));
        }
    });
    return lines;
}
function findLineIntersections(line, crossCheckLines) {
    const intersections = [];
    crossCheckLines.forEach((crossCheckLine) => {
        const intersection = line.intersectsWithLine(crossCheckLine);
        if (intersection) {
            intersections.push(intersection);
        }
    });
    return intersections;
}
function getDistence(p1, p2) {
    return new Line(p1, p2).squaredLength();
}
/**
 * Split input line into multiple based on intersection points.
 */
function createJumps(line, intersections, jumpSize) {
    return intersections.reduce((memo, point, idx) => {
        // skipping points that were merged with the previous line
        // to make bigger arc over multiple lines that are close to each other
        if (skippedPoints.includes(point)) {
            return memo;
        }
        // always grab the last line from buffer and modify it
        const lastLine = memo.pop() || line;
        // calculate start and end of jump by moving by a given size of jump
        const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);
        let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize);
        // now try to look at the next intersection point
        const nextPoint = intersections[idx + 1];
        if (nextPoint != null) {
            const distance = jumpEnd.distance(nextPoint);
            if (distance <= jumpSize) {
                // next point is close enough, move the jump end by this
                // difference and mark the next point to be skipped
                jumpEnd = nextPoint.move(lastLine.start, distance);
                skippedPoints.push(nextPoint);
            }
        }
        else {
            // this block is inside of `else` as an optimization so the distance is
            // not calculated when we know there are no other intersection points
            const endDistance = jumpStart.distance(lastLine.end);
            // if the end is too close to possible jump, draw remaining line instead of a jump
            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
                memo.push(lastLine);
                return memo;
            }
        }
        const startDistance = jumpEnd.distance(lastLine.start);
        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
            // if the start of line is too close to jump, draw that line instead of a jump
            memo.push(lastLine);
            return memo;
        }
        // finally create a jump line
        const jumpLine = new Line(jumpStart, jumpEnd);
        // it's just simple line but with a `isJump` property
        jumppedLines.push(jumpLine);
        memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));
        return memo;
    }, []);
}
function buildPath(lines, jumpSize, jumpType, radius) {
    const path = new Path$2();
    let segment;
    // first move to the start of a first line
    segment = Path$2.createSegment('M', lines[0].start);
    path.appendSegment(segment);
    lines.forEach((line, index) => {
        if (jumppedLines.includes(line)) {
            let angle;
            let diff;
            let control1;
            let control2;
            if (jumpType === 'arc') {
                // approximates semicircle with 2 curves
                angle = -90;
                // determine rotation of arc based on difference between points
                diff = line.start.diff(line.end);
                // make sure the arc always points up (or right)
                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);
                if (xAxisRotate) {
                    angle += 180;
                }
                const center = line.getCenter();
                const centerLine = new Line(center, line.end).rotate(angle, center);
                let halfLine;
                // first half
                halfLine = new Line(line.start, center);
                control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);
                control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);
                segment = Path$2.createSegment('C', control1, control2, centerLine.end);
                path.appendSegment(segment);
                // second half
                halfLine = new Line(center, line.end);
                control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);
                control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);
                segment = Path$2.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            }
            else if (jumpType === 'gap') {
                segment = Path$2.createSegment('M', line.end);
                path.appendSegment(segment);
            }
            else if (jumpType === 'cubic') {
                // approximates semicircle with 1 curve
                angle = line.start.theta(line.end);
                const xOffset = jumpSize * 0.6;
                let yOffset = jumpSize * 1.35;
                // determine rotation of arc based on difference between points
                diff = line.start.diff(line.end);
                // make sure the arc always points up (or right)
                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);
                if (xAxisRotate) {
                    yOffset *= -1;
                }
                control1 = new Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);
                control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);
                segment = Path$2.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            }
        }
        else {
            const nextLine = lines[index + 1];
            if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {
                segment = Path$2.createSegment('L', line.end);
                path.appendSegment(segment);
            }
            else {
                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
            }
        }
    });
    return path;
}
function buildRoundedSegment(offset, path, curr, prev, next) {
    const prevDistance = curr.distance(prev) / 2;
    const nextDistance = curr.distance(next) / 2;
    const startMove = -Math.min(offset, prevDistance);
    const endMove = -Math.min(offset, nextDistance);
    const roundedStart = curr.clone().move(prev, startMove).round();
    const roundedEnd = curr.clone().move(next, endMove).round();
    const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);
    const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);
    let segment;
    segment = Path$2.createSegment('L', roundedStart);
    path.appendSegment(segment);
    segment = Path$2.createSegment('C', control1, control2, roundedEnd);
    path.appendSegment(segment);
}
let jumppedLines;
let skippedPoints;
const jumpover = function (sourcePoint, targetPoint, routePoints, options = {}) {
    jumppedLines = [];
    skippedPoints = [];
    setupUpdating(this);
    const jumpSize = options.size || 5;
    const jumpType = options.type || 'arc';
    const radius = options.radius || 0;
    // list of connector types not to jump over.
    const ignoreConnectors = options.ignoreConnectors || ['smooth'];
    const graph = this.graph;
    const model = graph.model;
    const allLinks = model.getEdges();
    // there is just one link, draw it directly
    if (allLinks.length === 1) {
        return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);
    }
    const edge = this.cell;
    const thisIndex = allLinks.indexOf(edge);
    const defaultConnector = graph.options.connecting.connector || {};
    // not all links are meant to be jumped over.
    const edges = allLinks.filter((link, idx) => {
        const connector = link.getConnector() || defaultConnector;
        // avoid jumping over links with connector type listed in `ignored connectors`.
        if (ignoreConnectors.includes(connector.name)) {
            return false;
        }
        // filter out links that are above this one and  have the same connector type
        // otherwise there would double hoops for each intersection
        if (idx > thisIndex) {
            return connector.name !== 'jumpover';
        }
        return true;
    });
    // find views for all links
    const linkViews = edges.map((edge) => {
        return graph.renderer.findViewByCell(edge);
    });
    // create lines for this link
    const thisLines = createLines(sourcePoint, targetPoint, routePoints);
    // create lines for all other links
    const linkLines = linkViews.map((linkView) => {
        if (linkView == null) {
            return [];
        }
        if (linkView === this) {
            return thisLines;
        }
        return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);
    });
    // transform lines for this link by splitting with jump lines at
    // points of intersection with other links
    const jumpingLines = [];
    thisLines.forEach((line) => {
        // iterate all links and grab the intersections with this line
        // these are then sorted by distance so the line can be split more easily
        const intersections = edges
            .reduce((memo, link, i) => {
            // don't intersection with itself
            if (link !== edge) {
                const lineIntersections = findLineIntersections(line, linkLines[i]);
                memo.push(...lineIntersections);
            }
            return memo;
        }, [])
            .sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));
        if (intersections.length > 0) {
            // split the line based on found intersection points
            jumpingLines.push(...createJumps(line, intersections, jumpSize));
        }
        else {
            // without any intersection the line goes uninterrupted
            jumpingLines.push(line);
        }
    });
    const path = buildPath(jumpingLines, jumpSize, jumpType, radius);
    jumppedLines = [];
    skippedPoints = [];
    return options.raw ? path : path.serialize();
};

var connectors = /*#__PURE__*/Object.freeze({
	__proto__: null,
	jumpover: jumpover,
	loop: loop,
	normal: normal,
	rounded: rounded,
	smooth: smooth
});

var Connector;
(function (Connector) {
    Connector.presets = connectors;
    Connector.registry = Registry.create({
        type: 'connector',
    });
    Connector.registry.register(Connector.presets, true);
})(Connector || (Connector = {}));

const create = Registry.create;

var index$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get Attr () { return Attr; },
	get Background () { return Background; },
	get ConnectionPoint () { return ConnectionPoint; },
	get ConnectionStrategy () { return ConnectionStrategy; },
	get Connector () { return Connector; },
	get EdgeAnchor () { return EdgeAnchor; },
	get EdgeTool () { return EdgeTool; },
	get Filter () { return Filter; },
	get Grid () { return Grid; },
	get Highlighter () { return Highlighter; },
	get Marker () { return Marker; },
	get NodeAnchor () { return NodeAnchor; },
	get NodeTool () { return NodeTool; },
	get PortLabelLayout () { return PortLabelLayout; },
	get PortLayout () { return PortLayout; },
	get Registry () { return Registry; },
	get Router () { return Router; },
	create: create
});

class Animation {
    constructor(cell) {
        this.cell = cell;
        this.ids = {};
        this.cache = {};
    }
    get() {
        return Object.keys(this.ids);
    }
    start(path, targetValue, options = {}, delim = '/') {
        const startValue = this.cell.getPropByPath(path);
        const localOptions = defaults$3(options, Animation.defaultOptions);
        const timing = this.getTiming(localOptions.timing);
        const interpolate = this.getInterp(localOptions.interp, startValue, targetValue);
        let startTime = 0;
        const key = Array.isArray(path) ? path.join(delim) : path;
        const paths = Array.isArray(path) ? path : path.split(delim);
        const iterate = () => {
            const now = new Date().getTime();
            if (startTime === 0) {
                startTime = now;
            }
            const elaspe = now - startTime;
            let progress = elaspe / localOptions.duration;
            if (progress < 1) {
                this.ids[key] = requestAnimationFrame$1(iterate);
            }
            else {
                progress = 1;
            }
            const currentValue = interpolate(timing(progress));
            this.cell.setPropByPath(paths, currentValue);
            if (options.progress) {
                options.progress(Object.assign({ progress, currentValue }, this.getArgs(key)));
            }
            if (progress === 1) {
                // TODO: remove in the next major version
                this.cell.notify('transition:end', this.getArgs(key));
                this.cell.notify('transition:complete', this.getArgs(key));
                options.complete && options.complete(this.getArgs(key));
                this.cell.notify('transition:finish', this.getArgs(key));
                options.finish && options.finish(this.getArgs(key));
                this.clean(key);
            }
        };
        setTimeout(() => {
            this.stop(path, undefined, delim);
            this.cache[key] = { startValue, targetValue, options: localOptions };
            this.ids[key] = requestAnimationFrame$1(iterate);
            // TODO: remove in the next major version
            this.cell.notify('transition:begin', this.getArgs(key));
            this.cell.notify('transition:start', this.getArgs(key));
            options.start && options.start(this.getArgs(key));
        }, options.delay);
        return this.stop.bind(this, path, delim, options);
    }
    stop(path, options = {}, delim = '/') {
        const paths = Array.isArray(path) ? path : path.split(delim);
        Object.keys(this.ids)
            .filter((key) => isEqual(paths, key.split(delim).slice(0, paths.length)))
            .forEach((key) => {
            cancelAnimationFrame$1(this.ids[key]);
            const data = this.cache[key];
            const commonArgs = this.getArgs(key);
            const localOptions = Object.assign(Object.assign({}, data.options), options);
            const jumpedToEnd = localOptions.jumpedToEnd;
            if (jumpedToEnd && data.targetValue != null) {
                this.cell.setPropByPath(key, data.targetValue);
                this.cell.notify('transition:end', Object.assign({}, commonArgs));
                this.cell.notify('transition:complete', Object.assign({}, commonArgs));
                localOptions.complete && localOptions.complete(Object.assign({}, commonArgs));
            }
            const stopArgs = Object.assign({ jumpedToEnd }, commonArgs);
            this.cell.notify('transition:stop', Object.assign({}, stopArgs));
            localOptions.stop && localOptions.stop(Object.assign({}, stopArgs));
            this.cell.notify('transition:finish', Object.assign({}, commonArgs));
            localOptions.finish && localOptions.finish(Object.assign({}, commonArgs));
            this.clean(key);
        });
        return this;
    }
    clean(key) {
        delete this.ids[key];
        delete this.cache[key];
    }
    getTiming(timing) {
        return typeof timing === 'string' ? Timing[timing] : timing;
    }
    getInterp(interp, startValue, targetValue) {
        if (interp) {
            return interp(startValue, targetValue);
        }
        if (typeof targetValue === 'number') {
            return Interp.number(startValue, targetValue);
        }
        if (typeof targetValue === 'string') {
            if (targetValue[0] === '#') {
                return Interp.color(startValue, targetValue);
            }
            return Interp.unit(startValue, targetValue);
        }
        return Interp.object(startValue, targetValue);
    }
    getArgs(key) {
        const data = this.cache[key];
        return {
            path: key,
            startValue: data.startValue,
            targetValue: data.targetValue,
            cell: this.cell,
        };
    }
}
(function (Animation) {
    Animation.defaultOptions = {
        delay: 10,
        duration: 100,
        timing: 'linear',
    };
})(Animation || (Animation = {}));

var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Store extends Basecoat {
    constructor(data = {}) {
        super();
        this.pending = false;
        this.changing = false;
        this.data = {};
        this.mutate(cloneDeep(data));
        this.changed = {};
    }
    mutate(data, options = {}) {
        const unset = options.unset === true;
        const silent = options.silent === true;
        const changes = [];
        const changing = this.changing;
        this.changing = true;
        if (!changing) {
            this.previous = cloneDeep(this.data);
            this.changed = {};
        }
        const current = this.data;
        const previous = this.previous;
        const changed = this.changed;
        Object.keys(data).forEach((k) => {
            const key = k;
            const newValue = data[key];
            if (!isEqual(current[key], newValue)) {
                changes.push(key);
            }
            if (!isEqual(previous[key], newValue)) {
                changed[key] = newValue;
            }
            else {
                delete changed[key];
            }
            if (unset) {
                delete current[key];
            }
            else {
                current[key] = newValue;
            }
        });
        if (!silent && changes.length > 0) {
            this.pending = true;
            this.pendingOptions = options;
            changes.forEach((key) => {
                this.emit('change:*', {
                    key,
                    options,
                    store: this,
                    current: current[key],
                    previous: previous[key],
                });
            });
        }
        if (changing) {
            return this;
        }
        if (!silent) {
            // Changes can be recursively nested within `"change"` events.
            while (this.pending) {
                this.pending = false;
                this.emit('changed', {
                    current,
                    previous,
                    store: this,
                    options: this.pendingOptions,
                });
            }
        }
        this.pending = false;
        this.changing = false;
        this.pendingOptions = null;
        return this;
    }
    get(key, defaultValue) {
        if (key == null) {
            return this.data;
        }
        const ret = this.data[key];
        return ret == null ? defaultValue : ret;
    }
    getPrevious(key) {
        if (this.previous) {
            const ret = this.previous[key];
            return ret == null ? undefined : ret;
        }
        return undefined;
    }
    set(key, value, options) {
        if (key != null) {
            if (typeof key === 'object') {
                this.mutate(key, value);
            }
            else {
                this.mutate({ [key]: value }, options);
            }
        }
        return this;
    }
    remove(key, options) {
        const empty = undefined;
        const subset = {};
        let opts;
        if (typeof key === 'string') {
            subset[key] = empty;
            opts = options;
        }
        else if (Array.isArray(key)) {
            key.forEach((k) => (subset[k] = empty));
            opts = options;
        }
        else {
            // eslint-disable-next-line
            for (const key in this.data) {
                subset[key] = empty;
            }
            opts = key;
        }
        this.mutate(subset, Object.assign(Object.assign({}, opts), { unset: true }));
        return this;
    }
    getByPath(path) {
        return getByPath(this.data, path, '/');
    }
    setByPath(path, value, options = {}) {
        const delim = '/';
        const pathArray = Array.isArray(path) ? [...path] : path.split(delim);
        const pathString = Array.isArray(path) ? path.join(delim) : path;
        const property = pathArray[0];
        const pathArrayLength = pathArray.length;
        options.propertyPath = pathString;
        options.propertyValue = value;
        options.propertyPathArray = pathArray;
        if (pathArrayLength === 1) {
            this.set(property, value, options);
        }
        else {
            const update = {};
            let diver = update;
            let nextKey = property;
            // Initialize the nested object. Subobjects are either arrays or objects.
            // An empty array is created if the sub-key is an integer. Otherwise, an
            // empty object is created.
            for (let i = 1; i < pathArrayLength; i += 1) {
                const key = pathArray[i];
                const isArrayIndex = Number.isFinite(Number(key));
                diver = diver[nextKey] = isArrayIndex ? [] : {};
                nextKey = key;
            }
            // Fills update with the `value` on `path`.
            setByPath(update, pathArray, value, delim);
            const data = cloneDeep(this.data);
            // If rewrite mode enabled, we replace value referenced by path with the
            // new one (we don't merge).
            if (options.rewrite) {
                unsetByPath(data, path, delim);
            }
            const merged = merge(data, update);
            this.set(property, merged[property], options);
        }
        return this;
    }
    removeByPath(path, options) {
        const keys = Array.isArray(path) ? path : path.split('/');
        const key = keys[0];
        if (keys.length === 1) {
            this.remove(key, options);
        }
        else {
            const paths = keys.slice(1);
            const prop = cloneDeep(this.get(key));
            if (prop) {
                unsetByPath(prop, paths);
            }
            this.set(key, prop, options);
        }
        return this;
    }
    hasChanged(key) {
        if (key == null) {
            return Object.keys(this.changed).length > 0;
        }
        return key in this.changed;
    }
    /**
     * Returns an object containing all the data that have changed,
     * or `null` if there are no changes. Useful for determining what
     * parts of a view need to be updated.
     */
    getChanges(diff) {
        if (diff == null) {
            return this.hasChanged() ? cloneDeep(this.changed) : null;
        }
        const old = this.changing ? this.previous : this.data;
        const changed = {};
        let hasChanged;
        // eslint-disable-next-line
        for (const key in diff) {
            const val = diff[key];
            if (!isEqual(old[key], val)) {
                changed[key] = val;
                hasChanged = true;
            }
        }
        return hasChanged ? cloneDeep(changed) : null;
    }
    /**
     * Returns a copy of the store's `data` object.
     */
    toJSON() {
        return cloneDeep(this.data);
    }
    clone() {
        const constructor = this.constructor;
        return new constructor(this.data);
    }
    dispose() {
        this.off();
        this.data = {};
        this.previous = {};
        this.changed = {};
        this.pending = false;
        this.changing = false;
        this.pendingOptions = null;
        this.trigger('disposed', { store: this });
    }
}
__decorate$s([
    Basecoat.dispose()
], Store.prototype, "dispose", null);

/* eslint-disable no-underscore-dangle */
var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$j = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Cell extends Basecoat {
    constructor(metadata = {}) {
        super();
        const ctor = this.constructor;
        const defaults = ctor.getDefaults(true);
        const props = merge({}, this.preprocess(defaults), this.preprocess(metadata));
        this.id = props.id || uuid$1();
        this.store = new Store(props);
        this.animation = new Animation(this);
        this.setup();
        this.init();
        this.postprocess(metadata);
    }
    static config(presets) {
        const { markup, propHooks, attrHooks } = presets, others = __rest$j(presets, ["markup", "propHooks", "attrHooks"]);
        if (markup != null) {
            this.markup = markup;
        }
        if (propHooks) {
            this.propHooks = this.propHooks.slice();
            if (Array.isArray(propHooks)) {
                this.propHooks.push(...propHooks);
            }
            else if (typeof propHooks === 'function') {
                this.propHooks.push(propHooks);
            }
            else {
                Object.keys(propHooks).forEach((name) => {
                    const hook = propHooks[name];
                    if (typeof hook === 'function') {
                        this.propHooks.push(hook);
                    }
                });
            }
        }
        if (attrHooks) {
            this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);
        }
        this.defaults = merge({}, this.defaults, others);
    }
    static getMarkup() {
        return this.markup;
    }
    static getDefaults(raw) {
        return (raw ? this.defaults : cloneDeep(this.defaults));
    }
    static getAttrHooks() {
        return this.attrHooks;
    }
    static applyPropHooks(cell, metadata) {
        return this.propHooks.reduce((memo, hook) => {
            return hook ? call(hook, cell, memo) : memo;
        }, metadata);
    }
    // #endregion
    get [Symbol.toStringTag]() {
        return Cell.toStringTag;
    }
    init() { }
    // #region model
    get model() {
        return this._model;
    }
    set model(model) {
        if (this._model !== model) {
            this._model = model;
        }
    }
    // #endregion
    preprocess(metadata, ignoreIdCheck) {
        const id = metadata.id;
        const ctor = this.constructor;
        const props = ctor.applyPropHooks(this, metadata);
        if (id == null && ignoreIdCheck !== true) {
            props.id = uuid$1();
        }
        return props;
    }
    postprocess(metadata) { } // eslint-disable-line
    setup() {
        this.store.on('change:*', (metadata) => {
            const { key, current, previous, options } = metadata;
            this.notify('change:*', {
                key,
                options,
                current,
                previous,
                cell: this,
            });
            this.notify(`change:${key}`, {
                options,
                current,
                previous,
                cell: this,
            });
            const type = key;
            if (type === 'source' || type === 'target') {
                this.notify(`change:terminal`, {
                    type,
                    current,
                    previous,
                    options,
                    cell: this,
                });
            }
        });
        this.store.on('changed', ({ options }) => this.notify('changed', { options, cell: this }));
    }
    notify(name, args) {
        this.trigger(name, args);
        const model = this.model;
        if (model) {
            model.notify(`cell:${name}`, args);
            if (this.isNode()) {
                model.notify(`node:${name}`, Object.assign(Object.assign({}, args), { node: this }));
            }
            else if (this.isEdge()) {
                model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: this }));
            }
        }
        return this;
    }
    isNode() {
        return false;
    }
    isEdge() {
        return false;
    }
    isSameStore(cell) {
        return this.store === cell.store;
    }
    get view() {
        return this.store.get('view');
    }
    get shape() {
        return this.store.get('shape', '');
    }
    getProp(key, defaultValue) {
        if (key == null) {
            return this.store.get();
        }
        return this.store.get(key, defaultValue);
    }
    setProp(key, value, options) {
        if (typeof key === 'string') {
            this.store.set(key, value, options);
        }
        else {
            const props = this.preprocess(key, true);
            this.store.set(merge({}, this.getProp(), props), value);
            this.postprocess(key);
        }
        return this;
    }
    removeProp(key, options) {
        if (typeof key === 'string' || Array.isArray(key)) {
            this.store.removeByPath(key, options);
        }
        else {
            this.store.remove(options);
        }
        return this;
    }
    hasChanged(key) {
        return key == null ? this.store.hasChanged() : this.store.hasChanged(key);
    }
    getPropByPath(path) {
        return this.store.getByPath(path);
    }
    setPropByPath(path, value, options = {}) {
        if (this.model) {
            // update inner reference
            if (path === 'children') {
                this._children = value
                    ? value
                        .map((id) => this.model.getCell(id))
                        .filter((child) => child != null)
                    : null;
            }
            else if (path === 'parent') {
                this._parent = value ? this.model.getCell(value) : null;
            }
        }
        this.store.setByPath(path, value, options);
        return this;
    }
    removePropByPath(path, options = {}) {
        const paths = Array.isArray(path) ? path : path.split('/');
        // Once a property is removed from the `attrs` the CellView will
        // recognize a `dirty` flag and re-render itself in order to remove
        // the attribute from SVGElement.
        if (paths[0] === 'attrs') {
            options.dirty = true;
        }
        this.store.removeByPath(paths, options);
        return this;
    }
    prop(key, value, options) {
        if (key == null) {
            return this.getProp();
        }
        if (typeof key === 'string' || Array.isArray(key)) {
            if (arguments.length === 1) {
                return this.getPropByPath(key);
            }
            if (value == null) {
                return this.removePropByPath(key, options || {});
            }
            return this.setPropByPath(key, value, options || {});
        }
        return this.setProp(key, value || {});
    }
    previous(name) {
        return this.store.getPrevious(name);
    }
    // #endregion
    // #region zIndex
    get zIndex() {
        return this.getZIndex();
    }
    set zIndex(z) {
        if (z == null) {
            this.removeZIndex();
        }
        else {
            this.setZIndex(z);
        }
    }
    getZIndex() {
        return this.store.get('zIndex');
    }
    setZIndex(z, options = {}) {
        this.store.set('zIndex', z, options);
        return this;
    }
    removeZIndex(options = {}) {
        this.store.remove('zIndex', options);
        return this;
    }
    toFront(options = {}) {
        const model = this.model;
        if (model) {
            let z = model.getMaxZIndex();
            let cells;
            if (options.deep) {
                cells = this.getDescendants({ deep: true, breadthFirst: true });
                cells.unshift(this);
            }
            else {
                cells = [this];
            }
            z = z - cells.length + 1;
            const count = model.total();
            let changed = model.indexOf(this) !== count - cells.length;
            if (!changed) {
                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
            }
            if (changed) {
                this.batchUpdate('to-front', () => {
                    z += cells.length;
                    cells.forEach((cell, index) => {
                        cell.setZIndex(z + index, options);
                    });
                });
            }
        }
        return this;
    }
    toBack(options = {}) {
        const model = this.model;
        if (model) {
            let z = model.getMinZIndex();
            let cells;
            if (options.deep) {
                cells = this.getDescendants({ deep: true, breadthFirst: true });
                cells.unshift(this);
            }
            else {
                cells = [this];
            }
            let changed = model.indexOf(this) !== 0;
            if (!changed) {
                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
            }
            if (changed) {
                this.batchUpdate('to-back', () => {
                    z -= cells.length;
                    cells.forEach((cell, index) => {
                        cell.setZIndex(z + index, options);
                    });
                });
            }
        }
        return this;
    }
    // #endregion
    // #region markup
    get markup() {
        return this.getMarkup();
    }
    set markup(value) {
        if (value == null) {
            this.removeMarkup();
        }
        else {
            this.setMarkup(value);
        }
    }
    getMarkup() {
        let markup = this.store.get('markup');
        if (markup == null) {
            const ctor = this.constructor;
            markup = ctor.getMarkup();
        }
        return markup;
    }
    setMarkup(markup, options = {}) {
        this.store.set('markup', markup, options);
        return this;
    }
    removeMarkup(options = {}) {
        this.store.remove('markup', options);
        return this;
    }
    // #endregion
    // #region attrs
    get attrs() {
        return this.getAttrs();
    }
    set attrs(value) {
        if (value == null) {
            this.removeAttrs();
        }
        else {
            this.setAttrs(value);
        }
    }
    getAttrs() {
        const result = this.store.get('attrs');
        return result ? Object.assign({}, result) : {};
    }
    setAttrs(attrs, options = {}) {
        if (attrs == null) {
            this.removeAttrs(options);
        }
        else {
            const set = (attrs) => this.store.set('attrs', attrs, options);
            if (options.overwrite === true) {
                set(attrs);
            }
            else {
                const prev = this.getAttrs();
                if (options.deep === false) {
                    set(Object.assign(Object.assign({}, prev), attrs));
                }
                else {
                    set(merge({}, prev, attrs));
                }
            }
        }
        return this;
    }
    replaceAttrs(attrs, options = {}) {
        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { overwrite: true }));
    }
    updateAttrs(attrs, options = {}) {
        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { deep: false }));
    }
    removeAttrs(options = {}) {
        this.store.remove('attrs', options);
        return this;
    }
    getAttrDefinition(attrName) {
        if (!attrName) {
            return null;
        }
        const ctor = this.constructor;
        const hooks = ctor.getAttrHooks() || {};
        let definition = hooks[attrName] || Attr.registry.get(attrName);
        if (!definition) {
            const name = camelCase(attrName);
            definition = hooks[name] || Attr.registry.get(name);
        }
        return definition || null;
    }
    getAttrByPath(path) {
        if (path == null || path === '') {
            return this.getAttrs();
        }
        return this.getPropByPath(this.prefixAttrPath(path));
    }
    setAttrByPath(path, value, options = {}) {
        this.setPropByPath(this.prefixAttrPath(path), value, options);
        return this;
    }
    removeAttrByPath(path, options = {}) {
        this.removePropByPath(this.prefixAttrPath(path), options);
        return this;
    }
    prefixAttrPath(path) {
        return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;
    }
    attr(path, value, options) {
        if (path == null) {
            return this.getAttrByPath();
        }
        if (typeof path === 'string' || Array.isArray(path)) {
            if (arguments.length === 1) {
                return this.getAttrByPath(path);
            }
            if (value == null) {
                return this.removeAttrByPath(path, options || {});
            }
            return this.setAttrByPath(path, value, options || {});
        }
        return this.setAttrs(path, (value || {}));
    }
    // #endregion
    // #region visible
    get visible() {
        return this.isVisible();
    }
    set visible(value) {
        this.setVisible(value);
    }
    setVisible(visible, options = {}) {
        this.store.set('visible', visible, options);
        return this;
    }
    isVisible() {
        return this.store.get('visible') !== false;
    }
    show(options = {}) {
        if (!this.isVisible()) {
            this.setVisible(true, options);
        }
        return this;
    }
    hide(options = {}) {
        if (this.isVisible()) {
            this.setVisible(false, options);
        }
        return this;
    }
    toggleVisible(isVisible, options = {}) {
        const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();
        const localOptions = typeof isVisible === 'boolean' ? options : isVisible;
        if (visible) {
            this.show(localOptions);
        }
        else {
            this.hide(localOptions);
        }
        return this;
    }
    // #endregion
    // #region data
    get data() {
        return this.getData();
    }
    set data(val) {
        this.setData(val);
    }
    getData() {
        return this.store.get('data');
    }
    setData(data, options = {}) {
        if (data == null) {
            this.removeData(options);
        }
        else {
            const set = (data) => this.store.set('data', data, options);
            if (options.overwrite === true) {
                set(data);
            }
            else {
                const prev = this.getData();
                if (options.deep === false) {
                    set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);
                }
                else {
                    set(merge({}, prev, data));
                }
            }
        }
        return this;
    }
    replaceData(data, options = {}) {
        return this.setData(data, Object.assign(Object.assign({}, options), { overwrite: true }));
    }
    updateData(data, options = {}) {
        return this.setData(data, Object.assign(Object.assign({}, options), { deep: false }));
    }
    removeData(options = {}) {
        this.store.remove('data', options);
        return this;
    }
    // #endregion
    // #region parent children
    get parent() {
        return this.getParent();
    }
    get children() {
        return this.getChildren();
    }
    getParentId() {
        return this.store.get('parent');
    }
    getParent() {
        const parentId = this.getParentId();
        if (parentId && this.model) {
            const parent = this.model.getCell(parentId);
            this._parent = parent;
            return parent;
        }
        return null;
    }
    getChildren() {
        const childrenIds = this.store.get('children');
        if (childrenIds && childrenIds.length && this.model) {
            const children = childrenIds
                .map((id) => { var _a; return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id); })
                .filter((cell) => cell != null);
            this._children = children;
            return [...children];
        }
        return null;
    }
    hasParent() {
        return this.parent != null;
    }
    isParentOf(child) {
        return child != null && child.getParent() === this;
    }
    isChildOf(parent) {
        return parent != null && this.getParent() === parent;
    }
    eachChild(iterator, context) {
        if (this.children) {
            this.children.forEach(iterator, context);
        }
        return this;
    }
    filterChild(filter, context) {
        return this.children ? this.children.filter(filter, context) : [];
    }
    getChildCount() {
        return this.children == null ? 0 : this.children.length;
    }
    getChildIndex(child) {
        return this.children == null ? -1 : this.children.indexOf(child);
    }
    getChildAt(index) {
        return this.children != null && index >= 0 ? this.children[index] : null;
    }
    getAncestors(options = {}) {
        const ancestors = [];
        let parent = this.getParent();
        while (parent) {
            ancestors.push(parent);
            parent = options.deep !== false ? parent.getParent() : null;
        }
        return ancestors;
    }
    getDescendants(options = {}) {
        if (options.deep !== false) {
            // breadth first
            if (options.breadthFirst) {
                const cells = [];
                const queue = this.getChildren() || [];
                while (queue.length > 0) {
                    const parent = queue.shift();
                    const children = parent.getChildren();
                    cells.push(parent);
                    if (children) {
                        queue.push(...children);
                    }
                }
                return cells;
            }
            // depth first
            {
                const cells = this.getChildren() || [];
                cells.forEach((cell) => {
                    cells.push(...cell.getDescendants(options));
                });
                return cells;
            }
        }
        return this.getChildren() || [];
    }
    isDescendantOf(ancestor, options = {}) {
        if (ancestor == null) {
            return false;
        }
        if (options.deep !== false) {
            let current = this.getParent();
            while (current) {
                if (current === ancestor) {
                    return true;
                }
                current = current.getParent();
            }
            return false;
        }
        return this.isChildOf(ancestor);
    }
    isAncestorOf(descendant, options = {}) {
        if (descendant == null) {
            return false;
        }
        return descendant.isDescendantOf(this, options);
    }
    contains(cell) {
        return this.isAncestorOf(cell);
    }
    getCommonAncestor(...cells) {
        return Cell.getCommonAncestor(this, ...cells);
    }
    setParent(parent, options = {}) {
        this._parent = parent;
        if (parent) {
            this.store.set('parent', parent.id, options);
        }
        else {
            this.store.remove('parent', options);
        }
        return this;
    }
    setChildren(children, options = {}) {
        this._children = children;
        if (children != null) {
            this.store.set('children', children.map((child) => child.id), options);
        }
        else {
            this.store.remove('children', options);
        }
        return this;
    }
    unembed(child, options = {}) {
        const children = this.children;
        if (children != null && child != null) {
            const index = this.getChildIndex(child);
            if (index !== -1) {
                children.splice(index, 1);
                child.setParent(null, options);
                this.setChildren(children, options);
            }
        }
        return this;
    }
    embed(child, options = {}) {
        child.addTo(this, options);
        return this;
    }
    addTo(target, options = {}) {
        if (Cell.isCell(target)) {
            target.addChild(this, options);
        }
        else {
            target.addCell(this, options);
        }
        return this;
    }
    insertTo(parent, index, options = {}) {
        parent.insertChild(this, index, options);
        return this;
    }
    addChild(child, options = {}) {
        return this.insertChild(child, undefined, options);
    }
    insertChild(child, index, options = {}) {
        if (child != null && child !== this) {
            const oldParent = child.getParent();
            const changed = this !== oldParent;
            let pos = index;
            if (pos == null) {
                pos = this.getChildCount();
                if (!changed) {
                    pos -= 1;
                }
            }
            // remove from old parent
            if (oldParent) {
                const children = oldParent.getChildren();
                if (children) {
                    const index = children.indexOf(child);
                    if (index >= 0) {
                        child.setParent(null, options);
                        children.splice(index, 1);
                        oldParent.setChildren(children, options);
                    }
                }
            }
            let children = this.children;
            if (children == null) {
                children = [];
                children.push(child);
            }
            else {
                children.splice(pos, 0, child);
            }
            child.setParent(this, options);
            this.setChildren(children, options);
            if (changed && this.model) {
                const incomings = this.model.getIncomingEdges(this);
                const outgoings = this.model.getOutgoingEdges(this);
                if (incomings) {
                    incomings.forEach((edge) => edge.updateParent(options));
                }
                if (outgoings) {
                    outgoings.forEach((edge) => edge.updateParent(options));
                }
            }
            if (this.model) {
                this.model.addCell(child, options);
            }
        }
        return this;
    }
    removeFromParent(options = {}) {
        const parent = this.getParent();
        if (parent != null) {
            const index = parent.getChildIndex(this);
            parent.removeChildAt(index, options);
        }
        return this;
    }
    removeChild(child, options = {}) {
        const index = this.getChildIndex(child);
        return this.removeChildAt(index, options);
    }
    removeChildAt(index, options = {}) {
        const child = this.getChildAt(index);
        const children = this.children;
        if (children != null && child != null) {
            this.unembed(child, options);
            child.remove(options);
        }
        return child;
    }
    remove(options = {}) {
        this.batchUpdate('remove', () => {
            const parent = this.getParent();
            if (parent) {
                parent.removeChild(this, options);
            }
            if (options.deep !== false) {
                this.eachChild((child) => child.remove(options));
            }
            if (this.model) {
                this.model.removeCell(this, options);
            }
        });
        return this;
    }
    transition(path, target, options = {}, delim = '/') {
        return this.animation.start(path, target, options, delim);
    }
    stopTransition(path, options, delim = '/') {
        this.animation.stop(path, options, delim);
        return this;
    }
    getTransitions() {
        return this.animation.get();
    }
    // #endregion
    // #region transform
    // eslint-disable-next-line
    translate(tx, ty, options) {
        return this;
    }
    scale(sx, // eslint-disable-line
    sy, // eslint-disable-line
    origin, // eslint-disable-line
    options) {
        return this;
    }
    addTools(items, obj, options) {
        const toolItems = Array.isArray(items) ? items : [items];
        const name = typeof obj === 'string' ? obj : null;
        const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};
        if (config.reset) {
            return this.setTools({ name, items: toolItems, local: config.local }, config);
        }
        let tools = cloneDeep(this.getTools());
        if (tools == null || name == null || tools.name === name) {
            if (tools == null) {
                tools = {};
            }
            if (!tools.items) {
                tools.items = [];
            }
            tools.name = name;
            tools.items = [...tools.items, ...toolItems];
            return this.setTools(Object.assign({}, tools), config);
        }
    }
    setTools(tools, options = {}) {
        if (tools == null) {
            this.removeTools();
        }
        else {
            this.store.set('tools', Cell.normalizeTools(tools), options);
        }
        return this;
    }
    getTools() {
        return this.store.get('tools');
    }
    removeTools(options = {}) {
        this.store.remove('tools', options);
        return this;
    }
    hasTools(name) {
        const tools = this.getTools();
        if (tools == null) {
            return false;
        }
        if (name == null) {
            return true;
        }
        return tools.name === name;
    }
    hasTool(name) {
        const tools = this.getTools();
        if (tools == null) {
            return false;
        }
        return tools.items.some((item) => typeof item === 'string' ? item === name : item.name === name);
    }
    removeTool(nameOrIndex, options = {}) {
        const tools = cloneDeep(this.getTools());
        if (tools) {
            let updated = false;
            const items = tools.items.slice();
            const remove = (index) => {
                items.splice(index, 1);
                updated = true;
            };
            if (typeof nameOrIndex === 'number') {
                remove(nameOrIndex);
            }
            else {
                for (let i = items.length - 1; i >= 0; i -= 1) {
                    const item = items[i];
                    const exist = typeof item === 'string'
                        ? item === nameOrIndex
                        : item.name === nameOrIndex;
                    if (exist) {
                        remove(i);
                    }
                }
            }
            if (updated) {
                tools.items = items;
                this.setTools(tools, options);
            }
        }
        return this;
    }
    // #endregion
    // #region common
    // eslint-disable-next-line
    getBBox(options) {
        return new Rectangle();
    }
    // eslint-disable-next-line
    getConnectionPoint(edge, type) {
        return new Point();
    }
    toJSON(options = {}) {
        const props = Object.assign({}, this.store.get());
        const toString = Object.prototype.toString;
        const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';
        if (!props.shape) {
            const ctor = this.constructor;
            throw new Error(`Unable to serialize ${cellType} missing "shape" prop, check the ${cellType} "${ctor.name || toString.call(ctor)}"`);
        }
        const ctor = this.constructor;
        const diff = options.diff === true;
        const attrs = props.attrs || {};
        const presets = ctor.getDefaults(true);
        // When `options.diff` is `true`, we should process the custom options,
        // such as `width`, `height` etc. to ensure the comparing work correctly.
        const defaults = diff ? this.preprocess(presets, true) : presets;
        const defaultAttrs = defaults.attrs || {};
        const finalAttrs = {};
        Object.keys(props).forEach((key) => {
            const val = props[key];
            if (val != null &&
                !Array.isArray(val) &&
                typeof val === 'object' &&
                !isPlainObject(val)) {
                throw new Error(`Can only serialize ${cellType} with plain-object props, but got a "${toString.call(val)}" type of key "${key}" on ${cellType} "${this.id}"`);
            }
            if (key !== 'attrs' && key !== 'shape' && diff) {
                const preset = defaults[key];
                if (isEqual(val, preset)) {
                    delete props[key];
                }
            }
        });
        Object.keys(attrs).forEach((key) => {
            const attr = attrs[key];
            const defaultAttr = defaultAttrs[key];
            Object.keys(attr).forEach((name) => {
                const value = attr[name];
                const defaultValue = defaultAttr ? defaultAttr[name] : null;
                if (value != null &&
                    typeof value === 'object' &&
                    !Array.isArray(value)) {
                    Object.keys(value).forEach((subName) => {
                        const subValue = value[subName];
                        if (defaultAttr == null ||
                            defaultValue == null ||
                            !isObject(defaultValue) ||
                            !isEqual(defaultValue[subName], subValue)) {
                            if (finalAttrs[key] == null) {
                                finalAttrs[key] = {};
                            }
                            if (finalAttrs[key][name] == null) {
                                finalAttrs[key][name] = {};
                            }
                            const tmp = finalAttrs[key][name];
                            tmp[subName] = subValue;
                        }
                    });
                }
                else if (defaultAttr == null ||
                    !isEqual(defaultValue, value)) {
                    // `value` is not an object, default attribute with `key` does not
                    // exist or it is different than the attribute value set on the cell.
                    if (finalAttrs[key] == null) {
                        finalAttrs[key] = {};
                    }
                    finalAttrs[key][name] = value;
                }
            });
        });
        const finalProps = Object.assign(Object.assign({}, props), { attrs: isEmpty(finalAttrs) ? undefined : finalAttrs });
        if (finalProps.attrs == null) {
            delete finalProps.attrs;
        }
        const ret = finalProps;
        if (ret.angle === 0) {
            delete ret.angle;
        }
        return cloneDeep(ret);
    }
    clone(options = {}) {
        if (!options.deep) {
            const data = Object.assign({}, this.store.get());
            if (!options.keepId) {
                delete data.id;
            }
            delete data.parent;
            delete data.children;
            const ctor = this.constructor;
            return new ctor(data); // eslint-disable-line new-cap
        }
        // Deep cloning. Clone the cell itself and all its children.
        const map = Cell.deepClone(this);
        return map[this.id];
    }
    findView(graph) {
        return graph.renderer.findViewByCell(this);
    }
    // #endregion
    // #region batch
    startBatch(name, data = {}, model = this.model) {
        this.notify('batch:start', { name, data, cell: this });
        if (model) {
            model.startBatch(name, Object.assign(Object.assign({}, data), { cell: this }));
        }
        return this;
    }
    stopBatch(name, data = {}, model = this.model) {
        if (model) {
            model.stopBatch(name, Object.assign(Object.assign({}, data), { cell: this }));
        }
        this.notify('batch:stop', { name, data, cell: this });
        return this;
    }
    batchUpdate(name, execute, data) {
        // The model is null after cell was removed(remove batch).
        // So we should temp save model to trigger pairing batch event.
        const model = this.model;
        this.startBatch(name, data, model);
        const result = execute();
        this.stopBatch(name, data, model);
        return result;
    }
    // #endregion
    // #region IDisposable
    dispose() {
        this.removeFromParent();
        this.store.dispose();
    }
}
Cell.defaults = {};
Cell.attrHooks = {};
Cell.propHooks = [];
__decorate$r([
    Basecoat.dispose()
], Cell.prototype, "dispose", null);
(function (Cell) {
    function normalizeTools(raw) {
        if (typeof raw === 'string') {
            return { items: [raw] };
        }
        if (Array.isArray(raw)) {
            return { items: raw };
        }
        if (raw.items) {
            return raw;
        }
        return {
            items: [raw],
        };
    }
    Cell.normalizeTools = normalizeTools;
})(Cell || (Cell = {}));
(function (Cell) {
    Cell.toStringTag = `X6.${Cell.name}`;
    function isCell(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Cell) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const cell = instance;
        if ((tag == null || tag === Cell.toStringTag) &&
            typeof cell.isNode === 'function' &&
            typeof cell.isEdge === 'function' &&
            typeof cell.prop === 'function' &&
            typeof cell.attr === 'function') {
            return true;
        }
        return false;
    }
    Cell.isCell = isCell;
})(Cell || (Cell = {}));
(function (Cell) {
    function getCommonAncestor(...cells) {
        const ancestors = cells
            .filter((cell) => cell != null)
            .map((cell) => cell.getAncestors())
            .sort((a, b) => {
            return a.length - b.length;
        });
        const first = ancestors.shift();
        return (first.find((cell) => ancestors.every((item) => item.includes(cell))) ||
            null);
    }
    Cell.getCommonAncestor = getCommonAncestor;
    function getCellsBBox(cells, options = {}) {
        let bbox = null;
        for (let i = 0, ii = cells.length; i < ii; i += 1) {
            const cell = cells[i];
            let rect = cell.getBBox(options);
            if (rect) {
                if (cell.isNode()) {
                    const angle = cell.getAngle();
                    if (angle != null && angle !== 0) {
                        rect = rect.bbox(angle);
                    }
                }
                bbox = bbox == null ? rect : bbox.union(rect);
            }
        }
        return bbox;
    }
    Cell.getCellsBBox = getCellsBBox;
    function deepClone(cell) {
        const cells = [cell, ...cell.getDescendants({ deep: true })];
        return Cell.cloneCells(cells);
    }
    Cell.deepClone = deepClone;
    function cloneCells(cells) {
        const inputs = uniq(cells);
        const cloneMap = inputs.reduce((map, cell) => {
            map[cell.id] = cell.clone();
            return map;
        }, {});
        inputs.forEach((cell) => {
            const clone = cloneMap[cell.id];
            if (clone.isEdge()) {
                const sourceId = clone.getSourceCellId();
                const targetId = clone.getTargetCellId();
                if (sourceId && cloneMap[sourceId]) {
                    // Source is a node and the node is among the clones.
                    // Then update the source of the cloned edge.
                    clone.setSource(Object.assign(Object.assign({}, clone.getSource()), { cell: cloneMap[sourceId].id }));
                }
                if (targetId && cloneMap[targetId]) {
                    // Target is a node and the node is among the clones.
                    // Then update the target of the cloned edge.
                    clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), { cell: cloneMap[targetId].id }));
                }
            }
            // Find the parent of the original cell
            const parent = cell.getParent();
            if (parent && cloneMap[parent.id]) {
                clone.setParent(cloneMap[parent.id]);
            }
            // Find the children of the original cell
            const children = cell.getChildren();
            if (children && children.length) {
                const embeds = children.reduce((memo, child) => {
                    // Embedded cells that are not being cloned can not be carried
                    // over with other embedded cells.
                    if (cloneMap[child.id]) {
                        memo.push(cloneMap[child.id]);
                    }
                    return memo;
                }, []);
                if (embeds.length > 0) {
                    clone.setChildren(embeds);
                }
            }
        });
        return cloneMap;
    }
    Cell.cloneCells = cloneCells;
})(Cell || (Cell = {}));
(function (Cell) {
    Cell.config({
        propHooks(_a) {
            var { tools } = _a, metadata = __rest$j(_a, ["tools"]);
            if (tools) {
                metadata.tools = Cell.normalizeTools(tools);
            }
            return metadata;
        },
    });
})(Cell || (Cell = {}));

var ShareRegistry;
(function (ShareRegistry) {
    let edgeRegistry;
    let nodeRegistry;
    function exist(name, isNode) {
        return isNode
            ? edgeRegistry != null && edgeRegistry.exist(name)
            : nodeRegistry != null && nodeRegistry.exist(name);
    }
    ShareRegistry.exist = exist;
    function setEdgeRegistry(registry) {
        edgeRegistry = registry;
    }
    ShareRegistry.setEdgeRegistry = setEdgeRegistry;
    function setNodeRegistry(registry) {
        nodeRegistry = registry;
    }
    ShareRegistry.setNodeRegistry = setNodeRegistry;
})(ShareRegistry || (ShareRegistry = {}));

class PortManager {
    constructor(data) {
        this.ports = [];
        this.groups = {};
        this.init(cloneDeep(data));
    }
    getPorts() {
        return this.ports;
    }
    getGroup(groupName) {
        return groupName != null ? this.groups[groupName] : null;
    }
    getPortsByGroup(groupName) {
        return this.ports.filter((p) => p.group === groupName || (p.group == null && groupName == null));
    }
    getPortsLayoutByGroup(groupName, elemBBox) {
        const ports = this.getPortsByGroup(groupName);
        const group = groupName ? this.getGroup(groupName) : null;
        const groupPosition = group ? group.position : null;
        const groupPositionName = groupPosition ? groupPosition.name : null;
        let layoutFn;
        if (groupPositionName != null) {
            const fn = PortLayout.registry.get(groupPositionName);
            if (fn == null) {
                return PortLayout.registry.onNotFound(groupPositionName);
            }
            layoutFn = fn;
        }
        else {
            layoutFn = PortLayout.presets.left;
        }
        const portsArgs = ports.map((port) => (port && port.position && port.position.args) || {});
        const groupArgs = (groupPosition && groupPosition.args) || {};
        const layouts = layoutFn(portsArgs, elemBBox, groupArgs);
        return layouts.map((portLayout, index) => {
            const port = ports[index];
            return {
                portLayout,
                portId: port.id,
                portSize: port.size,
                portAttrs: port.attrs,
                labelSize: port.label.size,
                labelLayout: this.getPortLabelLayout(port, Point.create(portLayout.position), elemBBox),
            };
        });
    }
    init(data) {
        const { groups, items } = data;
        if (groups != null) {
            Object.keys(groups).forEach((key) => {
                this.groups[key] = this.parseGroup(groups[key]);
            });
        }
        if (Array.isArray(items)) {
            items.forEach((item) => {
                this.ports.push(this.parsePort(item));
            });
        }
    }
    parseGroup(group) {
        return Object.assign(Object.assign({}, group), { label: this.getLabel(group, true), position: this.getPortPosition(group.position, true) });
    }
    parsePort(port) {
        const result = Object.assign({}, port);
        const group = this.getGroup(port.group) || {};
        result.markup = result.markup || group.markup;
        result.attrs = merge({}, group.attrs, result.attrs);
        result.position = this.createPosition(group, result);
        result.label = merge({}, group.label, this.getLabel(result));
        result.zIndex = this.getZIndex(group, result);
        result.size = Object.assign(Object.assign({}, group.size), result.size);
        return result;
    }
    getZIndex(group, port) {
        if (typeof port.zIndex === 'number') {
            return port.zIndex;
        }
        if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {
            return group.zIndex;
        }
        return 'auto';
    }
    createPosition(group, port) {
        return merge({
            name: 'left',
            args: {},
        }, group.position, { args: port.args });
    }
    getPortPosition(position, setDefault = false) {
        if (position == null) {
            if (setDefault) {
                return { name: 'left', args: {} };
            }
        }
        else {
            if (typeof position === 'string') {
                return {
                    name: position,
                    args: {},
                };
            }
            if (Array.isArray(position)) {
                return {
                    name: 'absolute',
                    args: { x: position[0], y: position[1] },
                };
            }
            if (typeof position === 'object') {
                return position;
            }
        }
        return { args: {} };
    }
    getPortLabelPosition(position, setDefault = false) {
        if (position == null) {
            if (setDefault) {
                return { name: 'left', args: {} };
            }
        }
        else {
            if (typeof position === 'string') {
                return {
                    name: position,
                    args: {},
                };
            }
            if (typeof position === 'object') {
                return position;
            }
        }
        return { args: {} };
    }
    getLabel(item, setDefaults = false) {
        const label = item.label || {};
        label.position = this.getPortLabelPosition(label.position, setDefaults);
        return label;
    }
    getPortLabelLayout(port, portPosition, elemBBox) {
        const name = port.label.position.name || 'left';
        const args = port.label.position.args || {};
        const layoutFn = PortLabelLayout.registry.get(name) || PortLabelLayout.presets.left;
        if (layoutFn) {
            return layoutFn(portPosition, elemBBox, args);
        }
        return null;
    }
}

var __rest$i = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
let Node$1 = class Node extends Cell {
    constructor(metadata = {}) {
        super(metadata);
        this.initPorts();
    }
    get [Symbol.toStringTag]() {
        return Node.toStringTag;
    }
    preprocess(metadata, ignoreIdCheck) {
        const { x, y, width, height } = metadata, others = __rest$i(metadata, ["x", "y", "width", "height"]);
        if (x != null || y != null) {
            const position = others.position;
            others.position = Object.assign(Object.assign({}, position), { x: x != null ? x : position ? position.x : 0, y: y != null ? y : position ? position.y : 0 });
        }
        if (width != null || height != null) {
            const size = others.size;
            others.size = Object.assign(Object.assign({}, size), { width: width != null ? width : size ? size.width : 0, height: height != null ? height : size ? size.height : 0 });
        }
        return super.preprocess(others, ignoreIdCheck);
    }
    isNode() {
        return true;
    }
    size(width, height, options) {
        if (width === undefined) {
            return this.getSize();
        }
        if (typeof width === 'number') {
            return this.setSize(width, height, options);
        }
        return this.setSize(width, height);
    }
    getSize() {
        const size = this.store.get('size');
        return size ? Object.assign({}, size) : { width: 1, height: 1 };
    }
    setSize(width, height, options) {
        if (typeof width === 'object') {
            this.resize(width.width, width.height, height);
        }
        else {
            this.resize(width, height, options);
        }
        return this;
    }
    resize(width, height, options = {}) {
        this.startBatch('resize', options);
        const direction = options.direction;
        if (direction) {
            const currentSize = this.getSize();
            switch (direction) {
                case 'left':
                case 'right':
                    // Don't change height when resizing horizontally.
                    height = currentSize.height; // eslint-disable-line
                    break;
                case 'top':
                case 'bottom':
                    // Don't change width when resizing vertically.
                    width = currentSize.width; // eslint-disable-line
                    break;
                default:
                    break;
            }
            const map = {
                right: 0,
                'top-right': 0,
                top: 1,
                'top-left': 1,
                left: 2,
                'bottom-left': 2,
                bottom: 3,
                'bottom-right': 3,
            };
            let quadrant = map[direction];
            const angle = Angle.normalize(this.getAngle() || 0);
            if (options.absolute) {
                // We are taking the node's rotation into account
                quadrant += Math.floor((angle + 45) / 90);
                quadrant %= 4;
            }
            // This is a rectangle in size of the un-rotated node.
            const bbox = this.getBBox();
            // Pick the corner point on the node, which meant to stay on its
            // place before and after the rotation.
            let fixedPoint;
            if (quadrant === 0) {
                fixedPoint = bbox.getBottomLeft();
            }
            else if (quadrant === 1) {
                fixedPoint = bbox.getCorner();
            }
            else if (quadrant === 2) {
                fixedPoint = bbox.getTopRight();
            }
            else {
                fixedPoint = bbox.getOrigin();
            }
            // Find an image of the previous indent point. This is the position,
            // where is the point actually located on the screen.
            const imageFixedPoint = fixedPoint
                .clone()
                .rotate(-angle, bbox.getCenter());
            // Every point on the element rotates around a circle with the centre of
            // rotation in the middle of the element while the whole element is being
            // rotated. That means that the distance from a point in the corner of
            // the element (supposed its always rect) to the center of the element
            // doesn't change during the rotation and therefore it equals to a
            // distance on un-rotated element.
            // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.
            const radius = Math.sqrt(width * width + height * height) / 2;
            // Now we are looking for an angle between x-axis and the line starting
            // at image of fixed point and ending at the center of the element.
            // We call this angle `alpha`.
            // The image of a fixed point is located in n-th quadrant. For each
            // quadrant passed going anti-clockwise we have to add 90 degrees.
            // Note that the first quadrant has index 0.
            //
            // 3 | 2
            // --c-- Quadrant positions around the element's center `c`
            // 0 | 1
            //
            let alpha = (quadrant * Math.PI) / 2;
            // Add an angle between the beginning of the current quadrant (line
            // parallel with x-axis or y-axis going through the center of the
            // element) and line crossing the indent of the fixed point and the
            // center of the element. This is the angle we need but on the
            // un-rotated element.
            alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height);
            // Lastly we have to deduct the original angle the element was rotated
            // by and that's it.
            alpha -= Angle.toRad(angle);
            // With this angle and distance we can easily calculate the centre of
            // the un-rotated element.
            // Note that fromPolar constructor accepts an angle in radians.
            const center = Point.fromPolar(radius, alpha, imageFixedPoint);
            // The top left corner on the un-rotated element has to be half a width
            // on the left and half a height to the top from the center. This will
            // be the origin of rectangle we were looking for.
            const origin = center.clone().translate(width / -2, height / -2);
            this.store.set('size', { width, height }, options);
            this.setPosition(origin.x, origin.y, options);
        }
        else {
            this.store.set('size', { width, height }, options);
        }
        this.stopBatch('resize', options);
        return this;
    }
    scale(sx, sy, origin, options = {}) {
        const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);
        this.startBatch('scale', options);
        this.setPosition(scaledBBox.x, scaledBBox.y, options);
        this.resize(scaledBBox.width, scaledBBox.height, options);
        this.stopBatch('scale');
        return this;
    }
    position(arg0, arg1, arg2) {
        if (typeof arg0 === 'number') {
            return this.setPosition(arg0, arg1, arg2);
        }
        return this.getPosition(arg0);
    }
    getPosition(options = {}) {
        if (options.relative) {
            const parent = this.getParent();
            if (parent != null && parent.isNode()) {
                const currentPosition = this.getPosition();
                const parentPosition = parent.getPosition();
                return {
                    x: currentPosition.x - parentPosition.x,
                    y: currentPosition.y - parentPosition.y,
                };
            }
        }
        const pos = this.store.get('position');
        return pos ? Object.assign({}, pos) : { x: 0, y: 0 };
    }
    setPosition(arg0, arg1, arg2 = {}) {
        let x;
        let y;
        let options;
        if (typeof arg0 === 'object') {
            x = arg0.x;
            y = arg0.y;
            options = arg1 || {};
        }
        else {
            x = arg0;
            y = arg1;
            options = arg2 || {};
        }
        if (options.relative) {
            const parent = this.getParent();
            if (parent != null && parent.isNode()) {
                const parentPosition = parent.getPosition();
                x += parentPosition.x;
                y += parentPosition.y;
            }
        }
        if (options.deep) {
            const currentPosition = this.getPosition();
            this.translate(x - currentPosition.x, y - currentPosition.y, options);
        }
        else {
            this.store.set('position', { x, y }, options);
        }
        return this;
    }
    translate(tx = 0, ty = 0, options = {}) {
        if (tx === 0 && ty === 0) {
            return this;
        }
        // Pass the initiator of the translation.
        options.translateBy = options.translateBy || this.id;
        const position = this.getPosition();
        if (options.restrict != null && options.translateBy === this.id) {
            // We are restricting the translation for the element itself only. We get
            // the bounding box of the element including all its embeds.
            // All embeds have to be translated the exact same way as the element.
            const bbox = this.getBBox({ deep: true });
            const ra = options.restrict;
            // - - - - - - - - - - - - -> ra.x + ra.width
            // - - - -> position.x      |
            // -> bbox.x
            //                   |
            //         
            //                 |
            //   
            //                  |
            //   <-dx->                     | restricted area right border
            //         <-width->        |    translated element
            //   <- - bbox.width - ->        embedded element
            const dx = position.x - bbox.x;
            const dy = position.y - bbox.y;
            // Find the maximal/minimal coordinates that the element can be translated
            // while complies the restrictions.
            const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
            const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));
            // recalculate the translation taking the restrictions into account.
            tx = x - position.x; // eslint-disable-line
            ty = y - position.y; // eslint-disable-line
        }
        const translatedPosition = {
            x: position.x + tx,
            y: position.y + ty,
        };
        // To find out by how much an element was translated in event
        // 'change:position' handlers.
        options.tx = tx;
        options.ty = ty;
        if (options.transition) {
            if (typeof options.transition !== 'object') {
                options.transition = {};
            }
            this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), { interp: Interp.object }));
            this.eachChild((child) => {
                var _a;
                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
                if (!excluded) {
                    child.translate(tx, ty, options);
                }
            });
        }
        else {
            this.startBatch('translate', options);
            this.store.set('position', translatedPosition, options);
            this.eachChild((child) => {
                var _a;
                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
                if (!excluded) {
                    child.translate(tx, ty, options);
                }
            });
            this.stopBatch('translate', options);
        }
        return this;
    }
    angle(val, options) {
        if (val == null) {
            return this.getAngle();
        }
        return this.rotate(val, options);
    }
    getAngle() {
        return this.store.get('angle', 0);
    }
    rotate(angle, options = {}) {
        const currentAngle = this.getAngle();
        if (options.center) {
            const size = this.getSize();
            const position = this.getPosition();
            const center = this.getBBox().getCenter();
            center.rotate(currentAngle - angle, options.center);
            const dx = center.x - size.width / 2 - position.x;
            const dy = center.y - size.height / 2 - position.y;
            this.startBatch('rotate', { angle, options });
            this.setPosition(position.x + dx, position.y + dy, options);
            this.rotate(angle, Object.assign(Object.assign({}, options), { center: null }));
            this.stopBatch('rotate');
        }
        else {
            this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);
        }
        return this;
    }
    // #endregion
    // #region common
    getBBox(options = {}) {
        if (options.deep) {
            const cells = this.getDescendants({ deep: true, breadthFirst: true });
            cells.push(this);
            return Cell.getCellsBBox(cells);
        }
        return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());
    }
    getConnectionPoint(edge, type) {
        const bbox = this.getBBox();
        const center = bbox.getCenter();
        const terminal = edge.getTerminal(type);
        if (terminal == null) {
            return center;
        }
        const portId = terminal.port;
        if (!portId || !this.hasPort(portId)) {
            return center;
        }
        const port = this.getPort(portId);
        if (!port || !port.group) {
            return center;
        }
        const layouts = this.getPortsPosition(port.group);
        const position = layouts[portId].position;
        const portCenter = Point.create(position).translate(bbox.getOrigin());
        const angle = this.getAngle();
        if (angle) {
            portCenter.rotate(-angle, center);
        }
        return portCenter;
    }
    /**
     * Sets cell's size and position based on the children bbox and given padding.
     */
    fit(options = {}) {
        const children = this.getChildren() || [];
        const embeds = children.filter((cell) => cell.isNode());
        if (embeds.length === 0) {
            return this;
        }
        this.startBatch('fit-embeds', options);
        if (options.deep) {
            embeds.forEach((cell) => cell.fit(options));
        }
        let { x, y, width, height } = Cell.getCellsBBox(embeds);
        const padding = normalizeSides(options.padding);
        x -= padding.left;
        y -= padding.top;
        width += padding.left + padding.right;
        height += padding.bottom + padding.top;
        this.store.set({
            position: { x, y },
            size: { width, height },
        }, options);
        this.stopBatch('fit-embeds');
        return this;
    }
    // #endregion
    // #region ports
    get portContainerMarkup() {
        return this.getPortContainerMarkup();
    }
    set portContainerMarkup(markup) {
        this.setPortContainerMarkup(markup);
    }
    getDefaultPortContainerMarkup() {
        return (this.store.get('defaultPortContainerMarkup') ||
            Markup.getPortContainerMarkup());
    }
    getPortContainerMarkup() {
        return (this.store.get('portContainerMarkup') ||
            this.getDefaultPortContainerMarkup());
    }
    setPortContainerMarkup(markup, options = {}) {
        this.store.set('portContainerMarkup', Markup.clone(markup), options);
        return this;
    }
    get portMarkup() {
        return this.getPortMarkup();
    }
    set portMarkup(markup) {
        this.setPortMarkup(markup);
    }
    getDefaultPortMarkup() {
        return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();
    }
    getPortMarkup() {
        return this.store.get('portMarkup') || this.getDefaultPortMarkup();
    }
    setPortMarkup(markup, options = {}) {
        this.store.set('portMarkup', Markup.clone(markup), options);
        return this;
    }
    get portLabelMarkup() {
        return this.getPortLabelMarkup();
    }
    set portLabelMarkup(markup) {
        this.setPortLabelMarkup(markup);
    }
    getDefaultPortLabelMarkup() {
        return (this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup());
    }
    getPortLabelMarkup() {
        return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();
    }
    setPortLabelMarkup(markup, options = {}) {
        this.store.set('portLabelMarkup', Markup.clone(markup), options);
        return this;
    }
    get ports() {
        const res = this.store.get('ports', { items: [] });
        if (res.items == null) {
            res.items = [];
        }
        return res;
    }
    getPorts() {
        return cloneDeep(this.ports.items);
    }
    getPortsByGroup(groupName) {
        return this.getPorts().filter((port) => port.group === groupName);
    }
    getPort(portId) {
        return cloneDeep(this.ports.items.find((port) => port.id && port.id === portId));
    }
    getPortAt(index) {
        return this.ports.items[index] || null;
    }
    hasPorts() {
        return this.ports.items.length > 0;
    }
    hasPort(portId) {
        return this.getPortIndex(portId) !== -1;
    }
    getPortIndex(port) {
        const portId = typeof port === 'string' ? port : port.id;
        return portId != null
            ? this.ports.items.findIndex((item) => item.id === portId)
            : -1;
    }
    getPortsPosition(groupName) {
        const size = this.getSize();
        const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));
        return layouts.reduce((memo, item) => {
            const layout = item.portLayout;
            memo[item.portId] = {
                position: Object.assign({}, layout.position),
                angle: layout.angle || 0,
            };
            return memo;
        }, {});
    }
    getPortProp(portId, path) {
        return this.getPropByPath(this.prefixPortPath(portId, path));
    }
    setPortProp(portId, arg1, arg2, arg3) {
        if (typeof arg1 === 'string' || Array.isArray(arg1)) {
            const path = this.prefixPortPath(portId, arg1);
            const value = arg2;
            return this.setPropByPath(path, value, arg3);
        }
        const path = this.prefixPortPath(portId);
        const value = arg1;
        return this.setPropByPath(path, value, arg2);
    }
    removePortProp(portId, path, options) {
        if (typeof path === 'string' || Array.isArray(path)) {
            return this.removePropByPath(this.prefixPortPath(portId, path), options);
        }
        return this.removePropByPath(this.prefixPortPath(portId), path);
    }
    portProp(portId, path, value, options) {
        if (path == null) {
            return this.getPortProp(portId);
        }
        if (typeof path === 'string' || Array.isArray(path)) {
            if (arguments.length === 2) {
                return this.getPortProp(portId, path);
            }
            if (value == null) {
                return this.removePortProp(portId, path, options);
            }
            return this.setPortProp(portId, path, value, options);
        }
        return this.setPortProp(portId, path, value);
    }
    prefixPortPath(portId, path) {
        const index = this.getPortIndex(portId);
        if (index === -1) {
            throw new Error(`Unable to find port with id: "${portId}"`);
        }
        if (path == null || path === '') {
            return ['ports', 'items', `${index}`];
        }
        if (Array.isArray(path)) {
            return ['ports', 'items', `${index}`, ...path];
        }
        return `ports/items/${index}/${path}`;
    }
    addPort(port, options) {
        const ports = [...this.ports.items];
        ports.push(port);
        this.setPropByPath('ports/items', ports, options);
        return this;
    }
    addPorts(ports, options) {
        this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);
        return this;
    }
    insertPort(index, port, options) {
        const ports = [...this.ports.items];
        ports.splice(index, 0, port);
        this.setPropByPath('ports/items', ports, options);
        return this;
    }
    removePort(port, options = {}) {
        return this.removePortAt(this.getPortIndex(port), options);
    }
    removePortAt(index, options = {}) {
        if (index >= 0) {
            const ports = [...this.ports.items];
            ports.splice(index, 1);
            options.rewrite = true;
            this.setPropByPath('ports/items', ports, options);
        }
        return this;
    }
    removePorts(portsForRemoval, opt) {
        let options;
        if (Array.isArray(portsForRemoval)) {
            options = opt || {};
            if (portsForRemoval.length) {
                options.rewrite = true;
                const currentPorts = [...this.ports.items];
                const remainingPorts = currentPorts.filter((cp) => !portsForRemoval.some((p) => {
                    const id = typeof p === 'string' ? p : p.id;
                    return cp.id === id;
                }));
                this.setPropByPath('ports/items', remainingPorts, options);
            }
        }
        else {
            options = portsForRemoval || {};
            options.rewrite = true;
            this.setPropByPath('ports/items', [], options);
        }
        return this;
    }
    getParsedPorts() {
        return this.port.getPorts();
    }
    getParsedGroups() {
        return this.port.groups;
    }
    getPortsLayoutByGroup(groupName, bbox) {
        return this.port.getPortsLayoutByGroup(groupName, bbox);
    }
    initPorts() {
        this.updatePortData();
        this.on('change:ports', () => {
            this.processRemovedPort();
            this.updatePortData();
        });
    }
    processRemovedPort() {
        const current = this.ports;
        const currentItemsMap = {};
        current.items.forEach((item) => {
            if (item.id) {
                currentItemsMap[item.id] = true;
            }
        });
        const removed = {};
        const previous = this.store.getPrevious('ports') || {
            items: [],
        };
        previous.items.forEach((item) => {
            if (item.id && !currentItemsMap[item.id]) {
                removed[item.id] = true;
            }
        });
        const model = this.model;
        if (model && !isEmpty(removed)) {
            const incomings = model.getConnectedEdges(this, { incoming: true });
            incomings.forEach((edge) => {
                const portId = edge.getTargetPortId();
                if (portId && removed[portId]) {
                    edge.remove();
                }
            });
            const outgoings = model.getConnectedEdges(this, { outgoing: true });
            outgoings.forEach((edge) => {
                const portId = edge.getSourcePortId();
                if (portId && removed[portId]) {
                    edge.remove();
                }
            });
        }
    }
    validatePorts() {
        const ids = {};
        const errors = [];
        this.ports.items.forEach((p) => {
            if (typeof p !== 'object') {
                errors.push(`Invalid port ${p}.`);
            }
            if (p.id == null) {
                p.id = this.generatePortId();
            }
            if (ids[p.id]) {
                errors.push('Duplicitied port id.');
            }
            ids[p.id] = true;
        });
        return errors;
    }
    generatePortId() {
        return uuid$1();
    }
    updatePortData() {
        const err = this.validatePorts();
        if (err.length > 0) {
            this.store.set('ports', this.store.getPrevious('ports'));
            throw new Error(err.join(' '));
        }
        const prev = this.port ? this.port.getPorts() : null;
        this.port = new PortManager(this.ports);
        const curr = this.port.getPorts();
        const added = prev
            ? curr.filter((item) => {
                if (!prev.find((prevPort) => prevPort.id === item.id)) {
                    return item;
                }
                return null;
            })
            : [...curr];
        const removed = prev
            ? prev.filter((item) => {
                if (!curr.find((curPort) => curPort.id === item.id)) {
                    return item;
                }
                return null;
            })
            : [];
        if (added.length > 0) {
            this.notify('ports:added', { added, cell: this, node: this });
        }
        if (removed.length > 0) {
            this.notify('ports:removed', { removed, cell: this, node: this });
        }
    }
};
Node$1.defaults = {
    angle: 0,
    position: { x: 0, y: 0 },
    size: { width: 1, height: 1 },
};
(function (Node) {
    Node.toStringTag = `X6.${Node.name}`;
    function isNode(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Node) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const node = instance;
        if ((tag == null || tag === Node.toStringTag) &&
            typeof node.isNode === 'function' &&
            typeof node.isEdge === 'function' &&
            typeof node.prop === 'function' &&
            typeof node.attr === 'function' &&
            typeof node.size === 'function' &&
            typeof node.position === 'function') {
            return true;
        }
        return false;
    }
    Node.isNode = isNode;
})(Node$1 || (Node$1 = {}));
(function (Node) {
    Node.config({
        propHooks(_a) {
            var { ports } = _a, metadata = __rest$i(_a, ["ports"]);
            if (ports) {
                metadata.ports = Array.isArray(ports) ? { items: ports } : ports;
            }
            return metadata;
        },
    });
})(Node$1 || (Node$1 = {}));
(function (Node) {
    Node.registry = Registry.create({
        type: 'node',
        process(shape, options) {
            if (ShareRegistry.exist(shape, true)) {
                throw new Error(`Node with name '${shape}' was registered by anthor Edge`);
            }
            if (typeof options === 'function') {
                options.config({ shape });
                return options;
            }
            let parent = Node;
            const { inherit } = options, config = __rest$i(options, ["inherit"]);
            if (inherit) {
                if (typeof inherit === 'string') {
                    const base = this.get(inherit);
                    if (base == null) {
                        this.onNotFound(inherit, 'inherited');
                    }
                    else {
                        parent = base;
                    }
                }
                else {
                    parent = inherit;
                }
            }
            if (config.constructorName == null) {
                config.constructorName = shape;
            }
            const ctor = parent.define.call(parent, config);
            ctor.config({ shape });
            return ctor;
        },
    });
    ShareRegistry.setNodeRegistry(Node.registry);
})(Node$1 || (Node$1 = {}));
(function (Node) {
    let counter = 0;
    function getClassName(name) {
        if (name) {
            return pascalCase(name);
        }
        counter += 1;
        return `CustomNode${counter}`;
    }
    function define(config) {
        const { constructorName, overwrite } = config, others = __rest$i(config, ["constructorName", "overwrite"]);
        const ctor = createClass(getClassName(constructorName || others.shape), this);
        ctor.config(others);
        if (others.shape) {
            Node.registry.register(others.shape, ctor, overwrite);
        }
        return ctor;
    }
    Node.define = define;
    function create(options) {
        const shape = options.shape || 'rect';
        const Ctor = Node.registry.get(shape);
        if (Ctor) {
            return new Ctor(options);
        }
        return Node.registry.onNotFound(shape);
    }
    Node.create = create;
})(Node$1 || (Node$1 = {}));

var __rest$h = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
let Base$1 = class Base extends Node$1 {
    get label() {
        return this.getLabel();
    }
    set label(val) {
        this.setLabel(val);
    }
    getLabel() {
        return this.getAttrByPath('text/text');
    }
    setLabel(label, options) {
        if (label == null) {
            this.removeLabel();
        }
        else {
            this.setAttrByPath('text/text', label, options);
        }
        return this;
    }
    removeLabel() {
        this.removeAttrByPath('text/text');
        return this;
    }
};
(function (Base) {
    Base.bodyAttr = {
        fill: '#ffffff',
        stroke: '#333333',
        strokeWidth: 2,
    };
    Base.labelAttr = {
        fontSize: 14,
        fill: '#000000',
        refX: 0.5,
        refY: 0.5,
        textAnchor: 'middle',
        textVerticalAnchor: 'middle',
        fontFamily: 'Arial, helvetica, sans-serif',
    };
    Base.config({
        attrs: { text: Object.assign({}, Base.labelAttr) },
        propHooks(metadata) {
            const { label } = metadata, others = __rest$h(metadata, ["label"]);
            if (label) {
                setByPath(others, 'attrs/text/text', label);
            }
            return others;
        },
        visible: true,
    });
})(Base$1 || (Base$1 = {}));

var __rest$g = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function getMarkup$1(tagName, noText = false) {
    return `<g class="rotatable"><g class="scalable"><${tagName}/></g>${noText ? '' : '<text/>'}</g>`;
}
function getName(name) {
    return `basic.${name}`;
}
function getImageUrlHook(attrName = 'xlink:href') {
    const hook = (metadata) => {
        const { imageUrl, imageWidth, imageHeight } = metadata, others = __rest$g(metadata, ["imageUrl", "imageWidth", "imageHeight"]);
        if (imageUrl != null || imageWidth != null || imageHeight != null) {
            const apply = () => {
                if (others.attrs) {
                    const image = others.attrs.image;
                    if (imageUrl != null) {
                        image[attrName] = imageUrl;
                    }
                    if (imageWidth != null) {
                        image.width = imageWidth;
                    }
                    if (imageHeight != null) {
                        image.height = imageHeight;
                    }
                    others.attrs.image = image;
                }
            };
            if (others.attrs) {
                if (others.attrs.image == null) {
                    others.attrs.image = {};
                }
                apply();
            }
            else {
                others.attrs = {
                    image: {},
                };
                apply();
            }
        }
        return others;
    };
    return hook;
}
function createShape$1(shape, config, options = {}) {
    const name = getName(shape);
    const defaults = {
        constructorName: name,
        attrs: {
            '.': {
                fill: '#ffffff',
                stroke: 'none',
            },
            [shape]: {
                fill: '#ffffff',
                stroke: '#000000',
            },
        },
    };
    if (!options.ignoreMarkup) {
        defaults.markup = getMarkup$1(shape, options.noText === true);
    }
    const base = options.parent || Base$1;
    return base.define(merge(defaults, config, { shape: name }));
}

const Rect$1 = createShape$1('rect', {
    attrs: {
        rect: {
            width: 100,
            height: 60,
        },
    },
});

const Circle$1 = createShape$1('circle', {
    width: 60,
    height: 60,
    attrs: {
        circle: {
            r: 30,
            cx: 30,
            cy: 30,
        },
    },
});

const Ellipse$1 = createShape$1('ellipse', {
    width: 60,
    height: 40,
    attrs: {
        ellipse: {
            rx: 30,
            ry: 20,
            cx: 30,
            cy: 20,
        },
    },
});

const Polygon$1 = createShape$1('polygon', {
    width: 60,
    height: 40,
    attrs: {
        text: {
            refY: null,
            refDy: 16,
        },
    },
});

const Polyline$1 = createShape$1('polyline', {
    width: 60,
    height: 40,
    attrs: {
        text: {
            refY: null,
            refDy: 16,
        },
    },
});

const Image$2 = createShape$1('image', {
    attrs: {
        text: {
            refY: null,
            refDy: 16,
        },
    },
    propHooks: getImageUrlHook(),
});

var __rest$f = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const Path$1 = createShape$1('path', {
    width: 60,
    height: 60,
    attrs: {
        text: {
            ref: 'path',
            refY: null,
            refDy: 16,
        },
    },
    propHooks(metadata) {
        const { d } = metadata, others = __rest$f(metadata, ["d"]);
        if (d != null) {
            setByPath(others, 'attrs/path/d', d);
        }
        return others;
    },
});

const Rhombus = createShape$1('rhombus', {
    d: 'M 30 0 L 60 30 30 60 0 30 z',
    attrs: {
        text: {
            refY: 0.5,
            refDy: null,
        },
    },
}, {
    parent: Path$1,
    ignoreMarkup: true,
});

const Cylinder$1 = createShape$1('cylinder', {
    width: 40,
    height: 40,
    attrs: {
        path: {
            fill: '#FFFFFF',
            stroke: '#cbd2d7',
            strokeWidth: 3,
            d: [
                'M 0 10 C 10 5, 30 5, 40 10 C 30 15, 10 15, 0 10',
                'L 0 20',
                'C 10 25, 30 25, 40 20',
                'L 40 10',
            ].join(' '),
        },
        text: {
            refY: 0.7,
            refDy: null,
            fill: '#435460',
        },
    },
}, {
    parent: Path$1,
    ignoreMarkup: true,
});

var __rest$e = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
let Edge$1 = class Edge extends Cell {
    constructor(metadata = {}) {
        super(metadata);
    }
    get [Symbol.toStringTag]() {
        return Edge.toStringTag;
    }
    preprocess(metadata, ignoreIdCheck) {
        const { source, sourceCell, sourcePort, sourcePoint, target, targetCell, targetPort, targetPoint } = metadata, others = __rest$e(metadata, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]);
        const data = others;
        const isValidId = (val) => typeof val === 'string' || typeof val === 'number';
        if (source != null) {
            if (Cell.isCell(source)) {
                data.source = { cell: source.id };
            }
            else if (isValidId(source)) {
                data.source = { cell: source };
            }
            else if (Point.isPoint(source)) {
                data.source = source.toJSON();
            }
            else if (Array.isArray(source)) {
                data.source = { x: source[0], y: source[1] };
            }
            else {
                const cell = source.cell;
                if (Cell.isCell(cell)) {
                    data.source = Object.assign(Object.assign({}, source), { cell: cell.id });
                }
                else {
                    data.source = source;
                }
            }
        }
        if (sourceCell != null || sourcePort != null) {
            let terminal = data.source;
            if (sourceCell != null) {
                const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;
                if (terminal) {
                    terminal.cell = id;
                }
                else {
                    terminal = data.source = { cell: id };
                }
            }
            if (sourcePort != null && terminal) {
                terminal.port = sourcePort;
            }
        }
        else if (sourcePoint != null) {
            data.source = Point.create(sourcePoint).toJSON();
        }
        if (target != null) {
            if (Cell.isCell(target)) {
                data.target = { cell: target.id };
            }
            else if (isValidId(target)) {
                data.target = { cell: target };
            }
            else if (Point.isPoint(target)) {
                data.target = target.toJSON();
            }
            else if (Array.isArray(target)) {
                data.target = { x: target[0], y: target[1] };
            }
            else {
                const cell = target.cell;
                if (Cell.isCell(cell)) {
                    data.target = Object.assign(Object.assign({}, target), { cell: cell.id });
                }
                else {
                    data.target = target;
                }
            }
        }
        if (targetCell != null || targetPort != null) {
            let terminal = data.target;
            if (targetCell != null) {
                const id = isValidId(targetCell) ? targetCell : targetCell.id;
                if (terminal) {
                    terminal.cell = id;
                }
                else {
                    terminal = data.target = { cell: id };
                }
            }
            if (targetPort != null && terminal) {
                terminal.port = targetPort;
            }
        }
        else if (targetPoint != null) {
            data.target = Point.create(targetPoint).toJSON();
        }
        return super.preprocess(data, ignoreIdCheck);
    }
    setup() {
        super.setup();
        this.on('change:labels', (args) => this.onLabelsChanged(args));
        this.on('change:vertices', (args) => this.onVertexsChanged(args));
    }
    isEdge() {
        return true;
    }
    // #region terminal
    disconnect(options = {}) {
        this.store.set({
            source: { x: 0, y: 0 },
            target: { x: 0, y: 0 },
        }, options);
        return this;
    }
    get source() {
        return this.getSource();
    }
    set source(data) {
        this.setSource(data);
    }
    getSource() {
        return this.getTerminal('source');
    }
    getSourceCellId() {
        return this.source.cell;
    }
    getSourcePortId() {
        return this.source.port;
    }
    setSource(source, args, options = {}) {
        return this.setTerminal('source', source, args, options);
    }
    get target() {
        return this.getTarget();
    }
    set target(data) {
        this.setTarget(data);
    }
    getTarget() {
        return this.getTerminal('target');
    }
    getTargetCellId() {
        return this.target.cell;
    }
    getTargetPortId() {
        return this.target.port;
    }
    setTarget(target, args, options = {}) {
        return this.setTerminal('target', target, args, options);
    }
    getTerminal(type) {
        return Object.assign({}, this.store.get(type));
    }
    setTerminal(type, terminal, args, options = {}) {
        // `terminal` is a cell
        if (Cell.isCell(terminal)) {
            this.store.set(type, merge({}, args, { cell: terminal.id }), options);
            return this;
        }
        // `terminal` is a point-like object
        const p = terminal;
        if (Point.isPoint(terminal) || (p.x != null && p.y != null)) {
            this.store.set(type, merge({}, args, { x: p.x, y: p.y }), options);
            return this;
        }
        // `terminal` is an object
        this.store.set(type, cloneDeep(terminal), options);
        return this;
    }
    getSourcePoint() {
        return this.getTerminalPoint('source');
    }
    getTargetPoint() {
        return this.getTerminalPoint('target');
    }
    getTerminalPoint(type) {
        const terminal = this[type];
        if (Point.isPointLike(terminal)) {
            return Point.create(terminal);
        }
        const cell = this.getTerminalCell(type);
        if (cell) {
            return cell.getConnectionPoint(this, type);
        }
        return new Point();
    }
    getSourceCell() {
        return this.getTerminalCell('source');
    }
    getTargetCell() {
        return this.getTerminalCell('target');
    }
    getTerminalCell(type) {
        if (this.model) {
            const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();
            if (cellId) {
                return this.model.getCell(cellId);
            }
        }
        return null;
    }
    getSourceNode() {
        return this.getTerminalNode('source');
    }
    getTargetNode() {
        return this.getTerminalNode('target');
    }
    getTerminalNode(type) {
        let cell = this; // eslint-disable-line
        const visited = {};
        while (cell && cell.isEdge()) {
            if (visited[cell.id]) {
                return null;
            }
            visited[cell.id] = true;
            cell = cell.getTerminalCell(type);
        }
        return cell && cell.isNode() ? cell : null;
    }
    // #endregion
    // #region router
    get router() {
        return this.getRouter();
    }
    set router(data) {
        if (data == null) {
            this.removeRouter();
        }
        else {
            this.setRouter(data);
        }
    }
    getRouter() {
        return this.store.get('router');
    }
    setRouter(name, args, options) {
        if (typeof name === 'object') {
            this.store.set('router', name, args);
        }
        else {
            this.store.set('router', { name, args }, options);
        }
        return this;
    }
    removeRouter(options = {}) {
        this.store.remove('router', options);
        return this;
    }
    // #endregion
    // #region connector
    get connector() {
        return this.getConnector();
    }
    set connector(data) {
        if (data == null) {
            this.removeConnector();
        }
        else {
            this.setConnector(data);
        }
    }
    getConnector() {
        return this.store.get('connector');
    }
    setConnector(name, args, options) {
        if (typeof name === 'object') {
            this.store.set('connector', name, args);
        }
        else {
            this.store.set('connector', { name, args }, options);
        }
        return this;
    }
    removeConnector(options = {}) {
        return this.store.remove('connector', options);
    }
    // #endregion
    // #region strategy
    get strategy() {
        return this.getStrategy();
    }
    set strategy(data) {
        if (data == null) {
            this.removeStrategy();
        }
        else {
            this.setStrategy(data);
        }
    }
    getStrategy() {
        return this.store.get('strategy');
    }
    setStrategy(name, args, options) {
        if (typeof name === 'object') {
            this.store.set('strategy', name, args);
        }
        else {
            this.store.set('strategy', { name, args }, options);
        }
        return this;
    }
    removeStrategy(options = {}) {
        return this.store.remove('strategy', options);
    }
    // #endregion
    // #region labels
    getDefaultLabel() {
        const ctor = this.constructor;
        const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};
        return cloneDeep(defaults);
    }
    get labels() {
        return this.getLabels();
    }
    set labels(labels) {
        this.setLabels(labels);
    }
    getLabels() {
        return [...this.store.get('labels', [])].map((item) => this.parseLabel(item));
    }
    setLabels(labels, options = {}) {
        this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);
        return this;
    }
    insertLabel(label, index, options = {}) {
        const labels = this.getLabels();
        const len = labels.length;
        let idx = index != null && Number.isFinite(index) ? index : len;
        if (idx < 0) {
            idx = len + idx + 1;
        }
        labels.splice(idx, 0, this.parseLabel(label));
        return this.setLabels(labels, options);
    }
    appendLabel(label, options = {}) {
        return this.insertLabel(label, -1, options);
    }
    getLabelAt(index) {
        const labels = this.getLabels();
        if (index != null && Number.isFinite(index)) {
            return this.parseLabel(labels[index]);
        }
        return null;
    }
    setLabelAt(index, label, options = {}) {
        if (index != null && Number.isFinite(index)) {
            const labels = this.getLabels();
            labels[index] = this.parseLabel(label);
            this.setLabels(labels, options);
        }
        return this;
    }
    removeLabelAt(index, options = {}) {
        const labels = this.getLabels();
        const idx = index != null && Number.isFinite(index) ? index : -1;
        const removed = labels.splice(idx, 1);
        this.setLabels(labels, options);
        return removed.length ? removed[0] : null;
    }
    parseLabel(label) {
        if (typeof label === 'string') {
            const ctor = this.constructor;
            return ctor.parseStringLabel(label);
        }
        return label;
    }
    onLabelsChanged({ previous, current, }) {
        const added = previous && current
            ? current.filter((label1) => {
                if (!previous.find((label2) => label1 === label2 || isEqual(label1, label2))) {
                    return label1;
                }
                return null;
            })
            : current
                ? [...current]
                : [];
        const removed = previous && current
            ? previous.filter((label1) => {
                if (!current.find((label2) => label1 === label2 || isEqual(label1, label2))) {
                    return label1;
                }
                return null;
            })
            : previous
                ? [...previous]
                : [];
        if (added.length > 0) {
            this.notify('labels:added', { added, cell: this, edge: this });
        }
        if (removed.length > 0) {
            this.notify('labels:removed', { removed, cell: this, edge: this });
        }
    }
    // #endregion
    // #region vertices
    get vertexMarkup() {
        return this.getVertexMarkup();
    }
    set vertexMarkup(markup) {
        this.setVertexMarkup(markup);
    }
    getDefaultVertexMarkup() {
        return this.store.get('defaultVertexMarkup') || Markup.getEdgeVertexMarkup();
    }
    getVertexMarkup() {
        return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();
    }
    setVertexMarkup(markup, options = {}) {
        this.store.set('vertexMarkup', Markup.clone(markup), options);
        return this;
    }
    get vertices() {
        return this.getVertices();
    }
    set vertices(vertices) {
        this.setVertices(vertices);
    }
    getVertices() {
        return [...this.store.get('vertices', [])];
    }
    setVertices(vertices, options = {}) {
        const points = Array.isArray(vertices) ? vertices : [vertices];
        this.store.set('vertices', points.map((p) => Point.toJSON(p)), options);
        return this;
    }
    insertVertex(vertice, index, options = {}) {
        const vertices = this.getVertices();
        const len = vertices.length;
        let idx = index != null && Number.isFinite(index) ? index : len;
        if (idx < 0) {
            idx = len + idx + 1;
        }
        vertices.splice(idx, 0, Point.toJSON(vertice));
        return this.setVertices(vertices, options);
    }
    appendVertex(vertex, options = {}) {
        return this.insertVertex(vertex, -1, options);
    }
    getVertexAt(index) {
        if (index != null && Number.isFinite(index)) {
            const vertices = this.getVertices();
            return vertices[index];
        }
        return null;
    }
    setVertexAt(index, vertice, options = {}) {
        if (index != null && Number.isFinite(index)) {
            const vertices = this.getVertices();
            vertices[index] = vertice;
            this.setVertices(vertices, options);
        }
        return this;
    }
    removeVertexAt(index, options = {}) {
        const vertices = this.getVertices();
        const idx = index != null && Number.isFinite(index) ? index : -1;
        vertices.splice(idx, 1);
        return this.setVertices(vertices, options);
    }
    onVertexsChanged({ previous, current, }) {
        const added = previous && current
            ? current.filter((p1) => {
                if (!previous.find((p2) => Point.equals(p1, p2))) {
                    return p1;
                }
                return null;
            })
            : current
                ? [...current]
                : [];
        const removed = previous && current
            ? previous.filter((p1) => {
                if (!current.find((p2) => Point.equals(p1, p2))) {
                    return p1;
                }
                return null;
            })
            : previous
                ? [...previous]
                : [];
        if (added.length > 0) {
            this.notify('vertexs:added', { added, cell: this, edge: this });
        }
        if (removed.length > 0) {
            this.notify('vertexs:removed', { removed, cell: this, edge: this });
        }
    }
    // #endregion
    // #region markup
    getDefaultMarkup() {
        return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();
    }
    getMarkup() {
        return super.getMarkup() || this.getDefaultMarkup();
    }
    // #endregion
    // #region toolMarkup
    get toolMarkup() {
        return this.getToolMarkup();
    }
    set toolMarkup(markup) {
        this.setToolMarkup(markup);
    }
    getDefaultToolMarkup() {
        return this.store.get('defaultToolMarkup') || Markup.getEdgeToolMarkup();
    }
    getToolMarkup() {
        return this.store.get('toolMarkup') || this.getDefaultToolMarkup();
    }
    setToolMarkup(markup, options = {}) {
        this.store.set('toolMarkup', markup, options);
        return this;
    }
    get doubleToolMarkup() {
        return this.getDoubleToolMarkup();
    }
    set doubleToolMarkup(markup) {
        this.setDoubleToolMarkup(markup);
    }
    getDefaultDoubleToolMarkup() {
        return this.store.get('defaultDoubleToolMarkup');
    }
    getDoubleToolMarkup() {
        return (this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup());
    }
    setDoubleToolMarkup(markup, options = {}) {
        this.store.set('doubleToolMarkup', markup, options);
        return this;
    }
    // #endregion
    // #region arrowheadMarkup
    get arrowheadMarkup() {
        return this.getArrowheadMarkup();
    }
    set arrowheadMarkup(markup) {
        this.setArrowheadMarkup(markup);
    }
    getDefaultArrowheadMarkup() {
        return (this.store.get('defaultArrowheadMarkup') ||
            Markup.getEdgeArrowheadMarkup());
    }
    getArrowheadMarkup() {
        return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();
    }
    setArrowheadMarkup(markup, options = {}) {
        this.store.set('arrowheadMarkup', markup, options);
        return this;
    }
    // #endregion
    // #region transform
    /**
     * Translate the edge vertices (and source and target if they are points)
     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
     */
    translate(tx, ty, options = {}) {
        options.translateBy = options.translateBy || this.id;
        options.tx = tx;
        options.ty = ty;
        return this.applyToPoints((p) => ({
            x: (p.x || 0) + tx,
            y: (p.y || 0) + ty,
        }), options);
    }
    /**
     * Scales the edge's points (vertices) relative to the given origin.
     */
    scale(sx, sy, origin, options = {}) {
        return this.applyToPoints((p) => {
            return Point.create(p).scale(sx, sy, origin).toJSON();
        }, options);
    }
    applyToPoints(worker, options = {}) {
        const attrs = {};
        const source = this.getSource();
        const target = this.getTarget();
        if (Point.isPointLike(source)) {
            attrs.source = worker(source);
        }
        if (Point.isPointLike(target)) {
            attrs.target = worker(target);
        }
        const vertices = this.getVertices();
        if (vertices.length > 0) {
            attrs.vertices = vertices.map(worker);
        }
        this.store.set(attrs, options);
        return this;
    }
    // #endregion
    // #region common
    getBBox() {
        return this.getPolyline().bbox();
    }
    getConnectionPoint() {
        return this.getPolyline().pointAt(0.5);
    }
    getPolyline() {
        const points = [
            this.getSourcePoint(),
            ...this.getVertices().map((vertice) => Point.create(vertice)),
            this.getTargetPoint(),
        ];
        return new Polyline$2(points);
    }
    updateParent(options) {
        let newParent = null;
        const source = this.getSourceCell();
        const target = this.getTargetCell();
        const prevParent = this.getParent();
        if (source && target) {
            if (source === target || source.isDescendantOf(target)) {
                newParent = target;
            }
            else if (target.isDescendantOf(source)) {
                newParent = source;
            }
            else {
                newParent = Cell.getCommonAncestor(source, target);
            }
        }
        // Unembeds the edge if source and target has no common
        // ancestor or common ancestor changed
        if (prevParent && (!newParent || newParent.id !== prevParent.id)) {
            prevParent.unembed(this, options);
        }
        if (newParent) {
            newParent.embed(this, options);
        }
        return newParent;
    }
    hasLoop(options = {}) {
        const source = this.getSource();
        const target = this.getTarget();
        const sourceId = source.cell;
        const targetId = target.cell;
        if (!sourceId || !targetId) {
            return false;
        }
        let loop = sourceId === targetId;
        // Note that there in the deep mode a edge can have a loop,
        // even if it connects only a parent and its embed.
        // A loop "target equals source" is valid in both shallow and deep mode.
        // eslint-disable-next-line
        if (!loop && options.deep && this._model) {
            const sourceCell = this.getSourceCell();
            const targetCell = this.getTargetCell();
            if (sourceCell && targetCell) {
                loop =
                    sourceCell.isAncestorOf(targetCell, options) ||
                        targetCell.isAncestorOf(sourceCell, options);
            }
        }
        return loop;
    }
    getFragmentAncestor() {
        const cells = [this, this.getSourceNode(), this.getTargetNode()].filter((item) => item != null);
        return this.getCommonAncestor(...cells);
    }
    isFragmentDescendantOf(cell) {
        const ancestor = this.getFragmentAncestor();
        return (!!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell)));
    }
};
Edge$1.defaults = {};
(function (Edge) {
    function equalTerminals(a, b) {
        const a1 = a;
        const b1 = b;
        if (a1.cell === b1.cell) {
            return a1.port === b1.port || (a1.port == null && b1.port == null);
        }
        return false;
    }
    Edge.equalTerminals = equalTerminals;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    Edge.defaultLabel = {
        markup: [
            {
                tagName: 'rect',
                selector: 'body',
            },
            {
                tagName: 'text',
                selector: 'label',
            },
        ],
        attrs: {
            text: {
                fill: '#000',
                fontSize: 14,
                textAnchor: 'middle',
                textVerticalAnchor: 'middle',
                pointerEvents: 'none',
            },
            rect: {
                ref: 'label',
                fill: '#fff',
                rx: 3,
                ry: 3,
                refWidth: 1,
                refHeight: 1,
                refX: 0,
                refY: 0,
            },
        },
        position: {
            distance: 0.5,
        },
    };
    function parseStringLabel(text) {
        return {
            attrs: { label: { text } },
        };
    }
    Edge.parseStringLabel = parseStringLabel;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    Edge.toStringTag = `X6.${Edge.name}`;
    function isEdge(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Edge) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const edge = instance;
        if ((tag == null || tag === Edge.toStringTag) &&
            typeof edge.isNode === 'function' &&
            typeof edge.isEdge === 'function' &&
            typeof edge.prop === 'function' &&
            typeof edge.attr === 'function' &&
            typeof edge.disconnect === 'function' &&
            typeof edge.getSource === 'function' &&
            typeof edge.getTarget === 'function') {
            return true;
        }
        return false;
    }
    Edge.isEdge = isEdge;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    Edge.registry = Registry.create({
        type: 'edge',
        process(shape, options) {
            if (ShareRegistry.exist(shape, false)) {
                throw new Error(`Edge with name '${shape}' was registered by anthor Node`);
            }
            if (typeof options === 'function') {
                options.config({ shape });
                return options;
            }
            let parent = Edge;
            // default inherit from 'dege'
            const { inherit = 'edge' } = options, others = __rest$e(options, ["inherit"]);
            if (typeof inherit === 'string') {
                const base = this.get(inherit || 'edge');
                if (base == null && inherit) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            else {
                parent = inherit;
            }
            if (others.constructorName == null) {
                others.constructorName = shape;
            }
            const ctor = parent.define.call(parent, others);
            ctor.config({ shape });
            return ctor;
        },
    });
    ShareRegistry.setEdgeRegistry(Edge.registry);
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    let counter = 0;
    function getClassName(name) {
        if (name) {
            return pascalCase(name);
        }
        counter += 1;
        return `CustomEdge${counter}`;
    }
    function define(config) {
        const { constructorName, overwrite } = config, others = __rest$e(config, ["constructorName", "overwrite"]);
        const ctor = createClass(getClassName(constructorName || others.shape), this);
        ctor.config(others);
        if (others.shape) {
            Edge.registry.register(others.shape, ctor, overwrite);
        }
        return ctor;
    }
    Edge.define = define;
    function create(options) {
        const shape = options.shape || 'edge';
        const Ctor = Edge.registry.get(shape);
        if (Ctor) {
            return new Ctor(options);
        }
        return Edge.registry.onNotFound(shape);
    }
    Edge.create = create;
})(Edge$1 || (Edge$1 = {}));
(function (Edge) {
    const shape = 'basic.edge';
    Edge.config({
        shape,
        propHooks(metadata) {
            const { label, vertices } = metadata, others = __rest$e(metadata, ["label", "vertices"]);
            if (label) {
                if (others.labels == null) {
                    others.labels = [];
                }
                const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;
                others.labels.push(formated);
            }
            if (vertices) {
                if (Array.isArray(vertices)) {
                    others.vertices = vertices.map((item) => Point.create(item).toJSON());
                }
            }
            return others;
        },
    });
    Edge.registry.register(shape, Edge);
})(Edge$1 || (Edge$1 = {}));

var __rest$d = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class EdgeView extends CellView {
    constructor() {
        super(...arguments);
        this.POINT_ROUNDING = 2;
        this.markerCache = {};
        // #endregion
        // #endregion
    }
    get [Symbol.toStringTag]() {
        return EdgeView.toStringTag;
    }
    getContainerClassName() {
        return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');
    }
    get sourceBBox() {
        const sourceView = this.sourceView;
        if (!sourceView) {
            const sourceDef = this.cell.getSource();
            return new Rectangle(sourceDef.x, sourceDef.y);
        }
        const sourceMagnet = this.sourceMagnet;
        if (sourceView.isEdgeElement(sourceMagnet)) {
            return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);
        }
        return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);
    }
    get targetBBox() {
        const targetView = this.targetView;
        if (!targetView) {
            const targetDef = this.cell.getTarget();
            return new Rectangle(targetDef.x, targetDef.y);
        }
        const targetMagnet = this.targetMagnet;
        if (targetView.isEdgeElement(targetMagnet)) {
            return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);
        }
        return targetView.getBBoxOfElement(targetMagnet || targetView.container);
    }
    isEdgeView() {
        return true;
    }
    confirmUpdate(flag, options = {}) {
        let ref = flag;
        if (this.hasAction(ref, 'source')) {
            if (!this.updateTerminalProperties('source')) {
                return ref;
            }
            ref = this.removeAction(ref, 'source');
        }
        if (this.hasAction(ref, 'target')) {
            if (!this.updateTerminalProperties('target')) {
                return ref;
            }
            ref = this.removeAction(ref, 'target');
        }
        const graph = this.graph;
        const sourceView = this.sourceView;
        const targetView = this.targetView;
        if (graph &&
            ((sourceView && !graph.renderer.isViewMounted(sourceView)) ||
                (targetView && !graph.renderer.isViewMounted(targetView)))) {
            // Wait for the sourceView and targetView to be rendered.
            return ref;
        }
        if (this.hasAction(ref, 'render')) {
            this.render();
            ref = this.removeAction(ref, [
                'render',
                'update',
                'vertices',
                'labels',
                'tools',
                'widget',
            ]);
            return ref;
        }
        ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers());
        ref = this.handleAction(ref, 'update', () => this.update(null, options));
        ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));
        ref = this.handleAction(ref, 'tools', () => {
            this.renderTools();
            this.updateToolsPosition();
        });
        ref = this.handleAction(ref, 'widget', () => this.renderExternalTools());
        return ref;
    }
    onLabelsChange(options = {}) {
        // Note: this optimization works in async=false mode only
        if (this.shouldRerenderLabels(options)) {
            this.renderLabels();
        }
        else {
            this.updateLabels();
        }
        this.updateLabelPositions();
    }
    shouldRerenderLabels(options = {}) {
        const previousLabels = this.cell.previous('labels');
        if (previousLabels == null) {
            return true;
        }
        // Here is an optimization for cases when we know, that change does
        // not require re-rendering of all labels.
        if ('propertyPathArray' in options && 'propertyValue' in options) {
            // The label is setting by `prop()` method
            const pathArray = options.propertyPathArray || [];
            const pathLength = pathArray.length;
            if (pathLength > 1) {
                // We are changing a single label here e.g. 'labels/0/position'
                const index = pathArray[1];
                if (previousLabels[index]) {
                    if (pathLength === 2) {
                        // We are changing the entire label. Need to check if the
                        // markup is also being changed.
                        return (typeof options.propertyValue === 'object' &&
                            has(options.propertyValue, 'markup'));
                    }
                    // We are changing a label property but not the markup
                    if (pathArray[2] !== 'markup') {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    render() {
        this.empty();
        this.containers = {};
        this.renderMarkup();
        this.renderLabels();
        this.update();
        this.renderExternalTools();
        return this;
    }
    renderMarkup() {
        const markup = this.cell.markup;
        if (markup) {
            if (typeof markup === 'string') {
                return this.renderStringMarkup(markup);
            }
            return this.renderJSONMarkup(markup);
        }
        throw new TypeError('Invalid edge markup.');
    }
    renderJSONMarkup(markup) {
        const ret = this.parseJSONMarkup(markup, this.container);
        this.selectors = ret.selectors;
        this.container.append(ret.fragment);
    }
    renderStringMarkup(markup) {
        const cache = this.containers;
        const children = Vector.createVectors(markup);
        // Cache children elements for quicker access.
        children.forEach((child) => {
            const className = child.attr('class');
            if (className) {
                cache[camelCase(className)] =
                    child.node;
            }
        });
        this.renderTools();
        this.renderVertexMarkers();
        this.renderArrowheadMarkers();
        append(this.container, children.map((child) => child.node));
    }
    renderLabels() {
        const edge = this.cell;
        const labels = edge.getLabels();
        const count = labels.length;
        let container = this.containers.labels;
        this.labelCache = {};
        this.labelSelectors = {};
        if (count <= 0) {
            if (container && container.parentNode) {
                container.parentNode.removeChild(container);
            }
            return this;
        }
        if (container) {
            this.empty(container);
        }
        else {
            container = createSvgElement('g');
            this.addClass(this.prefixClassName('edge-labels'), container);
            this.containers.labels = container;
        }
        for (let i = 0, ii = labels.length; i < ii; i += 1) {
            const label = labels[i];
            const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));
            let labelNode;
            let selectors;
            if (normalized) {
                labelNode = normalized.node;
                selectors = normalized.selectors;
            }
            else {
                const defaultLabel = edge.getDefaultLabel();
                const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));
                labelNode = normalized.node;
                selectors = normalized.selectors;
            }
            labelNode.setAttribute('data-index', `${i}`);
            container.appendChild(labelNode);
            const rootSelector = this.rootSelector;
            if (selectors[rootSelector]) {
                throw new Error('Ambiguous label root selector.');
            }
            selectors[rootSelector] = labelNode;
            this.labelCache[i] = labelNode;
            this.labelSelectors[i] = selectors;
        }
        if (container.parentNode == null) {
            this.container.appendChild(container);
        }
        this.updateLabels();
        this.customizeLabels();
        return this;
    }
    parseLabelMarkup(markup) {
        if (markup) {
            if (typeof markup === 'string') {
                return this.parseLabelStringMarkup(markup);
            }
            return this.parseJSONMarkup(markup);
        }
        return null;
    }
    parseLabelStringMarkup(labelMarkup) {
        const children = Vector.createVectors(labelMarkup);
        const fragment = document.createDocumentFragment();
        for (let i = 0, n = children.length; i < n; i += 1) {
            const currentChild = children[i].node;
            fragment.appendChild(currentChild);
        }
        return { fragment, selectors: {} };
    }
    normalizeLabelMarkup(markup) {
        if (markup == null) {
            return;
        }
        const fragment = markup.fragment;
        if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {
            throw new Error('Invalid label markup.');
        }
        let vel;
        const childNodes = fragment.childNodes;
        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {
            // default markup fragment is not wrapped in `<g/>`
            // add a `<g/>` container
            vel = Vector.create('g').append(fragment);
        }
        else {
            vel = Vector.create(childNodes[0]);
        }
        vel.addClass(this.prefixClassName('edge-label'));
        return {
            node: vel.node,
            selectors: markup.selectors,
        };
    }
    updateLabels() {
        if (this.containers.labels) {
            const edge = this.cell;
            const labels = edge.labels;
            const canLabelMove = this.can('edgeLabelMovable');
            const defaultLabel = edge.getDefaultLabel();
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const elem = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');
                const label = labels[i];
                const attrs = merge({}, defaultLabel.attrs, label.attrs);
                this.updateAttrs(elem, attrs, {
                    selectors,
                    rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined,
                });
            }
        }
    }
    mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {
        if (labelAttrs === null) {
            return null;
        }
        if (labelAttrs === undefined) {
            if (defaultLabelAttrs === null) {
                return null;
            }
            if (defaultLabelAttrs === undefined) {
                return undefined;
            }
            if (hasCustomMarkup) {
                return defaultLabelAttrs;
            }
            return merge({}, defaultLabelAttrs);
        }
        if (hasCustomMarkup) {
            return merge({}, defaultLabelAttrs, labelAttrs);
        }
    }
    customizeLabels() {
        if (this.containers.labels) {
            const edge = this.cell;
            const labels = edge.labels;
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const label = labels[i];
                const container = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                this.graph.hook.onEdgeLabelRendered({
                    edge,
                    label,
                    container,
                    selectors,
                });
            }
        }
    }
    renderTools() {
        const container = this.containers.tools;
        if (container == null) {
            return this;
        }
        const markup = this.cell.toolMarkup;
        const $container = this.$(container).empty();
        if (Markup.isStringMarkup(markup)) {
            let template$1 = template(markup);
            const tool = Vector.create(template$1());
            $container.append(tool.node);
            this.toolCache = tool.node;
            // If `doubleTools` is enabled, we render copy of the tools on the
            // other side of the edge as well but only if the edge is longer
            // than `longLength`.
            if (this.options.doubleTools) {
                let tool2;
                const doubleToolMarkup = this.cell.doubleToolMarkup;
                if (Markup.isStringMarkup(doubleToolMarkup)) {
                    template$1 = template(doubleToolMarkup);
                    tool2 = Vector.create(template$1());
                }
                else {
                    tool2 = tool.clone();
                }
                $container.append(tool2.node);
                this.tool2Cache = tool2.node;
            }
        }
        return this;
    }
    renderExternalTools() {
        const tools = this.cell.getTools();
        this.addTools(tools);
        return this;
    }
    renderVertexMarkers() {
        const container = this.containers.vertices;
        if (container == null) {
            return this;
        }
        const markup = this.cell.vertexMarkup;
        const $container = this.$(container).empty();
        if (Markup.isStringMarkup(markup)) {
            const template$1 = template(markup);
            this.cell.getVertices().forEach((vertex, index) => {
                $container.append(Vector.create(template$1(Object.assign({ index }, vertex))).node);
            });
        }
        return this;
    }
    renderArrowheadMarkers() {
        const container = this.containers.arrowheads;
        if (container == null) {
            return this;
        }
        const markup = this.cell.arrowheadMarkup;
        const $container = this.$(container).empty();
        if (Markup.isStringMarkup(markup)) {
            const template$1 = template(markup);
            const sourceArrowhead = Vector.create(template$1({ end: 'source' })).node;
            const targetArrowhead = Vector.create(template$1({ end: 'target' })).node;
            this.containers.sourceArrowhead = sourceArrowhead;
            this.containers.targetArrowhead = targetArrowhead;
            $container.append(sourceArrowhead, targetArrowhead);
        }
        return this;
    }
    // #endregion
    // #region updating
    update(partialAttrs, options = {}) {
        this.cleanCache();
        this.updateConnection(options);
        const attrs = this.cell.getAttrs();
        if (attrs != null) {
            this.updateAttrs(this.container, attrs, {
                attrs: partialAttrs === attrs ? null : partialAttrs,
                selectors: this.selectors,
            });
        }
        this.updateConnectionPath();
        this.updateLabelPositions();
        this.updateToolsPosition();
        this.updateArrowheadMarkers();
        this.updateTools(options);
        return this;
    }
    removeRedundantLinearVertices(options = {}) {
        const edge = this.cell;
        const vertices = edge.getVertices();
        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
        const rawCount = routePoints.length;
        // Puts the route points into a polyline and try to simplify.
        const polyline = new Polyline$2(routePoints);
        polyline.simplify({ threshold: 0.01 });
        const simplifiedPoints = polyline.points.map((point) => point.toJSON());
        const simplifiedCount = simplifiedPoints.length;
        // If simplification did not remove any redundant vertices.
        if (rawCount === simplifiedCount) {
            return 0;
        }
        // Sets simplified polyline points as edge vertices.
        // Removes first and last polyline points again (source/target anchors).
        edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);
        return rawCount - simplifiedCount;
    }
    updateConnectionPath() {
        const containers = this.containers;
        if (containers.connection) {
            const pathData = this.getConnectionPathData();
            containers.connection.setAttribute('d', pathData);
        }
        if (containers.connectionWrap) {
            const pathData = this.getConnectionPathData();
            containers.connectionWrap.setAttribute('d', pathData);
        }
        if (containers.sourceMarker && containers.targetMarker) {
            this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);
        }
    }
    getTerminalView(type) {
        switch (type) {
            case 'source':
                return this.sourceView || null;
            case 'target':
                return this.targetView || null;
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalAnchor(type) {
        switch (type) {
            case 'source':
                return Point.create(this.sourceAnchor);
            case 'target':
                return Point.create(this.targetAnchor);
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalConnectionPoint(type) {
        switch (type) {
            case 'source':
                return Point.create(this.sourcePoint);
            case 'target':
                return Point.create(this.targetPoint);
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalMagnet(type, options = {}) {
        switch (type) {
            case 'source': {
                if (options.raw) {
                    return this.sourceMagnet;
                }
                const sourceView = this.sourceView;
                if (!sourceView) {
                    return null;
                }
                return this.sourceMagnet || sourceView.container;
            }
            case 'target': {
                if (options.raw) {
                    return this.targetMagnet;
                }
                const targetView = this.targetView;
                if (!targetView) {
                    return null;
                }
                return this.targetMagnet || targetView.container;
            }
            default: {
                throw new Error(`Unknown terminal type '${type}'`);
            }
        }
    }
    updateConnection(options = {}) {
        const edge = this.cell;
        // The edge is being translated by an ancestor that will shift
        // source, target and vertices by an equal distance.
        if (options.translateBy &&
            edge.isFragmentDescendantOf(options.translateBy)) {
            const tx = options.tx || 0;
            const ty = options.ty || 0;
            this.routePoints = new Polyline$2(this.routePoints).translate(tx, ty).points;
            this.translateConnectionPoints(tx, ty);
            this.path.translate(tx, ty);
        }
        else {
            const vertices = edge.getVertices();
            // 1. Find anchor points
            const anchors = this.findAnchors(vertices);
            this.sourceAnchor = anchors.source;
            this.targetAnchor = anchors.target;
            // 2. Find route points
            this.routePoints = this.findRoutePoints(vertices);
            // 3. Find connection points
            const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
            this.sourcePoint = connectionPoints.source;
            this.targetPoint = connectionPoints.target;
            // 4. Find Marker Connection Point
            const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
            // 5. Make path
            this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);
        }
        this.cleanCache();
    }
    findAnchors(vertices) {
        const edge = this.cell;
        const source = edge.source;
        const target = edge.target;
        const firstVertex = vertices[0];
        const lastVertex = vertices[vertices.length - 1];
        if (target.priority && !source.priority) {
            // Reversed order
            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);
        }
        // Usual order
        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);
    }
    findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {
        let firstAnchor;
        let secondAnchor;
        const edge = this.cell;
        const firstTerminal = edge[firstType];
        const secondTerminal = edge[secondType];
        const firstView = this.getTerminalView(firstType);
        const secondView = this.getTerminalView(secondType);
        const firstMagnet = this.getTerminalMagnet(firstType);
        const secondMagnet = this.getTerminalMagnet(secondType);
        if (firstView) {
            let firstRef;
            if (firstPoint) {
                firstRef = Point.create(firstPoint);
            }
            else if (secondView) {
                firstRef = secondMagnet;
            }
            else {
                firstRef = Point.create(secondTerminal);
            }
            firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);
        }
        else {
            firstAnchor = Point.create(firstTerminal);
        }
        if (secondView) {
            const secondRef = Point.create(secondPoint || firstAnchor);
            secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);
        }
        else {
            secondAnchor = Point.isPointLike(secondTerminal)
                ? Point.create(secondTerminal)
                : new Point();
        }
        return {
            [firstType]: firstAnchor,
            [secondType]: secondAnchor,
        };
    }
    getAnchor(def, cellView, magnet, ref, terminalType) {
        const isEdge = cellView.isEdgeElement(magnet);
        const connecting = this.graph.options.connecting;
        let config = typeof def === 'string' ? { name: def } : def;
        if (!config) {
            const defaults = isEdge
                ? (terminalType === 'source'
                    ? connecting.sourceEdgeAnchor
                    : connecting.targetEdgeAnchor) || connecting.edgeAnchor
                : (terminalType === 'source'
                    ? connecting.sourceAnchor
                    : connecting.targetAnchor) || connecting.anchor;
            config = typeof defaults === 'string' ? { name: defaults } : defaults;
        }
        if (!config) {
            throw new Error(`Anchor should be specified.`);
        }
        let anchor;
        const name = config.name;
        if (isEdge) {
            const fn = EdgeAnchor.registry.get(name);
            if (typeof fn !== 'function') {
                return EdgeAnchor.registry.onNotFound(name);
            }
            anchor = call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
        }
        else {
            const fn = NodeAnchor.registry.get(name);
            if (typeof fn !== 'function') {
                return NodeAnchor.registry.onNotFound(name);
            }
            anchor = call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
        }
        return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();
    }
    findRoutePoints(vertices = []) {
        const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;
        const router = this.cell.getRouter() || defaultRouter;
        let routePoints;
        if (typeof router === 'function') {
            routePoints = call(router, this, vertices, {}, this);
        }
        else {
            const name = typeof router === 'string' ? router : router.name;
            const args = typeof router === 'string' ? {} : router.args || {};
            const fn = name ? Router.registry.get(name) : Router.presets.normal;
            if (typeof fn !== 'function') {
                return Router.registry.onNotFound(name);
            }
            routePoints = call(fn, this, vertices, args, this);
        }
        return routePoints == null
            ? vertices.map((p) => Point.create(p))
            : routePoints.map((p) => Point.create(p));
    }
    findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {
        const edge = this.cell;
        const connecting = this.graph.options.connecting;
        const sourceTerminal = edge.getSource();
        const targetTerminal = edge.getTarget();
        const sourceView = this.sourceView;
        const targetView = this.targetView;
        const firstRoutePoint = routePoints[0];
        const lastRoutePoint = routePoints[routePoints.length - 1];
        // source
        let sourcePoint;
        if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {
            const sourceMagnet = this.sourceMagnet || sourceView.container;
            const sourcePointRef = firstRoutePoint || targetAnchor;
            const sourceLine = new Line(sourcePointRef, sourceAnchor);
            const connectionPointDef = sourceTerminal.connectionPoint ||
                connecting.sourceConnectionPoint ||
                connecting.connectionPoint;
            sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');
        }
        else {
            sourcePoint = sourceAnchor;
        }
        // target
        let targetPoint;
        if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {
            const targetMagnet = this.targetMagnet || targetView.container;
            const targetConnectionPointDef = targetTerminal.connectionPoint ||
                connecting.targetConnectionPoint ||
                connecting.connectionPoint;
            const targetPointRef = lastRoutePoint || sourceAnchor;
            const targetLine = new Line(targetPointRef, targetAnchor);
            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');
        }
        else {
            targetPoint = targetAnchor;
        }
        return {
            source: sourcePoint,
            target: targetPoint,
        };
    }
    getConnectionPoint(def, view, magnet, line, endType) {
        const anchor = line.end;
        if (def == null) {
            return anchor;
        }
        const name = typeof def === 'string' ? def : def.name;
        const args = typeof def === 'string' ? {} : def.args;
        const fn = ConnectionPoint.registry.get(name);
        if (typeof fn !== 'function') {
            return ConnectionPoint.registry.onNotFound(name);
        }
        const connectionPoint = call(fn, this, line, view, magnet, args || {}, endType);
        return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;
    }
    updateMarkerAttr(type) {
        const attrs = this.cell.getAttrs();
        const key = `.${type}-marker`;
        const partial = attrs && attrs[key];
        if (partial) {
            this.updateAttrs(this.container, {}, {
                attrs: { [key]: partial },
                selectors: this.selectors,
            });
        }
    }
    findMarkerPoints(routePoints, sourcePoint, targetPoint) {
        const getLineWidth = (type) => {
            const attrs = this.cell.getAttrs();
            const keys = Object.keys(attrs);
            for (let i = 0, l = keys.length; i < l; i += 1) {
                const attr = attrs[keys[i]];
                if (attr[`${type}Marker`] || attr[`${type}-marker`]) {
                    const strokeWidth = attr.strokeWidth || attr['stroke-width'];
                    if (strokeWidth) {
                        return parseFloat(strokeWidth);
                    }
                    break;
                }
            }
            return null;
        };
        const firstRoutePoint = routePoints[0];
        const lastRoutePoint = routePoints[routePoints.length - 1];
        const sourceMarkerElem = this.containers.sourceMarker;
        const targetMarkerElem = this.containers.targetMarker;
        const cache = this.markerCache;
        let sourceMarkerPoint;
        let targetMarkerPoint;
        // Move the source point by the width of the marker taking into
        // account its scale around x-axis. Note that scale is the only
        // transform that makes sense to be set in `.marker-source`
        // attributes object as all other transforms (translate/rotate)
        // will be replaced by the `translateAndAutoOrient()` function.
        if (sourceMarkerElem) {
            this.updateMarkerAttr('source');
            // support marker connection point registry???
            cache.sourceBBox = cache.sourceBBox || getBBox(sourceMarkerElem);
            if (cache.sourceBBox.width > 0) {
                const scale$1 = scale(sourceMarkerElem);
                sourceMarkerPoint = sourcePoint
                    .clone()
                    .move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale$1.sx * -1);
            }
        }
        else {
            const strokeWidth = getLineWidth('source');
            if (strokeWidth) {
                sourceMarkerPoint = sourcePoint
                    .clone()
                    .move(firstRoutePoint || targetPoint, -strokeWidth);
            }
        }
        if (targetMarkerElem) {
            this.updateMarkerAttr('target');
            cache.targetBBox = cache.targetBBox || getBBox(targetMarkerElem);
            if (cache.targetBBox.width > 0) {
                const scale$1 = scale(targetMarkerElem);
                targetMarkerPoint = targetPoint
                    .clone()
                    .move(lastRoutePoint || sourcePoint, cache.targetBBox.width * scale$1.sx * -1);
            }
        }
        else {
            const strokeWidth = getLineWidth('target');
            if (strokeWidth) {
                targetMarkerPoint = targetPoint
                    .clone()
                    .move(lastRoutePoint || sourcePoint, -strokeWidth);
            }
        }
        // If there was no markup for the marker, use the connection point.
        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();
        cache.targetPoint = targetMarkerPoint || targetPoint.clone();
        return {
            source: sourceMarkerPoint,
            target: targetMarkerPoint,
        };
    }
    findPath(routePoints, sourcePoint, targetPoint) {
        const def = this.cell.getConnector() || this.graph.options.connecting.connector;
        let name;
        let args;
        let fn;
        if (typeof def === 'string') {
            name = def;
        }
        else {
            name = def.name;
            args = def.args;
        }
        if (name) {
            const method = Connector.registry.get(name);
            if (typeof method !== 'function') {
                return Connector.registry.onNotFound(name);
            }
            fn = method;
        }
        else {
            fn = Connector.presets.normal;
        }
        const path = call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), { raw: true }), this);
        return typeof path === 'string' ? Path$2.parse(path) : path;
    }
    translateConnectionPoints(tx, ty) {
        const cache = this.markerCache;
        if (cache.sourcePoint) {
            cache.sourcePoint.translate(tx, ty);
        }
        if (cache.targetPoint) {
            cache.targetPoint.translate(tx, ty);
        }
        this.sourcePoint.translate(tx, ty);
        this.targetPoint.translate(tx, ty);
        this.sourceAnchor.translate(tx, ty);
        this.targetAnchor.translate(tx, ty);
    }
    updateLabelPositions() {
        if (this.containers.labels == null) {
            return this;
        }
        const path = this.path;
        if (!path) {
            return this;
        }
        const edge = this.cell;
        const labels = edge.getLabels();
        if (labels.length === 0) {
            return this;
        }
        const defaultLabel = edge.getDefaultLabel();
        const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);
        for (let i = 0, ii = labels.length; i < ii; i += 1) {
            const label = labels[i];
            const labelNode = this.labelCache[i];
            if (!labelNode) {
                continue;
            }
            const labelPosition = this.normalizeLabelPosition(label.position);
            const pos = merge({}, defaultPosition, labelPosition);
            const matrix = this.getLabelTransformationMatrix(pos);
            labelNode.setAttribute('transform', matrixToTransformString(matrix));
        }
        return this;
    }
    updateToolsPosition() {
        if (this.containers.tools == null) {
            return this;
        }
        // Move the tools a bit to the target position but don't cover the
        // `sourceArrowhead` marker. Note that the offset is hardcoded here.
        // The offset should be always more than the
        // `this.$('.marker-arrowhead[end="source"]')[0].bbox().width` but looking
        // this up all the time would be slow.
        let scale = '';
        let offset = this.options.toolsOffset;
        const connectionLength = this.getConnectionLength();
        // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).
        // In that case we won't update tools position at all.
        if (connectionLength != null) {
            // If the edge is too short, make the tools half the
            // size and the offset twice as low.
            if (connectionLength < this.options.shortLength) {
                scale = 'scale(.5)';
                offset /= 2;
            }
            let pos = this.getPointAtLength(offset);
            if (pos != null) {
                attr$1(this.toolCache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);
            }
            if (this.options.doubleTools &&
                connectionLength >= this.options.longLength) {
                const doubleToolsOffset = this.options.doubleToolsOffset || offset;
                pos = this.getPointAtLength(connectionLength - doubleToolsOffset);
                if (pos != null) {
                    attr$1(this.tool2Cache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);
                }
                attr$1(this.tool2Cache, 'visibility', 'visible');
            }
            else if (this.options.doubleTools) {
                attr$1(this.tool2Cache, 'visibility', 'hidden');
            }
        }
        return this;
    }
    updateArrowheadMarkers() {
        const container = this.containers.arrowheads;
        if (container == null) {
            return this;
        }
        if (container.style.display === 'none') {
            return this;
        }
        const sourceArrowhead = this.containers.sourceArrowhead;
        const targetArrowhead = this.containers.targetArrowhead;
        if (sourceArrowhead && targetArrowhead) {
            const len = this.getConnectionLength() || 0;
            const sx = len < this.options.shortLength ? 0.5 : 1;
            scale(sourceArrowhead, sx);
            scale(targetArrowhead, sx);
            this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);
        }
        return this;
    }
    updateTerminalProperties(type) {
        const edge = this.cell;
        const graph = this.graph;
        const terminal = edge[type];
        const nodeId = terminal && terminal.cell;
        const viewKey = `${type}View`;
        // terminal is a point
        if (!nodeId) {
            this[viewKey] = null;
            this.updateTerminalMagnet(type);
            return true;
        }
        const terminalCell = graph.getCellById(nodeId);
        if (!terminalCell) {
            throw new Error(`Edge's ${type} node with id "${nodeId}" not exists`);
        }
        const endView = terminalCell.findView(graph);
        if (!endView) {
            return false;
        }
        this[viewKey] = endView;
        this.updateTerminalMagnet(type);
        return true;
    }
    updateTerminalMagnet(type) {
        const propName = `${type}Magnet`;
        const terminalView = this.getTerminalView(type);
        if (terminalView) {
            let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);
            if (magnet === terminalView.container) {
                magnet = null;
            }
            this[propName] = magnet;
        }
        else {
            this[propName] = null;
        }
    }
    translateAndAutoOrientArrows(sourceArrow, targetArrow) {
        const route = this.routePoints;
        if (sourceArrow) {
            translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);
        }
        if (targetArrow) {
            translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);
        }
    }
    getLabelPositionAngle(idx) {
        const label = this.cell.getLabelAt(idx);
        if (label && label.position && typeof label.position === 'object') {
            return label.position.angle || 0;
        }
        return 0;
    }
    getLabelPositionArgs(idx) {
        const label = this.cell.getLabelAt(idx);
        if (label && label.position && typeof label.position === 'object') {
            return label.position.options;
        }
    }
    getDefaultLabelPositionArgs() {
        const defaultLabel = this.cell.getDefaultLabel();
        if (defaultLabel &&
            defaultLabel.position &&
            typeof defaultLabel.position === 'object') {
            return defaultLabel.position.options;
        }
    }
    // merge default label position args into label position args
    // keep `undefined` or `null` because `{}` means something else
    mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {
        if (labelPositionArgs === null) {
            return null;
        }
        if (labelPositionArgs === undefined) {
            if (defaultLabelPositionArgs === null) {
                return null;
            }
            return defaultLabelPositionArgs;
        }
        return merge({}, defaultLabelPositionArgs, labelPositionArgs);
    }
    addLabel(p1, p2, p3, options) {
        let localX;
        let localY;
        let localAngle = 0;
        let localOptions;
        if (typeof p1 !== 'number') {
            localX = p1.x;
            localY = p1.y;
            if (typeof p2 === 'number') {
                localAngle = p2;
                localOptions = p3;
            }
            else {
                localOptions = p2;
            }
        }
        else {
            localX = p1;
            localY = p2;
            if (typeof p3 === 'number') {
                localAngle = p3;
                localOptions = options;
            }
            else {
                localOptions = p3;
            }
        }
        // merge label position arguments
        const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
        const labelPositionArgs = localOptions;
        const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
        // append label to labels array
        const label = {
            position: this.getLabelPosition(localX, localY, localAngle, positionArgs),
        };
        const index = -1;
        this.cell.insertLabel(label, index, localOptions);
        return index;
    }
    addVertex(x, y, options) {
        const isPoint = typeof x !== 'number';
        const localX = isPoint ? x.x : x;
        const localY = isPoint ? x.y : y;
        const localOptions = isPoint ? y : options;
        const vertex = { x: localX, y: localY };
        const index = this.getVertexIndex(localX, localY);
        this.cell.insertVertex(vertex, index, localOptions);
        return index;
    }
    sendToken(token, options, callback) {
        let duration;
        let reversed;
        let selector;
        let rorate;
        let timing = 'linear';
        if (typeof options === 'object') {
            duration = options.duration;
            reversed = options.reversed === true;
            selector = options.selector;
            if (options.rotate === false) {
                rorate = '';
            }
            else if (options.rotate === true) {
                rorate = 'auto';
            }
            else if (options.rotate != null) {
                rorate = `${options.rotate}`;
            }
            if (options.timing) {
                timing = options.timing;
            }
        }
        else {
            duration = options;
            reversed = false;
            selector = null;
        }
        duration = duration || 1000;
        const attrs = {
            dur: `${duration}ms`,
            repeatCount: '1',
            calcMode: timing,
            fill: 'freeze',
        };
        if (rorate) {
            attrs.rotate = rorate;
        }
        if (reversed) {
            attrs.keyPoints = '1;0';
            attrs.keyTimes = '0;1';
        }
        if (typeof options === 'object') {
            const { duration, reversed, selector, rotate, timing } = options, others = __rest$d(options, ["duration", "reversed", "selector", "rotate", "timing"]);
            Object.keys(others).forEach((key) => {
                attrs[key] = others[key];
            });
        }
        let path;
        if (typeof selector === 'string') {
            path = this.findOne(selector, this.container, this.selectors);
        }
        else {
            // Select connection path automatically.
            path = this.containers.connection
                ? this.containers.connection
                : this.container.querySelector('path');
        }
        if (!(path instanceof SVGPathElement)) {
            throw new Error('Token animation requires a valid connection path.');
        }
        const target = typeof token === 'string' ? this.findOne(token) : token;
        if (target == null) {
            throw new Error('Token animation requires a valid token element.');
        }
        const parent = target.parentNode;
        const revert = () => {
            if (!parent) {
                remove(target);
            }
        };
        const vToken = Vector.create(target);
        if (!parent) {
            vToken.appendTo(this.graph.view.stage);
        }
        const onComplete = attrs.complete;
        attrs.complete = (e) => {
            revert();
            if (callback) {
                callback();
            }
            if (onComplete) {
                onComplete(e);
            }
        };
        const stop = vToken.animateAlongPath(attrs, path);
        return () => {
            revert();
            stop();
        };
    }
    // #endregion
    getConnection() {
        return this.path != null ? this.path.clone() : null;
    }
    getConnectionPathData() {
        if (this.path == null) {
            return '';
        }
        const cache = this.cache.pathCache;
        if (!has(cache, 'data')) {
            cache.data = this.path.serialize();
        }
        return cache.data || '';
    }
    getConnectionSubdivisions() {
        if (this.path == null) {
            return null;
        }
        const cache = this.cache.pathCache;
        if (!has(cache, 'segmentSubdivisions')) {
            cache.segmentSubdivisions = this.path.getSegmentSubdivisions();
        }
        return cache.segmentSubdivisions;
    }
    getConnectionLength() {
        if (this.path == null) {
            return 0;
        }
        const cache = this.cache.pathCache;
        if (!has(cache, 'length')) {
            cache.length = this.path.length({
                segmentSubdivisions: this.getConnectionSubdivisions(),
            });
        }
        return cache.length;
    }
    getPointAtLength(length) {
        if (this.path == null) {
            return null;
        }
        return this.path.pointAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getPointAtRatio(ratio) {
        if (this.path == null) {
            return null;
        }
        if (isPercentage(ratio)) {
            // eslint-disable-next-line
            ratio = parseFloat(ratio) / 100;
        }
        return this.path.pointAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getTangentAtLength(length) {
        if (this.path == null) {
            return null;
        }
        return this.path.tangentAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getTangentAtRatio(ratio) {
        if (this.path == null) {
            return null;
        }
        return this.path.tangentAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPoint(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPoint(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPointLength(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPointLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPointRatio(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPointNormalizedLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getLabelPosition(x, y, p3, p4) {
        const pos = { distance: 0 };
        // normalize data from the two possible signatures
        let angle = 0;
        let options;
        if (typeof p3 === 'number') {
            angle = p3;
            options = p4;
        }
        else {
            options = p3;
        }
        if (options != null) {
            pos.options = options;
        }
        // identify distance/offset settings
        const isOffsetAbsolute = options && options.absoluteOffset;
        const isDistanceRelative = !(options && options.absoluteDistance);
        const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;
        // find closest point t
        const path = this.path;
        const pathOptions = {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        };
        const labelPoint = new Point(x, y);
        const t = path.closestPointT(labelPoint, pathOptions);
        // distance
        const totalLength = this.getConnectionLength() || 0;
        let labelDistance = path.lengthAtT(t, pathOptions);
        if (isDistanceRelative) {
            labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;
        }
        if (isDistanceAbsoluteReverse) {
            // fix for end point (-0 => 1)
            labelDistance = -1 * (totalLength - labelDistance) || 1;
        }
        pos.distance = labelDistance;
        // offset
        // use absolute offset if:
        // - options.absoluteOffset is true,
        // - options.absoluteOffset is not true but there is no tangent
        let tangent;
        if (!isOffsetAbsolute)
            tangent = path.tangentAtT(t);
        let labelOffset;
        if (tangent) {
            labelOffset = tangent.pointOffset(labelPoint);
        }
        else {
            const closestPoint = path.pointAtT(t);
            const labelOffsetDiff = labelPoint.diff(closestPoint);
            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };
        }
        pos.offset = labelOffset;
        pos.angle = angle;
        return pos;
    }
    normalizeLabelPosition(pos) {
        if (typeof pos === 'number') {
            return { distance: pos };
        }
        return pos;
    }
    getLabelTransformationMatrix(labelPosition) {
        const pos = this.normalizeLabelPosition(labelPosition);
        const options = pos.options || {};
        const labelAngle = pos.angle || 0;
        const labelDistance = pos.distance;
        const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
        let labelOffset = 0;
        const offsetCoord = { x: 0, y: 0 };
        const offset = pos.offset;
        if (offset) {
            if (typeof offset === 'number') {
                labelOffset = offset;
            }
            else {
                if (offset.x != null) {
                    offsetCoord.x = offset.x;
                }
                if (offset.y != null) {
                    offsetCoord.y = offset.y;
                }
            }
        }
        const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;
        const isKeepGradient = options.keepGradient;
        const isEnsureLegibility = options.ensureLegibility;
        const path = this.path;
        const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };
        const distance = isDistanceRelative
            ? labelDistance * this.getConnectionLength()
            : labelDistance;
        const tangent = path.tangentAtLength(distance, pathOpt);
        let translation;
        let angle = labelAngle;
        if (tangent) {
            if (isOffsetAbsolute) {
                translation = tangent.start;
                translation.translate(offsetCoord);
            }
            else {
                const normal = tangent.clone();
                normal.rotate(-90, tangent.start);
                normal.setLength(labelOffset);
                translation = normal.end;
            }
            if (isKeepGradient) {
                angle = tangent.angle() + labelAngle;
                if (isEnsureLegibility) {
                    angle = Angle.normalize(((angle + 90) % 180) - 90);
                }
            }
        }
        else {
            // fallback - the connection has zero length
            translation = path.start;
            if (isOffsetAbsolute) {
                translation.translate(offsetCoord);
            }
        }
        return createSVGMatrix()
            .translate(translation.x, translation.y)
            .rotate(angle);
    }
    getLabelCoordinates(pos) {
        const matrix = this.getLabelTransformationMatrix(pos);
        return new Point(matrix.e, matrix.f);
    }
    getVertexIndex(x, y) {
        const edge = this.cell;
        const vertices = edge.getVertices();
        const vertexLength = this.getClosestPointLength(new Point(x, y));
        let index = 0;
        if (vertexLength != null) {
            for (const ii = vertices.length; index < ii; index += 1) {
                const currentVertex = vertices[index];
                const currentLength = this.getClosestPointLength(currentVertex);
                if (currentLength != null && vertexLength < currentLength) {
                    break;
                }
            }
        }
        return index;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line
        const edge = view.cell;
        const cell = edge;
        if (x == null || y == null) {
            return { e, view, edge, cell };
        }
        return { e, x, y, view, edge, cell };
    }
    notifyUnhandledMouseDown(e, x, y) {
        this.notify('edge:unhandled:mousedown', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            edge: this.cell,
        });
    }
    notifyMouseDown(e, x, y) {
        super.onMouseDown(e, x, y);
        this.notify('edge:mousedown', this.getEventArgs(e, x, y));
    }
    notifyMouseMove(e, x, y) {
        super.onMouseMove(e, x, y);
        this.notify('edge:mousemove', this.getEventArgs(e, x, y));
    }
    notifyMouseUp(e, x, y) {
        super.onMouseUp(e, x, y);
        this.notify('edge:mouseup', this.getEventArgs(e, x, y));
    }
    onClick(e, x, y) {
        super.onClick(e, x, y);
        this.notify('edge:click', this.getEventArgs(e, x, y));
    }
    onDblClick(e, x, y) {
        super.onDblClick(e, x, y);
        this.notify('edge:dblclick', this.getEventArgs(e, x, y));
    }
    onContextMenu(e, x, y) {
        super.onContextMenu(e, x, y);
        this.notify('edge:contextmenu', this.getEventArgs(e, x, y));
    }
    onMouseDown(e, x, y) {
        this.notifyMouseDown(e, x, y);
        const className = e.target.getAttribute('class');
        switch (className) {
            case 'vertex': {
                this.startVertexDragging(e, x, y);
                return;
            }
            case 'vertex-remove':
            case 'vertex-remove-area': {
                this.handleVertexRemoving(e, x, y);
                return;
            }
            case 'connection':
            case 'connection-wrap': {
                this.handleVertexAdding(e, x, y);
                return;
            }
            case 'arrowhead': {
                this.startArrowheadDragging(e, x, y);
                return;
            }
            case 'source-marker':
            case 'target-marker': {
                this.notifyUnhandledMouseDown(e, x, y);
                return;
            }
            default:
                break;
        }
        this.startEdgeDragging(e, x, y);
    }
    onMouseMove(e, x, y) {
        const data = this.getEventData(e);
        switch (data.action) {
            case 'drag-vertex': {
                this.dragVertex(e, x, y);
                break;
            }
            case 'drag-label': {
                this.dragLabel(e, x, y);
                break;
            }
            case 'drag-arrowhead': {
                this.dragArrowhead(e, x, y);
                break;
            }
            case 'drag-edge': {
                this.dragEdge(e, x, y);
                break;
            }
            default:
                break;
        }
        this.notifyMouseMove(e, x, y);
        return data;
    }
    onMouseUp(e, x, y) {
        const data = this.getEventData(e);
        switch (data.action) {
            case 'drag-vertex': {
                this.stopVertexDragging(e, x, y);
                break;
            }
            case 'drag-label': {
                this.stopLabelDragging(e, x, y);
                break;
            }
            case 'drag-arrowhead': {
                this.stopArrowheadDragging(e, x, y);
                break;
            }
            case 'drag-edge': {
                this.stopEdgeDragging(e, x, y);
                break;
            }
            default:
                break;
        }
        this.notifyMouseUp(e, x, y);
        this.checkMouseleave(e);
        return data;
    }
    onMouseOver(e) {
        super.onMouseOver(e);
        this.notify('edge:mouseover', this.getEventArgs(e));
    }
    onMouseOut(e) {
        super.onMouseOut(e);
        this.notify('edge:mouseout', this.getEventArgs(e));
    }
    onMouseEnter(e) {
        super.onMouseEnter(e);
        this.notify('edge:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        super.onMouseLeave(e);
        this.notify('edge:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        super.onMouseWheel(e, x, y, delta);
        this.notify('edge:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onCustomEvent(e, name, x, y) {
        // For default edge tool
        const tool = findParentByClass(e.target, 'edge-tool', this.container);
        if (tool) {
            e.stopPropagation(); // no further action to be executed
            if (this.can('useEdgeTools')) {
                if (name === 'edge:remove') {
                    this.cell.remove({ ui: true });
                    return;
                }
                this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
            }
            this.notifyMouseDown(e, x, y);
        }
        else {
            this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
            super.onCustomEvent(e, name, x, y);
        }
    }
    onLabelMouseDown(e, x, y) {
        this.notifyMouseDown(e, x, y);
        this.startLabelDragging(e, x, y);
        const stopPropagation = this.getEventData(e).stopPropagation;
        if (stopPropagation) {
            e.stopPropagation();
        }
    }
    // #region drag edge
    startEdgeDragging(e, x, y) {
        if (!this.can('edgeMovable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        this.setEventData(e, {
            x,
            y,
            moving: false,
            action: 'drag-edge',
        });
    }
    dragEdge(e, x, y) {
        const data = this.getEventData(e);
        if (!data.moving) {
            data.moving = true;
            this.addClass('edge-moving');
            this.notify('edge:move', {
                e,
                x,
                y,
                view: this,
                cell: this.cell,
                edge: this.cell,
            });
        }
        this.cell.translate(x - data.x, y - data.y, { ui: true });
        this.setEventData(e, { x, y });
        this.notify('edge:moving', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            edge: this.cell,
        });
    }
    stopEdgeDragging(e, x, y) {
        const data = this.getEventData(e);
        if (data.moving) {
            this.removeClass('edge-moving');
            this.notify('edge:moved', {
                e,
                x,
                y,
                view: this,
                cell: this.cell,
                edge: this.cell,
            });
        }
        data.moving = false;
    }
    // #endregion
    // #region drag arrowhead
    prepareArrowheadDragging(type, options) {
        const magnet = this.getTerminalMagnet(type);
        const data = {
            action: 'drag-arrowhead',
            x: options.x,
            y: options.y,
            isNewEdge: options.isNewEdge === true,
            terminalType: type,
            initialMagnet: magnet,
            initialTerminal: clone(this.cell[type]),
            fallbackAction: options.fallbackAction || 'revert',
            getValidateConnectionArgs: this.createValidateConnectionArgs(type),
            options: options.options,
        };
        this.beforeArrowheadDragging(data);
        return data;
    }
    createValidateConnectionArgs(type) {
        const args = [];
        args[4] = type;
        args[5] = this;
        let opposite;
        let i = 0;
        let j = 0;
        if (type === 'source') {
            i = 2;
            opposite = 'target';
        }
        else {
            j = 2;
            opposite = 'source';
        }
        const terminal = this.cell[opposite];
        const cellId = terminal.cell;
        if (cellId) {
            let magnet;
            const view = (args[i] = this.graph.renderer.findViewByCell(cellId));
            if (view) {
                magnet = view.getMagnetFromEdgeTerminal(terminal);
                if (magnet === view.container) {
                    magnet = undefined;
                }
            }
            args[i + 1] = magnet;
        }
        return (cellView, magnet) => {
            args[j] = cellView;
            args[j + 1] = cellView.container === magnet ? undefined : magnet;
            return args;
        };
    }
    beforeArrowheadDragging(data) {
        data.zIndex = this.cell.zIndex;
        this.cell.toFront();
        const style = this.container.style;
        data.pointerEvents = style.pointerEvents;
        style.pointerEvents = 'none';
        if (this.graph.options.connecting.highlight) {
            this.highlightAvailableMagnets(data);
        }
    }
    afterArrowheadDragging(data) {
        if (data.zIndex != null) {
            this.cell.setZIndex(data.zIndex, { ui: true });
            data.zIndex = null;
        }
        const container = this.container;
        container.style.pointerEvents = data.pointerEvents || '';
        if (this.graph.options.connecting.highlight) {
            this.unhighlightAvailableMagnets(data);
        }
    }
    arrowheadDragging(target, x, y, data) {
        data.x = x;
        data.y = y;
        // Checking views right under the pointer
        if (data.currentTarget !== target) {
            // Unhighlight the previous view under pointer if there was one.
            if (data.currentMagnet && data.currentView) {
                data.currentView.unhighlight(data.currentMagnet, {
                    type: 'magnetAdsorbed',
                });
            }
            data.currentView = this.graph.renderer.findViewByElem(target);
            if (data.currentView) {
                // If we found a view that is under the pointer, we need to find
                // the closest magnet based on the real target element of the event.
                data.currentMagnet = data.currentView.findMagnet(target);
                if (data.currentMagnet &&
                    this.graph.hook.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {
                    data.currentView.highlight(data.currentMagnet, {
                        type: 'magnetAdsorbed',
                    });
                }
                else {
                    // This type of connection is not valid. Disregard this magnet.
                    data.currentMagnet = null;
                }
            }
            else {
                // Make sure we'll unset previous magnet.
                data.currentMagnet = null;
            }
        }
        data.currentTarget = target;
        this.cell.prop(data.terminalType, { x, y }, Object.assign(Object.assign({}, data.options), { ui: true }));
    }
    arrowheadDragged(data, x, y) {
        const view = data.currentView;
        const magnet = data.currentMagnet;
        if (!magnet || !view) {
            return;
        }
        view.unhighlight(magnet, { type: 'magnetAdsorbed' });
        const type = data.terminalType;
        const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);
        this.cell.setTerminal(type, terminal, { ui: true });
    }
    snapArrowhead(x, y, data) {
        const graph = this.graph;
        const { snap, allowEdge } = graph.options.connecting;
        const radius = (typeof snap === 'object' && snap.radius) || 50;
        const findViewsOption = {
            x: x - radius,
            y: y - radius,
            width: 2 * radius,
            height: 2 * radius,
        };
        const views = graph.renderer.findViewsInArea(findViewsOption);
        if (allowEdge) {
            const edgeViews = graph.renderer
                .findEdgeViewsInArea(findViewsOption)
                .filter((view) => {
                return view !== this;
            });
            views.push(...edgeViews);
        }
        const prevView = data.closestView || null;
        const prevMagnet = data.closestMagnet || null;
        data.closestView = null;
        data.closestMagnet = null;
        let distance;
        let minDistance = Number.MAX_SAFE_INTEGER;
        const pos = new Point(x, y);
        views.forEach((view) => {
            if (view.container.getAttribute('magnet') !== 'false') {
                // Find distance from the center of the cell to pointer coordinates
                distance = view.cell.getBBox().getCenter().distance(pos);
                // the connection is looked up in a circle area by `distance < r`
                if (distance < radius && distance < minDistance) {
                    if (prevMagnet === view.container ||
                        graph.hook.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {
                        minDistance = distance;
                        data.closestView = view;
                        data.closestMagnet = view.container;
                    }
                }
            }
            view.container.querySelectorAll('[magnet]').forEach((magnet) => {
                if (magnet.getAttribute('magnet') !== 'false') {
                    const bbox = view.getBBoxOfElement(magnet);
                    distance = pos.distance(bbox.getCenter());
                    if (distance < radius && distance < minDistance) {
                        if (prevMagnet === magnet ||
                            graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {
                            minDistance = distance;
                            data.closestView = view;
                            data.closestMagnet = magnet;
                        }
                    }
                }
            });
        });
        let terminal;
        const type = data.terminalType;
        const closestView = data.closestView;
        const closestMagnet = data.closestMagnet;
        const changed = prevMagnet !== closestMagnet;
        if (prevView && changed) {
            prevView.unhighlight(prevMagnet, {
                type: 'magnetAdsorbed',
            });
        }
        if (closestView) {
            if (!changed) {
                return;
            }
            closestView.highlight(closestMagnet, {
                type: 'magnetAdsorbed',
            });
            terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);
        }
        else {
            terminal = { x, y };
        }
        this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), { ui: true }));
    }
    snapArrowheadEnd(data) {
        // Finish off link snapping.
        // Everything except view unhighlighting was already done on pointermove.
        const closestView = data.closestView;
        const closestMagnet = data.closestMagnet;
        if (closestView && closestMagnet) {
            closestView.unhighlight(closestMagnet, {
                type: 'magnetAdsorbed',
            });
            data.currentMagnet = closestView.findMagnet(closestMagnet);
        }
        data.closestView = null;
        data.closestMagnet = null;
    }
    finishEmbedding(data) {
        // Resets parent of the edge if embedding is enabled
        if (this.graph.options.embedding.enabled && this.cell.updateParent()) {
            // Make sure we don't reverse to the original 'z' index
            data.zIndex = null;
        }
    }
    fallbackConnection(data) {
        switch (data.fallbackAction) {
            case 'remove':
                this.cell.remove({ ui: true });
                break;
            case 'revert':
            default:
                this.cell.prop(data.terminalType, data.initialTerminal, {
                    ui: true,
                });
                break;
        }
    }
    notifyConnectionEvent(data, e) {
        const terminalType = data.terminalType;
        const initialTerminal = data.initialTerminal;
        const currentTerminal = this.cell[terminalType];
        const changed = currentTerminal && !Edge$1.equalTerminals(initialTerminal, currentTerminal);
        if (changed) {
            const graph = this.graph;
            const previous = initialTerminal;
            const previousCell = previous.cell
                ? graph.getCellById(previous.cell)
                : null;
            const previousPort = previous.port;
            const previousView = previousCell
                ? graph.findViewByCell(previousCell)
                : null;
            const previousPoint = previousCell || data.isNewEdge
                ? null
                : Point.create(initialTerminal).toJSON();
            const current = currentTerminal;
            const currentCell = current.cell ? graph.getCellById(current.cell) : null;
            const currentPort = current.port;
            const currentView = currentCell ? graph.findViewByCell(currentCell) : null;
            const currentPoint = currentCell
                ? null
                : Point.create(currentTerminal).toJSON();
            this.notify('edge:connected', {
                e,
                previousCell,
                previousPort,
                previousView,
                previousPoint,
                currentCell,
                currentView,
                currentPort,
                currentPoint,
                previousMagnet: data.initialMagnet,
                currentMagnet: data.currentMagnet,
                edge: this.cell,
                view: this,
                type: terminalType,
                isNew: data.isNewEdge,
            });
        }
    }
    highlightAvailableMagnets(data) {
        const graph = this.graph;
        const cells = graph.model.getCells();
        data.marked = {};
        for (let i = 0, ii = cells.length; i < ii; i += 1) {
            const view = graph.renderer.findViewByCell(cells[i]);
            if (!view) {
                continue;
            }
            const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));
            if (view.container.getAttribute('magnet') !== 'false') {
                magnets.push(view.container);
            }
            const availableMagnets = magnets.filter((magnet) => graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));
            if (availableMagnets.length > 0) {
                // highlight all available magnets
                for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {
                    view.highlight(availableMagnets[j], { type: 'magnetAvailable' });
                }
                // highlight the entire view
                view.highlight(null, { type: 'nodeAvailable' });
                data.marked[view.cell.id] = availableMagnets;
            }
        }
    }
    unhighlightAvailableMagnets(data) {
        const marked = data.marked || {};
        Object.keys(marked).forEach((id) => {
            const view = this.graph.renderer.findViewByCell(id);
            if (view) {
                const magnets = marked[id];
                magnets.forEach((magnet) => {
                    view.unhighlight(magnet, { type: 'magnetAvailable' });
                });
                view.unhighlight(null, { type: 'nodeAvailable' });
            }
        });
        data.marked = null;
    }
    startArrowheadDragging(e, x, y) {
        if (!this.can('arrowheadMovable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        const elem = e.target;
        const type = elem.getAttribute('data-terminal');
        const data = this.prepareArrowheadDragging(type, { x, y });
        this.setEventData(e, data);
    }
    dragArrowhead(e, x, y) {
        const data = this.getEventData(e);
        if (this.graph.options.connecting.snap) {
            this.snapArrowhead(x, y, data);
        }
        else {
            this.arrowheadDragging(this.getEventTarget(e), x, y, data);
        }
    }
    stopArrowheadDragging(e, x, y) {
        const graph = this.graph;
        const data = this.getEventData(e);
        if (graph.options.connecting.snap) {
            this.snapArrowheadEnd(data);
        }
        else {
            this.arrowheadDragged(data, x, y);
        }
        const valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);
        if (valid) {
            this.finishEmbedding(data);
            this.notifyConnectionEvent(data, e);
        }
        else {
            // If the changed edge is not allowed, revert to its previous state.
            this.fallbackConnection(data);
        }
        this.afterArrowheadDragging(data);
    }
    // #endregion
    // #region drag lable
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    startLabelDragging(e, x, y) {
        if (this.can('edgeLabelMovable')) {
            const target = e.currentTarget;
            const index = parseInt(target.getAttribute('data-index'), 10);
            const positionAngle = this.getLabelPositionAngle(index);
            const labelPositionArgs = this.getLabelPositionArgs(index);
            const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
            const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
            this.setEventData(e, {
                index,
                positionAngle,
                positionArgs,
                stopPropagation: true,
                action: 'drag-label',
            });
        }
        else {
            // If labels can't be dragged no default action is triggered.
            this.setEventData(e, { stopPropagation: true });
        }
        this.graph.view.delegateDragEvents(e, this);
    }
    dragLabel(e, x, y) {
        const data = this.getEventData(e);
        const originLabel = this.cell.getLabelAt(data.index);
        const label = merge({}, originLabel, {
            position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs),
        });
        this.cell.setLabelAt(data.index, label);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    stopLabelDragging(e, x, y) { }
    // #endregion
    // #region drag vertex
    handleVertexAdding(e, x, y) {
        if (!this.can('vertexAddable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        // Store the index at which the new vertex has just been placed.
        // We'll be update the very same vertex position in `pointermove()`.
        const index = this.addVertex({ x, y }, { ui: true });
        this.setEventData(e, {
            index,
            action: 'drag-vertex',
        });
    }
    handleVertexRemoving(e, x, y) {
        if (!this.can('vertexDeletable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        const target = e.target;
        const index = parseInt(target.getAttribute('idx'), 10);
        this.cell.removeVertexAt(index);
    }
    startVertexDragging(e, x, y) {
        if (!this.can('vertexMovable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        const target = e.target;
        const index = parseInt(target.getAttribute('idx'), 10);
        this.setEventData(e, {
            index,
            action: 'drag-vertex',
        });
    }
    dragVertex(e, x, y) {
        const data = this.getEventData(e);
        this.cell.setVertexAt(data.index, { x, y }, { ui: true });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    stopVertexDragging(e, x, y) { }
}
(function (EdgeView) {
    EdgeView.toStringTag = `X6.${EdgeView.name}`;
    function isEdgeView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof EdgeView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === EdgeView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function' &&
            typeof view.update === 'function' &&
            typeof view.getConnection === 'function') {
            return true;
        }
        return false;
    }
    EdgeView.isEdgeView = isEdgeView;
})(EdgeView || (EdgeView = {}));
EdgeView.config({
    isSvgElement: true,
    priority: 1,
    bootstrap: ['render', 'source', 'target'],
    actions: {
        view: ['render'],
        markup: ['render'],
        attrs: ['update'],
        source: ['source', 'update'],
        target: ['target', 'update'],
        router: ['update'],
        connector: ['update'],
        labels: ['labels'],
        defaultLabel: ['labels'],
        vertices: ['vertices', 'update'],
        vertexMarkup: ['vertices'],
        toolMarkup: ['tools'],
        tools: ['widget'],
    },
    shortLength: 105,
    longLength: 155,
    toolsOffset: 40,
    doubleTools: false,
    doubleToolsOffset: 65,
    sampleInterval: 50,
});
EdgeView.registry.register('edge', EdgeView, true);

class NodeView extends CellView {
    constructor() {
        super(...arguments);
        this.scalableNode = null;
        this.rotatableNode = null;
        this.scalableSelector = 'scalable';
        this.rotatableSelector = 'rotatable';
        this.defaultPortMarkup = Markup.getPortMarkup();
        this.defaultPortLabelMarkup = Markup.getPortLabelMarkup();
        this.defaultPortContainerMarkup = Markup.getPortContainerMarkup();
        this.portsCache = {};
        // #endregion
    }
    get [Symbol.toStringTag]() {
        return NodeView.toStringTag;
    }
    getContainerClassName() {
        const classList = [
            super.getContainerClassName(),
            this.prefixClassName('node'),
        ];
        if (!this.can('nodeMovable')) {
            classList.push(this.prefixClassName('node-immovable'));
        }
        return classList.join(' ');
    }
    updateClassName(e) {
        const target = e.target;
        if (target.hasAttribute('magnet')) {
            // port
            const className = this.prefixClassName('port-unconnectable');
            if (this.can('magnetConnectable')) {
                removeClass(target, className);
            }
            else {
                addClass(target, className);
            }
        }
        else {
            // node
            const className = this.prefixClassName('node-immovable');
            if (this.can('nodeMovable')) {
                this.removeClass(className);
            }
            else {
                this.addClass(className);
            }
        }
    }
    isNodeView() {
        return true;
    }
    confirmUpdate(flag, options = {}) {
        let ret = flag;
        if (this.hasAction(ret, 'ports')) {
            this.removePorts();
            this.cleanPortsCache();
        }
        if (this.hasAction(ret, 'render')) {
            this.render();
            ret = this.removeAction(ret, [
                'render',
                'update',
                'resize',
                'translate',
                'rotate',
                'ports',
                'tools',
            ]);
        }
        else {
            ret = this.handleAction(ret, 'resize', () => this.resize(options), 'update');
            ret = this.handleAction(ret, 'update', () => this.update(), 
            // `update()` will render ports when useCSSSelectors are enabled
            Config.useCSSSelector ? 'ports' : null);
            ret = this.handleAction(ret, 'translate', () => this.translate());
            ret = this.handleAction(ret, 'rotate', () => this.rotate());
            ret = this.handleAction(ret, 'ports', () => this.renderPorts());
            ret = this.handleAction(ret, 'tools', () => this.renderTools());
        }
        return ret;
    }
    update(partialAttrs) {
        this.cleanCache();
        // When CSS selector strings are used, make sure no rule matches port nodes.
        if (Config.useCSSSelector) {
            this.removePorts();
        }
        const node = this.cell;
        const size = node.getSize();
        const attrs = node.getAttrs();
        this.updateAttrs(this.container, attrs, {
            attrs: partialAttrs === attrs ? null : partialAttrs,
            rootBBox: new Rectangle(0, 0, size.width, size.height),
            selectors: this.selectors,
            scalableNode: this.scalableNode,
            rotatableNode: this.rotatableNode,
        });
        if (Config.useCSSSelector) {
            this.renderPorts();
        }
    }
    renderMarkup() {
        const markup = this.cell.markup;
        if (markup) {
            if (typeof markup === 'string') {
                return this.renderStringMarkup(markup);
            }
            return this.renderJSONMarkup(markup);
        }
        throw new TypeError('Invalid node markup.');
    }
    renderJSONMarkup(markup) {
        const ret = this.parseJSONMarkup(markup, this.container);
        const one = (elems) => Array.isArray(elems) ? elems[0] : elems;
        this.selectors = ret.selectors;
        this.rotatableNode = one(this.selectors[this.rotatableSelector]);
        this.scalableNode = one(this.selectors[this.scalableSelector]);
        this.container.appendChild(ret.fragment);
    }
    renderStringMarkup(markup) {
        append(this.container, Vector.toNodes(Vector.createVectors(markup)));
        this.rotatableNode = findOne(this.container, `.${this.rotatableSelector}`);
        this.scalableNode = findOne(this.container, `.${this.scalableSelector}`);
        this.selectors = {};
        if (this.rootSelector) {
            this.selectors[this.rootSelector] = this.container;
        }
    }
    render() {
        this.empty();
        this.renderMarkup();
        if (this.scalableNode) {
            // Double update is necessary for elements with the scalable group only
            // Note the `resize()` triggers the other `update`.
            this.update();
        }
        this.resize();
        if (this.rotatableNode) {
            this.rotate();
            this.translate();
        }
        else {
            this.updateTransform();
        }
        if (!Config.useCSSSelector) {
            this.renderPorts();
        }
        this.renderTools();
        return this;
    }
    resize(opt = {}) {
        if (this.scalableNode) {
            return this.updateSize(opt);
        }
        if (this.cell.getAngle()) {
            this.rotate();
        }
        this.update();
    }
    translate() {
        if (this.rotatableNode) {
            return this.updateTranslation();
        }
        this.updateTransform();
    }
    rotate() {
        if (this.rotatableNode) {
            this.updateRotation();
            // It's necessary to call the update for the nodes outside
            // the rotatable group referencing nodes inside the group
            this.update();
            return;
        }
        this.updateTransform();
    }
    getTranslationString() {
        const position = this.cell.getPosition();
        return `translate(${position.x},${position.y})`;
    }
    getRotationString() {
        const angle = this.cell.getAngle();
        if (angle) {
            const size = this.cell.getSize();
            return `rotate(${angle},${size.width / 2},${size.height / 2})`;
        }
    }
    updateTransform() {
        let transform = this.getTranslationString();
        const rot = this.getRotationString();
        if (rot) {
            transform += ` ${rot}`;
        }
        this.container.setAttribute('transform', transform);
    }
    updateRotation() {
        if (this.rotatableNode != null) {
            const transform = this.getRotationString();
            if (transform != null) {
                this.rotatableNode.setAttribute('transform', transform);
            }
            else {
                this.rotatableNode.removeAttribute('transform');
            }
        }
    }
    updateTranslation() {
        this.container.setAttribute('transform', this.getTranslationString());
    }
    updateSize(opt = {}) {
        const cell = this.cell;
        const size = cell.getSize();
        const angle = cell.getAngle();
        const scalableNode = this.scalableNode;
        // Getting scalable group's bbox.
        // Due to a bug in webkit's native SVG .getBBox implementation, the
        // bbox of groups with path children includes the paths' control points.
        // To work around the issue, we need to check whether there are any path
        // elements inside the scalable group.
        let recursive = false;
        if (scalableNode.getElementsByTagName('path').length > 0) {
            // If scalable has at least one descendant that is a path, we need
            // toswitch to recursive bbox calculation. Otherwise, group bbox
            // calculation works and so we can use the (faster) native function.
            recursive = true;
        }
        const scalableBBox = getBBox(scalableNode, { recursive });
        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero
        // which can happen if the element does not have any content.
        const sx = size.width / (scalableBBox.width || 1);
        const sy = size.height / (scalableBBox.height || 1);
        scalableNode.setAttribute('transform', `scale(${sx},${sy})`);
        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`
        // Order of transformations is significant but we want to reconstruct the object always in the order:
        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,
        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the
        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation
        // around the center of the resized object (which is a different origin then the origin of the previous rotation)
        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.
        // Cancel the rotation but now around a different origin, which is the center of the scaled object.
        const rotatableNode = this.rotatableNode;
        if (rotatableNode != null) {
            const transform = rotatableNode.getAttribute('transform');
            if (transform) {
                rotatableNode.setAttribute('transform', `${transform} rotate(${-angle},${size.width / 2},${size.height / 2})`);
                const rotatableBBox = getBBox(scalableNode, {
                    target: this.graph.view.stage,
                });
                // Store new x, y and perform rotate() again against the new rotation origin.
                cell.prop('position', { x: rotatableBBox.x, y: rotatableBBox.y }, Object.assign({ updated: true }, opt));
                this.translate();
                this.rotate();
            }
        }
        // Update must always be called on non-rotated element. Otherwise,
        // relative positioning would work with wrong (rotated) bounding boxes.
        this.update();
    }
    // #region ports
    findPortElem(portId, selector) {
        const cache = portId ? this.portsCache[portId] : null;
        if (!cache) {
            return null;
        }
        const portRoot = cache.portContentElement;
        const portSelectors = cache.portContentSelectors || {};
        return this.findOne(selector, portRoot, portSelectors);
    }
    initializePorts() {
        this.cleanPortsCache();
    }
    refreshPorts() {
        this.removePorts();
        this.cleanPortsCache();
        this.renderPorts();
    }
    cleanPortsCache() {
        this.portsCache = {};
    }
    removePorts() {
        Object.keys(this.portsCache).forEach((portId) => {
            const cached = this.portsCache[portId];
            remove(cached.portElement);
        });
    }
    renderPorts() {
        const container = this.getPortsContainer();
        // References to rendered elements without z-index
        const references = [];
        container.childNodes.forEach((child) => {
            references.push(child);
        });
        const portsGropsByZ = groupBy(this.cell.getParsedPorts(), 'zIndex');
        const autoZIndexKey = 'auto';
        // render non-z first
        if (portsGropsByZ[autoZIndexKey]) {
            portsGropsByZ[autoZIndexKey].forEach((port) => {
                const portElement = this.getPortElement(port);
                container.append(portElement);
                references.push(portElement);
            });
        }
        Object.keys(portsGropsByZ).forEach((key) => {
            if (key !== autoZIndexKey) {
                const zIndex = parseInt(key, 10);
                this.appendPorts(portsGropsByZ[key], zIndex, references);
            }
        });
        this.updatePorts();
    }
    getPortsContainer() {
        return this.rotatableNode || this.container;
    }
    appendPorts(ports, zIndex, refs) {
        const elems = ports.map((p) => this.getPortElement(p));
        if (refs[zIndex] || zIndex < 0) {
            before(refs[Math.max(zIndex, 0)], elems);
        }
        else {
            append(this.getPortsContainer(), elems);
        }
    }
    getPortElement(port) {
        const cached = this.portsCache[port.id];
        if (cached) {
            return cached.portElement;
        }
        return this.createPortElement(port);
    }
    createPortElement(port) {
        let renderResult = Markup.renderMarkup(this.getPortContainerMarkup());
        const portElement = renderResult.elem;
        if (portElement == null) {
            throw new Error('Invalid port container markup.');
        }
        renderResult = Markup.renderMarkup(this.getPortMarkup(port));
        const portContentElement = renderResult.elem;
        const portContentSelectors = renderResult.selectors;
        if (portContentElement == null) {
            throw new Error('Invalid port markup.');
        }
        this.setAttrs({
            port: port.id,
            'port-group': port.group,
        }, portContentElement);
        renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));
        const portLabelElement = renderResult.elem;
        const portLabelSelectors = renderResult.selectors;
        if (portLabelElement == null) {
            throw new Error('Invalid port label markup.');
        }
        let portSelectors;
        if (portContentSelectors && portLabelSelectors) {
            // eslint-disable-next-line
            for (const key in portLabelSelectors) {
                if (portContentSelectors[key] && key !== this.rootSelector) {
                    throw new Error('Selectors within port must be unique.');
                }
            }
            portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);
        }
        else {
            portSelectors = portContentSelectors || portLabelSelectors;
        }
        let portClass = 'x6-port';
        if (port.group) {
            portClass += ` x6-port-${port.group}`;
        }
        addClass(portElement, portClass);
        addClass(portContentElement, 'x6-port-body');
        addClass(portLabelElement, 'x6-port-label');
        portElement.appendChild(portContentElement);
        portElement.appendChild(portLabelElement);
        this.portsCache[port.id] = {
            portElement,
            portSelectors,
            portLabelElement,
            portLabelSelectors,
            portContentElement,
            portContentSelectors,
        };
        this.graph.hook.onPortRendered({
            port,
            node: this.cell,
            container: portElement,
            selectors: portSelectors,
            labelContainer: portLabelElement,
            labelSelectors: portLabelSelectors,
            contentContainer: portContentElement,
            contentSelectors: portContentSelectors,
        });
        return portElement;
    }
    updatePorts() {
        // Layout ports without group
        this.updatePortGroup();
        // Layout ports with explicit group
        const groups = this.cell.getParsedGroups();
        Object.keys(groups).forEach((groupName) => this.updatePortGroup(groupName));
    }
    updatePortGroup(groupName) {
        const bbox = Rectangle.fromSize(this.cell.getSize());
        const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);
        for (let i = 0, n = metrics.length; i < n; i += 1) {
            const metric = metrics[i];
            const portId = metric.portId;
            const cached = this.portsCache[portId] || {};
            const portLayout = metric.portLayout;
            this.applyPortTransform(cached.portElement, portLayout);
            if (metric.portAttrs != null) {
                const options = {
                    selectors: cached.portSelectors || {},
                };
                if (metric.portSize) {
                    options.rootBBox = Rectangle.fromSize(metric.portSize);
                }
                this.updateAttrs(cached.portElement, metric.portAttrs, options);
            }
            const labelLayout = metric.labelLayout;
            if (labelLayout) {
                this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));
                if (labelLayout.attrs) {
                    const options = {
                        selectors: cached.portLabelSelectors || {},
                    };
                    if (metric.labelSize) {
                        options.rootBBox = Rectangle.fromSize(metric.labelSize);
                    }
                    this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);
                }
            }
        }
    }
    applyPortTransform(element, layout, initialAngle = 0) {
        const angle = layout.angle;
        const position = layout.position;
        const matrix = createSVGMatrix()
            .rotate(initialAngle)
            .translate(position.x || 0, position.y || 0)
            .rotate(angle || 0);
        transform$1(element, matrix, { absolute: true });
    }
    getPortContainerMarkup() {
        return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;
    }
    getPortMarkup(port) {
        return port.markup || this.cell.portMarkup || this.defaultPortMarkup;
    }
    getPortLabelMarkup(label) {
        return (label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup);
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line
        const node = view.cell;
        const cell = node;
        if (x == null || y == null) {
            return { e, view, node, cell };
        }
        return { e, x, y, view, node, cell };
    }
    notifyMouseDown(e, x, y) {
        super.onMouseDown(e, x, y);
        this.notify('node:mousedown', this.getEventArgs(e, x, y));
    }
    notifyMouseMove(e, x, y) {
        super.onMouseMove(e, x, y);
        this.notify('node:mousemove', this.getEventArgs(e, x, y));
    }
    notifyMouseUp(e, x, y) {
        // Problem: super will call stopBatch before event listeners
        // attached to this **node** run. Those events will not count
        // towards this batch, despite being triggered by the same UI event.
        //
        // This complicates a lot of stuff e.g. history recording.
        //
        // See https://github.com/antvis/X6/issues/2421 for background.
        super.onMouseUp(e, x, y);
        this.notify('node:mouseup', this.getEventArgs(e, x, y));
    }
    onClick(e, x, y) {
        super.onClick(e, x, y);
        this.notify('node:click', this.getEventArgs(e, x, y));
    }
    onDblClick(e, x, y) {
        super.onDblClick(e, x, y);
        this.notify('node:dblclick', this.getEventArgs(e, x, y));
    }
    onContextMenu(e, x, y) {
        super.onContextMenu(e, x, y);
        this.notify('node:contextmenu', this.getEventArgs(e, x, y));
    }
    onMouseDown(e, x, y) {
        if (this.isPropagationStopped(e)) {
            return;
        }
        // foreignObjectonMouseDown
        // onMouseDown
        const target = e.target;
        if (clickable(target) || isInputElement(target)) {
            return;
        }
        this.notifyMouseDown(e, x, y);
        this.startNodeDragging(e, x, y);
    }
    onMouseMove(e, x, y) {
        const data = this.getEventData(e);
        const action = data.action;
        if (action === 'magnet') {
            this.dragMagnet(e, x, y);
        }
        else {
            if (action === 'move') {
                const meta = data;
                const view = meta.targetView || this;
                view.dragNode(e, x, y);
                view.notify('node:moving', {
                    e,
                    x,
                    y,
                    view,
                    cell: view.cell,
                    node: view.cell,
                });
            }
            this.notifyMouseMove(e, x, y);
        }
        this.setEventData(e, data);
    }
    onMouseUp(e, x, y) {
        const data = this.getEventData(e);
        const action = data.action;
        if (action === 'magnet') {
            this.stopMagnetDragging(e, x, y);
        }
        else {
            // foreignObjectonMouseUp
            // onMouseUp
            const target = e.target;
            if (clickable(target) || isInputElement(target)) {
                return;
            }
            this.notifyMouseUp(e, x, y);
            if (action === 'move') {
                const meta = data;
                const view = meta.targetView || this;
                view.stopNodeDragging(e, x, y);
            }
        }
        const magnet = data.targetMagnet;
        if (magnet) {
            this.onMagnetClick(e, magnet, x, y);
        }
        this.checkMouseleave(e);
    }
    onMouseOver(e) {
        super.onMouseOver(e);
        this.notify('node:mouseover', this.getEventArgs(e));
    }
    onMouseOut(e) {
        super.onMouseOut(e);
        this.notify('node:mouseout', this.getEventArgs(e));
    }
    onMouseEnter(e) {
        this.updateClassName(e);
        super.onMouseEnter(e);
        this.notify('node:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        super.onMouseLeave(e);
        this.notify('node:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        super.onMouseWheel(e, x, y, delta);
        this.notify('node:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onMagnetClick(e, magnet, x, y) {
        const count = this.graph.view.getMouseMovedCount(e);
        if (count > this.graph.options.clickThreshold) {
            return;
        }
        this.notify('node:magnet:click', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetDblClick(e, magnet, x, y) {
        this.notify('node:magnet:dblclick', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetContextMenu(e, magnet, x, y) {
        this.notify('node:magnet:contextmenu', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetMouseDown(e, magnet, x, y) {
        this.startMagnetDragging(e, x, y);
    }
    onCustomEvent(e, name, x, y) {
        this.notify('node:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
        super.onCustomEvent(e, name, x, y);
    }
    prepareEmbedding(e) {
        // const cell = data.cell || this.cell
        // const graph = data.graph || this.graph
        // const model = graph.model
        // model.startBatch('to-front')
        // // Bring the model to the front with all his embeds.
        // cell.toFront({ deep: true, ui: true })
        // const maxZ = model
        //   .getNodes()
        //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)
        // const connectedEdges = model.getConnectedEdges(cell, {
        //   deep: true,
        //   enclosed: true,
        // })
        // connectedEdges.forEach((edge) => {
        //   const zIndex = edge.getZIndex() || 0
        //   if (zIndex <= maxZ) {
        //     edge.setZIndex(maxZ + 1, { ui: true })
        //   }
        // })
        // model.stopBatch('to-front')
        // Before we start looking for suitable parent we remove the current one.
        // const parent = cell.getParent()
        // if (parent) {
        //   parent.unembed(cell, { ui: true })
        // }
        const data = this.getEventData(e);
        const node = data.cell || this.cell;
        const view = this.graph.findViewByCell(node);
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        this.notify('node:embed', {
            e,
            node,
            view,
            cell: node,
            x: localPoint.x,
            y: localPoint.y,
            currentParent: node.getParent(),
        });
    }
    processEmbedding(e, data) {
        const cell = data.cell || this.cell;
        const graph = data.graph || this.graph;
        const options = graph.options.embedding;
        const findParent = options.findParent;
        let candidates = typeof findParent === 'function'
            ? call(findParent, graph, {
                view: this,
                node: this.cell,
            }).filter((c) => {
                return (Cell.isCell(c) &&
                    this.cell.id !== c.id &&
                    !c.isDescendantOf(this.cell));
            })
            : graph.model.getNodesUnderNode(cell, {
                by: findParent,
            });
        // Picks the node with the highest `z` index
        if (options.frontOnly) {
            if (candidates.length > 0) {
                const zIndexMap = groupBy(candidates, 'zIndex');
                const maxZIndex = max(Object.keys(zIndexMap).map((z) => parseInt(z, 10)));
                if (maxZIndex) {
                    candidates = zIndexMap[maxZIndex];
                }
            }
        }
        // Filter the nodes which is invisiable
        candidates = candidates.filter((candidate) => candidate.visible);
        let newCandidateView = null;
        const prevCandidateView = data.candidateEmbedView;
        const validateEmbeding = options.validate;
        for (let i = candidates.length - 1; i >= 0; i -= 1) {
            const candidate = candidates[i];
            if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {
                // candidate remains the same
                newCandidateView = prevCandidateView;
                break;
            }
            else {
                const view = candidate.findView(graph);
                if (call(validateEmbeding, graph, {
                    child: this.cell,
                    parent: view.cell,
                    childView: this,
                    parentView: view,
                })) {
                    // flip to the new candidate
                    newCandidateView = view;
                    break;
                }
            }
        }
        this.clearEmbedding(data);
        if (newCandidateView) {
            newCandidateView.highlight(null, { type: 'embedding' });
        }
        data.candidateEmbedView = newCandidateView;
        const localPoint = graph.snapToGrid(e.clientX, e.clientY);
        this.notify('node:embedding', {
            e,
            cell,
            node: cell,
            view: graph.findViewByCell(cell),
            x: localPoint.x,
            y: localPoint.y,
            currentParent: cell.getParent(),
            candidateParent: newCandidateView ? newCandidateView.cell : null,
        });
    }
    clearEmbedding(data) {
        const candidateView = data.candidateEmbedView;
        if (candidateView) {
            candidateView.unhighlight(null, { type: 'embedding' });
            data.candidateEmbedView = null;
        }
    }
    finalizeEmbedding(e, data) {
        this.graph.startBatch('embedding');
        const cell = data.cell || this.cell;
        const graph = data.graph || this.graph;
        const view = graph.findViewByCell(cell);
        const parent = cell.getParent();
        const candidateView = data.candidateEmbedView;
        if (candidateView) {
            // Candidate view is chosen to become the parent of the node.
            candidateView.unhighlight(null, { type: 'embedding' });
            data.candidateEmbedView = null;
            if (parent == null || parent.id !== candidateView.cell.id) {
                candidateView.cell.insertChild(cell, undefined, { ui: true });
            }
        }
        else if (parent) {
            parent.unembed(cell, { ui: true });
        }
        graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {
            edge.updateParent({ ui: true });
        });
        if (view && candidateView) {
            const localPoint = graph.snapToGrid(e.clientX, e.clientY);
            view.notify('node:embedded', {
                e,
                cell,
                x: localPoint.x,
                y: localPoint.y,
                node: cell,
                view: graph.findViewByCell(cell),
                previousParent: parent,
                currentParent: cell.getParent(),
            });
        }
        this.graph.stopBatch('embedding');
    }
    getDelegatedView() {
        let cell = this.cell;
        let view = this; // eslint-disable-line
        while (view) {
            if (cell.isEdge()) {
                break;
            }
            if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {
                return view;
            }
            cell = cell.getParent();
            view = this.graph.renderer.findViewByCell(cell);
        }
        return null;
    }
    startMagnetDragging(e, x, y) {
        if (!this.can('magnetConnectable')) {
            return;
        }
        e.stopPropagation();
        const magnet = e.currentTarget;
        const graph = this.graph;
        this.setEventData(e, {
            targetMagnet: magnet,
        });
        if (graph.hook.validateMagnet(this, magnet, e)) {
            if (graph.options.magnetThreshold <= 0) {
                this.startConnectting(e, magnet, x, y);
            }
            this.setEventData(e, {
                action: 'magnet',
            });
            this.stopPropagation(e);
        }
        else {
            // port #2258
            if (hasClass(magnet, 'x6-port-body') ||
                JQuery(magnet).closest('.x6-port-body').length > 0) {
                this.stopPropagation(e);
            }
            this.onMouseDown(e, x, y);
        }
        graph.view.delegateDragEvents(e, this);
    }
    startConnectting(e, magnet, x, y) {
        this.graph.model.startBatch('add-edge');
        const edgeView = this.createEdgeFromMagnet(magnet, x, y);
        edgeView.notifyMouseDown(e, x, y); // backwards compatibility events
        edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {
            x,
            y,
            isNewEdge: true,
            fallbackAction: 'remove',
        }));
        this.setEventData(e, { edgeView });
    }
    createEdgeFromMagnet(magnet, x, y) {
        const graph = this.graph;
        const model = graph.model;
        const edge = graph.hook.getDefaultEdge(this, magnet);
        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));
        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { x, y }));
        edge.addTo(model, { async: false, ui: true });
        return edge.findView(graph);
    }
    dragMagnet(e, x, y) {
        const data = this.getEventData(e);
        const edgeView = data.edgeView;
        if (edgeView) {
            edgeView.onMouseMove(e, x, y);
            this.autoScrollGraph(e.clientX, e.clientY);
        }
        else {
            const graph = this.graph;
            const magnetThreshold = graph.options.magnetThreshold;
            const currentTarget = this.getEventTarget(e);
            const targetMagnet = data.targetMagnet;
            // magnetThreshold when the pointer leaves the magnet
            if (magnetThreshold === 'onleave') {
                if (targetMagnet === currentTarget ||
                    targetMagnet.contains(currentTarget)) {
                    return;
                }
                // eslint-disable-next-line no-lonely-if
            }
            else {
                // magnetThreshold defined as a number of movements
                if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {
                    return;
                }
            }
            this.startConnectting(e, targetMagnet, x, y);
        }
    }
    stopMagnetDragging(e, x, y) {
        const data = this.eventData(e);
        const edgeView = data.edgeView;
        if (edgeView) {
            edgeView.onMouseUp(e, x, y);
            this.graph.model.stopBatch('add-edge');
        }
    }
    notifyUnhandledMouseDown(e, x, y) {
        this.notify('node:unhandled:mousedown', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            node: this.cell,
        });
    }
    notifyNodeMove(name, e, x, y, cell) {
        let cells = [cell];
        const selection = this.graph.selection.widget;
        if (selection && selection.options.movable) {
            const selectedCells = this.graph.getSelectedCells();
            if (selectedCells.includes(cell)) {
                cells = selectedCells.filter((c) => c.isNode());
            }
        }
        cells.forEach((c) => {
            this.notify(name, {
                e,
                x,
                y,
                cell: c,
                node: c,
                view: c.findView(this.graph),
            });
        });
    }
    startNodeDragging(e, x, y) {
        const targetView = this.getDelegatedView();
        if (targetView == null || !targetView.can('nodeMovable')) {
            return this.notifyUnhandledMouseDown(e, x, y);
        }
        this.setEventData(e, {
            targetView,
            action: 'move',
        });
        const position = Point.create(targetView.cell.getPosition());
        targetView.setEventData(e, {
            moving: false,
            offset: position.diff(x, y),
            restrict: this.graph.hook.getRestrictArea(targetView),
        });
    }
    dragNode(e, x, y) {
        const node = this.cell;
        const graph = this.graph;
        const gridSize = graph.getGridSize();
        const data = this.getEventData(e);
        const offset = data.offset;
        const restrict = data.restrict;
        if (!data.moving) {
            data.moving = true;
            this.addClass('node-moving');
            this.notifyNodeMove('node:move', e, x, y, this.cell);
        }
        this.autoScrollGraph(e.clientX, e.clientY);
        const posX = Util$3.snapToGrid(x + offset.x, gridSize);
        const posY = Util$3.snapToGrid(y + offset.y, gridSize);
        node.setPosition(posX, posY, {
            restrict,
            deep: true,
            ui: true,
        });
        if (graph.options.embedding.enabled) {
            if (!data.embedding) {
                this.prepareEmbedding(e);
                data.embedding = true;
            }
            this.processEmbedding(e, data);
        }
    }
    stopNodeDragging(e, x, y) {
        const data = this.getEventData(e);
        if (data.embedding) {
            this.finalizeEmbedding(e, data);
        }
        if (data.moving) {
            this.removeClass('node-moving');
            this.notifyNodeMove('node:moved', e, x, y, this.cell);
        }
        data.moving = false;
        data.embedding = false;
    }
    autoScrollGraph(x, y) {
        const scroller = this.graph.scroller.widget;
        if (scroller) {
            scroller.autoScroll(x, y);
        }
    }
}
(function (NodeView) {
    NodeView.toStringTag = `X6.${NodeView.name}`;
    function isNodeView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof NodeView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === NodeView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function' &&
            typeof view.update === 'function' &&
            typeof view.findPortElem === 'function' &&
            typeof view.resize === 'function' &&
            typeof view.rotate === 'function' &&
            typeof view.translate === 'function') {
            return true;
        }
        return false;
    }
    NodeView.isNodeView = isNodeView;
})(NodeView || (NodeView = {}));
NodeView.config({
    isSvgElement: true,
    priority: 0,
    bootstrap: ['render'],
    actions: {
        view: ['render'],
        markup: ['render'],
        attrs: ['update'],
        size: ['resize', 'ports', 'tools'],
        angle: ['rotate', 'tools'],
        position: ['translate', 'tools'],
        ports: ['ports'],
        tools: ['tools'],
    },
});
NodeView.registry.register('node', NodeView, true);

const viewName = getName('text');
class Text extends createShape$1('text', {
    view: viewName,
    attrs: {
        text: {
            fontSize: 18,
            fill: '#000000',
            stroke: null,
            refX: 0.5,
            refY: 0.5,
        },
    },
}, { noText: true }) {
}
(function (Text) {
    class View extends NodeView {
        confirmUpdate(flag, options = {}) {
            let ret = super.confirmUpdate(flag, options);
            if (this.hasAction(ret, 'scale')) {
                this.resize();
                ret = this.removeAction(ret, 'scale');
            }
            return ret;
        }
    }
    Text.View = View;
    View.config({
        actions: {
            attrs: ['scale'],
        },
    });
    NodeView.registry.register(viewName, View);
})(Text || (Text = {}));

class Collection extends Basecoat {
    constructor(cells, options = {}) {
        super();
        this.length = 0;
        this.comparator = options.comparator || 'zIndex';
        this.clean();
        if (cells) {
            this.reset(cells, { silent: true });
        }
    }
    toJSON() {
        return this.cells.map((cell) => cell.toJSON());
    }
    add(cells, index, options) {
        let localIndex;
        let localOptions;
        if (typeof index === 'number') {
            localIndex = index;
            localOptions = Object.assign({ merge: false }, options);
        }
        else {
            localIndex = this.length;
            localOptions = Object.assign({ merge: false }, index);
        }
        if (localIndex > this.length) {
            localIndex = this.length;
        }
        if (localIndex < 0) {
            localIndex += this.length + 1;
        }
        const entities = Array.isArray(cells) ? cells : [cells];
        const sortable = this.comparator &&
            typeof index !== 'number' &&
            localOptions.sort !== false;
        const sortAttr = this.comparator || null;
        let sort = false;
        const added = [];
        const merged = [];
        entities.forEach((cell) => {
            const existing = this.get(cell);
            if (existing) {
                if (localOptions.merge && !cell.isSameStore(existing)) {
                    existing.setProp(cell.getProp(), options); // merge
                    merged.push(existing);
                    if (sortable && !sort) {
                        if (sortAttr == null || typeof sortAttr === 'function') {
                            sort = existing.hasChanged();
                        }
                        else if (typeof sortAttr === 'string') {
                            sort = existing.hasChanged(sortAttr);
                        }
                        else {
                            sort = sortAttr.some((key) => existing.hasChanged(key));
                        }
                    }
                }
            }
            else {
                added.push(cell);
                this.reference(cell);
            }
        });
        if (added.length) {
            if (sortable) {
                sort = true;
            }
            this.cells.splice(localIndex, 0, ...added);
            this.length = this.cells.length;
        }
        if (sort) {
            this.sort({ silent: true });
        }
        if (!localOptions.silent) {
            added.forEach((cell, i) => {
                const args = {
                    cell,
                    index: localIndex + i,
                    options: localOptions,
                };
                this.trigger('added', args);
                if (!localOptions.dryrun) {
                    cell.notify('added', Object.assign({}, args));
                }
            });
            if (sort) {
                this.trigger('sorted');
            }
            if (added.length || merged.length) {
                this.trigger('updated', {
                    added,
                    merged,
                    removed: [],
                    options: localOptions,
                });
            }
        }
        return this;
    }
    remove(cells, options = {}) {
        const arr = Array.isArray(cells) ? cells : [cells];
        const removed = this.removeCells(arr, options);
        if (!options.silent && removed.length > 0) {
            this.trigger('updated', {
                options,
                removed,
                added: [],
                merged: [],
            });
        }
        return Array.isArray(cells) ? removed : removed[0];
    }
    removeCells(cells, options) {
        const removed = [];
        for (let i = 0; i < cells.length; i += 1) {
            const cell = this.get(cells[i]);
            if (cell == null) {
                continue;
            }
            const index = this.cells.indexOf(cell);
            this.cells.splice(index, 1);
            this.length -= 1;
            delete this.map[cell.id];
            removed.push(cell);
            this.unreference(cell);
            if (!options.dryrun) {
                cell.remove();
            }
            if (!options.silent) {
                this.trigger('removed', { cell, index, options });
                if (!options.dryrun) {
                    cell.notify('removed', { cell, index, options });
                }
            }
        }
        return removed;
    }
    reset(cells, options = {}) {
        const previous = this.cells.slice();
        previous.forEach((cell) => this.unreference(cell));
        this.clean();
        this.add(cells, Object.assign({ silent: true }, options));
        if (!options.silent) {
            const current = this.cells.slice();
            this.trigger('reseted', {
                options,
                previous,
                current,
            });
            const added = [];
            const removed = [];
            current.forEach((a) => {
                const exist = previous.some((b) => b.id === a.id);
                if (!exist) {
                    added.push(a);
                }
            });
            previous.forEach((a) => {
                const exist = current.some((b) => b.id === a.id);
                if (!exist) {
                    removed.push(a);
                }
            });
            this.trigger('updated', { options, added, removed, merged: [] });
        }
        return this;
    }
    push(cell, options) {
        return this.add(cell, this.length, options);
    }
    pop(options) {
        const cell = this.at(this.length - 1);
        return this.remove(cell, options);
    }
    unshift(cell, options) {
        return this.add(cell, 0, options);
    }
    shift(options) {
        const cell = this.at(0);
        return this.remove(cell, options);
    }
    get(cell) {
        if (cell == null) {
            return null;
        }
        const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;
        return this.map[id] || null;
    }
    has(cell) {
        return this.get(cell) != null;
    }
    at(index) {
        if (index < 0) {
            index += this.length; // eslint-disable-line
        }
        return this.cells[index] || null;
    }
    first() {
        return this.at(0);
    }
    last() {
        return this.at(-1);
    }
    indexOf(cell) {
        return this.cells.indexOf(cell);
    }
    toArray() {
        return this.cells.slice();
    }
    sort(options = {}) {
        if (this.comparator != null) {
            this.cells = sortBy(this.cells, this.comparator);
            if (!options.silent) {
                this.trigger('sorted');
            }
        }
        return this;
    }
    clone() {
        const constructor = this.constructor;
        return new constructor(this.cells.slice(), {
            comparator: this.comparator,
        });
    }
    reference(cell) {
        this.map[cell.id] = cell;
        cell.on('*', this.notifyCellEvent, this);
    }
    unreference(cell) {
        cell.off('*', this.notifyCellEvent, this);
        delete this.map[cell.id];
    }
    notifyCellEvent(name, args) {
        const cell = args.cell;
        this.trigger(`cell:${name}`, args);
        if (cell) {
            if (cell.isNode()) {
                this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), { node: cell }));
            }
            else if (cell.isEdge()) {
                this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: cell }));
            }
        }
    }
    clean() {
        this.length = 0;
        this.cells = [];
        this.map = {};
    }
}

class Model extends Basecoat {
    constructor(cells = []) {
        super();
        this.batches = {};
        this.addings = new WeakMap();
        this.nodes = {};
        this.edges = {};
        this.outgoings = {};
        this.incomings = {};
        this.collection = new Collection(cells);
        this.setup();
    }
    get [Symbol.toStringTag]() {
        return Model.toStringTag;
    }
    notify(name, args) {
        this.trigger(name, args);
        const graph = this.graph;
        if (graph) {
            if (name === 'sorted' || name === 'reseted' || name === 'updated') {
                graph.trigger(`model:${name}`, args);
            }
            else {
                graph.trigger(name, args);
            }
        }
        return this;
    }
    setup() {
        const collection = this.collection;
        collection.on('sorted', () => this.notify('sorted', null));
        collection.on('updated', (args) => this.notify('updated', args));
        collection.on('cell:change:zIndex', () => this.sortOnChangeZ());
        collection.on('added', ({ cell }) => {
            this.onCellAdded(cell);
        });
        collection.on('removed', (args) => {
            const cell = args.cell;
            this.onCellRemoved(cell, args.options);
            // Should trigger remove-event manually after cell was removed.
            this.notify('cell:removed', args);
            if (cell.isNode()) {
                this.notify('node:removed', Object.assign(Object.assign({}, args), { node: cell }));
            }
            else if (cell.isEdge()) {
                this.notify('edge:removed', Object.assign(Object.assign({}, args), { edge: cell }));
            }
        });
        collection.on('reseted', (args) => {
            this.onReset(args.current);
            this.notify('reseted', args);
        });
        collection.on('edge:change:source', ({ edge }) => this.onEdgeTerminalChanged(edge, 'source'));
        collection.on('edge:change:target', ({ edge }) => {
            this.onEdgeTerminalChanged(edge, 'target');
        });
    }
    sortOnChangeZ() {
        this.collection.sort();
    }
    onCellAdded(cell) {
        const cellId = cell.id;
        if (cell.isEdge()) {
            // Auto update edge's parent
            cell.updateParent();
            this.edges[cellId] = true;
            this.onEdgeTerminalChanged(cell, 'source');
            this.onEdgeTerminalChanged(cell, 'target');
        }
        else {
            this.nodes[cellId] = true;
        }
    }
    onCellRemoved(cell, options) {
        const cellId = cell.id;
        if (cell.isEdge()) {
            delete this.edges[cellId];
            const source = cell.getSource();
            const target = cell.getTarget();
            if (source && source.cell) {
                const cache = this.outgoings[source.cell];
                const index = cache ? cache.indexOf(cellId) : -1;
                if (index >= 0) {
                    cache.splice(index, 1);
                    if (cache.length === 0) {
                        delete this.outgoings[source.cell];
                    }
                }
            }
            if (target && target.cell) {
                const cache = this.incomings[target.cell];
                const index = cache ? cache.indexOf(cellId) : -1;
                if (index >= 0) {
                    cache.splice(index, 1);
                    if (cache.length === 0) {
                        delete this.incomings[target.cell];
                    }
                }
            }
        }
        else {
            delete this.nodes[cellId];
        }
        if (!options.clear) {
            if (options.disconnectEdges) {
                this.disconnectConnectedEdges(cell, options);
            }
            else {
                this.removeConnectedEdges(cell, options);
            }
        }
        if (cell.model === this) {
            cell.model = null;
        }
    }
    onReset(cells) {
        this.nodes = {};
        this.edges = {};
        this.outgoings = {};
        this.incomings = {};
        cells.forEach((cell) => this.onCellAdded(cell));
    }
    onEdgeTerminalChanged(edge, type) {
        const ref = type === 'source' ? this.outgoings : this.incomings;
        const prev = edge.previous(type);
        if (prev && prev.cell) {
            const cellId = Cell.isCell(prev.cell) ? prev.cell.id : prev.cell;
            const cache = ref[cellId];
            const index = cache ? cache.indexOf(edge.id) : -1;
            if (index >= 0) {
                cache.splice(index, 1);
                if (cache.length === 0) {
                    delete ref[cellId];
                }
            }
        }
        const terminal = edge.getTerminal(type);
        if (terminal && terminal.cell) {
            const terminalId = Cell.isCell(terminal.cell)
                ? terminal.cell.id
                : terminal.cell;
            const cache = ref[terminalId] || [];
            const index = cache.indexOf(edge.id);
            if (index === -1) {
                cache.push(edge.id);
            }
            ref[terminalId] = cache;
        }
    }
    prepareCell(cell, options) {
        if (!cell.model && (!options || !options.dryrun)) {
            cell.model = this;
        }
        if (cell.zIndex == null) {
            cell.setZIndex(this.getMaxZIndex() + 1, { silent: true });
        }
        return cell;
    }
    resetCells(cells, options = {}) {
        // Do not update model at this time. Because if we just update the graph
        // with the same json-data, the edge will reference to the old nodes.
        cells.map((cell) => this.prepareCell(cell, Object.assign(Object.assign({}, options), { dryrun: true })));
        this.collection.reset(cells, options);
        // Update model and trigger edge update it's references
        cells.map((cell) => this.prepareCell(cell, { options }));
        return this;
    }
    clear(options = {}) {
        const raw = this.getCells();
        if (raw.length === 0) {
            return this;
        }
        const localOptions = Object.assign(Object.assign({}, options), { clear: true });
        this.batchUpdate('clear', () => {
            // The nodes come after the edges.
            const cells = raw.sort((a, b) => {
                const v1 = a.isEdge() ? 1 : 2;
                const v2 = b.isEdge() ? 1 : 2;
                return v1 - v2;
            });
            while (cells.length > 0) {
                // Note that all the edges are removed first, so it's safe to
                // remove the nodes without removing the connected edges first.
                const cell = cells.shift();
                if (cell) {
                    cell.remove(localOptions);
                }
            }
        }, localOptions);
        return this;
    }
    addNode(metadata, options = {}) {
        const node = Node$1.isNode(metadata) ? metadata : this.createNode(metadata);
        this.addCell(node, options);
        return node;
    }
    createNode(metadata) {
        return Node$1.create(metadata);
    }
    addEdge(metadata, options = {}) {
        const edge = Edge$1.isEdge(metadata) ? metadata : this.createEdge(metadata);
        this.addCell(edge, options);
        return edge;
    }
    createEdge(metadata) {
        return Edge$1.create(metadata);
    }
    addCell(cell, options = {}) {
        if (Array.isArray(cell)) {
            return this.addCells(cell, options);
        }
        if (!this.collection.has(cell) && !this.addings.has(cell)) {
            this.addings.set(cell, true);
            this.collection.add(this.prepareCell(cell, options), options);
            cell.eachChild((child) => this.addCell(child, options));
            this.addings.delete(cell);
        }
        return this;
    }
    addCells(cells, options = {}) {
        const count = cells.length;
        if (count === 0) {
            return this;
        }
        const localOptions = Object.assign(Object.assign({}, options), { position: count - 1, maxPosition: count - 1 });
        this.startBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));
        cells.forEach((cell) => {
            this.addCell(cell, localOptions);
            localOptions.position -= 1;
        });
        this.stopBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));
        return this;
    }
    removeCell(obj, options = {}) {
        const cell = typeof obj === 'string' ? this.getCell(obj) : obj;
        if (cell && this.has(cell)) {
            return this.collection.remove(cell, options);
        }
        return null;
    }
    updateCellId(cell, newId) {
        this.startBatch('update', { id: newId });
        cell.prop('id', newId);
        const newCell = cell.clone({ keepId: true });
        this.addCell(newCell);
        // update connected edge terminal
        const edges = this.getConnectedEdges(cell);
        edges.forEach((edge) => {
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (sourceCell === cell) {
                edge.setSource(Object.assign(Object.assign({}, edge.getSource()), { cell: newId }));
            }
            if (targetCell === cell) {
                edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { cell: newId }));
            }
        });
        this.removeCell(cell);
        this.stopBatch('update', { id: newId });
        return newCell;
    }
    removeCells(cells, options = {}) {
        if (cells.length) {
            return this.batchUpdate('remove', () => {
                return cells.map((cell) => this.removeCell(cell, options));
            });
        }
        return [];
    }
    removeConnectedEdges(cell, options = {}) {
        const edges = this.getConnectedEdges(cell);
        edges.forEach((edge) => {
            edge.remove(options);
        });
        return edges;
    }
    disconnectConnectedEdges(cell, options = {}) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        this.getConnectedEdges(cell).forEach((edge) => {
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (sourceCell && sourceCell.id === cellId) {
                edge.setSource({ x: 0, y: 0 }, options);
            }
            if (targetCell && targetCell.id === cellId) {
                edge.setTarget({ x: 0, y: 0 }, options);
            }
        });
    }
    has(obj) {
        return this.collection.has(obj);
    }
    total() {
        return this.collection.length;
    }
    indexOf(cell) {
        return this.collection.indexOf(cell);
    }
    /**
     * Returns a cell from the graph by its id.
     */
    getCell(id) {
        return this.collection.get(id);
    }
    /**
     * Returns all the nodes and edges in the graph.
     */
    getCells() {
        return this.collection.toArray();
    }
    /**
     * Returns the first cell (node or edge) in the graph. The first cell is
     * defined as the cell with the lowest `zIndex`.
     */
    getFirstCell() {
        return this.collection.first();
    }
    /**
     * Returns the last cell (node or edge) in the graph. The last cell is
     * defined as the cell with the highest `zIndex`.
     */
    getLastCell() {
        return this.collection.last();
    }
    /**
     * Returns the lowest `zIndex` value in the graph.
     */
    getMinZIndex() {
        const first = this.collection.first();
        return first ? first.getZIndex() || 0 : 0;
    }
    /**
     * Returns the highest `zIndex` value in the graph.
     */
    getMaxZIndex() {
        const last = this.collection.last();
        return last ? last.getZIndex() || 0 : 0;
    }
    getCellsFromCache(cache) {
        return cache
            ? Object.keys(cache)
                .map((id) => this.getCell(id))
                .filter((cell) => cell != null)
            : [];
    }
    /**
     * Returns all the nodes in the graph.
     */
    getNodes() {
        return this.getCellsFromCache(this.nodes);
    }
    /**
     * Returns all the edges in the graph.
     */
    getEdges() {
        return this.getCellsFromCache(this.edges);
    }
    /**
     * Returns all outgoing edges for the node.
     */
    getOutgoingEdges(cell) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        const cellIds = this.outgoings[cellId];
        return cellIds
            ? cellIds
                .map((id) => this.getCell(id))
                .filter((cell) => cell && cell.isEdge())
            : null;
    }
    /**
     * Returns all incoming edges for the node.
     */
    getIncomingEdges(cell) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        const cellIds = this.incomings[cellId];
        return cellIds
            ? cellIds
                .map((id) => this.getCell(id))
                .filter((cell) => cell && cell.isEdge())
            : null;
    }
    /**
     * Returns edges connected with cell.
     */
    getConnectedEdges(cell, options = {}) {
        const result = [];
        const node = typeof cell === 'string' ? this.getCell(cell) : cell;
        if (node == null) {
            return result;
        }
        const cache = {};
        const indirect = options.indirect;
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        const collect = (cell, isOutgoing) => {
            const edges = isOutgoing
                ? this.getOutgoingEdges(cell)
                : this.getIncomingEdges(cell);
            if (edges != null) {
                edges.forEach((edge) => {
                    if (cache[edge.id]) {
                        return;
                    }
                    result.push(edge);
                    cache[edge.id] = true;
                    if (indirect) {
                        if (incoming) {
                            collect(edge, false);
                        }
                        if (outgoing) {
                            collect(edge, true);
                        }
                    }
                });
            }
            if (indirect && cell.isEdge()) {
                const terminal = isOutgoing
                    ? cell.getTargetCell()
                    : cell.getSourceCell();
                if (terminal && terminal.isEdge()) {
                    if (!cache[terminal.id]) {
                        result.push(terminal);
                        collect(terminal, isOutgoing);
                    }
                }
            }
        };
        if (outgoing) {
            collect(node, true);
        }
        if (incoming) {
            collect(node, false);
        }
        if (options.deep) {
            const descendants = node.getDescendants({ deep: true });
            const embedsCache = {};
            descendants.forEach((cell) => {
                if (cell.isNode()) {
                    embedsCache[cell.id] = true;
                }
            });
            const collectSub = (cell, isOutgoing) => {
                const edges = isOutgoing
                    ? this.getOutgoingEdges(cell.id)
                    : this.getIncomingEdges(cell.id);
                if (edges != null) {
                    edges.forEach((edge) => {
                        if (!cache[edge.id]) {
                            const sourceCell = edge.getSourceCell();
                            const targetCell = edge.getTargetCell();
                            if (!options.enclosed &&
                                sourceCell &&
                                embedsCache[sourceCell.id] &&
                                targetCell &&
                                embedsCache[targetCell.id]) {
                                return;
                            }
                            result.push(edge);
                            cache[edge.id] = true;
                        }
                    });
                }
            };
            descendants.forEach((cell) => {
                if (cell.isEdge()) {
                    return;
                }
                if (outgoing) {
                    collectSub(cell, true);
                }
                if (incoming) {
                    collectSub(cell, false);
                }
            });
        }
        return result;
    }
    isBoundary(cell, isOrigin) {
        const node = typeof cell === 'string' ? this.getCell(cell) : cell;
        const arr = isOrigin
            ? this.getIncomingEdges(node)
            : this.getOutgoingEdges(node);
        return arr == null || arr.length === 0;
    }
    getBoundaryNodes(isOrigin) {
        const result = [];
        Object.keys(this.nodes).forEach((nodeId) => {
            if (this.isBoundary(nodeId, isOrigin)) {
                const node = this.getCell(nodeId);
                if (node) {
                    result.push(node);
                }
            }
        });
        return result;
    }
    /**
     * Returns an array of all the roots of the graph.
     */
    getRoots() {
        return this.getBoundaryNodes(true);
    }
    /**
     * Returns an array of all the leafs of the graph.
     */
    getLeafs() {
        return this.getBoundaryNodes(false);
    }
    /**
     * Returns `true` if the node is a root node, i.e. there is no edges
     * coming to the node.
     */
    isRoot(cell) {
        return this.isBoundary(cell, true);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e. there is no edges
     * going out from the node.
     */
    isLeaf(cell) {
        return this.isBoundary(cell, false);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */
    getNeighbors(cell, options = {}) {
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        const edges = this.getConnectedEdges(cell, options);
        const map = edges.reduce((memo, edge) => {
            const hasLoop = edge.hasLoop(options);
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (incoming &&
                sourceCell &&
                sourceCell.isNode() &&
                !memo[sourceCell.id]) {
                if (hasLoop ||
                    (sourceCell !== cell &&
                        (!options.deep || !sourceCell.isDescendantOf(cell)))) {
                    memo[sourceCell.id] = sourceCell;
                }
            }
            if (outgoing &&
                targetCell &&
                targetCell.isNode() &&
                !memo[targetCell.id]) {
                if (hasLoop ||
                    (targetCell !== cell &&
                        (!options.deep || !targetCell.isDescendantOf(cell)))) {
                    memo[targetCell.id] = targetCell;
                }
            }
            return memo;
        }, {});
        if (cell.isEdge()) {
            if (incoming) {
                const sourceCell = cell.getSourceCell();
                if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {
                    map[sourceCell.id] = sourceCell;
                }
            }
            if (outgoing) {
                const targetCell = cell.getTargetCell();
                if (targetCell && targetCell.isNode() && !map[targetCell.id]) {
                    map[targetCell.id] = targetCell;
                }
            }
        }
        return Object.keys(map).map((id) => map[id]);
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */
    isNeighbor(cell1, cell2, options = {}) {
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        return this.getConnectedEdges(cell1, options).some((edge) => {
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (incoming && sourceCell && sourceCell.id === cell2.id) {
                return true;
            }
            if (outgoing && targetCell && targetCell.id === cell2.id) {
                return true;
            }
            return false;
        });
    }
    getSuccessors(cell, options = {}) {
        const successors = [];
        this.search(cell, (curr, distance) => {
            if (curr !== cell && this.matchDistance(distance, options.distance)) {
                successors.push(curr);
            }
        }, Object.assign(Object.assign({}, options), { outgoing: true }));
        return successors;
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */
    isSuccessor(cell1, cell2, options = {}) {
        let result = false;
        this.search(cell1, (curr, distance) => {
            if (curr === cell2 &&
                curr !== cell1 &&
                this.matchDistance(distance, options.distance)) {
                result = true;
                return false;
            }
        }, Object.assign(Object.assign({}, options), { outgoing: true }));
        return result;
    }
    getPredecessors(cell, options = {}) {
        const predecessors = [];
        this.search(cell, (curr, distance) => {
            if (curr !== cell && this.matchDistance(distance, options.distance)) {
                predecessors.push(curr);
            }
        }, Object.assign(Object.assign({}, options), { incoming: true }));
        return predecessors;
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */
    isPredecessor(cell1, cell2, options = {}) {
        let result = false;
        this.search(cell1, (curr, distance) => {
            if (curr === cell2 &&
                curr !== cell1 &&
                this.matchDistance(distance, options.distance)) {
                result = true;
                return false;
            }
        }, Object.assign(Object.assign({}, options), { incoming: true }));
        return result;
    }
    matchDistance(distance, preset) {
        if (preset == null) {
            return true;
        }
        if (typeof preset === 'function') {
            return preset(distance);
        }
        if (Array.isArray(preset) && preset.includes(distance)) {
            return true;
        }
        return distance === preset;
    }
    /**
     * Returns the common ancestor of the passed cells.
     */
    getCommonAncestor(...cells) {
        const arr = [];
        cells.forEach((item) => {
            if (item) {
                if (Array.isArray(item)) {
                    arr.push(...item);
                }
                else {
                    arr.push(item);
                }
            }
        });
        return Cell.getCommonAncestor(...arr);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */
    getSubGraph(cells, options = {}) {
        const subgraph = [];
        const cache = {};
        const nodes = [];
        const edges = [];
        const collect = (cell) => {
            if (!cache[cell.id]) {
                subgraph.push(cell);
                cache[cell.id] = cell;
                if (cell.isEdge()) {
                    edges.push(cell);
                }
                if (cell.isNode()) {
                    nodes.push(cell);
                }
            }
        };
        cells.forEach((cell) => {
            collect(cell);
            if (options.deep) {
                const descendants = cell.getDescendants({ deep: true });
                descendants.forEach((descendant) => collect(descendant));
            }
        });
        edges.forEach((edge) => {
            // For edges, include their source & target
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (sourceCell && !cache[sourceCell.id]) {
                subgraph.push(sourceCell);
                cache[sourceCell.id] = sourceCell;
                if (sourceCell.isNode()) {
                    nodes.push(sourceCell);
                }
            }
            if (targetCell && !cache[targetCell.id]) {
                subgraph.push(targetCell);
                cache[targetCell.id] = targetCell;
                if (targetCell.isNode()) {
                    nodes.push(targetCell);
                }
            }
        });
        nodes.forEach((node) => {
            // For nodes, include their connected edges if their source/target
            // is in the subgraph.
            const edges = this.getConnectedEdges(node, options);
            edges.forEach((edge) => {
                const sourceCell = edge.getSourceCell();
                const targetCell = edge.getTargetCell();
                if (!cache[edge.id] &&
                    sourceCell &&
                    cache[sourceCell.id] &&
                    targetCell &&
                    cache[targetCell.id]) {
                    subgraph.push(edge);
                    cache[edge.id] = edge;
                }
            });
        });
        return subgraph;
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */
    cloneSubGraph(cells, options = {}) {
        const subgraph = this.getSubGraph(cells, options);
        return this.cloneCells(subgraph);
    }
    cloneCells(cells) {
        return Cell.cloneCells(cells);
    }
    getNodesFromPoint(x, y) {
        const p = typeof x === 'number' ? { x, y: y || 0 } : x;
        return this.getNodes().filter((node) => {
            return node.getBBox().containsPoint(p);
        });
    }
    getNodesInArea(x, y, w, h, options) {
        const rect = typeof x === 'number'
            ? new Rectangle(x, y, w, h)
            : Rectangle.create(x);
        const opts = typeof x === 'number' ? options : y;
        const strict = opts && opts.strict;
        return this.getNodes().filter((node) => {
            const bbox = node.getBBox();
            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
        });
    }
    getEdgesInArea(x, y, w, h, options) {
        const rect = typeof x === 'number'
            ? new Rectangle(x, y, w, h)
            : Rectangle.create(x);
        const opts = typeof x === 'number' ? options : y;
        const strict = opts && opts.strict;
        return this.getEdges().filter((edge) => {
            const bbox = edge.getBBox();
            if (bbox.width === 0) {
                bbox.inflate(1, 0);
            }
            else if (bbox.height === 0) {
                bbox.inflate(0, 1);
            }
            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
        });
    }
    getNodesUnderNode(node, options = {}) {
        const bbox = node.getBBox();
        const nodes = options.by == null || options.by === 'bbox'
            ? this.getNodesInArea(bbox)
            : this.getNodesFromPoint(bbox[options.by]);
        return nodes.filter((curr) => node.id !== curr.id && !curr.isDescendantOf(node));
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */
    getAllCellsBBox() {
        return this.getCellsBBox(this.getCells());
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */
    getCellsBBox(cells, options = {}) {
        return Cell.getCellsBBox(cells, options);
    }
    // #region search
    search(cell, iterator, options = {}) {
        if (options.breadthFirst) {
            this.breadthFirstSearch(cell, iterator, options);
        }
        else {
            this.depthFirstSearch(cell, iterator, options);
        }
    }
    breadthFirstSearch(cell, iterator, options = {}) {
        const queue = [];
        const visited = {};
        const distance = {};
        queue.push(cell);
        distance[cell.id] = 0;
        while (queue.length > 0) {
            const next = queue.shift();
            if (next == null || visited[next.id]) {
                continue;
            }
            visited[next.id] = true;
            if (call(iterator, this, next, distance[next.id]) === false) {
                continue;
            }
            const neighbors = this.getNeighbors(next, options);
            neighbors.forEach((neighbor) => {
                distance[neighbor.id] = distance[next.id] + 1;
                queue.push(neighbor);
            });
        }
    }
    depthFirstSearch(cell, iterator, options = {}) {
        const queue = [];
        const visited = {};
        const distance = {};
        queue.push(cell);
        distance[cell.id] = 0;
        while (queue.length > 0) {
            const next = queue.pop();
            if (next == null || visited[next.id]) {
                continue;
            }
            visited[next.id] = true;
            if (call(iterator, this, next, distance[next.id]) === false) {
                continue;
            }
            const neighbors = this.getNeighbors(next, options);
            const lastIndex = queue.length;
            neighbors.forEach((neighbor) => {
                distance[neighbor.id] = distance[next.id] + 1;
                queue.splice(lastIndex, 0, neighbor);
            });
        }
    }
    // #endregion
    // #region shortest path
    /** *
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */
    getShortestPath(source, target, options = {}) {
        const adjacencyList = {};
        this.getEdges().forEach((edge) => {
            const sourceId = edge.getSourceCellId();
            const targetId = edge.getTargetCellId();
            if (sourceId && targetId) {
                if (!adjacencyList[sourceId]) {
                    adjacencyList[sourceId] = [];
                }
                if (!adjacencyList[targetId]) {
                    adjacencyList[targetId] = [];
                }
                adjacencyList[sourceId].push(targetId);
                if (!options.directed) {
                    adjacencyList[targetId].push(sourceId);
                }
            }
        });
        const sourceId = typeof source === 'string' ? source : source.id;
        const previous = Dijkstra.run(adjacencyList, sourceId, options.weight);
        const path = [];
        let targetId = typeof target === 'string' ? target : target.id;
        if (previous[targetId]) {
            path.push(targetId);
        }
        while ((targetId = previous[targetId])) {
            path.unshift(targetId);
        }
        return path;
    }
    // #endregion
    // #region transform
    /**
     * Translate all cells in the graph by `tx` and `ty` pixels.
     */
    translate(tx, ty, options) {
        this.getCells()
            .filter((cell) => !cell.hasParent())
            .forEach((cell) => cell.translate(tx, ty, options));
        return this;
    }
    resize(width, height, options) {
        return this.resizeCells(width, height, this.getCells(), options);
    }
    resizeCells(width, height, cells, options = {}) {
        const bbox = this.getCellsBBox(cells);
        if (bbox) {
            const sx = Math.max(width / bbox.width, 0);
            const sy = Math.max(height / bbox.height, 0);
            const origin = bbox.getOrigin();
            cells.forEach((cell) => cell.scale(sx, sy, origin, options));
        }
        return this;
    }
    // #endregion
    // #region serialize/deserialize
    toJSON(options = {}) {
        return Model.toJSON(this.getCells(), options);
    }
    parseJSON(data) {
        return Model.fromJSON(data);
    }
    fromJSON(data, options = {}) {
        const cells = this.parseJSON(data);
        this.resetCells(cells, options);
        return this;
    }
    // #endregion
    // #region batch
    startBatch(name, data = {}) {
        this.batches[name] = (this.batches[name] || 0) + 1;
        this.notify('batch:start', { name, data });
        return this;
    }
    stopBatch(name, data = {}) {
        this.batches[name] = (this.batches[name] || 0) - 1;
        this.notify('batch:stop', { name, data });
        return this;
    }
    batchUpdate(name, execute, data = {}) {
        this.startBatch(name, data);
        const result = execute();
        this.stopBatch(name, data);
        return result;
    }
    hasActiveBatch(name = Object.keys(this.batches)) {
        const names = Array.isArray(name) ? name : [name];
        return names.some((batch) => this.batches[batch] > 0);
    }
}
(function (Model) {
    Model.toStringTag = `X6.${Model.name}`;
    function isModel(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Model) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const model = instance;
        if ((tag == null || tag === Model.toStringTag) &&
            typeof model.addNode === 'function' &&
            typeof model.addEdge === 'function' &&
            model.collection != null) {
            return true;
        }
        return false;
    }
    Model.isModel = isModel;
})(Model || (Model = {}));
(function (Model) {
    function toJSON(cells, options = {}) {
        return {
            cells: cells.map((cell) => cell.toJSON(options)),
        };
    }
    Model.toJSON = toJSON;
    function fromJSON(data) {
        const cells = [];
        if (Array.isArray(data)) {
            cells.push(...data);
        }
        else {
            if (data.cells) {
                cells.push(...data.cells);
            }
            if (data.nodes) {
                data.nodes.forEach((node) => {
                    if (node.shape == null) {
                        node.shape = 'rect';
                    }
                    cells.push(node);
                });
            }
            if (data.edges) {
                data.edges.forEach((edge) => {
                    if (edge.shape == null) {
                        edge.shape = 'edge';
                    }
                    cells.push(edge);
                });
            }
        }
        return cells.map((cell) => {
            const type = cell.shape;
            if (type) {
                if (Node$1.registry.exist(type)) {
                    return Node$1.create(cell);
                }
                if (Edge$1.registry.exist(type)) {
                    return Edge$1.create(cell);
                }
            }
            throw new Error('The `shape` should be specified when creating a node/edge instance');
        });
    }
    Model.fromJSON = fromJSON;
})(Model || (Model = {}));

const contentSelector = '.text-block-content';
const registryName = getName('text-block');
let TextBlock$1 = class TextBlock extends Node$1 {
    get content() {
        return this.getContent();
    }
    set content(val) {
        this.setContent(val);
    }
    getContent() {
        return this.store.get('content', '');
    }
    setContent(content, options = {}) {
        this.store.set('content', content, options);
    }
    setup() {
        super.setup();
        this.store.on('change:*', (metadata) => {
            const key = metadata.key;
            if (key === 'content') {
                this.updateContent(this.getContent());
            }
            else if (key === 'size') {
                this.updateSize(this.getSize());
            }
        });
        this.updateSize(this.getSize());
        this.updateContent(this.getContent());
    }
    updateSize(size) {
        if (Platform.SUPPORT_FOREIGNOBJECT) {
            this.setAttrs({
                foreignObject: Object.assign({}, size),
                [contentSelector]: {
                    style: Object.assign({}, size),
                },
            });
        }
    }
    updateContent(content) {
        if (Platform.SUPPORT_FOREIGNOBJECT) {
            this.setAttrs({
                [contentSelector]: {
                    html: content ? sanitizeHTML(content) : '',
                },
            });
        }
        else {
            this.setAttrs({
                [contentSelector]: {
                    text: content,
                },
            });
        }
    }
};
(function (TextBlock) {
    TextBlock.config({
        type: registryName,
        view: registryName,
        markup: [
            '<g class="rotatable">',
            '<g class="scalable"><rect/></g>',
            Platform.SUPPORT_FOREIGNOBJECT
                ? [
                    `<foreignObject>`,
                    `<body xmlns="http://www.w3.org/1999/xhtml">`,
                    `<div class="${contentSelector.substr(1)}" />`,
                    `</body>`,
                    `</foreignObject>`,
                ].join('')
                : `<text class="${contentSelector.substr(1)}"/>`,
            '</g>',
        ].join(''),
        attrs: {
            '.': {
                fill: '#ffffff',
                stroke: 'none',
            },
            rect: {
                fill: '#ffffff',
                stroke: '#000000',
                width: 80,
                height: 100,
            },
            text: {
                fill: '#000000',
                fontSize: 14,
                fontFamily: 'Arial, helvetica, sans-serif',
            },
            body: {
                style: {
                    background: 'transparent',
                    position: 'static',
                    margin: 0,
                    padding: 0,
                },
            },
            foreignObject: {
                style: {
                    overflow: 'hidden',
                },
            },
            [contentSelector]: {
                refX: 0.5,
                refY: 0.5,
                yAlign: 'middle',
                xAlign: 'middle',
                style: {
                    textAlign: 'center',
                    verticalAlign: 'middle',
                    display: 'table-cell',
                    padding: '0 5px',
                    margin: 0,
                },
            },
        },
    });
    Node$1.registry.register(registryName, TextBlock);
})(TextBlock$1 || (TextBlock$1 = {}));
(function (TextBlock) {
    const contentAction = 'content';
    class View extends NodeView {
        confirmUpdate(flag, options = {}) {
            let ret = super.confirmUpdate(flag, options);
            if (this.hasAction(ret, contentAction)) {
                this.updateContent();
                ret = this.removeAction(ret, contentAction);
            }
            return ret;
        }
        update(partialAttrs) {
            if (Platform.SUPPORT_FOREIGNOBJECT) {
                super.update(partialAttrs);
            }
            else {
                const node = this.cell;
                const attrs = Object.assign({}, (partialAttrs || node.getAttrs()));
                delete attrs[contentSelector];
                super.update(attrs);
                if (!partialAttrs || has(partialAttrs, contentSelector)) {
                    this.updateContent(partialAttrs);
                }
            }
        }
        updateContent(partialAttrs) {
            if (Platform.SUPPORT_FOREIGNOBJECT) {
                super.update(partialAttrs);
            }
            else {
                const node = this.cell;
                const textAttrs = (partialAttrs || node.getAttrs())[contentSelector];
                // Break the text to fit the node size taking into
                // account the attributes set on the node.
                const text = breakText(node.getContent(), node.getSize(), textAttrs, {
                    svgDocument: this.graph.view.svg,
                });
                const attrs = {
                    [contentSelector]: merge({}, textAttrs, { text }),
                };
                super.update(attrs);
            }
        }
    }
    TextBlock.View = View;
    (function (View) {
        View.config({
            bootstrap: ['render', contentAction],
            actions: Platform.SUPPORT_FOREIGNOBJECT
                ? {}
                : {
                    size: contentAction,
                    content: contentAction,
                },
        });
        NodeView.registry.register(registryName, View);
    })(View = TextBlock.View || (TextBlock.View = {}));
})(TextBlock$1 || (TextBlock$1 = {}));

var index$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Circle: Circle$1,
	Cylinder: Cylinder$1,
	Ellipse: Ellipse$1,
	Image: Image$2,
	Path: Path$1,
	Polygon: Polygon$1,
	Polyline: Polyline$1,
	Rect: Rect$1,
	Rhombus: Rhombus,
	get Text () { return Text; },
	get TextBlock () { return TextBlock$1; }
});

const Empty = Base$1.define({
    shape: 'empty',
});

function getMarkup(tagName, selector = 'body') {
    return [
        {
            tagName,
            selector,
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ];
}
function createShape(shape, config, options = {}) {
    const defaults = {
        constructorName: shape,
        markup: getMarkup(shape, options.selector),
        attrs: {
            [shape]: Object.assign({}, Base$1.bodyAttr),
        },
    };
    const base = options.parent || Base$1;
    return base.define(merge(defaults, config, { shape }));
}

const Rect = createShape('rect', {
    attrs: {
        body: {
            refWidth: '100%',
            refHeight: '100%',
        },
    },
});

const HeaderedRect = Node$1.define({
    shape: 'rect-headered',
    markup: [
        {
            tagName: 'rect',
            selector: 'body',
        },
        {
            tagName: 'rect',
            selector: 'header',
        },
        {
            tagName: 'text',
            selector: 'headerText',
        },
        {
            tagName: 'text',
            selector: 'bodyText',
        },
    ],
    attrs: {
        body: Object.assign(Object.assign({}, Base$1.bodyAttr), { refWidth: '100%', refHeight: '100%' }),
        header: Object.assign(Object.assign({}, Base$1.bodyAttr), { refWidth: '100%', height: 30, stroke: '#000000' }),
        headerText: Object.assign(Object.assign({}, Base$1.labelAttr), { refX: '50%', refY: 15, fontSize: 16 }),
        bodyText: Object.assign(Object.assign({}, Base$1.labelAttr), { refY2: 15 }),
    },
});

const Circle = createShape('circle', {
    attrs: {
        body: {
            refCx: '50%',
            refCy: '50%',
            refR: '50%',
        },
    },
});

const CYLINDER_TILT = 10;
const Cylinder = Base$1.define({
    shape: 'cylinder',
    overwrite: true,
    markup: [
        {
            tagName: 'path',
            selector: 'body',
        },
        {
            tagName: 'ellipse',
            selector: 'top',
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ],
    attrs: {
        body: Object.assign(Object.assign({}, Base$1.bodyAttr), { lateral: CYLINDER_TILT }),
        top: Object.assign(Object.assign({}, Base$1.bodyAttr), { refCx: '50%', refRx: '50%', cy: CYLINDER_TILT, ry: CYLINDER_TILT }),
    },
    attrHooks: {
        lateral: {
            set(t, { refBBox }) {
                const isPercentage$1 = isPercentage(t);
                if (isPercentage$1) {
                    // eslint-disable-next-line
                    t = parseFloat(t) / 100;
                }
                const x = refBBox.x;
                const y = refBBox.y;
                const w = refBBox.width;
                const h = refBBox.height;
                // curve control point variables
                const rx = w / 2;
                const ry = isPercentage$1 ? h * t : t;
                const kappa = 0.551784;
                const cx = kappa * rx;
                const cy = kappa * ry;
                // shape variables
                const xLeft = x;
                const xCenter = x + w / 2;
                const xRight = x + w;
                const ySideTop = y + ry;
                const yCurveTop = ySideTop - ry;
                const ySideBottom = y + h - ry;
                const yCurveBottom = y + h;
                // return calculated shape
                const data = [
                    'M',
                    xLeft,
                    ySideTop,
                    'L',
                    xLeft,
                    ySideBottom,
                    'C',
                    x,
                    ySideBottom + cy,
                    xCenter - cx,
                    yCurveBottom,
                    xCenter,
                    yCurveBottom,
                    'C',
                    xCenter + cx,
                    yCurveBottom,
                    xRight,
                    ySideBottom + cy,
                    xRight,
                    ySideBottom,
                    'L',
                    xRight,
                    ySideTop,
                    'C',
                    xRight,
                    ySideTop - cy,
                    xCenter + cx,
                    yCurveTop,
                    xCenter,
                    yCurveTop,
                    'C',
                    xCenter - cx,
                    yCurveTop,
                    xLeft,
                    ySideTop - cy,
                    xLeft,
                    ySideTop,
                    'Z',
                ];
                return { d: data.join(' ') };
            },
        },
    },
    knob: {
        enabled: true,
        position({ node }) {
            const lateral = node.attr('body/lateral');
            return { x: 0, y: lateral };
        },
        onMouseMove({ node, data, deltaY }) {
            if (deltaY !== 0) {
                const bbox = node.getBBox();
                const previous = node.attr('body/lateral');
                if (data.round == null) {
                    data.round = previous;
                }
                const min = 0;
                const max = bbox.height / 2;
                const current = clamp$1(data.round + deltaY, min, max);
                if (current !== previous) {
                    node.attr({
                        body: { lateral: current },
                        top: {
                            cy: current,
                            ry: current,
                        },
                    });
                }
            }
        },
    },
});

const Ellipse = createShape('ellipse', {
    attrs: {
        body: {
            refCx: '50%',
            refCy: '50%',
            refRx: '50%',
            refRy: '50%',
        },
    },
});

var __rest$c = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Poly extends Base$1 {
    get points() {
        return this.getPoints();
    }
    set points(pts) {
        this.setPoints(pts);
    }
    getPoints() {
        return this.getAttrByPath('body/refPoints');
    }
    setPoints(points, options) {
        if (points == null) {
            this.removePoints();
        }
        else {
            this.setAttrByPath('body/refPoints', Poly.pointsToString(points), options);
        }
        return this;
    }
    removePoints() {
        this.removeAttrByPath('body/refPoints');
        return this;
    }
}
(function (Poly) {
    function pointsToString(points) {
        return typeof points === 'string'
            ? points
            : points
                .map((p) => {
                if (Array.isArray(p)) {
                    return p.join(',');
                }
                if (Point.isPointLike(p)) {
                    return `${p.x}, ${p.y}`;
                }
                return '';
            })
                .join(' ');
    }
    Poly.pointsToString = pointsToString;
    Poly.config({
        propHooks(metadata) {
            const { points } = metadata, others = __rest$c(metadata, ["points"]);
            if (points) {
                const data = pointsToString(points);
                if (data) {
                    setByPath(others, 'attrs/body/refPoints', data);
                }
            }
            return others;
        },
    });
})(Poly || (Poly = {}));

const Polygon = createShape('polygon', {}, { parent: Poly });

const Polyline = createShape('polyline', {}, { parent: Poly });

var __rest$b = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const Path = Base$1.define({
    shape: 'path',
    markup: [
        {
            tagName: 'rect',
            selector: 'bg',
        },
        {
            tagName: 'path',
            selector: 'body',
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ],
    attrs: {
        bg: {
            refWidth: '100%',
            refHeight: '100%',
            fill: 'none',
            stroke: 'none',
            pointerEvents: 'all',
        },
        body: {
            fill: 'none',
            stroke: '#000',
            strokeWidth: 2,
        },
    },
    propHooks(metadata) {
        const { path } = metadata, others = __rest$b(metadata, ["path"]);
        if (path) {
            setByPath(others, 'attrs/body/refD', path);
        }
        return others;
    },
});

var __rest$a = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const TextBlock = Base$1.define({
    shape: 'text-block',
    markup: [
        {
            tagName: 'rect',
            selector: 'body',
        },
        Platform.SUPPORT_FOREIGNOBJECT
            ? {
                tagName: 'foreignObject',
                selector: 'foreignObject',
                children: [
                    {
                        tagName: 'div',
                        ns: ns.xhtml,
                        selector: 'label',
                        style: {
                            width: '100%',
                            height: '100%',
                            position: 'static',
                            backgroundColor: 'transparent',
                            textAlign: 'center',
                            margin: 0,
                            padding: '0px 5px',
                            boxSizing: 'border-box',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                        },
                    },
                ],
            }
            : {
                tagName: 'text',
                selector: 'label',
                attrs: {
                    textAnchor: 'middle',
                },
            },
    ],
    attrs: {
        body: Object.assign(Object.assign({}, Base$1.bodyAttr), { refWidth: '100%', refHeight: '100%' }),
        foreignObject: {
            refWidth: '100%',
            refHeight: '100%',
        },
        label: {
            style: {
                fontSize: 14,
            },
        },
    },
    propHooks(metadata) {
        const { text } = metadata, others = __rest$a(metadata, ["text"]);
        if (text) {
            setByPath(others, 'attrs/label/text', text);
        }
        return others;
    },
    attrHooks: {
        text: {
            set(text, { cell, view, refBBox, elem, attrs }) {
                if (elem instanceof HTMLElement) {
                    elem.textContent = text;
                }
                else {
                    // No foreign object
                    const style = attrs.style || {};
                    const wrapValue = { text, width: -5, height: '100%' };
                    const wrapAttrs = Object.assign({ textVerticalAnchor: 'middle' }, style);
                    const textWrap = Attr.presets.textWrap;
                    call(textWrap.set, this, wrapValue, {
                        cell,
                        view,
                        elem,
                        refBBox,
                        attrs: wrapAttrs,
                    });
                    return { fill: style.color || null };
                }
            },
            position(text, { refBBox, elem }) {
                if (elem instanceof SVGElement) {
                    return refBBox.getCenter();
                }
            },
        },
    },
});

const Image$1 = createShape('image', {
    attrs: {
        image: {
            refWidth: '100%',
            refHeight: '100%',
        },
    },
    propHooks: getImageUrlHook(),
}, {
    selector: 'image',
});

const BorderedImage = createShape('image-bordered', {
    markup: [
        {
            tagName: 'rect',
            selector: 'background',
            attrs: {
                stroke: 'none',
            },
        },
        {
            tagName: 'image',
            selector: 'image',
        },
        {
            tagName: 'rect',
            selector: 'border',
            attrs: {
                fill: 'none',
            },
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ],
    attrs: {
        background: {
            refWidth: -1,
            refHeight: -1,
            x: 0.5,
            y: 0.5,
            fill: '#ffffff',
        },
        border: {
            refWidth: '100%',
            refHeight: '100%',
            stroke: '#333333',
            strokeWidth: 2,
        },
        image: {
            // xlinkHref: '[URL]'
            refWidth: -1,
            refHeight: -1,
            x: 0.5,
            y: 0.5,
        },
    },
    propHooks: getImageUrlHook(),
});

const EmbeddedImage = createShape('image-embedded', {
    markup: [
        {
            tagName: 'rect',
            selector: 'body',
        },
        {
            tagName: 'image',
            selector: 'image',
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ],
    attrs: {
        body: {
            refWidth: '100%',
            refHeight: '100%',
            stroke: '#333333',
            fill: '#FFFFFF',
            strokeWidth: 2,
        },
        image: {
            // xlinkHref: '[URL]'
            refWidth: '30%',
            refHeight: -20,
            x: 10,
            y: 10,
            preserveAspectRatio: 'xMidYMin',
        },
    },
    propHooks: getImageUrlHook(),
});

const InscribedImage = createShape('image-inscribed', {
    propHooks: getImageUrlHook(),
    markup: [
        {
            tagName: 'ellipse',
            selector: 'background',
        },
        {
            tagName: 'image',
            selector: 'image',
        },
        {
            tagName: 'ellipse',
            selector: 'border',
            attrs: {
                fill: 'none',
            },
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ],
    attrs: {
        border: {
            refRx: '50%',
            refRy: '50%',
            refCx: '50%',
            refCy: '50%',
            stroke: '#333333',
            strokeWidth: 2,
        },
        background: {
            refRx: '50%',
            refRy: '50%',
            refCx: '50%',
            refCy: '50%',
            fill: '#ffffff',
        },
        image: {
            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%
            refWidth: '68%',
            refHeight: '68%',
            // The image offset is calculated as (100% - 68%) / 2
            refX: '16%',
            refY: '16%',
            preserveAspectRatio: 'xMidYMid',
            // xlinkHref: '[URL]'
        },
        // label: {
        //   refX: '50%',
        //   refY: '100%',
        //   refY2: 10,
        //   textAnchor: 'middle',
        //   textVerticalAnchor: 'top',
        // },
    },
});

const Edge = Edge$1.define({
    shape: 'edge',
    markup: [
        {
            tagName: 'path',
            selector: 'wrap',
            groupSelector: 'lines',
            attrs: {
                fill: 'none',
                cursor: 'pointer',
                stroke: 'transparent',
                strokeLinecap: 'round',
            },
        },
        {
            tagName: 'path',
            selector: 'line',
            groupSelector: 'lines',
            attrs: {
                fill: 'none',
                pointerEvents: 'none',
            },
        },
    ],
    attrs: {
        lines: {
            connection: true,
            strokeLinejoin: 'round',
        },
        wrap: {
            strokeWidth: 10,
        },
        line: {
            stroke: '#333',
            strokeWidth: 2,
            targetMarker: 'classic',
        },
    },
});

const ShadowEdge = Edge$1.define({
    shape: 'shadow-edge',
    markup: [
        {
            tagName: 'path',
            selector: 'shadow',
            attrs: {
                fill: 'none',
            },
        },
        {
            tagName: 'path',
            selector: 'line',
            attrs: {
                fill: 'none',
                cursor: 'pointer',
            },
        },
    ],
    attrs: {
        line: {
            connection: true,
            stroke: '#FF0000',
            strokeWidth: 20,
            strokeLinejoin: 'round',
            targetMarker: {
                name: 'path',
                stroke: 'none',
                d: 'M 0 -10 -10 0 0 10 z',
                offsetX: -5,
            },
            sourceMarker: {
                name: 'path',
                stroke: 'none',
                d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z',
                offsetX: -5,
            },
        },
        shadow: {
            connection: true,
            refX: 3,
            refY: 6,
            stroke: '#000000',
            strokeOpacity: 0.2,
            strokeWidth: 20,
            strokeLinejoin: 'round',
            targetMarker: {
                name: 'path',
                d: 'M 0 -10 -10 0 0 10 z',
                stroke: 'none',
                offsetX: -5,
            },
            sourceMarker: {
                name: 'path',
                stroke: 'none',
                d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z',
                offsetX: -5,
            },
        },
    },
});

const DoubleEdge = Edge$1.define({
    shape: 'double-edge',
    markup: [
        {
            tagName: 'path',
            selector: 'outline',
            attrs: {
                fill: 'none',
            },
        },
        {
            tagName: 'path',
            selector: 'line',
            attrs: {
                fill: 'none',
                cursor: 'pointer',
            },
        },
    ],
    attrs: {
        line: {
            connection: true,
            stroke: '#dddddd',
            strokeWidth: 4,
            strokeLinejoin: 'round',
            targetMarker: {
                tagName: 'path',
                stroke: '#000000',
                d: 'M 10 -3 10 -10 -2 0 10 10 10 3',
            },
        },
        outline: {
            connection: true,
            stroke: '#000000',
            strokeWidth: 6,
            strokeLinejoin: 'round',
        },
    },
});

class HTML extends Base$1 {
    get html() {
        return this.getHTML();
    }
    set html(val) {
        this.setHTML(val);
    }
    getHTML() {
        return this.store.get('html');
    }
    setHTML(html, options = {}) {
        if (html == null) {
            this.removeHTML(options);
        }
        else {
            this.store.set('html', html, options);
        }
        return this;
    }
    removeHTML(options = {}) {
        return this.store.remove('html', options);
    }
}
(function (HTML) {
    class View extends NodeView {
        init() {
            super.init();
            this.cell.on('change:*', () => {
                const shouldUpdate = this.graph.hook.shouldUpdateHTMLComponent(this.cell);
                if (shouldUpdate) {
                    this.renderHTMLComponent();
                }
            });
        }
        confirmUpdate(flag) {
            const ret = super.confirmUpdate(flag);
            return this.handleAction(ret, View.action, () => this.renderHTMLComponent());
        }
        renderHTMLComponent() {
            const container = this.selectors && this.selectors.foContent;
            if (container) {
                const $wrap = this.$(container).empty();
                const component = this.graph.hook.getHTMLComponent(this.cell);
                if (component) {
                    if (typeof component === 'string') {
                        $wrap.html(component);
                    }
                    else {
                        $wrap.append(component);
                    }
                }
            }
        }
    }
    HTML.View = View;
    (function (View) {
        View.action = 'html';
        View.config({
            bootstrap: [View.action],
            actions: {
                html: View.action,
            },
        });
        NodeView.registry.register('html-view', View);
    })(View = HTML.View || (HTML.View = {}));
})(HTML || (HTML = {}));
(function (HTML) {
    HTML.config({
        view: 'html-view',
        markup: [
            {
                tagName: 'rect',
                selector: 'body',
            },
            Object.assign({}, Markup.getForeignObjectMarkup()),
            {
                tagName: 'text',
                selector: 'label',
            },
        ],
        attrs: {
            body: {
                fill: 'none',
                stroke: 'none',
                refWidth: '100%',
                refHeight: '100%',
            },
            fo: {
                refWidth: '100%',
                refHeight: '100%',
            },
        },
    });
    Node$1.registry.register('html', HTML);
})(HTML || (HTML = {}));
(function (HTML) {
    HTML.componentRegistry = Registry.create({
        type: 'html componnet',
    });
})(HTML || (HTML = {}));

var index$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BorderedImage: BorderedImage,
	Circle: Circle,
	Cylinder: Cylinder,
	DoubleEdge: DoubleEdge,
	Edge: Edge,
	Ellipse: Ellipse,
	EmbeddedImage: EmbeddedImage,
	Empty: Empty,
	get HTML () { return HTML; },
	HeaderedRect: HeaderedRect,
	Image: Image$1,
	InscribedImage: InscribedImage,
	Path: Path,
	Polygon: Polygon,
	Polyline: Polyline,
	Rect: Rect,
	ShadowEdge: ShadowEdge,
	TextBlock: TextBlock
});

var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AutoSave extends Disablable {
    constructor(options) {
        super();
        this.delay = 10;
        this.throttle = 2;
        this.threshold = 5;
        this.changeCount = 0;
        this.timestamp = 0;
        this.options = Object.assign(Object.assign({}, AutoSave.defaultOptions), options);
        this.graph.model.on('cell:change:*', this.onModelChanged, this);
    }
    get graph() {
        return this.options.graph;
    }
    onModelChanged() {
        if (this.disabled) {
            return;
        }
        const now = new Date().getTime();
        const dt = (now - this.timestamp) / 1000;
        if (dt > this.delay ||
            (this.changeCount >= this.threshold && dt > this.throttle)) {
            this.save();
            this.reset();
        }
        else {
            this.changeCount += 1;
        }
    }
    save() {
        this.trigger('save');
    }
    reset() {
        this.changeCount = 0;
        this.timestamp = new Date().getTime();
    }
    dispose() {
        this.graph.model.off('cell:change:*', this.onModelChanged, this);
    }
}
__decorate$q([
    Disablable.dispose()
], AutoSave.prototype, "dispose", null);
(function (AutoSave) {
    AutoSave.defaultOptions = {
        delay: 10,
        throttle: 2,
        threshold: 5,
    };
})(AutoSave || (AutoSave = {}));

class Base extends Disposable {
    constructor(graph) {
        super();
        this.graph = graph;
        this.init();
    }
    get options() {
        return this.graph.options;
    }
    get model() {
        return this.graph.model;
    }
    get view() {
        return this.graph.view;
    }
    init() { }
}

var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class GraphView extends View {
    constructor(graph) {
        super();
        this.graph = graph;
        const { selectors, fragment } = Markup.parseJSONMarkup(GraphView.markup);
        this.background = selectors.background;
        this.grid = selectors.grid;
        this.svg = selectors.svg;
        this.defs = selectors.defs;
        this.viewport = selectors.viewport;
        this.primer = selectors.primer;
        this.stage = selectors.stage;
        this.decorator = selectors.decorator;
        this.overlay = selectors.overlay;
        this.container = this.options.container;
        this.restore = GraphView.snapshoot(this.container);
        this.$(this.container)
            .addClass(this.prefixClassName('graph'))
            .append(fragment);
        this.delegateEvents();
    }
    get model() {
        return this.graph.model;
    }
    get options() {
        return this.graph.options;
    }
    delegateEvents() {
        const ctor = this.constructor;
        super.delegateEvents(ctor.events);
        return this;
    }
    /**
     * Guard the specified event. If the event is not interesting, it
     * returns `true`, otherwise returns `false`.
     */
    guard(e, view) {
        // handled as `contextmenu` type
        if (e.type === 'mousedown' && e.button === 2) {
            return true;
        }
        if (this.options.guard && this.options.guard(e, view)) {
            return true;
        }
        if (e.data && e.data.guarded !== undefined) {
            return e.data.guarded;
        }
        if (view && view.cell && Cell.isCell(view.cell)) {
            return false;
        }
        if (this.svg === e.target ||
            this.container === e.target ||
            JQuery.contains(this.svg, e.target)) {
            return false;
        }
        return true;
    }
    findView(elem) {
        return this.graph.renderer.findViewByElem(elem);
    }
    onDblClick(evt) {
        if (this.options.preventDefaultDblClick) {
            evt.preventDefault();
        }
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onDblClick(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:dblclick', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    onClick(evt) {
        if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {
            const e = this.normalizeEvent(evt);
            const view = this.findView(e.target);
            if (this.guard(e, view)) {
                return;
            }
            const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
            if (view) {
                view.onClick(e, localPoint.x, localPoint.y);
            }
            else {
                this.graph.trigger('blank:click', {
                    e,
                    x: localPoint.x,
                    y: localPoint.y,
                });
            }
        }
    }
    isPreventDefaultContextMenu(evt, view) {
        let preventDefaultContextMenu = this.options.preventDefaultContextMenu;
        if (typeof preventDefaultContextMenu === 'function') {
            preventDefaultContextMenu = call(preventDefaultContextMenu, this.graph, { view });
        }
        return preventDefaultContextMenu;
    }
    onContextMenu(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.isPreventDefaultContextMenu(e, view)) {
            evt.preventDefault();
        }
        if (this.guard(e, view)) {
            return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onContextMenu(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:contextmenu', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    delegateDragEvents(e, view) {
        if (e.data == null) {
            e.data = {};
        }
        this.setEventData(e, {
            currentView: view || null,
            mouseMovedCount: 0,
            startPosition: {
                x: e.clientX,
                y: e.clientY,
            },
        });
        const ctor = this.constructor;
        this.delegateDocumentEvents(ctor.documentEvents, e.data);
        this.undelegateEvents();
    }
    getMouseMovedCount(e) {
        const data = this.getEventData(e);
        return data.mouseMovedCount || 0;
    }
    onMouseDown(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (this.options.preventDefaultMouseDown) {
            e.preventDefault();
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onMouseDown(e, localPoint.x, localPoint.y);
        }
        else {
            if (this.options.preventDefaultBlankAction &&
                ['touchstart'].includes(e.type)) {
                e.preventDefault();
            }
            this.graph.trigger('blank:mousedown', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        this.delegateDragEvents(e, view);
    }
    onMouseMove(evt) {
        const data = this.getEventData(evt);
        const startPosition = data.startPosition;
        if (startPosition &&
            startPosition.x === evt.clientX &&
            startPosition.y === evt.clientY) {
            return;
        }
        if (data.mouseMovedCount == null) {
            data.mouseMovedCount = 0;
        }
        data.mouseMovedCount += 1;
        const mouseMovedCount = data.mouseMovedCount;
        if (mouseMovedCount <= this.options.moveThreshold) {
            return;
        }
        const e = this.normalizeEvent(evt);
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        const view = data.currentView;
        if (view) {
            view.onMouseMove(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:mousemove', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        this.setEventData(e, data);
    }
    onMouseUp(e) {
        this.undelegateDocumentEvents();
        const normalized = this.normalizeEvent(e);
        const localPoint = this.graph.snapToGrid(normalized.clientX, normalized.clientY);
        const data = this.getEventData(e);
        const view = data.currentView;
        if (view) {
            view.onMouseUp(normalized, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:mouseup', {
                e: normalized,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        if (!e.isPropagationStopped()) {
            this.onClick(JQuery.Event(e, {
                type: 'click',
                data: e.data,
            }));
        }
        e.stopImmediatePropagation();
        this.delegateEvents();
    }
    onMouseOver(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (view) {
            view.onMouseOver(e);
        }
        else {
            // prevent border of paper from triggering this
            if (this.container === e.target) {
                return;
            }
            this.graph.trigger('blank:mouseover', { e });
        }
    }
    onMouseOut(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (view) {
            view.onMouseOut(e);
        }
        else {
            if (this.container === e.target) {
                return;
            }
            this.graph.trigger('blank:mouseout', { e });
        }
    }
    onMouseEnter(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const relatedView = this.graph.renderer.findViewByElem(e.relatedTarget);
        if (view) {
            if (relatedView === view) {
                // mouse moved from tool to view
                return;
            }
            view.onMouseEnter(e);
        }
        else {
            if (relatedView) {
                return;
            }
            this.graph.trigger('graph:mouseenter', { e });
        }
    }
    onMouseLeave(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const relatedView = this.graph.renderer.findViewByElem(e.relatedTarget);
        if (view) {
            if (relatedView === view) {
                // mouse moved from view to tool
                return;
            }
            view.onMouseLeave(e);
        }
        else {
            if (relatedView) {
                return;
            }
            this.graph.trigger('graph:mouseleave', { e });
        }
    }
    onMouseWheel(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const originalEvent = e.originalEvent;
        const localPoint = this.graph.snapToGrid(originalEvent.clientX, originalEvent.clientY);
        const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta || -originalEvent.detail));
        if (view) {
            view.onMouseWheel(e, localPoint.x, localPoint.y, delta);
        }
        else {
            this.graph.trigger('blank:mousewheel', {
                e,
                delta,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    onCustomEvent(evt) {
        const elem = evt.currentTarget;
        const event = elem.getAttribute('event') || elem.getAttribute('data-event');
        if (event) {
            const view = this.findView(elem);
            if (view) {
                const e = this.normalizeEvent(evt);
                if (this.guard(e, view)) {
                    return;
                }
                const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
                view.onCustomEvent(e, event, localPoint.x, localPoint.y);
            }
        }
    }
    handleMagnetEvent(evt, handler) {
        const magnetElem = evt.currentTarget;
        const magnetValue = magnetElem.getAttribute('magnet');
        if (magnetValue && magnetValue.toLowerCase() !== 'false') {
            const view = this.findView(magnetElem);
            if (view) {
                const e = this.normalizeEvent(evt);
                if (this.guard(e, view)) {
                    return;
                }
                const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
                call(handler, this.graph, view, e, magnetElem, localPoint.x, localPoint.y);
            }
        }
    }
    onMagnetMouseDown(e) {
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetMouseDown(e, magnet, x, y);
        });
    }
    onMagnetDblClick(e) {
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetDblClick(e, magnet, x, y);
        });
    }
    onMagnetContextMenu(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.isPreventDefaultContextMenu(e, view)) {
            e.preventDefault();
        }
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetContextMenu(e, magnet, x, y);
        });
    }
    onLabelMouseDown(evt) {
        const labelNode = evt.currentTarget;
        const view = this.findView(labelNode);
        if (view) {
            const e = this.normalizeEvent(evt);
            if (this.guard(e, view)) {
                return;
            }
            const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
            view.onLabelMouseDown(e, localPoint.x, localPoint.y);
        }
    }
    onImageDragStart() {
        // This is the only way to prevent image dragging in Firefox that works.
        // Setting -moz-user-select: none, draggable="false" attribute or
        // user-drag: none didn't help.
        return false;
    }
    dispose() {
        this.undelegateEvents();
        this.undelegateDocumentEvents();
        this.restore();
        this.restore = () => { };
    }
}
__decorate$p([
    View.dispose()
], GraphView.prototype, "dispose", null);
(function (GraphView) {
    const prefixCls = `${Config.prefixCls}-graph`;
    GraphView.markup = [
        {
            ns: ns.xhtml,
            tagName: 'div',
            selector: 'background',
            className: `${prefixCls}-background`,
        },
        {
            ns: ns.xhtml,
            tagName: 'div',
            selector: 'grid',
            className: `${prefixCls}-grid`,
        },
        {
            ns: ns.svg,
            tagName: 'svg',
            selector: 'svg',
            className: `${prefixCls}-svg`,
            attrs: {
                width: '100%',
                height: '100%',
                'xmlns:xlink': ns.xlink,
            },
            children: [
                {
                    tagName: 'defs',
                    selector: 'defs',
                },
                {
                    tagName: 'g',
                    selector: 'viewport',
                    className: `${prefixCls}-svg-viewport`,
                    children: [
                        {
                            tagName: 'g',
                            selector: 'primer',
                            className: `${prefixCls}-svg-primer`,
                        },
                        {
                            tagName: 'g',
                            selector: 'stage',
                            className: `${prefixCls}-svg-stage`,
                        },
                        {
                            tagName: 'g',
                            selector: 'decorator',
                            className: `${prefixCls}-svg-decorator`,
                        },
                        {
                            tagName: 'g',
                            selector: 'overlay',
                            className: `${prefixCls}-svg-overlay`,
                        },
                    ],
                },
            ],
        },
    ];
    function snapshoot(elem) {
        const cloned = elem.cloneNode();
        elem.childNodes.forEach((child) => cloned.appendChild(child));
        return () => {
            // remove all children
            empty(elem);
            // remove all attributes
            while (elem.attributes.length > 0) {
                elem.removeAttribute(elem.attributes[0].name);
            }
            // restore attributes
            for (let i = 0, l = cloned.attributes.length; i < l; i += 1) {
                const attr = cloned.attributes[i];
                elem.setAttribute(attr.name, attr.value);
            }
            // restore children
            cloned.childNodes.forEach((child) => elem.appendChild(child));
        };
    }
    GraphView.snapshoot = snapshoot;
})(GraphView || (GraphView = {}));
(function (GraphView) {
    const prefixCls = Config.prefixCls;
    GraphView.events = {
        dblclick: 'onDblClick',
        contextmenu: 'onContextMenu',
        touchstart: 'onMouseDown',
        mousedown: 'onMouseDown',
        mouseover: 'onMouseOver',
        mouseout: 'onMouseOut',
        mouseenter: 'onMouseEnter',
        mouseleave: 'onMouseLeave',
        mousewheel: 'onMouseWheel',
        DOMMouseScroll: 'onMouseWheel',
        [`mouseenter  .${prefixCls}-cell`]: 'onMouseEnter',
        [`mouseleave  .${prefixCls}-cell`]: 'onMouseLeave',
        [`mouseenter  .${prefixCls}-cell-tools`]: 'onMouseEnter',
        [`mouseleave  .${prefixCls}-cell-tools`]: 'onMouseLeave',
        [`mousedown   .${prefixCls}-cell [event]`]: 'onCustomEvent',
        [`touchstart  .${prefixCls}-cell [event]`]: 'onCustomEvent',
        [`mousedown   .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
        [`touchstart  .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
        [`dblclick    .${prefixCls}-cell [magnet]`]: 'onMagnetDblClick',
        [`contextmenu .${prefixCls}-cell [magnet]`]: 'onMagnetContextMenu',
        [`mousedown   .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
        [`touchstart  .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
        [`dblclick    .${prefixCls}-cell [data-magnet]`]: 'onMagnetDblClick',
        [`contextmenu .${prefixCls}-cell [data-magnet]`]: 'onMagnetContextMenu',
        [`mousedown   .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
        [`touchstart  .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
        [`dragstart   .${prefixCls}-cell image`]: 'onImageDragStart',
        [`mousedown   .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown',
        [`touchstart  .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown',
    };
    GraphView.documentEvents = {
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
        touchcancel: 'onMouseUp',
    };
})(GraphView || (GraphView = {}));

var Decorator$1;
(function (Decorator) {
    function checkScroller(err, warning) {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            descriptor.value = function (...args) {
                const scroller = this.scroller.widget;
                if (scroller == null) {
                    const msg = `Shoule enable scroller to use method '${methodName}'`;
                    if (err !== false) {
                        console.error(msg);
                        throw new Error(msg);
                    }
                    if (warning !== false) {
                        console.warn(msg);
                    }
                    return this;
                }
                return raw.call(this, ...args);
            };
        };
    }
    Decorator.checkScroller = checkScroller;
})(Decorator$1 || (Decorator$1 = {}));

/* eslint-disable */
/**
 * Auto generated file, do not modify it!
 */
const content = `.x6-graph {
  position: relative;
  outline: none;
  touch-action: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
@keyframes halo-pie-visibility {
  0% {
    visibility: hidden;
  }
  100% {
    visibility: visible;
  }
}
@keyframes halo-pie-opening {
  0% {
    transform: scale(0.4) rotate(-20deg);
  }
  100% {
    transform: scale(1) rotate(0);
  }
}
.x6-widget-handle {
  position: absolute;
  width: 20px;
  height: 20px;
  background-color: transparent;
  background-repeat: no-repeat;
  background-position: 0 0;
  background-size: 20px 20px;
  cursor: pointer;
  user-select: none;
  pointer-events: auto;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-handle.hidden {
  display: none;
}
.x6-widget-handle-selected {
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}
.x6-widget-handle-remove {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%20M4.152%2C14.598C1.273%2C11.719%2C1.273%2C7.035%2C4.153%2C4.154%20c2.88-2.88%2C7.563-2.88%2C10.443%2C0c2.881%2C2.88%2C2.881%2C7.562%2C0%2C10.443C11.716%2C17.477%2C7.032%2C17.477%2C4.152%2C14.598L4.152%2C14.598z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
  cursor: pointer;
}
.x6-widget-handle-remove:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-rotate {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');
  cursor: move;
}
.x6-widget-handle-rotate:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-resize {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%236A6C8A%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');
  cursor: se-resize;
}
.x6-widget-handle-resize:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%23FD6EB6%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');
}
.x6-widget-handle-clone {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.85%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
  cursor: move;
}
.x6-widget-handle-clone:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.849%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%20M15.172%2C16.328%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-link {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');
  cursor: move;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}
.x6-widget-handle-link:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-fork {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%236A6C8A%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20C7.552%2C9.82%2C7.602%2C9.589%2C7.602%2C9.344c0-0.25-0.051-0.487-0.129-0.71l4.097-2.364c0.393%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.014%2C0.149%2C0.021%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.982%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.014%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
  cursor: move;
}
.x6-widget-handle-fork:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%23FD6EB6%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20c0.075-0.22%2C0.125-0.452%2C0.125-0.697c0-0.25-0.051-0.487-0.129-0.71l4.097-2.365c0.394%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.015%2C0.148%2C0.022%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.981%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.013%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-unlink {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-unlink:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-direction {
  background-image: url("data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%236A6C8A%3Bstroke%3A%236A6C8A%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%236A6C8A%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E");
}
.x6-widget-handle-direction:hover {
  background-image: url("data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%23FD6EB6%3Bstroke%3A%23FD6EB6%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%23FD6EB6%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E");
}
.x6-widget-handle-surround .x6-widget-handle-animate .x6-widget-handle {
  transition: background-size 80ms, width 80ms, height 80ms, top 150ms, left 150ms, bottom 150ms, right 150ms;
}
.x6-widget-handle-surround .x6-widget-handle-pos-se {
  right: -25px;
  bottom: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-nw {
  top: -21px;
  left: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-n {
  top: -22px;
  left: 50%;
  margin-left: -10px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-e {
  top: -webkit-calc(40%);
  top: calc(50% - 10px);
  right: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-ne {
  top: -21px;
  right: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-w {
  top: 50%;
  left: -25px;
  margin-top: -10px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-sw {
  bottom: -25px;
  left: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-s {
  bottom: -24px;
  left: 50%;
  margin-left: -10px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle {
  width: 15px;
  height: 15px;
  font-size: 15px;
  background-size: 15px 15px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-se {
  right: -19px;
  bottom: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-nw {
  top: -19px;
  left: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-n {
  top: -19px;
  margin-left: -7.5px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-e {
  top: -webkit-calc(42%);
  top: calc(50% - 8px);
  right: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-ne {
  top: -19px;
  right: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-w {
  left: -19px;
  margin-top: -8px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-sw {
  bottom: -19px;
  left: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-s {
  bottom: -19px;
  margin-left: -7.5px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle {
  width: 10px;
  height: 10px;
  font-size: 10px;
  background-size: 10px 10px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-se {
  right: -15px;
  bottom: -13px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-nw {
  top: -13px;
  left: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-n {
  top: -13px;
  margin-left: -5px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-e {
  top: -webkit-calc(45%);
  top: calc(50% - 5px);
  right: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-ne {
  top: -13px;
  right: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-w {
  left: -15px;
  margin-top: -5px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-sw {
  bottom: -13px;
  left: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-s {
  bottom: -13px;
  margin-left: -5px;
}
.x6-widget-handle-toolbar {
  position: absolute;
  top: -50px;
  display: table-row;
  padding: 7px 5px;
}
.x6-widget-handle-toolbar::after {
  position: absolute;
  top: 100%;
  left: 10px;
  width: 0;
  height: 0;
  margin-top: 4px;
  border-right: 10px solid transparent;
  border-left: 10px solid transparent;
  content: '';
}
.x6-widget-handle-toolbar .x6-widget-handle {
  position: relative;
  display: table-cell;
  min-width: 20px;
  margin: 0 2px;
  background-position: 3px 3px;
  background-size: 16px 16px;
}
.x6-widget-handle-toolbar .x6-widget-handle::after {
  position: absolute;
  bottom: -11px;
  width: 100%;
  content: '';
}
.x6-widget-handle-pie {
  position: absolute;
  top: -webkit-calc(0%);
  top: calc(50% - 50px);
  right: -50px;
  z-index: 1;
  display: none;
  width: 100px;
  height: 100px;
  margin: -2px -2px 0 0;
  border-radius: 50%;
  cursor: default;
  pointer-events: visiblePainted;
}
.x6-widget-handle-pie .x6-widget-handle {
  width: 1px;
  height: auto;
  pointer-events: visiblePainted;
}
.x6-widget-handle-pie-slice-svg {
  width: 100%;
  height: 100%;
  overflow: visible !important;
}
.x6-widget-handle-pie-slice-img,
.x6-widget-handle-pie-slice-txt {
  display: none;
  pointer-events: none;
}
.x6-widget-handle-pie[data-pie-toggle-position='e'] {
  top: calc(50% - 50px);
  right: -50px;
  left: auto;
}
.x6-widget-handle-pie[data-pie-toggle-position='w'] {
  top: calc(50% - 50px);
  right: auto;
  left: -52px;
}
.x6-widget-handle-pie[data-pie-toggle-position='n'] {
  top: -50px;
  right: auto;
  bottom: auto;
  left: calc(50% - 52px);
}
.x6-widget-handle-pie[data-pie-toggle-position='s'] {
  top: auto;
  right: auto;
  bottom: -52px;
  left: calc(50% - 52px);
}
.x6-widget-handle-pie-opened {
  display: block;
  animation: halo-pie-visibility 0.1s, halo-pie-opening 0.1s;
  animation-timing-function: step-end, ease;
  animation-delay: 0s, 0.1s;
}
.x6-widget-handle-pie-toggle {
  position: absolute;
  top: -webkit-calc(35%);
  top: calc(50% - 15px);
  right: -15px;
  z-index: 2;
  display: block;
  box-sizing: border-box;
  width: 30px;
  height: 30px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 20px 20px;
  border-radius: 50%;
  cursor: pointer;
  user-select: none;
  pointer-events: visiblePainted;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-handle-pie-toggle-pos-e {
  top: -webkit-calc(35%);
  top: calc(50% - 15px);
  right: -15px;
  bottom: auto;
  left: auto;
}
.x6-widget-handle-pie-toggle-pos-w {
  top: -webkit-calc(35%);
  top: calc(50% - 15px);
  right: auto;
  bottom: auto;
  left: -15px;
}
.x6-widget-handle-pie-toggle-pos-n {
  top: -15px;
  right: auto;
  bottom: auto;
  left: -webkit-calc(35%);
  left: calc(50% - 15px);
}
.x6-widget-handle-pie-toggle-pos-s {
  top: auto;
  right: auto;
  bottom: -15px;
  left: -webkit-calc(35%);
  left: calc(50% - 15px);
}
.x6-widget-handle-pie-toggle-opened {
  transition: 0.1s background-image;
}
.x6-widget-handle-toolbar {
  position: static;
  display: inline-block;
  margin-top: -50px;
  margin-left: 45px;
  white-space: nowrap;
  vertical-align: top;
  background-color: #f5f5f5;
  border-bottom: 3px solid #333;
  border-radius: 5px;
  box-shadow: 0 1px 2px #222;
}
.x6-widget-handle-toolbar::after {
  top: -12px;
  left: 55px;
  margin-top: 0;
  border-top: 6px solid #333;
  border-right: 10px solid transparent;
  border-left: 10px solid transparent;
}
.x6-widget-handle-toolbar .x6-widget-handle {
  display: inline-block;
  vertical-align: top;
}
.x6-widget-handle-toolbar .x6-widget-handle:hover::after {
  border-bottom: 4px solid #fc6cb8;
}
.x6-widget-handle-toolbar .x6-widget-handle-rotate {
  position: absolute;
  top: 100%;
  right: 100%;
  margin-top: 3px;
  margin-right: 6px;
}
.x6-widget-handle-toolbar .x6-widget-handle-remove:hover::after,
.x6-widget-handle-toolbar .x6-widget-handle-rotate:hover::after {
  border-bottom: none;
}
.x6-widget-handle-toolbar .x6-widget-handle + .x6-widget-handle {
  margin-left: 4px;
}
.x6-widget-handle-pie {
  box-sizing: content-box;
  background-color: #f5f5f5;
  border: 2px solid #404040;
}
.x6-widget-handle-pie-slice {
  fill: transparent;
  stroke: #e9e9e9;
  stroke-width: 1;
}
.x6-widget-handle-pie-slice:hover {
  fill: #fff;
}
.x6-widget-handle-pie-slice-img {
  display: block;
}
.x6-widget-handle-selected .x6-widget-handle-pie-slice {
  fill: #fff;
}
.x6-widget-handle-pie-toggle {
  background-color: #f6f6f6;
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');
  background-size: 16px 16px;
  border: 2px solid #3b425f;
}
.x6-widget-handle-pie-toggle:hover {
  background-color: #fff;
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');
  border-color: #fd6eb6;
}
.x6-widget-handle-pie-toggle-opened {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%236a6c8a%22%20%2F%3E%3C%2Fsvg%3E');
}
.x6-widget-handle-pie-toggle-opened:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%23FD6EB6%22%20%2F%3E%3C%2Fsvg%3E');
}
.x6-widget-dnd {
  position: absolute;
  top: -10000px;
  left: -10000px;
  z-index: 999999;
  display: none;
  cursor: move;
  opacity: 0.7;
  pointer-events: 'cursor';
}
.x6-widget-dnd.dragging {
  display: inline-block;
}
.x6-widget-dnd.dragging * {
  pointer-events: none !important;
}
.x6-widget-dnd .x6-graph {
  background: transparent;
  box-shadow: none;
}
.x6-widget-halo {
  position: absolute;
  pointer-events: none;
}
.x6-widget-halo-content {
  position: absolute;
  top: 100%;
  padding: 6px;
  font-size: 10px;
  line-height: 14px;
  text-align: center;
  border-radius: 6px;
}
.x6-widget-halo-handles + .x6-widget-halo-content {
  right: -20px;
  left: -20px;
  margin-top: 30px;
}
.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {
  margin-top: 25px;
}
.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {
  margin-top: 20px;
}
.x6-widget-halo-handles.x6-widget-handle-pie + .x6-widget-halo-content {
  right: 0;
  left: 0;
  margin-top: 10px;
}
.x6-widget-halo-content {
  color: #fff;
  background-color: #6a6b8a;
}
.x6-widget-halo.type-node .x6-widget-handle-toolbar .x6-widget-handle-remove {
  position: absolute;
  right: 100%;
  bottom: 100%;
  margin-right: 6px;
  margin-bottom: 3px;
}
.x6-widget-halo.type-edge .x6-widget-handle-surround .x6-widget-handle-remove {
  background-color: #fff;
  border-radius: 50%;
}
.x6-widget-halo.type-edge .x6-widget-handle-toolbar {
  margin-top: -60px;
  margin-left: -18px;
}
.x6-widget-halo.type-edge .x6-widget-handle-toolbar::after {
  top: -22px;
  left: -9px;
}
.x6-widget-minimap {
  position: relative;
  display: table-cell;
  box-sizing: border-box;
  overflow: hidden;
  text-align: center;
  vertical-align: middle;
  background-color: #fff;
  user-select: none;
}
.x6-widget-minimap .x6-graph {
  display: inline-block;
  box-shadow: 0 0 4px 0 #eee;
  cursor: pointer;
}
.x6-widget-minimap .x6-graph > svg {
  pointer-events: none;
  shape-rendering: optimizeSpeed;
}
.x6-widget-minimap .x6-graph .x6-node * {
  /* stylelint-disable-next-line */
  vector-effect: initial;
}
.x6-widget-minimap-viewport {
  position: absolute;
  box-sizing: content-box !important;
  margin: -2px 0 0 -2px;
  border: 2px solid #31d0c6;
  cursor: move;
}
.x6-widget-minimap-viewport-zoom {
  position: absolute;
  right: 0;
  bottom: 0;
  box-sizing: border-box;
  width: 12px;
  height: 12px;
  margin: 0 -6px -6px 0;
  background-color: #fff;
  border: 2px solid #31d0c6;
  border-radius: 50%;
  cursor: nwse-resize;
}
.x6-graph-scroller {
  position: relative;
  box-sizing: border-box;
  overflow: scroll;
  outline: none;
}
.x6-graph-scroller-content {
  position: relative;
}
.x6-graph-scroller-background {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-scroller .x6-graph {
  position: absolute;
  display: inline-block;
  margin: 0;
  box-shadow: none;
}
.x6-graph-scroller .x6-graph > svg {
  display: block;
}
.x6-graph-scroller.x6-graph-scroller-paged .x6-graph {
  box-shadow: 0 0 4px 0 #eee;
}
.x6-graph-scroller.x6-graph-scroller-pannable[data-panning='false'] {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph-scroller.x6-graph-scroller-pannable[data-panning='true'] {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-graph-pagebreak {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-pagebreak-vertical {
  position: absolute;
  top: 0;
  bottom: 0;
  box-sizing: border-box;
  width: 1px;
  border-left: 1px dashed #bdbdbd;
}
.x6-graph-pagebreak-horizontal {
  position: absolute;
  right: 0;
  left: 0;
  box-sizing: border-box;
  height: 1px;
  border-top: 1px dashed #bdbdbd;
}
.x6-widget-selection {
  position: absolute;
  display: none;
  width: 0;
  height: 0;
  touch-action: none;
}
.x6-widget-selection-rubberband {
  display: block;
  overflow: visible;
  opacity: 0.3;
}
.x6-widget-selection-selected {
  display: block;
}
.x6-widget-selection-box {
  cursor: move;
}
.x6-widget-selection-inner[data-selection-length='0'],
.x6-widget-selection-inner[data-selection-length='1'] {
  display: none;
}
.x6-widget-selection-content {
  position: absolute;
  top: 100%;
  right: -20px;
  left: -20px;
  margin-top: 30px;
  padding: 6px;
  line-height: 14px;
  text-align: center;
  border-radius: 6px;
}
.x6-widget-selection-content:empty {
  display: none;
}
.x6-widget-selection-rubberband {
  background-color: #3498db;
  border: 2px solid #2980b9;
}
.x6-widget-selection-box {
  box-sizing: content-box !important;
  margin-top: -4px;
  margin-left: -4px;
  padding-right: 4px;
  padding-bottom: 4px;
  border: 2px dashed #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-inner {
  box-sizing: content-box !important;
  margin-top: -8px;
  margin-left: -8px;
  padding-right: 12px;
  padding-bottom: 12px;
  border: 2px solid #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-content {
  color: #fff;
  font-size: 10px;
  background-color: #6a6b8a;
}
.x6-widget-snapline {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  pointer-events: none;
}
.x6-widget-snapline-vertical,
.x6-widget-snapline-horizontal {
  stroke: #2ecc71;
  stroke-width: 1px;
}
.x6-widget-stencil {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-widget-stencil::after {
  position: absolute;
  top: 0;
  display: block;
  width: 100%;
  height: 20px;
  padding: 8px 0;
  line-height: 20px;
  text-align: center;
  opacity: 0;
  transition: top 0.1s linear, opacity 0.1s linear;
  content: ' ';
  pointer-events: none;
}
.x6-widget-stencil-content {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  height: auto;
  overflow-x: hidden;
  overflow-y: auto;
}
.x6-widget-stencil .x6-node [magnet]:not([magnet='passive']) {
  pointer-events: none;
}
.x6-widget-stencil-group {
  padding: 0;
  padding-bottom: 8px;
  overflow: hidden;
  user-select: none;
}
.x6-widget-stencil-group.collapsed {
  height: auto;
  padding-bottom: 0;
}
.x6-widget-stencil-group-title {
  position: relative;
  margin-top: 0;
  margin-bottom: 0;
  padding: 4px;
  cursor: pointer;
}
.x6-widget-stencil-title,
.x6-widget-stencil-group > .x6-widget-stencil-group-title {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  user-select: none;
}
.x6-widget-stencil .unmatched {
  opacity: 0.3;
}
.x6-widget-stencil .x6-node.unmatched {
  display: none;
}
.x6-widget-stencil-group.unmatched {
  display: none;
}
.x6-widget-stencil-search-text {
  position: relative;
  z-index: 1;
  box-sizing: border-box;
  width: 100%;
  height: 30px;
  max-height: 30px;
  line-height: 30px;
  outline: 0;
}
.x6-widget-stencil.not-found::after {
  opacity: 1;
  content: attr(data-not-found-text);
}
.x6-widget-stencil.not-found.searchable::after {
  top: 30px;
}
.x6-widget-stencil.not-found.searchable.collapsable::after {
  top: 50px;
}
.x6-widget-stencil {
  color: #333;
  background: #f5f5f5;
}
.x6-widget-stencil-content {
  position: absolute;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-content {
  top: 32px;
}
.x6-widget-stencil.searchable > .x6-widget-stencil-content {
  top: 80px;
}
.x6-widget-stencil.not-found::after {
  position: absolute;
}
.x6-widget-stencil.not-found.searchable.collapsable::after {
  top: 80px;
}
.x6-widget-stencil.not-found.searchable::after {
  top: 60px;
}
.x6-widget-stencil-group {
  height: auto;
  margin-bottom: 1px;
  padding: 0;
  transition: none;
}
.x6-widget-stencil-group .x6-graph {
  background: transparent;
  box-shadow: none;
}
.x6-widget-stencil-group.collapsed {
  height: auto;
  max-height: 31px;
}
.x6-widget-stencil-title,
.x6-widget-stencil-group > .x6-widget-stencil-group-title {
  position: relative;
  left: 0;
  box-sizing: border-box;
  width: 100%;
  height: 32px;
  padding: 0 5px 0 8px;
  color: #666;
  font-weight: 700;
  font-size: 12px;
  line-height: 32px;
  cursor: default;
  transition: all 0.3;
}
.x6-widget-stencil-title:hover,
.x6-widget-stencil-group > .x6-widget-stencil-group-title:hover {
  color: #444;
}
.x6-widget-stencil-title {
  background: #e9e9e9;
}
.x6-widget-stencil-group > .x6-widget-stencil-group-title {
  background: #ededed;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title {
  padding-left: 32px;
  cursor: pointer;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {
  position: absolute;
  top: 6px;
  left: 8px;
  display: block;
  width: 18px;
  height: 18px;
  margin: 0;
  padding: 0;
  background-color: transparent;
  background-repeat: no-repeat;
  background-position: 0 0;
  border: none;
  content: ' ';
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {
  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48L2c+PC9zdmc+');
  opacity: 0.4;
  transition: all 0.3s;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title:hover::before,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title:hover::before {
  opacity: 0.6;
}
.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title::before,
.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title::before {
  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48cGF0aCBkPSJNOC44MTcgNS42MjN2Ni43NTZhLjU1OC41NTggMCAwMDEuMTE2IDBWNS42MjNhLjU1OC41NTggMCAxMC0xLjExNiAweiIvPjwvZz48L3N2Zz4=');
  opacity: 0.4;
}
.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title:hover::before,
.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title:hover::before {
  opacity: 0.6;
}
.x6-widget-stencil input[type='search'] {
  -webkit-appearance: textfield;
}
.x6-widget-stencil input[type='search']::-webkit-search-cancel-button,
.x6-widget-stencil input[type='search']::-webkit-search-decoration {
  -webkit-appearance: none;
}
.x6-widget-stencil-search-text {
  display: block;
  width: 90%;
  margin: 8px 5%;
  padding-left: 8px;
  color: #333;
  background: #fff;
  border: 1px solid #e9e9e9;
  border-radius: 12px;
  outline: 0;
}
.x6-widget-stencil-search-text:focus {
  outline: 0;
}
.x6-widget-stencil::after {
  color: #808080;
  font-weight: 600;
  font-size: 12px;
  background: 0 0;
}
.x6-widget-transform {
  position: absolute;
  box-sizing: content-box !important;
  margin: -5px 0 0 -5px;
  padding: 4px;
  border: 1px dashed #000;
  border-radius: 5px;
  user-select: none;
  pointer-events: none;
}
.x6-widget-transform > div {
  position: absolute;
  box-sizing: border-box;
  background-color: #fff;
  border: 1px solid #000;
  transition: background-color 0.2s;
  pointer-events: auto;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-transform > div:hover {
  background-color: #d3d3d3;
}
.x6-widget-transform-cursor-n {
  cursor: n-resize;
}
.x6-widget-transform-cursor-s {
  cursor: s-resize;
}
.x6-widget-transform-cursor-e {
  cursor: e-resize;
}
.x6-widget-transform-cursor-w {
  cursor: w-resize;
}
.x6-widget-transform-cursor-ne {
  cursor: ne-resize;
}
.x6-widget-transform-cursor-nw {
  cursor: nw-resize;
}
.x6-widget-transform-cursor-se {
  cursor: se-resize;
}
.x6-widget-transform-cursor-sw {
  cursor: sw-resize;
}
.x6-widget-transform-resize {
  width: 10px;
  height: 10px;
  border-radius: 6px;
}
.x6-widget-transform-resize[data-position='top-left'] {
  top: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='top-right'] {
  top: -5px;
  right: -5px;
}
.x6-widget-transform-resize[data-position='bottom-left'] {
  bottom: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='bottom-right'] {
  right: -5px;
  bottom: -5px;
}
.x6-widget-transform-resize[data-position='top'] {
  top: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='bottom'] {
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='left'] {
  top: 50%;
  left: -5px;
  margin-top: -5px;
}
.x6-widget-transform-resize[data-position='right'] {
  top: 50%;
  right: -5px;
  margin-top: -5px;
}
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='top'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='right'] {
  display: none;
}
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='right'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='top'] {
  display: none;
}
.x6-widget-transform.no-resize .x6-widget-transform-resize {
  display: none;
}
.x6-widget-transform-rotate {
  top: -20px;
  left: -20px;
  width: 12px;
  height: 12px;
  border-radius: 6px;
  cursor: crosshair;
}
.x6-widget-transform.no-rotate .x6-widget-transform-rotate {
  display: none;
}
.x6-widget-transform-active {
  border-color: transparent;
  pointer-events: all;
}
.x6-widget-transform-active > div {
  display: none;
}
.x6-widget-transform-active > .x6-widget-transform-active-handle {
  display: block;
  background-color: #808080;
}
.x6-widget-knob {
  position: absolute;
  box-sizing: border-box;
  width: 16px;
  height: 16px;
  margin-top: -8px;
  margin-left: -8px;
  cursor: pointer;
  user-select: none;
}
.x6-widget-knob::before,
.x6-widget-knob::after {
  position: absolute;
  transform: rotate(45deg);
  content: '';
}
.x6-widget-knob::before {
  top: 4px;
  left: 4px;
  box-sizing: border-box;
  width: 8px;
  height: 8px;
  background-color: #fff;
}
.x6-widget-knob::after {
  top: 5px;
  left: 5px;
  box-sizing: border-box;
  width: 6px;
  height: 6px;
  background-color: #fca000;
}
.x6-graph-print {
  position: relative;
}
.x6-graph-print .x6-graph-print-ready {
  display: none;
}
.x6-graph-print .x6-graph-print-preview {
  overflow: hidden !important;
  background: #fff !important;
}
@media print {
  html,
  html > body.x6-graph-printing {
    position: relative !important;
    width: 100% !important;
    height: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
  html > body.x6-graph-printing > * {
    display: none !important;
  }
  html > body.x6-graph-printing > .x6-graph-print {
    display: block !important;
  }
  .x6-graph-print {
    top: 0 !important;
    left: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
    overflow: hidden !important;
    page-break-after: always;
    background: #fff !important;
  }
  .x6-graph-print .x6-graph-print-ready {
    display: none;
  }
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;

var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class CSSManager extends Base {
    init() {
        if (Config.autoInsertCSS) {
            CSSManager.ensure();
        }
    }
    dispose() {
        CSSManager.clean();
    }
}
__decorate$o([
    CSSManager.dispose()
], CSSManager.prototype, "dispose", null);
(function (CSSManager) {
    let styleElement;
    let counter = 0;
    function ensure() {
        counter += 1;
        if (counter > 1)
            return;
        if (!Platform.isApplyingHMR()) {
            styleElement = document.createElement('style');
            styleElement.setAttribute('type', 'text/css');
            styleElement.textContent = content;
            const head = document.querySelector('head');
            if (head) {
                head.insertBefore(styleElement, head.firstChild);
            }
        }
    }
    CSSManager.ensure = ensure;
    function clean() {
        counter -= 1;
        if (counter > 0)
            return;
        if (styleElement && styleElement.parentNode) {
            styleElement.parentNode.removeChild(styleElement);
        }
        styleElement = null;
    }
    CSSManager.clean = clean;
})(CSSManager || (CSSManager = {}));

var __rest$9 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Handle {
    get handleClassName() {
        return ClassNames$1.handle;
    }
    get pie() {
        return Object.assign(Object.assign({}, Handle.defaultPieOptions), this.handleOptions.pie);
    }
    initHandles() {
        this.handles = [];
        if (this.handleOptions.handles) {
            this.handleOptions.handles.forEach((handle) => this.addHandle(handle));
        }
        if (this.handleOptions.type === 'pie') {
            if (this.pie.toggles) {
                const className = ClassNames$1.pieToggle;
                this.$pieToggles = {};
                this.pie.toggles.forEach((item) => {
                    const $elem = this.$('<div/>');
                    this.applyAttrs($elem, item.attrs);
                    $elem
                        .addClass(className)
                        .addClass(`${className}-pos-${item.position || 'e'}`)
                        .attr('data-name', item.name)
                        .appendTo(this.container);
                    this.$pieToggles[item.name] = $elem;
                });
            }
            this.setPieIcons();
        }
        if (this.$handleContainer) {
            const type = this.handleOptions.type || 'surround';
            this.$handleContainer
                .addClass(ClassNames$1.wrap)
                .addClass(ClassNames$1.animate)
                .addClass(`${ClassNames$1.handle}-${type}`);
        }
        this.delegateEvents({
            [`mousedown .${ClassNames$1.handle}`]: 'onHandleMouseDown',
            [`touchstart .${ClassNames$1.handle}`]: 'onHandleMouseDown',
            [`mousedown .${ClassNames$1.pieToggle}`]: 'onPieToggleMouseDown',
            [`touchstart .${ClassNames$1.pieToggle}`]: 'onPieToggleMouseDown',
        });
    }
    onHandleMouseDown(evt) {
        const action = this.$(evt.currentTarget)
            .closest(`.${ClassNames$1.handle}`)
            .attr('data-action');
        if (action) {
            evt.preventDefault();
            evt.stopPropagation();
            this.setEventData(evt, {
                action,
                clientX: evt.clientX,
                clientY: evt.clientY,
                startX: evt.clientX,
                startY: evt.clientY,
            });
            if (evt.type === 'mousedown' && evt.button === 2) {
                this.triggerHandleAction(action, 'contextmenu', evt);
            }
            else {
                this.triggerHandleAction(action, 'mousedown', evt);
                this.delegateDocumentEvents({
                    mousemove: 'onHandleMouseMove',
                    touchmove: 'onHandleMouseMove',
                    mouseup: 'onHandleMouseUp',
                    touchend: 'onHandleMouseUp',
                    touchcancel: 'onHandleMouseUp',
                }, evt.data);
            }
        }
    }
    onHandleMouseMove(evt) {
        const data = this.getEventData(evt);
        const action = data.action;
        if (action) {
            this.triggerHandleAction(action, 'mousemove', evt);
        }
    }
    onHandleMouseUp(evt) {
        const data = this.getEventData(evt);
        const action = data.action;
        if (action) {
            this.triggerHandleAction(action, 'mouseup', evt);
            this.undelegateDocumentEvents();
        }
    }
    triggerHandleAction(action, eventName, evt, args) {
        evt.preventDefault();
        evt.stopPropagation();
        const e = this.normalizeEvent(evt);
        const data = this.getEventData(e);
        const local = this.graph.snapToGrid(e.clientX, e.clientY);
        const origin = this.graph.snapToGrid(data.clientX, data.clientY);
        const dx = local.x - origin.x;
        const dy = local.y - origin.y;
        this.trigger(`action:${action}:${eventName}`, Object.assign({ e,
            dx,
            dy, x: local.x, y: local.y, offsetX: evt.clientX - data.startX, offsetY: evt.clientY - data.startY }, args));
        data.clientX = evt.clientX;
        data.clientY = evt.clientY;
    }
    onPieToggleMouseDown(evt) {
        evt.stopPropagation();
        const name = this.$(evt.target)
            .closest(`.${ClassNames$1.pieToggle}`)
            .attr('data-name');
        if (!this.isOpen(name)) {
            if (this.isOpen()) {
                this.toggleState();
            }
        }
        this.toggleState(name);
    }
    setPieIcons() {
        if (this.handleOptions.type === 'pie') {
            this.$handleContainer.find(`.${ClassNames$1.handle}`).each((_, elem) => {
                const $elem = this.$(elem);
                const action = $elem.attr('data-action');
                const className = ClassNames$1.pieSlice;
                const handle = this.getHandle(action);
                if (!handle || !handle.icon) {
                    const contect = window
                        .getComputedStyle(elem, ':before')
                        .getPropertyValue('content');
                    if (contect && contect !== 'none') {
                        const $icons = $elem.find(`.${className}-txt`);
                        if ($icons.length) {
                            Vector.create($icons[0]).text(contect.replace(/['"]/g, ''));
                        }
                    }
                    const bgImg = $elem.css('background-image');
                    if (bgImg) {
                        const matches = bgImg.match(/url\(['"]?([^'"]+)['"]?\)/);
                        if (matches) {
                            const href = matches[1];
                            const $imgs = $elem.find(`.${className}-img`);
                            if ($imgs.length > 0) {
                                Vector.create($imgs[0]).attr('xlink:href', href);
                            }
                        }
                    }
                }
            });
        }
    }
    getHandleIdx(name) {
        return this.handles.findIndex((item) => item.name === name);
    }
    hasHandle(name) {
        return this.getHandleIdx(name) >= 0;
    }
    getHandle(name) {
        return this.handles.find((item) => item.name === name);
    }
    renderHandle(handle) {
        const $handle = this.$('<div/>')
            .addClass(`${ClassNames$1.handle} ${ClassNames$1.handle}-${handle.name}`)
            .attr('data-action', handle.name)
            .prop('draggable', false);
        if (this.handleOptions.type === 'pie') {
            const index = this.getHandleIdx(handle.name);
            const pie = this.pie;
            const outerRadius = pie.outerRadius;
            const innerRadius = pie.innerRadius;
            const offset = (outerRadius + innerRadius) / 2;
            const ratio = new Point(outerRadius, outerRadius);
            const delta = Angle.toRad(pie.sliceAngle);
            const curRad = index * delta + Angle.toRad(pie.startAngle);
            const nextRad = curRad + delta;
            const pathData = createSlicePathData(innerRadius, outerRadius, curRad, nextRad);
            const vSvg = Vector.create('svg').addClass(`${ClassNames$1.pieSlice}-svg`);
            const vPath = Vector.create('path')
                .addClass(ClassNames$1.pieSlice)
                .attr('d', pathData)
                .translate(outerRadius, outerRadius);
            const pos = Point.fromPolar(offset, -curRad - delta / 2, ratio).toJSON();
            const iconSize = pie.iconSize;
            const vImg = Vector.create('image')
                .attr(pos)
                .addClass(`${ClassNames$1.pieSlice}-img`);
            pos.y = pos.y + iconSize - 2;
            const vText = Vector.create('text', { 'font-size': iconSize })
                .attr(pos)
                .addClass(`${ClassNames$1.pieSlice}-txt`);
            vImg.attr({
                width: iconSize,
                height: iconSize,
            });
            vImg.translate(-iconSize / 2, -iconSize / 2);
            vText.translate(-iconSize / 2, -iconSize / 2);
            vSvg.append([vPath, vImg, vText]);
            $handle.append(vSvg.node);
        }
        else {
            $handle.addClass(`${ClassNames$1.handle}-pos-${handle.position}`);
            if (handle.content) {
                if (typeof handle.content === 'string') {
                    $handle.html(handle.content);
                }
                else {
                    $handle.append(handle.content);
                }
            }
        }
        this.updateHandleIcon($handle, handle.icon);
        this.applyAttrs($handle, handle.attrs);
        return $handle;
    }
    addHandle(handle) {
        if (!this.hasHandle(handle.name)) {
            this.handles.push(handle);
            const events = handle.events;
            if (events) {
                Object.keys(events).forEach((action) => {
                    const callback = events[action];
                    const name = `action:${handle.name}:${action}`;
                    if (typeof callback === 'string') {
                        this.on(name, this[callback], this);
                    }
                    else {
                        this.on(name, callback);
                    }
                });
            }
            if (this.$handleContainer) {
                this.$handleContainer.append(this.renderHandle(handle));
            }
        }
        return this;
    }
    addHandles(handles) {
        handles.forEach((handle) => this.addHandle(handle));
        return this;
    }
    removeHandles() {
        while (this.handles.length) {
            this.removeHandle(this.handles[0].name);
        }
        return this;
    }
    removeHandle(name) {
        const index = this.getHandleIdx(name);
        const handle = this.handles[index];
        if (handle) {
            if (handle.events) {
                Object.keys(handle.events).forEach((event) => {
                    this.off(`action:${name}:${event}`);
                });
            }
            this.getHandleElem(name).remove();
            this.handles.splice(index, 1);
        }
        return this;
    }
    changeHandle(name, newHandle) {
        const handle = this.getHandle(name);
        if (handle) {
            this.removeHandle(name);
            this.addHandle(Object.assign(Object.assign({}, handle), newHandle));
        }
        return this;
    }
    toggleHandle(name, selected) {
        const handle = this.getHandle(name);
        if (handle) {
            const $handle = this.getHandleElem(name);
            const className = `${ClassNames$1.handle}-selected`;
            if (selected === undefined) {
                selected = !$handle.hasClass(className); // eslint-disable-line
            }
            $handle.toggleClass(className, selected);
            const icon = selected ? handle.iconSelected : handle.icon;
            if (icon) {
                this.updateHandleIcon($handle, icon);
            }
        }
        return this;
    }
    selectHandle(name) {
        return this.toggleHandle(name, true);
    }
    deselectHandle(name) {
        return this.toggleHandle(name, false);
    }
    deselectAllHandles() {
        this.handles.forEach((handle) => this.deselectHandle(handle.name));
        return this;
    }
    getHandleElem(name) {
        return this.$handleContainer.find(`.${ClassNames$1.handle}-${name}`);
    }
    updateHandleIcon($handle, icon) {
        if (this.handleOptions.type === 'pie') {
            const $icons = $handle.find(`.${ClassNames$1.pieSliceImg}`);
            this.$($icons[0]).attr('xlink:href', icon || '');
        }
        else {
            $handle.css('background-image', icon ? `url(${icon})` : '');
        }
    }
    isRendered() {
        return this.$handleContainer != null;
    }
    isOpen(name) {
        if (this.isRendered()) {
            return name
                ? this.$pieToggles[name].hasClass(ClassNames$1.pieToggleOpened)
                : this.$handleContainer.hasClass(`${ClassNames$1.pieOpended}`);
        }
        return false;
    }
    toggleState(name) {
        if (this.isRendered()) {
            const $handleContainer = this.$handleContainer;
            Object.keys(this.$pieToggles).forEach((key) => {
                const $toggle = this.$pieToggles[key];
                $toggle.removeClass(ClassNames$1.pieToggleOpened);
            });
            if (this.isOpen()) {
                this.trigger('pie:close', { name });
                $handleContainer.removeClass(ClassNames$1.pieOpended);
            }
            else {
                this.trigger('pie:open', { name });
                if (name) {
                    const toggles = this.pie.toggles;
                    const toggle = toggles && toggles.find((i) => i.name === name);
                    if (toggle) {
                        $handleContainer.attr({
                            'data-pie-toggle-name': toggle.name,
                            'data-pie-toggle-position': toggle.position,
                        });
                    }
                    this.$pieToggles[name].addClass(ClassNames$1.pieToggleOpened);
                }
                $handleContainer.addClass(ClassNames$1.pieOpended);
            }
        }
    }
    applyAttrs(elem, attrs) {
        if (attrs) {
            const $elem = View.$(elem);
            Object.keys(attrs).forEach((selector) => {
                const $element = $elem.find(selector).addBack().filter(selector);
                const _a = attrs[selector], { class: cls } = _a, attr = __rest$9(_a, ["class"]);
                if (cls) {
                    $element.addClass(cls);
                }
                $element.attr(attr);
            });
        }
    }
}
(function (Handle) {
    Handle.defaultPieOptions = {
        innerRadius: 20,
        outerRadius: 50,
        sliceAngle: 45,
        startAngle: 0,
        iconSize: 14,
        toggles: [
            {
                name: 'default',
                position: 'e',
            },
        ],
    };
})(Handle || (Handle = {}));
var ClassNames$1;
(function (ClassNames) {
    ClassNames.handle = View.prototype.prefixClassName('widget-handle');
    ClassNames.wrap = `${ClassNames.handle}-wrap`;
    ClassNames.animate = `${ClassNames.handle}-animate`;
    ClassNames.pieOpended = `${ClassNames.handle}-pie-opened`;
    ClassNames.pieToggle = `${ClassNames.handle}-pie-toggle`;
    ClassNames.pieToggleOpened = `${ClassNames.handle}-pie-toggle-opened`;
    ClassNames.pieSlice = `${ClassNames.handle}-pie-slice`;
    ClassNames.pieSliceImg = `${ClassNames.handle}-pie-slice-img`;
})(ClassNames$1 || (ClassNames$1 = {}));

var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$8 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Widget extends View {
    constructor(options) {
        super();
        const _a = options, { view, cell, node, edge, graph } = _a, localOptions = __rest$8(_a, ["view", "cell", "node", "edge", "graph"]);
        if (view) {
            this.view = view;
            this.cell = view.cell;
            this.graph = view.graph;
            this.model = this.graph.model;
        }
        else if ((cell || edge || node) && graph) {
            this.cell = node || edge || cell;
            this.view = graph.renderer.findViewByCell(this.cell);
            this.graph = graph;
            this.model = this.graph.model;
        }
        const ctor = this.constructor;
        if (options.clearAll !== false) {
            ctor.removeInstances(this.graph);
        }
        ctor.register(this);
        this.init(localOptions);
    }
    static ensureCache() {
        if (!this.instanceCache.has(this)) {
            this.instanceCache.set(this, {});
        }
        return this.instanceCache.get(this);
    }
    static register(instance, graph) {
        if (graph == null) {
            // eslint-disable-next-line
            graph = instance.graph;
        }
        const dic = this.ensureCache();
        let cache = dic[graph.view.cid];
        if (cache == null) {
            cache = dic[graph.view.cid] = {};
        }
        cache[instance.cid] = instance;
    }
    static unregister(instance, graph) {
        if (graph == null) {
            // eslint-disable-next-line
            graph = instance.graph;
        }
        const dic = this.ensureCache();
        if (dic[graph.view.cid]) {
            delete dic[graph.view.cid][instance.cid];
        }
    }
    static removeInstances(graph) {
        const dic = this.ensureCache();
        const cache = dic[graph.view.cid];
        if (cache) {
            Object.keys(cache).forEach((cid) => {
                const instance = cache[cid];
                if (instance) {
                    instance.remove();
                }
            });
        }
    }
    static getInstances(graph) {
        const dic = this.ensureCache();
        return dic[graph.view.cid] || {};
    }
    init(options) { } // eslint-disable-line
    render() {
        return this;
    }
    startListening() {
        if (this.options.clearOnBlankMouseDown !== false) {
            this.graph.on('blank:mousedown', this.remove, this);
        }
    }
    stopListening() {
        if (this.options.clearOnBlankMouseDown !== false) {
            this.graph.off('blank:mousedown', this.remove, this);
        }
    }
    remove() {
        this.stopListening();
        const ctor = this.constructor;
        ctor.unregister(this);
        return super.remove();
    }
    dispose() {
        this.remove();
    }
}
// #region static
Widget.instanceCache = new WeakMap();
__decorate$n([
    View.dispose()
], Widget.prototype, "dispose", null);

class Knob extends Widget {
    get node() {
        return this.cell;
    }
    get metadata() {
        const meta = this.cell.prop('knob');
        if (Array.isArray(meta)) {
            if (this.options.index != null) {
                return meta[this.options.index];
            }
            return null;
        }
        return meta;
    }
    init(options) {
        this.options = Object.assign({}, options);
        this.render();
        this.startListening();
    }
    startListening() {
        this.delegateEvents({
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        });
        this.model.on('*', this.update, this);
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
        this.model.on('reseted', this.remove, this);
        this.node.on('removed', this.remove, this);
        this.view.on('node:resize:mousedown', this.onTransform, this);
        this.view.on('node:rotate:mousedown', this.onTransform, this);
        this.view.on('node:resize:mouseup', this.onTransformed, this);
        this.view.on('node:rotate:mouseup', this.onTransformed, this);
        this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);
        this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);
        super.startListening();
    }
    stopListening() {
        this.undelegateEvents();
        this.model.off('*', this.update, this);
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
        this.model.off('reseted', this.remove, this);
        this.node.off('removed', this.remove, this);
        this.view.off('node:resize:mousedown', this.onTransform, this);
        this.view.off('node:rotate:mousedown', this.onTransform, this);
        this.view.off('node:resize:mouseup', this.onTransformed, this);
        this.view.off('node:rotate:mouseup', this.onTransformed, this);
        this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);
        this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);
        super.stopListening();
    }
    render() {
        this.container = document.createElement('div');
        addClass(this.container, this.prefixClassName('widget-knob'));
        if (this.options.className) {
            addClass(this.container, this.options.className);
        }
        this.view.addClass(Private$4.KNOB);
        this.graph.container.appendChild(this.container);
        this.update();
        return this;
    }
    remove() {
        this.view.removeClass(Private$4.KNOB);
        return super.remove();
    }
    update() {
        if (this.metadata) {
            const { update, position } = this.metadata;
            const args = {
                knob: this,
                cell: this.cell,
                node: this.node,
            };
            if (position) {
                const pos = position.call(this.graph, Object.assign({}, args));
                if (pos) {
                    const ctm = this.graph.matrix();
                    const bbox = this.node.getBBox();
                    const angle = Angle.normalize(this.node.getAngle());
                    const local = Point.create(pos);
                    if (angle !== 0) {
                        local.rotate(-angle, { x: bbox.width / 2, y: bbox.height / 2 });
                    }
                    local.translate(bbox).scale(ctm.a, ctm.d).translate(ctm.e, ctm.f);
                    this.container.style.left = `${local.x}px`;
                    this.container.style.top = `${local.y}px`;
                }
            }
            if (update) {
                update.call(this.graph, Object.assign({}, args));
            }
        }
    }
    hide() {
        this.container.style.display = 'none';
    }
    show() {
        this.container.style.display = '';
    }
    onTransform() {
        this.hide();
    }
    onTransformed() {
        this.show();
    }
    onKnobMouseDown({ knob }) {
        if (this.cid !== knob.cid) {
            this.hide();
        }
    }
    onKnobMouseUp() {
        this.show();
    }
    notify(name, evt) {
        if (this.view) {
            const e = this.view.normalizeEvent(evt);
            const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
            this.view.notify(`cell:${name}`, {
                e,
                view: this.view,
                node: this.node,
                cell: this.cell,
                x: localPoint.x,
                y: localPoint.y,
                knob: this,
            });
            if (this.cell.isNode()) {
                this.view.notify(`node:${name}`, {
                    e,
                    view: this.view,
                    node: this.node,
                    cell: this.cell,
                    x: localPoint.x,
                    y: localPoint.y,
                    knob: this,
                });
            }
            else if (this.cell.isEdge()) {
                this.view.notify(`edge:${name}`, {
                    e,
                    view: this.view,
                    edge: this.cell,
                    cell: this.cell,
                    x: localPoint.x,
                    y: localPoint.y,
                    knob: this,
                });
            }
        }
    }
    onMouseDown(e) {
        e.stopPropagation();
        this.setEventData(e, {
            knobbing: false,
            originX: e.clientX,
            originY: e.clientY,
            clientX: e.clientX,
            clientY: e.clientY,
        });
        this.graph.view.undelegateEvents();
        this.delegateDocumentEvents(Private$4.documentEvents, e.data);
        if (this.metadata && this.metadata.onMouseDown) {
            this.metadata.onMouseDown.call(this.graph, {
                e,
                data: this.getEventData(e),
                knob: this,
                cell: this.cell,
                node: this.node,
            });
        }
        this.notify('knob:mousedown', e);
    }
    onMouseMove(e) {
        const data = this.getEventData(e);
        const view = this.graph.findViewByCell(this.node);
        if (!data.knobbing) {
            data.knobbing = true;
            if (view) {
                view.addClass(Private$4.KNOBBING);
                this.notify('knob', e);
            }
            this.model.startBatch('knob', { cid: this.cid });
        }
        data.clientX = e.clientX;
        data.clientY = e.clientY;
        if (this.metadata && this.metadata.onMouseMove) {
            const ctm = this.graph.matrix();
            const dx = (e.clientX - data.originX) / ctm.a;
            const dy = (e.clientY - data.originY) / ctm.d;
            const angle = this.node.getAngle();
            const delta = new Point(dx, dy).rotate(angle);
            this.metadata.onMouseMove.call(this.graph, {
                e,
                data,
                deltaX: delta.x,
                deltaY: delta.y,
                knob: this,
                cell: this.cell,
                node: this.node,
            });
        }
        this.notify('knobbing', e);
        this.notify('knob:mousemove', e);
    }
    onMouseUp(e) {
        this.undelegateDocumentEvents();
        this.graph.view.delegateEvents();
        const data = this.getEventData(e);
        const view = this.graph.findViewByCell(this.node);
        if (data.knobbing) {
            if (view) {
                view.removeClass(Private$4.KNOBBING);
            }
            if (this.metadata && this.metadata.onMouseUp) {
                this.metadata.onMouseUp.call(this.graph, {
                    e,
                    data,
                    knob: this,
                    cell: this.cell,
                    node: this.node,
                });
            }
            this.model.stopBatch('knob', { cid: this.cid });
            this.notify('knobbed', e);
        }
        this.notify('knob:mouseup', e);
    }
}
var Private$4;
(function (Private) {
    Private.KNOB = 'has-widget-knob';
    Private.KNOBBING = 'node-knobbing';
    Private.documentEvents = {
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
    };
})(Private$4 || (Private$4 = {}));

var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ClassName;
(function (ClassName) {
    ClassName.root = 'widget-minimap';
    ClassName.viewport = `${ClassName.root}-viewport`;
    ClassName.zoom = `${ClassName.viewport}-zoom`;
})(ClassName || (ClassName = {}));
class MiniMap extends View {
    constructor(options) {
        super();
        this.options = Object.assign(Object.assign({}, Util$2.defaultOptions), options);
        this.updateViewport = debounce$1(this.updateViewport.bind(this), 0);
        this.container = document.createElement('div');
        this.$container = this.$(this.container).addClass(this.prefixClassName(ClassName.root));
        const graphContainer = document.createElement('div');
        this.container.appendChild(graphContainer);
        this.$viewport = this.$('<div>').addClass(this.prefixClassName(ClassName.viewport));
        if (this.options.scalable) {
            this.zoomHandle = this.$('<div>')
                .addClass(this.prefixClassName(ClassName.zoom))
                .appendTo(this.$viewport)
                .get(0);
        }
        this.$container.append(this.$viewport).css({
            width: this.options.width,
            height: this.options.height,
            padding: this.options.padding,
        });
        if (this.options.container) {
            this.options.container.appendChild(this.container);
        }
        this.sourceGraph = this.graph;
        const targetGraphOptions = Object.assign(Object.assign({}, this.options.graphOptions), { container: graphContainer, model: this.sourceGraph.model, frozen: true, async: this.sourceGraph.isAsync(), interacting: false, grid: false, background: false, rotating: false, resizing: false, embedding: false, selecting: false, snapline: false, clipboard: false, history: false, scroller: false });
        this.targetGraph = this.options.createGraph
            ? this.options.createGraph(targetGraphOptions)
            : new Graph(targetGraphOptions);
        this.targetGraph.renderer.unfreeze();
        this.updatePaper(this.sourceGraph.options.width, this.sourceGraph.options.height);
        this.startListening();
    }
    get graph() {
        return this.options.graph;
    }
    get scroller() {
        return this.graph.scroller.widget;
    }
    get graphContainer() {
        if (this.scroller) {
            return this.scroller.container;
        }
        return this.graph.container;
    }
    get $graphContainer() {
        if (this.scroller) {
            return this.scroller.$container;
        }
        return this.$(this.graph.container);
    }
    startListening() {
        if (this.scroller) {
            this.$graphContainer.on(`scroll${this.getEventNamespace()}`, this.updateViewport);
        }
        else {
            this.sourceGraph.on('translate', this.onTransform, this);
            this.sourceGraph.on('scale', this.onTransform, this);
            this.sourceGraph.on('model:updated', this.onModelUpdated, this);
        }
        this.sourceGraph.on('resize', this.updatePaper, this);
        this.delegateEvents({
            mousedown: 'startAction',
            touchstart: 'startAction',
            [`mousedown .${this.prefixClassName('graph')}`]: 'scrollTo',
            [`touchstart .${this.prefixClassName('graph')}`]: 'scrollTo',
        });
    }
    stopListening() {
        if (this.scroller) {
            this.$graphContainer.off(this.getEventNamespace());
        }
        else {
            this.sourceGraph.off('translate', this.onTransform, this);
            this.sourceGraph.off('scale', this.onTransform, this);
            this.sourceGraph.off('model:updated', this.onModelUpdated, this);
        }
        this.sourceGraph.off('resize', this.updatePaper, this);
        this.undelegateEvents();
    }
    onRemove() {
        this.targetGraph.view.remove();
        this.stopListening();
        this.targetGraph.dispose();
    }
    onTransform(options) {
        if (options.ui || this.targetGraphTransforming) {
            this.updateViewport();
        }
    }
    onModelUpdated() {
        this.targetGraph.zoomToFit();
    }
    updatePaper(w, h) {
        let width;
        let height;
        if (typeof w === 'object') {
            width = w.width;
            height = w.height;
        }
        else {
            width = w;
            height = h;
        }
        const origin = this.sourceGraph.options;
        const scale = this.sourceGraph.transform.getScale();
        const maxWidth = this.options.width - 2 * this.options.padding;
        const maxHeight = this.options.height - 2 * this.options.padding;
        width /= scale.sx; // eslint-disable-line
        height /= scale.sy; // eslint-disable-line
        this.ratio = Math.min(maxWidth / width, maxHeight / height);
        const ratio = this.ratio;
        const x = (origin.x * ratio) / scale.sx;
        const y = (origin.y * ratio) / scale.sy;
        width *= ratio; // eslint-disable-line
        height *= ratio; // eslint-disable-line
        this.targetGraph.resizeGraph(width, height);
        this.targetGraph.translate(x, y);
        if (this.scroller) {
            this.targetGraph.scale(ratio, ratio);
        }
        else {
            this.targetGraph.zoomToFit();
        }
        this.updateViewport();
        return this;
    }
    updateViewport() {
        const sourceGraphScale = this.sourceGraph.transform.getScale();
        const targetGraphScale = this.targetGraph.transform.getScale();
        let origin = null;
        if (this.scroller) {
            origin = this.scroller.clientToLocalPoint(0, 0);
        }
        else {
            origin = this.graph.graphToLocal(0, 0);
        }
        const position = this.$(this.targetGraph.container).position();
        const translation = this.targetGraph.translate();
        translation.ty = translation.ty || 0;
        this.geometry = {
            top: position.top + origin.y * targetGraphScale.sy + translation.ty,
            left: position.left + origin.x * targetGraphScale.sx + translation.tx,
            width: (this.$graphContainer.innerWidth() * targetGraphScale.sx) /
                sourceGraphScale.sx,
            height: (this.$graphContainer.innerHeight() * targetGraphScale.sy) /
                sourceGraphScale.sy,
        };
        this.$viewport.css(this.geometry);
    }
    startAction(evt) {
        const e = this.normalizeEvent(evt);
        const action = e.target === this.zoomHandle ? 'zooming' : 'panning';
        const { tx, ty } = this.sourceGraph.translate();
        const eventData = {
            action,
            clientX: e.clientX,
            clientY: e.clientY,
            scrollLeft: this.graphContainer.scrollLeft,
            scrollTop: this.graphContainer.scrollTop,
            zoom: this.sourceGraph.zoom(),
            scale: this.sourceGraph.transform.getScale(),
            geometry: this.geometry,
            translateX: tx,
            translateY: ty,
        };
        this.targetGraphTransforming = true;
        this.delegateDocumentEvents(Util$2.documentEvents, eventData);
    }
    doAction(evt) {
        const e = this.normalizeEvent(evt);
        const clientX = e.clientX;
        const clientY = e.clientY;
        const data = e.data;
        switch (data.action) {
            case 'panning': {
                const scale = this.sourceGraph.transform.getScale();
                const rx = (clientX - data.clientX) * scale.sx;
                const ry = (clientY - data.clientY) * scale.sy;
                if (this.scroller) {
                    this.graphContainer.scrollLeft = data.scrollLeft + rx / this.ratio;
                    this.graphContainer.scrollTop = data.scrollTop + ry / this.ratio;
                }
                else {
                    this.sourceGraph.translate(data.translateX - rx / this.ratio, data.translateY - ry / this.ratio);
                }
                break;
            }
            case 'zooming': {
                const startScale = data.scale;
                const startGeometry = data.geometry;
                const delta = 1 + (data.clientX - clientX) / startGeometry.width / startScale.sx;
                if (data.frameId) {
                    cancelAnimationFrame(data.frameId);
                }
                data.frameId = requestAnimationFrame(() => {
                    this.sourceGraph.zoom(delta * data.zoom, {
                        absolute: true,
                        minScale: this.options.minScale,
                        maxScale: this.options.maxScale,
                    });
                });
                break;
            }
            default:
                break;
        }
    }
    stopAction() {
        this.undelegateDocumentEvents();
        this.targetGraphTransforming = false;
    }
    scrollTo(evt) {
        const e = this.normalizeEvent(evt);
        let x;
        let y;
        const ts = this.targetGraph.translate();
        ts.ty = ts.ty || 0;
        if (e.offsetX == null) {
            const offset = this.$(this.targetGraph.container).offset();
            x = e.pageX - offset.left;
            y = e.pageY - offset.top;
        }
        else {
            x = e.offsetX;
            y = e.offsetY;
        }
        const cx = (x - ts.tx) / this.ratio;
        const cy = (y - ts.ty) / this.ratio;
        this.sourceGraph.centerPoint(cx, cy);
    }
    dispose() {
        this.remove();
    }
}
__decorate$m([
    View.dispose()
], MiniMap.prototype, "dispose", null);
var Util$2;
(function (Util) {
    Util.defaultOptions = {
        width: 300,
        height: 200,
        padding: 10,
        scalable: true,
        minScale: 0.01,
        maxScale: 16,
        graphOptions: {},
        createGraph: (options) => new Graph(options),
    };
    Util.documentEvents = {
        mousemove: 'doAction',
        touchmove: 'doAction',
        mouseup: 'stopAction',
        touchend: 'stopAction',
    };
})(Util$2 || (Util$2 = {}));

var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$7 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Snapline extends View {
    constructor(options) {
        super();
        const { graph } = options, others = __rest$7(options, ["graph"]);
        this.graph = graph;
        this.options = Object.assign({ tolerance: 10 }, others);
        this.offset = { x: 0, y: 0 };
        this.render();
        this.parseFilter();
        if (!this.disabled) {
            this.startListening();
        }
    }
    get model() {
        return this.graph.model;
    }
    get containerClassName() {
        return this.prefixClassName('widget-snapline');
    }
    get verticalClassName() {
        return `${this.containerClassName}-vertical`;
    }
    get horizontalClassName() {
        return `${this.containerClassName}-horizontal`;
    }
    get disabled() {
        return (this.options.enabled !== true ||
            this.graph.options.snapline.enabled !== true);
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
            this.graph.options.snapline.enabled = true;
            this.startListening();
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
            this.graph.options.snapline.enabled = false;
            this.stopListening();
        }
    }
    setFilter(filter) {
        this.options.filter = filter;
        this.parseFilter();
    }
    render() {
        const container = (this.containerWrapper = new Vector('svg'));
        const horizontal = (this.horizontal = new Vector('line'));
        const vertical = (this.vertical = new Vector('line'));
        container.addClass(this.containerClassName);
        horizontal.addClass(this.horizontalClassName);
        vertical.addClass(this.verticalClassName);
        container.setAttribute('width', '100%');
        container.setAttribute('height', '100%');
        horizontal.setAttribute('display', 'none');
        vertical.setAttribute('display', 'none');
        container.append([horizontal, vertical]);
        if (this.options.className) {
            container.addClass(this.options.className);
        }
        this.container = this.containerWrapper.node;
    }
    startListening() {
        this.stopListening();
        this.graph.on('node:mousedown', this.captureCursorOffset, this);
        this.graph.on('node:mousemove', this.snapOnMoving, this);
        this.model.on('batch:stop', this.onBatchStop, this);
        this.delegateDocumentEvents({
            mouseup: 'hide',
            touchend: 'hide',
        });
    }
    stopListening() {
        this.graph.off('node:mousedown', this.captureCursorOffset, this);
        this.graph.off('node:mousemove', this.snapOnMoving, this);
        this.model.off('batch:stop', this.onBatchStop, this);
        this.undelegateDocumentEvents();
    }
    parseFilter() {
        this.filterShapes = {};
        this.filterCells = {};
        this.filterFunction = null;
        const filter = this.options.filter;
        if (Array.isArray(filter)) {
            filter.forEach((item) => {
                if (typeof item === 'string') {
                    this.filterShapes[item] = true;
                }
                else {
                    this.filterCells[item.id] = true;
                }
            });
        }
        else if (typeof filter === 'function') {
            this.filterFunction = filter;
        }
    }
    onBatchStop({ name, data }) {
        if (name === 'resize') {
            this.snapOnResizing(data.cell, data);
        }
    }
    captureCursorOffset({ view, x, y }) {
        const targetView = view.getDelegatedView();
        if (targetView && this.isNodeMovable(targetView)) {
            const pos = view.cell.getPosition();
            this.offset = {
                x: x - pos.x,
                y: y - pos.y,
            };
        }
    }
    isNodeMovable(view) {
        return view && view.cell.isNode() && view.can('nodeMovable');
    }
    snapOnResizing(node, options) {
        if (this.options.resizing &&
            !options.snapped &&
            options.ui &&
            options.direction &&
            options.trueDirection) {
            const view = this.graph.renderer.findViewByCell(node);
            if (view && view.cell.isNode()) {
                const nodeBbox = node.getBBox();
                const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());
                const nodeTopLeft = nodeBBoxRotated.getTopLeft();
                const nodeBottomRight = nodeBBoxRotated.getBottomRight();
                const angle = Angle.normalize(node.getAngle());
                const tolerance = this.options.tolerance || 0;
                let verticalLeft;
                let verticalTop;
                let verticalHeight;
                let horizontalTop;
                let horizontalLeft;
                let horizontalWidth;
                const snapOrigin = {
                    vertical: 0,
                    horizontal: 0,
                };
                const direction = options.direction;
                const trueDirection = options.trueDirection;
                const relativeDirection = options.relativeDirection;
                if (trueDirection.indexOf('right') !== -1) {
                    snapOrigin.vertical = nodeBottomRight.x;
                }
                else {
                    snapOrigin.vertical = nodeTopLeft.x;
                }
                if (trueDirection.indexOf('bottom') !== -1) {
                    snapOrigin.horizontal = nodeBottomRight.y;
                }
                else {
                    snapOrigin.horizontal = nodeTopLeft.y;
                }
                this.model.getNodes().some((cell) => {
                    if (this.isIgnored(node, cell)) {
                        return false;
                    }
                    const snapBBox = cell.getBBox().bbox(cell.getAngle());
                    const snapTopLeft = snapBBox.getTopLeft();
                    const snapBottomRight = snapBBox.getBottomRight();
                    const groups = {
                        vertical: [snapTopLeft.x, snapBottomRight.x],
                        horizontal: [snapTopLeft.y, snapBottomRight.y],
                    };
                    const distances = {};
                    Object.keys(groups).forEach((k) => {
                        const key = k;
                        const list = groups[key]
                            .map((value) => ({
                            position: value,
                            distance: Math.abs(value - snapOrigin[key]),
                        }))
                            .filter((item) => item.distance <= tolerance);
                        distances[key] = sortBy(list, (item) => item.distance);
                    });
                    if (verticalLeft == null && distances.vertical.length > 0) {
                        verticalLeft = distances.vertical[0].position;
                        verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
                        verticalHeight =
                            Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
                    }
                    if (horizontalTop == null && distances.horizontal.length > 0) {
                        horizontalTop = distances.horizontal[0].position;
                        horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
                        horizontalWidth =
                            Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
                    }
                    return verticalLeft != null && horizontalTop != null;
                });
                this.hide();
                let dx = 0;
                let dy = 0;
                if (horizontalTop != null || verticalLeft != null) {
                    if (verticalLeft != null) {
                        dx =
                            trueDirection.indexOf('right') !== -1
                                ? verticalLeft - nodeBottomRight.x
                                : nodeTopLeft.x - verticalLeft;
                    }
                    if (horizontalTop != null) {
                        dy =
                            trueDirection.indexOf('bottom') !== -1
                                ? horizontalTop - nodeBottomRight.y
                                : nodeTopLeft.y - horizontalTop;
                    }
                }
                let dWidth = 0;
                let dHeight = 0;
                if (angle % 90 === 0) {
                    if (angle === 90 || angle === 270) {
                        dWidth = dy;
                        dHeight = dx;
                    }
                    else {
                        dWidth = dx;
                        dHeight = dy;
                    }
                }
                else {
                    const quadrant = angle >= 0 && angle < 90
                        ? 1
                        : angle >= 90 && angle < 180
                            ? 4
                            : angle >= 180 && angle < 270
                                ? 3
                                : 2;
                    if (horizontalTop != null && verticalLeft != null) {
                        if (dx < dy) {
                            dy = 0;
                            horizontalTop = undefined;
                        }
                        else {
                            dx = 0;
                            verticalLeft = undefined;
                        }
                    }
                    const rad = Angle.toRad(angle % 90);
                    if (dx) {
                        dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);
                    }
                    if (dy) {
                        dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);
                    }
                    const quadrant13 = quadrant === 1 || quadrant === 3;
                    switch (relativeDirection) {
                        case 'top':
                        case 'bottom':
                            dHeight = dy
                                ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad))
                                : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
                            break;
                        case 'left':
                        case 'right':
                            dWidth = dx
                                ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad))
                                : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
                            break;
                        default:
                            break;
                    }
                }
                switch (relativeDirection) {
                    case 'top':
                    case 'bottom':
                        dWidth = 0;
                        break;
                    case 'left':
                    case 'right':
                        dHeight = 0;
                        break;
                    default:
                        break;
                }
                const gridSize = this.graph.getGridSize();
                let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);
                let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);
                if (options.minWidth && options.minWidth > gridSize) {
                    newWidth = Math.max(newWidth, options.minWidth);
                }
                if (options.minHeight && options.minHeight > gridSize) {
                    newHeight = Math.max(newHeight, options.minHeight);
                }
                if (options.maxWidth) {
                    newWidth = Math.min(newWidth, options.maxWidth);
                }
                if (options.maxHeight) {
                    newHeight = Math.min(newHeight, options.maxHeight);
                }
                if (options.preserveAspectRatio) {
                    if (dHeight < dWidth) {
                        newHeight = newWidth * (nodeBbox.height / nodeBbox.width);
                    }
                    else {
                        newWidth = newHeight * (nodeBbox.width / nodeBbox.height);
                    }
                }
                if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {
                    node.resize(newWidth, newHeight, {
                        direction,
                        relativeDirection,
                        trueDirection,
                        snapped: true,
                        snaplines: this.cid,
                        restrict: this.graph.hook.getRestrictArea(view),
                    });
                    if (verticalHeight) {
                        verticalHeight += newHeight - nodeBbox.height;
                    }
                    if (horizontalWidth) {
                        horizontalWidth += newWidth - nodeBbox.width;
                    }
                }
                const newRotatedBBox = node.getBBox().bbox(angle);
                if (verticalLeft &&
                    Math.abs(newRotatedBBox.x - verticalLeft) > 1 &&
                    Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {
                    verticalLeft = undefined;
                }
                if (horizontalTop &&
                    Math.abs(newRotatedBBox.y - horizontalTop) > 1 &&
                    Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {
                    horizontalTop = undefined;
                }
                this.update({
                    verticalLeft,
                    verticalTop,
                    verticalHeight,
                    horizontalTop,
                    horizontalLeft,
                    horizontalWidth,
                });
            }
        }
    }
    snapOnMoving({ view, e, x, y }) {
        const targetView = view.getEventData(e).delegatedView || view;
        if (!this.isNodeMovable(targetView)) {
            return;
        }
        const node = targetView.cell;
        const size = node.getSize();
        const position = node.getPosition();
        const cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);
        const angle = node.getAngle();
        const nodeCenter = cellBBox.getCenter();
        const nodeBBoxRotated = cellBBox.bbox(angle);
        const nodeTopLeft = nodeBBoxRotated.getTopLeft();
        const nodeBottomRight = nodeBBoxRotated.getBottomRight();
        const distance = this.options.tolerance || 0;
        let verticalLeft;
        let verticalTop;
        let verticalHeight;
        let horizontalTop;
        let horizontalLeft;
        let horizontalWidth;
        let verticalFix = 0;
        let horizontalFix = 0;
        this.model.getNodes().some((targetNode) => {
            if (this.isIgnored(node, targetNode)) {
                return false;
            }
            const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());
            const snapCenter = snapBBox.getCenter();
            const snapTopLeft = snapBBox.getTopLeft();
            const snapBottomRight = snapBBox.getBottomRight();
            if (verticalLeft == null) {
                if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {
                    verticalLeft = snapCenter.x;
                    verticalFix = 0.5;
                }
                else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {
                    verticalLeft = snapTopLeft.x;
                    verticalFix = 0;
                }
                else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {
                    verticalLeft = snapTopLeft.x;
                    verticalFix = 1;
                }
                else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {
                    verticalLeft = snapBottomRight.x;
                    verticalFix = 1;
                }
                else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {
                    verticalLeft = snapBottomRight.x;
                }
                if (verticalLeft != null) {
                    verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
                    verticalHeight =
                        Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
                }
            }
            if (horizontalTop == null) {
                if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {
                    horizontalTop = snapCenter.y;
                    horizontalFix = 0.5;
                }
                else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {
                    horizontalTop = snapTopLeft.y;
                }
                else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {
                    horizontalTop = snapTopLeft.y;
                    horizontalFix = 1;
                }
                else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {
                    horizontalTop = snapBottomRight.y;
                    horizontalFix = 1;
                }
                else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {
                    horizontalTop = snapBottomRight.y;
                }
                if (horizontalTop != null) {
                    horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
                    horizontalWidth =
                        Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
                }
            }
            return verticalLeft != null && horizontalTop != null;
        });
        this.hide();
        if (horizontalTop != null || verticalLeft != null) {
            if (horizontalTop != null) {
                nodeBBoxRotated.y =
                    horizontalTop - horizontalFix * nodeBBoxRotated.height;
            }
            if (verticalLeft != null) {
                nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;
            }
            const newCenter = nodeBBoxRotated.getCenter();
            const newX = newCenter.x - cellBBox.width / 2;
            const newY = newCenter.y - cellBBox.height / 2;
            const dx = newX - position.x;
            const dy = newY - position.y;
            if (dx !== 0 || dy !== 0) {
                node.translate(dx, dy, {
                    snapped: true,
                    restrict: this.graph.hook.getRestrictArea(targetView),
                });
                if (horizontalWidth) {
                    horizontalWidth += dx;
                }
                if (verticalHeight) {
                    verticalHeight += dy;
                }
            }
            this.update({
                verticalLeft,
                verticalTop,
                verticalHeight,
                horizontalTop,
                horizontalLeft,
                horizontalWidth,
            });
        }
    }
    isIgnored(snapNode, targetNode) {
        return (targetNode.id === snapNode.id ||
            targetNode.isDescendantOf(snapNode) ||
            this.filterShapes[targetNode.shape] ||
            this.filterCells[targetNode.id] ||
            (this.filterFunction &&
                call(this.filterFunction, this.graph, targetNode)));
    }
    update(metadata) {
        // https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations
        if (metadata.horizontalTop) {
            const start = this.graph.localToGraph(new Point(metadata.horizontalLeft, metadata.horizontalTop));
            const end = this.graph.localToGraph(new Point(metadata.horizontalLeft + metadata.horizontalWidth, metadata.horizontalTop));
            this.horizontal.setAttributes({
                x1: this.options.sharp ? `${start.x}` : '0',
                y1: `${start.y}`,
                x2: this.options.sharp ? `${end.x}` : '100%',
                y2: `${end.y}`,
                display: 'inherit',
            });
        }
        else {
            this.horizontal.setAttribute('display', 'none');
        }
        if (metadata.verticalLeft) {
            const start = this.graph.localToGraph(new Point(metadata.verticalLeft, metadata.verticalTop));
            const end = this.graph.localToGraph(new Point(metadata.verticalLeft, metadata.verticalTop + metadata.verticalHeight));
            this.vertical.setAttributes({
                x1: `${start.x}`,
                y1: this.options.sharp ? `${start.y}` : '0',
                x2: `${end.x}`,
                y2: this.options.sharp ? `${end.y}` : '100%',
                display: 'inherit',
            });
        }
        else {
            this.vertical.setAttribute('display', 'none');
        }
        this.show();
    }
    resetTimer() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    show() {
        this.resetTimer();
        if (this.container.parentNode == null) {
            this.graph.container.appendChild(this.container);
        }
        return this;
    }
    hide() {
        this.resetTimer();
        this.vertical.setAttribute('display', 'none');
        this.horizontal.setAttribute('display', 'none');
        const clean = this.options.clean;
        const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;
        if (delay > 0) {
            this.timer = window.setTimeout(() => {
                if (this.container.parentNode !== null) {
                    this.unmount();
                }
            }, delay);
        }
        return this;
    }
    onRemove() {
        this.stopListening();
        this.hide();
    }
    dispose() {
        this.remove();
    }
}
__decorate$l([
    View.dispose()
], Snapline.prototype, "dispose", null);

var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Renderer extends Base {
    init() {
        this.resetUpdates();
        this.startListening();
        // Renders existing cells in the model.
        this.resetViews(this.model.getCells());
        // Starts rendering loop.
        if (!this.isFrozen() && this.isAsync()) {
            this.updateViewsAsync();
        }
    }
    startListening() {
        this.model.on('sorted', this.onSortModel, this);
        this.model.on('reseted', this.onModelReseted, this);
        this.model.on('batch:stop', this.onBatchStop, this);
        this.model.on('cell:added', this.onCellAdded, this);
        this.model.on('cell:removed', this.onCellRemoved, this);
        this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);
        this.model.on('cell:change:visible', this.onCellVisibleChanged, this);
    }
    stopListening() {
        this.model.off('sorted', this.onSortModel, this);
        this.model.off('reseted', this.onModelReseted, this);
        this.model.off('batch:stop', this.onBatchStop, this);
        this.model.off('cell:added', this.onCellAdded, this);
        this.model.off('cell:removed', this.onCellRemoved, this);
        this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);
        this.model.off('cell:change:visible', this.onCellVisibleChanged, this);
    }
    resetUpdates() {
        this.updates = {
            priorities: [{}, {}, {}],
            mounted: {},
            mountedCids: [],
            unmounted: {},
            unmountedCids: [],
            count: 0,
            sort: false,
            frozen: false,
            freezeKey: null,
            animationId: null,
        };
    }
    onSortModel() {
        if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {
            return;
        }
        this.sortViews();
    }
    onModelReseted({ options }) {
        this.removeZPivots();
        this.resetViews(this.model.getCells(), options);
    }
    onBatchStop({ name, data }) {
        if (this.isFrozen()) {
            return;
        }
        const model = this.model;
        if (!this.isAsync()) {
            const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;
            if (updateDelayingBatches.includes(name) &&
                !model.hasActiveBatch(updateDelayingBatches)) {
                this.updateViews(data);
            }
        }
        const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;
        if (sortDelayingBatches.includes(name) &&
            !model.hasActiveBatch(sortDelayingBatches)) {
            this.sortViews();
        }
    }
    onCellAdded({ cell, options }) {
        const position = options.position;
        if (this.isAsync() || typeof position !== 'number') {
            this.renderView(cell, options);
        }
        else {
            if (options.maxPosition === position) {
                this.freeze({ key: 'addCells' });
            }
            this.renderView(cell, options);
            if (position === 0) {
                this.unfreeze({ key: 'addCells' });
            }
        }
    }
    onCellRemoved({ cell, options }) {
        const view = this.findViewByCell(cell);
        if (view) {
            this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);
        }
    }
    onCellZIndexChanged({ cell, options, }) {
        if (this.options.sorting === 'approx') {
            const view = this.findViewByCell(cell);
            if (view) {
                this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);
            }
        }
    }
    onCellVisibleChanged({ cell, current: visible, options, }) {
        // Hide connected edges before cell
        if (!visible) {
            this.processEdgeOnTerminalVisibleChanged(cell, false);
        }
        const view = this.findViewByCell(cell);
        if (!visible && view) {
            this.removeView(cell);
        }
        else if (visible && view == null) {
            this.renderView(cell, options);
        }
        // Show connected edges after cell rendered
        if (visible) {
            this.processEdgeOnTerminalVisibleChanged(cell, true);
        }
        // this.sortViews()
    }
    processEdgeOnTerminalVisibleChanged(node, visible) {
        const getOpposite = (edge, currentTerminal) => {
            const sourceId = edge.getSourceCellId();
            if (sourceId !== currentTerminal.id) {
                return edge.getSourceCell();
            }
            const targetId = edge.getTargetCellId();
            if (targetId !== currentTerminal.id) {
                return edge.getTargetCell();
            }
            return null;
        };
        this.model.getConnectedEdges(node).forEach((edge) => {
            const opposite = getOpposite(edge, node);
            if (opposite == null || opposite.isVisible()) {
                visible ? edge.show() : edge.hide();
            }
        });
    }
    isEdgeTerminalVisible(edge, terminal) {
        const cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();
        const cell = cellId ? this.model.getCell(cellId) : null;
        if (cell && !cell.isVisible()) {
            return false;
        }
        return true;
    }
    requestConnectedEdgesUpdate(view, options = {}) {
        if (CellView.isCellView(view)) {
            const cell = view.cell;
            const edges = this.model.getConnectedEdges(cell);
            for (let j = 0, n = edges.length; j < n; j += 1) {
                const edge = edges[j];
                const edgeView = this.findViewByCell(edge);
                if (!edgeView) {
                    continue;
                }
                const flagLabels = ['update'];
                if (edge.getTargetCell() === cell) {
                    flagLabels.push('target');
                }
                if (edge.getSourceCell() === cell) {
                    flagLabels.push('source');
                }
                this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);
            }
        }
    }
    forcePostponedViewUpdate(view, flag) {
        if (!view || !CellView.isCellView(view)) {
            return false;
        }
        const cell = view.cell;
        if (cell.isNode()) {
            return false;
        }
        const edgeView = view;
        if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {
            // EdgeView is waiting for the source/target cellView to be rendered.
            // This can happen when the cells are not in the viewport.
            let sourceFlag = 0;
            const sourceView = this.findViewByCell(cell.getSourceCell());
            if (sourceView && !this.isViewMounted(sourceView)) {
                sourceFlag = this.dumpView(sourceView);
                edgeView.updateTerminalMagnet('source');
            }
            let targetFlag = 0;
            const targetView = this.findViewByCell(cell.getTargetCell());
            if (targetView && !this.isViewMounted(targetView)) {
                targetFlag = this.dumpView(targetView);
                edgeView.updateTerminalMagnet('target');
            }
            if (sourceFlag === 0 && targetFlag === 0) {
                // If leftover flag is 0, all view updates were done.
                return !this.dumpView(edgeView);
            }
        }
        return false;
    }
    scheduleViewUpdate(view, flag, priority, options = {}) {
        const cid = view.cid;
        const updates = this.updates;
        let cache = updates.priorities[priority];
        if (!cache) {
            cache = updates.priorities[priority] = {};
        }
        const currentFlag = cache[cid] || 0;
        if ((currentFlag & flag) === flag) {
            return;
        }
        if (!currentFlag) {
            updates.count += 1;
        }
        if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {
            // When a view is removed we need to remove the
            // insert flag as this is a reinsert.
            cache[cid] ^= Renderer.FLAG_INSERT;
        }
        else if (flag & Renderer.FLAG_INSERT &&
            currentFlag & Renderer.FLAG_REMOVE) {
            // When a view is added we need to remove the remove
            // flag as this is view was previously removed.
            cache[cid] ^= Renderer.FLAG_REMOVE;
        }
        cache[cid] |= flag;
        this.graph.hook.onViewUpdated(view, flag, options);
    }
    requestViewUpdate(view, flag, priority, options = {}) {
        this.scheduleViewUpdate(view, flag, priority, options);
        const isAsync = this.isAsync();
        if (this.isFrozen() ||
            (isAsync && options.async !== false) ||
            this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {
            return;
        }
        const stats = this.updateViews(options);
        if (isAsync) {
            this.graph.trigger('render:done', { stats, options });
        }
    }
    /**
     * Adds view into the DOM and update it.
     */
    dumpView(view, options = {}) {
        if (view == null) {
            return 0;
        }
        const cid = view.cid;
        const updates = this.updates;
        const cache = updates.priorities[view.priority];
        const flag = this.registerMountedView(view) | cache[cid];
        delete cache[cid];
        if (!flag) {
            return 0;
        }
        return this.updateView(view, flag, options);
    }
    /**
     * Adds all views into the DOM and update them.
     */
    dumpViews(options = {}) {
        this.checkView(options);
        this.updateViews(options);
    }
    /**
     * Ensure the view associated with the cell is attached
     * to the DOM and updated.
     */
    requireView(cell, options = {}) {
        const view = this.findViewByCell(cell);
        if (view == null) {
            return null;
        }
        this.dumpView(view, options);
        return view;
    }
    updateView(view, flag, options = {}) {
        if (view == null) {
            return 0;
        }
        if (CellView.isCellView(view)) {
            if (flag & Renderer.FLAG_REMOVE) {
                this.removeView(view.cell);
                return 0;
            }
            if (flag & Renderer.FLAG_INSERT) {
                this.insertView(view);
                flag ^= Renderer.FLAG_INSERT; // eslint-disable-line
            }
        }
        if (!flag) {
            return 0;
        }
        return view.confirmUpdate(flag, options);
    }
    updateViews(options = {}) {
        let result;
        let batchCount = 0;
        let updatedCount = 0;
        let priority = Renderer.MIN_PRIORITY;
        do {
            result = this.updateViewsBatch(options);
            batchCount += 1;
            updatedCount += result.updatedCount;
            priority = Math.min(result.priority, priority);
        } while (!result.empty);
        return {
            priority,
            batchCount,
            updatedCount,
        };
    }
    updateViewsBatch(options = {}) {
        const updates = this.updates;
        const priorities = updates.priorities;
        const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;
        let empty = true;
        let priority = Renderer.MIN_PRIORITY;
        let mountedCount = 0;
        let unmountedCount = 0;
        let updatedCount = 0;
        let postponedCount = 0;
        let checkView = options.checkView || this.options.checkView;
        if (typeof checkView !== 'function') {
            checkView = null;
        }
        // eslint-disable-next-line
        main: for (let p = 0, n = priorities.length; p < n; p += 1) {
            const cache = priorities[p];
            // eslint-disable-next-line
            for (const cid in cache) {
                if (updatedCount >= batchSize) {
                    empty = false; // goto next batch
                    break main; // eslint-disable-line no-labels
                }
                const view = View.views[cid];
                if (!view) {
                    delete cache[cid];
                    continue;
                }
                let currentFlag = cache[cid];
                // Do not check a view for viewport if we are about to remove the view.
                if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {
                    const isUnmounted = cid in updates.unmounted;
                    if (checkView &&
                        !call(checkView, this.graph, {
                            view: view,
                            unmounted: isUnmounted,
                        })) {
                        // Unmount view
                        if (!isUnmounted) {
                            this.registerUnmountedView(view);
                            view.unmount();
                        }
                        updates.unmounted[cid] |= currentFlag;
                        delete cache[cid];
                        unmountedCount += 1;
                        continue;
                    }
                    // Mount view
                    if (isUnmounted) {
                        currentFlag |= Renderer.FLAG_INSERT;
                        mountedCount += 1;
                    }
                    currentFlag |= this.registerMountedView(view);
                }
                const cellView = view;
                let leftoverFlag = this.updateView(view, currentFlag, options);
                if (leftoverFlag > 0) {
                    const cell = cellView.cell;
                    if (cell && cell.isEdge()) {
                        // remove edge view when source cell is invisible
                        if (cellView.hasAction(leftoverFlag, 'source') &&
                            !this.isEdgeTerminalVisible(cell, 'source')) {
                            leftoverFlag = cellView.removeAction(leftoverFlag, 'source');
                            leftoverFlag |= Renderer.FLAG_REMOVE;
                        }
                        // remove edge view when target cell is invisible
                        if (cellView.hasAction(leftoverFlag, 'target') &&
                            !this.isEdgeTerminalVisible(cell, 'target')) {
                            leftoverFlag = cellView.removeAction(leftoverFlag, 'target');
                            leftoverFlag |= Renderer.FLAG_REMOVE;
                        }
                    }
                }
                if (leftoverFlag > 0) {
                    // update has not finished
                    cache[cid] = leftoverFlag;
                    if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) ||
                        cache[cid]) {
                        postponedCount += 1;
                        empty = false;
                        continue;
                    }
                }
                if (priority > p) {
                    priority = p;
                }
                updatedCount += 1;
                delete cache[cid];
            }
        }
        return {
            empty,
            priority,
            mountedCount,
            unmountedCount,
            updatedCount,
            postponedCount,
        };
    }
    updateViewsAsync(options = {}, data = {
        processed: 0,
        priority: Renderer.MIN_PRIORITY,
    }) {
        const updates = this.updates;
        const animationId = updates.animationId;
        if (animationId) {
            cancelAnimationFrame$1(animationId);
            if (data.processed === 0) {
                const beforeFn = options.before;
                if (typeof beforeFn === 'function') {
                    call(beforeFn, this.graph, this.graph);
                }
            }
            const stats = this.updateViewsBatch(options);
            const checkout = this.checkViewImpl({
                checkView: options.checkView,
                mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,
                unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount,
            });
            let processed = data.processed;
            const total = updates.count;
            const mountedCount = checkout.mountedCount;
            const unmountedCount = checkout.unmountedCount;
            if (stats.updatedCount > 0) {
                // Some updates have been just processed
                processed += stats.updatedCount + stats.unmountedCount;
                data.priority = Math.min(stats.priority, data.priority);
                if (stats.empty && mountedCount === 0) {
                    stats.priority = data.priority;
                    stats.mountedCount += mountedCount;
                    stats.unmountedCount += unmountedCount;
                    this.graph.trigger('render:done', { stats, options });
                    data.processed = 0;
                    updates.count = 0;
                }
                else {
                    data.processed = processed;
                }
            }
            // Progress callback
            const progressFn = options.progress;
            if (total && typeof progressFn === 'function') {
                call(progressFn, this.graph, {
                    total,
                    done: stats.empty,
                    current: processed,
                });
            }
            // The current frame could have been canceled in a callback
            if (updates.animationId !== animationId) {
                return;
            }
        }
        updates.animationId = requestAnimationFrame$1(() => {
            this.updateViewsAsync(options, data);
        });
    }
    registerMountedView(view) {
        const cid = view.cid;
        const updates = this.updates;
        if (cid in updates.mounted) {
            return 0;
        }
        updates.mounted[cid] = true;
        updates.mountedCids.push(cid);
        const flag = updates.unmounted[cid] || 0;
        delete updates.unmounted[cid];
        return flag;
    }
    registerUnmountedView(view) {
        const cid = view.cid;
        const updates = this.updates;
        if (cid in updates.unmounted) {
            return 0;
        }
        updates.unmounted[cid] |= Renderer.FLAG_INSERT;
        const flag = updates.unmounted[cid];
        updates.unmountedCids.push(cid);
        delete updates.mounted[cid];
        return flag;
    }
    isViewMounted(view) {
        if (view == null) {
            return false;
        }
        const cid = view.cid;
        return cid in this.updates.mounted;
    }
    getMountedViews() {
        return Object.keys(this.updates.mounted).map((cid) => CellView.views[cid]);
    }
    getUnmountedViews() {
        return Object.keys(this.updates.unmounted).map((cid) => CellView.views[cid]);
    }
    checkMountedViews(viewportFn, batchSize) {
        let unmountCount = 0;
        if (typeof viewportFn !== 'function') {
            return unmountCount;
        }
        const updates = this.updates;
        const mounted = updates.mounted;
        const mountedCids = updates.mountedCids;
        const size = batchSize == null
            ? mountedCids.length
            : Math.min(mountedCids.length, batchSize);
        for (let i = 0; i < size; i += 1) {
            const cid = mountedCids[i];
            if (!(cid in mounted)) {
                continue;
            }
            const view = CellView.views[cid];
            if (view == null) {
                continue;
            }
            const shouldMount = call(viewportFn, this.graph, {
                view: view,
                unmounted: true,
            });
            if (shouldMount) {
                // Push at the end of all mounted ids
                mountedCids.push(cid);
                continue;
            }
            unmountCount += 1;
            const flag = this.registerUnmountedView(view);
            if (flag) {
                view.unmount();
            }
        }
        // Get rid of views, that have been unmounted
        mountedCids.splice(0, size);
        return unmountCount;
    }
    checkUnmountedViews(checkView, batchSize) {
        let mountCount = 0;
        if (typeof checkView !== 'function') {
            checkView = null; // eslint-disable-line
        }
        const updates = this.updates;
        const unmounted = updates.unmounted;
        const unmountedCids = updates.unmountedCids;
        const size = batchSize == null
            ? unmountedCids.length
            : Math.min(unmountedCids.length, batchSize);
        for (let i = 0; i < size; i += 1) {
            const cid = unmountedCids[i];
            if (!(cid in unmounted)) {
                continue;
            }
            const view = CellView.views[cid];
            if (view == null) {
                continue;
            }
            if (checkView &&
                !call(checkView, this.graph, { view, unmounted: false })) {
                unmountedCids.push(cid);
                continue;
            }
            mountCount += 1;
            const flag = this.registerMountedView(view);
            if (flag) {
                this.scheduleViewUpdate(view, flag, view.priority, {
                    mounting: true,
                });
            }
        }
        // Get rid of views, that have been mounted
        unmountedCids.splice(0, size);
        return mountCount;
    }
    checkViewImpl(options = {
        mountedBatchSize: Number.MAX_SAFE_INTEGER,
        unmountedBatchSize: Number.MAX_SAFE_INTEGER,
    }) {
        const checkView = options.checkView || this.options.checkView;
        const unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);
        const mountedCount = this.checkUnmountedViews(checkView, 
        // Do not check views, that have been just unmounted
        // and pushed at the end of the cids array
        unmountedCount > 0
            ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize)
            : options.mountedBatchSize);
        return { mountedCount, unmountedCount };
    }
    /**
     * Determine every view in the graph should be attached/detached.
     */
    checkView(options = {}) {
        return this.checkViewImpl(options);
    }
    isFrozen() {
        return !!this.options.frozen;
    }
    /**
     * Freeze the graph then the graph does not automatically re-render upon
     * changes in the graph. This is useful when adding large numbers of cells.
     */
    freeze(options = {}) {
        const key = options.key;
        const updates = this.updates;
        const frozen = this.options.frozen;
        const freezeKey = updates.freezeKey;
        if (key && key !== freezeKey) {
            if (frozen && freezeKey) {
                // key passed, but the graph is already freezed with another key
                return;
            }
            updates.frozen = frozen;
            updates.freezeKey = key;
        }
        this.options.frozen = true;
        const animationId = updates.animationId;
        updates.animationId = null;
        if (this.isAsync() && animationId != null) {
            cancelAnimationFrame$1(animationId);
        }
        this.graph.trigger('freeze', { key });
    }
    unfreeze(options = {}) {
        const key = options.key;
        const updates = this.updates;
        const freezeKey = updates.freezeKey;
        // key passed, but the graph is already freezed with another key
        if (key && freezeKey && key !== freezeKey) {
            return;
        }
        updates.freezeKey = null;
        // key passed, but the graph is already freezed
        if (key && key === freezeKey && updates.frozen) {
            return;
        }
        const callback = () => {
            this.options.frozen = updates.frozen = false;
            if (updates.sort) {
                this.sortViews();
                updates.sort = false;
            }
            const afterFn = options.after;
            if (afterFn) {
                call(afterFn, this.graph, this.graph);
            }
            this.graph.trigger('unfreeze', { key });
        };
        if (this.isAsync()) {
            this.freeze();
            const onProgress = options.progress;
            this.updateViewsAsync(Object.assign(Object.assign({}, options), { progress: ({ done, current, total }) => {
                    if (onProgress) {
                        call(onProgress, this.graph, { done, current, total });
                    }
                    // sort views after async render
                    if (done) {
                        callback();
                    }
                } }));
        }
        else {
            this.updateViews(options);
            callback();
        }
    }
    isAsync() {
        return !!this.options.async;
    }
    setAsync(async) {
        this.options.async = async;
    }
    onRemove() {
        this.freeze();
        this.removeViews();
    }
    resetViews(cells = [], options = {}) {
        this.resetUpdates();
        this.removeViews();
        this.freeze({ key: 'reset' });
        for (let i = 0, n = cells.length; i < n; i += 1) {
            this.renderView(cells[i], options);
        }
        this.unfreeze({ key: 'reset' });
        this.sortViews();
    }
    removeView(cell) {
        const view = this.views[cell.id];
        if (view) {
            const cid = view.cid;
            const updates = this.updates;
            const mounted = updates.mounted;
            const unmounted = updates.unmounted;
            view.remove();
            delete this.views[cell.id];
            delete mounted[cid];
            delete unmounted[cid];
        }
        return view;
    }
    removeViews() {
        if (this.views) {
            Object.keys(this.views).forEach((id) => {
                const view = this.views[id];
                if (view) {
                    this.removeView(view.cell);
                }
            });
        }
        this.views = {};
    }
    renderView(cell, options = {}) {
        const id = cell.id;
        const views = this.views;
        let flag = 0;
        let view = views[id];
        if (!cell.isVisible()) {
            return;
        }
        if (cell.isEdge()) {
            if (!this.isEdgeTerminalVisible(cell, 'source') ||
                !this.isEdgeTerminalVisible(cell, 'target')) {
                return;
            }
        }
        if (view) {
            flag = Renderer.FLAG_INSERT;
        }
        else {
            const tmp = this.graph.hook.createCellView(cell);
            if (tmp) {
                view = views[cell.id] = tmp;
                view.graph = this.graph;
                flag = this.registerUnmountedView(view) | view.getBootstrapFlag();
            }
        }
        if (view) {
            this.requestViewUpdate(view, flag, view.priority, options);
        }
    }
    isExactSorting() {
        return this.options.sorting === 'exact';
    }
    sortViews() {
        if (!this.isExactSorting()) {
            return;
        }
        if (this.isFrozen()) {
            // sort views once unfrozen
            this.updates.sort = true;
            return;
        }
        this.sortViewsExact();
    }
    sortElements(elems, comparator) {
        // Highly inspired by the jquery.sortElements plugin by Padolsey.
        // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.
        const placements = elems.map((elem) => {
            const parentNode = elem.parentNode;
            // Since the element itself will change position, we have
            // to have some way of storing it's original position in
            // the DOM. The easiest way is to have a 'flag' node:
            const nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);
            return (targetNode) => {
                if (parentNode === targetNode) {
                    throw new Error("You can't sort elements if any one is a descendant of another.");
                }
                // Insert before flag
                parentNode.insertBefore(targetNode, nextSibling);
                // Remove flag
                parentNode.removeChild(nextSibling);
            };
        });
        elems.sort(comparator).forEach((elem, index) => placements[index](elem));
    }
    sortViewsExact() {
        // const elems = this.view.stage.querySelectorAll('[data-cell-id]')
        // const length = elems.length
        // const cells = []
        // for (let i = 0; i < length; i++) {
        //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')
        //   cells.push({
        //     id: cell.id,
        //     zIndex: cell.getZIndex() || 0,
        //     elem: elems[i],
        //   })
        // }
        // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)
        // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves
        // if (moves && moves.length) {
        //   moves.forEach((move) => {
        //     if (move.type) {
        //       const elem = move.item.elem as Element
        //       const parentNode = elem.parentNode
        //       const index = move.index
        //       if (parentNode) {
        //         if (index === length - 1) {
        //           parentNode.appendChild(elem)
        //         } else if (index < length - 1) {
        //           parentNode.insertBefore(elem, elems[index + 1])
        //         }
        //       }
        //     }
        //   })
        // }
        // Run insertion sort algorithm in order to efficiently sort DOM
        // elements according to their associated cell `zIndex` attribute.
        const elems = this.view
            .$(this.view.stage)
            .children('[data-cell-id]')
            .toArray();
        const model = this.model;
        this.sortElements(elems, (a, b) => {
            const cellA = model.getCell(a.getAttribute('data-cell-id') || '');
            const cellB = model.getCell(b.getAttribute('data-cell-id') || '');
            const z1 = cellA.getZIndex() || 0;
            const z2 = cellB.getZIndex() || 0;
            return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;
        });
    }
    addZPivot(zIndex = 0) {
        if (this.zPivots == null) {
            this.zPivots = {};
        }
        const pivots = this.zPivots;
        let pivot = pivots[zIndex];
        if (pivot) {
            return pivot;
        }
        pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);
        let neighborZ = -Infinity;
        // eslint-disable-next-line
        for (const key in pivots) {
            const currentZ = +key;
            if (currentZ < zIndex && currentZ > neighborZ) {
                neighborZ = currentZ;
                if (neighborZ === zIndex - 1) {
                    continue;
                }
            }
        }
        const layer = this.view.stage;
        if (neighborZ !== -Infinity) {
            const neighborPivot = pivots[neighborZ];
            layer.insertBefore(pivot, neighborPivot.nextSibling);
        }
        else {
            layer.insertBefore(pivot, layer.firstChild);
        }
        return pivot;
    }
    removeZPivots() {
        if (this.zPivots) {
            Object.keys(this.zPivots).forEach((z) => {
                const elem = this.zPivots[z];
                if (elem && elem.parentNode) {
                    elem.parentNode.removeChild(elem);
                }
            });
        }
        this.zPivots = {};
    }
    insertView(view) {
        const stage = this.view.stage;
        switch (this.options.sorting) {
            case 'approx': {
                const zIndex = view.cell.getZIndex();
                const pivot = this.addZPivot(zIndex);
                stage.insertBefore(view.container, pivot);
                break;
            }
            case 'exact':
            default:
                stage.appendChild(view.container);
                break;
        }
    }
    findViewByCell(cell) {
        if (cell == null) {
            return null;
        }
        const id = Cell.isCell(cell) ? cell.id : cell;
        return this.views[id];
    }
    findViewByElem(elem) {
        if (elem == null) {
            return null;
        }
        const target = typeof elem === 'string'
            ? this.view.stage.querySelector(elem)
            : elem instanceof Element
                ? elem
                : elem[0];
        if (target) {
            const id = this.view.findAttr('data-cell-id', target);
            if (id) {
                return this.views[id];
            }
        }
        return null;
    }
    findViewsFromPoint(p) {
        const ref = { x: p.x, y: p.y };
        return this.model
            .getCells()
            .map((cell) => this.findViewByCell(cell))
            .filter((view) => {
            if (view != null) {
                return getBBox(view.container, {
                    target: this.view.stage,
                }).containsPoint(ref);
            }
            return false;
        });
    }
    findEdgeViewsInArea(rect, options = {}) {
        const area = Rectangle.create(rect);
        return this.model
            .getEdges()
            .map((edge) => this.findViewByCell(edge))
            .filter((view) => {
            if (view) {
                const bbox = getBBox(view.container, {
                    target: this.view.stage,
                });
                if (bbox.width === 0) {
                    bbox.inflate(1, 0);
                }
                else if (bbox.height === 0) {
                    bbox.inflate(0, 1);
                }
                return options.strict
                    ? area.containsRect(bbox)
                    : area.isIntersectWithRect(bbox);
            }
            return false;
        });
    }
    findViewsInArea(rect, options = {}) {
        const area = Rectangle.create(rect);
        return this.model
            .getNodes()
            .map((node) => this.findViewByCell(node))
            .filter((view) => {
            if (view) {
                const bbox = getBBox(view.container, {
                    target: this.view.stage,
                });
                return options.strict
                    ? area.containsRect(bbox)
                    : area.isIntersectWithRect(bbox);
            }
            return false;
        });
    }
    dispose() {
        this.resetUpdates();
        this.stopListening();
    }
}
__decorate$k([
    Base.dispose()
], Renderer.prototype, "dispose", null);
(function (Renderer) {
    Renderer.FLAG_INSERT = 1 << 30;
    Renderer.FLAG_REMOVE = 1 << 29;
    Renderer.MOUNT_BATCH_SIZE = 1000;
    Renderer.UPDATE_BATCH_SIZE = 1000;
    Renderer.MIN_PRIORITY = 2;
    Renderer.SORT_DELAYING_BATCHES = [
        'add',
        'to-front',
        'to-back',
    ];
    Renderer.UPDATE_DELAYING_BATCHES = ['translate'];
})(Renderer || (Renderer = {}));

var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class BackgroundManager extends Base {
    get elem() {
        return this.view.background;
    }
    init() {
        this.startListening();
        if (this.options.background) {
            this.draw(this.options.background);
        }
    }
    startListening() {
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
    }
    stopListening() {
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
    }
    updateBackgroundImage(options = {}) {
        let backgroundSize = options.size || 'auto auto';
        let backgroundPosition = options.position || 'center';
        const scale = this.graph.transform.getScale();
        const ts = this.graph.translate();
        // backgroundPosition
        if (typeof backgroundPosition === 'object') {
            const x = ts.tx + scale.sx * (backgroundPosition.x || 0);
            const y = ts.ty + scale.sy * (backgroundPosition.y || 0);
            backgroundPosition = `${x}px ${y}px`;
        }
        // backgroundSize
        if (typeof backgroundSize === 'object') {
            backgroundSize = Rectangle.fromSize(backgroundSize).scale(scale.sx, scale.sy);
            backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`;
        }
        this.elem.style.backgroundSize = backgroundSize;
        this.elem.style.backgroundPosition = backgroundPosition;
    }
    drawBackgroundImage(img, options = {}) {
        if (!(img instanceof HTMLImageElement)) {
            this.elem.style.backgroundImage = '';
            return;
        }
        // draw multiple times to show the last image
        const cache = this.optionsCache;
        if (cache && cache.image !== options.image) {
            return;
        }
        let uri;
        const opacity = options.opacity;
        const backgroundSize = options.size;
        let backgroundRepeat = options.repeat || 'no-repeat';
        const pattern = Background.registry.get(backgroundRepeat);
        if (typeof pattern === 'function') {
            const quality = options.quality || 1;
            img.width *= quality;
            img.height *= quality;
            const canvas = pattern(img, options);
            if (!(canvas instanceof HTMLCanvasElement)) {
                throw new Error('Background pattern must return an HTML Canvas instance');
            }
            uri = canvas.toDataURL('image/png');
            // `repeat` was changed in pattern function
            if (options.repeat && backgroundRepeat !== options.repeat) {
                backgroundRepeat = options.repeat;
            }
            else {
                backgroundRepeat = 'repeat';
            }
            if (typeof backgroundSize === 'object') {
                // recalculate the tile size if an object passed in
                backgroundSize.width *= canvas.width / img.width;
                backgroundSize.height *= canvas.height / img.height;
            }
            else if (backgroundSize === undefined) {
                // calcule the tile size if no provided
                options.size = {
                    width: canvas.width / quality,
                    height: canvas.height / quality,
                };
            }
        }
        else {
            uri = img.src;
            if (backgroundSize === undefined) {
                options.size = {
                    width: img.width,
                    height: img.height,
                };
            }
        }
        if (cache != null &&
            typeof options.size === 'object' &&
            options.image === cache.image &&
            options.repeat === cache.repeat &&
            options.quality ===
                cache.quality) {
            cache.size = clone(options.size);
        }
        const style = this.elem.style;
        style.backgroundImage = `url(${uri})`;
        style.backgroundRepeat = backgroundRepeat;
        style.opacity = opacity == null || opacity >= 1 ? '' : `${opacity}`;
        this.updateBackgroundImage(options);
    }
    updateBackgroundColor(color) {
        this.elem.style.backgroundColor = color || '';
    }
    updateBackgroundOptions(options) {
        this.graph.options.background = options;
    }
    update() {
        if (this.optionsCache) {
            this.updateBackgroundImage(this.optionsCache);
        }
    }
    draw(options) {
        const opts = options || {};
        this.updateBackgroundOptions(options);
        this.updateBackgroundColor(opts.color);
        if (opts.image) {
            this.optionsCache = clone(opts);
            const img = document.createElement('img');
            img.onload = () => this.drawBackgroundImage(img, options);
            img.setAttribute('crossorigin', 'anonymous');
            img.src = opts.image;
        }
        else {
            this.drawBackgroundImage(null);
            this.optionsCache = null;
        }
    }
    clear() {
        this.draw();
    }
    dispose() {
        this.clear();
        this.stopListening();
    }
}
__decorate$j([
    Base.dispose()
], BackgroundManager.prototype, "dispose", null);

var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$6 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Scroller extends View {
    constructor(options) {
        super();
        this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        this.options = Util$1.getOptions(options);
        const scale = this.graph.transform.getScale();
        this.sx = scale.sx;
        this.sy = scale.sy;
        const width = this.options.width || this.graph.options.width;
        const height = this.options.height || this.graph.options.height;
        this.container = document.createElement('div');
        this.$container = this.$(this.container)
            .addClass(this.prefixClassName(Util$1.containerClass))
            .css({ width, height });
        if (this.options.pageVisible) {
            this.$container.addClass(this.prefixClassName(Util$1.pagedClass));
        }
        if (this.options.className) {
            this.$container.addClass(this.options.className);
        }
        const graphContainer = this.graph.container;
        if (graphContainer.parentNode) {
            this.$container.insertBefore(graphContainer);
        }
        // copy style
        const style = graphContainer.getAttribute('style');
        if (style) {
            const obj = {};
            const styles = style.split(';');
            styles.forEach((item) => {
                const section = item.trim();
                if (section) {
                    const pair = section.split(':');
                    if (pair.length) {
                        obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
                    }
                }
            });
            Object.keys(obj).forEach((key) => {
                if (key === 'width' || key === 'height') {
                    return;
                }
                graphContainer.style[key] = '';
                this.container.style[key] = obj[key];
            });
        }
        this.content = document.createElement('div');
        this.$content = this.$(this.content)
            .addClass(this.prefixClassName(Util$1.contentClass))
            .css({
            width: this.graph.options.width,
            height: this.graph.options.height,
        });
        // custom background
        this.background = document.createElement('div');
        this.$background = this.$(this.background).addClass(this.prefixClassName(Util$1.backgroundClass));
        this.$content.append(this.background);
        if (!this.options.pageVisible) {
            this.$content.append(this.graph.view.grid);
        }
        this.$content.append(graphContainer);
        this.$content.appendTo(this.container);
        this.startListening();
        if (!this.options.pageVisible) {
            this.graph.grid.update();
        }
        this.backgroundManager = new Scroller.Background(this);
        if (!this.options.autoResize) {
            this.update();
        }
    }
    get graph() {
        return this.options.graph;
    }
    get model() {
        return this.graph.model;
    }
    startListening() {
        const graph = this.graph;
        const model = this.model;
        graph.on('scale', this.onScale, this);
        graph.on('resize', this.onResize, this);
        graph.on('before:print', this.storeScrollPosition, this);
        graph.on('before:export', this.storeScrollPosition, this);
        graph.on('after:print', this.restoreScrollPosition, this);
        graph.on('after:export', this.restoreScrollPosition, this);
        graph.on('render:done', this.onRenderDone, this);
        graph.on('unfreeze', this.onUpdate, this);
        model.on('reseted', this.onUpdate, this);
        model.on('cell:added', this.onUpdate, this);
        model.on('cell:removed', this.onUpdate, this);
        model.on('cell:changed', this.onUpdate, this);
        model.on('batch:stop', this.onBatchStop, this);
        this.delegateBackgroundEvents();
    }
    stopListening() {
        const graph = this.graph;
        const model = this.model;
        graph.off('scale', this.onScale, this);
        graph.off('resize', this.onResize, this);
        graph.off('beforeprint', this.storeScrollPosition, this);
        graph.off('beforeexport', this.storeScrollPosition, this);
        graph.off('afterprint', this.restoreScrollPosition, this);
        graph.off('afterexport', this.restoreScrollPosition, this);
        graph.off('render:done', this.onRenderDone, this);
        graph.off('unfreeze', this.onUpdate, this);
        model.off('reseted', this.onUpdate, this);
        model.off('cell:added', this.onUpdate, this);
        model.off('cell:removed', this.onUpdate, this);
        model.off('cell:changed', this.onUpdate, this);
        model.off('batch:stop', this.onBatchStop, this);
        this.undelegateBackgroundEvents();
    }
    enableAutoResize() {
        this.options.autoResize = true;
    }
    disableAutoResize() {
        this.options.autoResize = false;
    }
    onUpdate() {
        if (this.graph.isAsync() || !this.options.autoResize) {
            return;
        }
        this.update();
    }
    onBatchStop(args) {
        if (this.graph.isAsync() || !this.options.autoResize) {
            return;
        }
        if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {
            this.update();
        }
    }
    delegateBackgroundEvents(events) {
        const evts = events || GraphView.events;
        this.delegatedHandlers = Object.keys(evts).reduce((memo, name) => {
            const handler = evts[name];
            if (name.indexOf(' ') === -1) {
                if (typeof handler === 'function') {
                    memo[name] = handler;
                }
                else {
                    let method = this.graph.view[handler];
                    if (typeof method === 'function') {
                        method = method.bind(this.graph.view);
                        memo[name] = method;
                    }
                }
            }
            return memo;
        }, {});
        this.onBackgroundEvent = this.onBackgroundEvent.bind(this);
        Object.keys(this.delegatedHandlers).forEach((name) => {
            this.delegateEvent(name, {
                guarded: false,
            }, this.onBackgroundEvent);
        });
    }
    undelegateBackgroundEvents() {
        Object.keys(this.delegatedHandlers).forEach((name) => {
            this.undelegateEvent(name, this.onBackgroundEvent);
        });
    }
    onBackgroundEvent(e) {
        let valid = false;
        const target = e.target;
        if (!this.options.pageVisible) {
            const view = this.graph.view;
            valid = view.background === target || view.grid === target;
        }
        else if (this.options.background) {
            valid = this.background === target;
        }
        else {
            valid = this.content === target;
        }
        if (valid) {
            const handler = this.delegatedHandlers[e.type];
            if (typeof handler === 'function') {
                handler.apply(this.graph, arguments); // eslint-disable-line
            }
        }
    }
    onRenderDone({ stats }) {
        if (this.options.autoResize && stats.priority < 2) {
            this.update();
        }
    }
    onResize() {
        if (this.cachedCenterPoint) {
            this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);
            this.updatePageBreak();
        }
    }
    onScale({ sx, sy, ox, oy }) {
        this.updateScale(sx, sy);
        if (ox || oy) {
            this.centerPoint(ox, oy);
            this.updatePageBreak();
        }
        const autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;
        if (typeof autoResizeOptions === 'function') {
            this.update();
        }
    }
    storeScrollPosition() {
        this.cachedScrollLeft = this.container.scrollLeft;
        this.cachedScrollTop = this.container.scrollTop;
    }
    restoreScrollPosition() {
        this.container.scrollLeft = this.cachedScrollLeft;
        this.container.scrollTop = this.cachedScrollTop;
        this.cachedScrollLeft = null;
        this.cachedScrollTop = null;
    }
    storeClientSize() {
        this.cachedClientSize = {
            width: this.container.clientWidth,
            height: this.container.clientHeight,
        };
    }
    restoreClientSize() {
        this.cachedClientSize = null;
    }
    beforeManipulation() {
        if (Platform.IS_IE || Platform.IS_EDGE) {
            this.$container.css('visibility', 'hidden');
        }
    }
    afterManipulation() {
        if (Platform.IS_IE || Platform.IS_EDGE) {
            this.$container.css('visibility', 'visible');
        }
    }
    updatePageSize(width, height) {
        if (width != null) {
            this.options.pageWidth = width;
        }
        if (height != null) {
            this.options.pageHeight = height;
        }
        this.updatePageBreak();
    }
    updatePageBreak() {
        if (this.pageBreak && this.pageBreak.parentNode) {
            this.pageBreak.parentNode.removeChild(this.pageBreak);
        }
        this.pageBreak = null;
        if (this.options.pageVisible && this.options.pageBreak) {
            const graphWidth = this.graph.options.width;
            const graphHeight = this.graph.options.height;
            const pageWidth = this.options.pageWidth * this.sx;
            const pageHeight = this.options.pageHeight * this.sy;
            if (pageWidth === 0 || pageHeight === 0) {
                return;
            }
            if (graphWidth > pageWidth || graphHeight > pageHeight) {
                let hasPageBreak = false;
                const container = document.createElement('div');
                for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {
                    this.$('<div/>')
                        .addClass(this.prefixClassName(`graph-pagebreak-vertical`))
                        .css({ left: i * pageWidth })
                        .appendTo(container);
                    hasPageBreak = true;
                }
                for (let i = 1, l = Math.floor(graphHeight / pageHeight); i < l; i += 1) {
                    this.$('<div/>')
                        .addClass(this.prefixClassName(`graph-pagebreak-horizontal`))
                        .css({ top: i * pageHeight })
                        .appendTo(container);
                    hasPageBreak = true;
                }
                if (hasPageBreak) {
                    addClass(container, this.prefixClassName('graph-pagebreak'));
                    this.$(this.graph.view.grid).after(container);
                    this.pageBreak = container;
                }
            }
        }
    }
    update() {
        const size = this.getClientSize();
        this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);
        let resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;
        if (typeof resizeOptions === 'function') {
            resizeOptions = call(resizeOptions, this, this);
        }
        const options = Object.assign({ gridWidth: this.options.pageWidth, gridHeight: this.options.pageHeight, allowNewOrigin: 'negative', contentArea: this.calcContextArea(resizeOptions) }, resizeOptions);
        this.graph.fitToContent(this.getFitToContentOptions(options));
    }
    calcContextArea(resizeOptions) {
        const direction = resizeOptions === null || resizeOptions === void 0 ? void 0 : resizeOptions.direction;
        if (!direction) {
            return this.graph.transform.getContentArea(resizeOptions);
        }
        function getCellBBox(cell) {
            let rect = cell.getBBox();
            if (rect) {
                if (cell.isNode()) {
                    const angle = cell.getAngle();
                    if (angle != null && angle !== 0) {
                        rect = rect.bbox(angle);
                    }
                }
            }
            return rect;
        }
        const gridWidth = this.options.pageWidth || 1;
        const gridHeight = this.options.pageHeight || 1;
        let calculativeCells = this.graph.getCells();
        if (!direction.includes('top')) {
            calculativeCells = calculativeCells.filter((cell) => {
                const bbox = getCellBBox(cell);
                return bbox.y >= 0;
            });
        }
        if (!direction.includes('left')) {
            calculativeCells = calculativeCells.filter((cell) => {
                const bbox = getCellBBox(cell);
                return bbox.x >= 0;
            });
        }
        if (!direction.includes('right')) {
            calculativeCells = calculativeCells.filter((cell) => {
                const bbox = getCellBBox(cell);
                return bbox.x + bbox.width <= gridWidth;
            });
        }
        if (!direction.includes('bottom')) {
            calculativeCells = calculativeCells.filter((cell) => {
                const bbox = getCellBBox(cell);
                return bbox.y + bbox.height <= gridHeight;
            });
        }
        return this.model.getCellsBBox(calculativeCells) || new Rectangle();
    }
    getFitToContentOptions(options) {
        const sx = this.sx;
        const sy = this.sy;
        options.gridWidth && (options.gridWidth *= sx);
        options.gridHeight && (options.gridHeight *= sy);
        options.minWidth && (options.minWidth *= sx);
        options.minHeight && (options.minHeight *= sy);
        if (typeof options.padding === 'object') {
            options.padding = {
                left: (options.padding.left || 0) * sx,
                right: (options.padding.right || 0) * sx,
                top: (options.padding.top || 0) * sy,
                bottom: (options.padding.bottom || 0) * sy,
            };
        }
        else if (typeof options.padding === 'number') {
            options.padding *= sx;
        }
        if (!this.options.autoResize) {
            options.contentArea = Rectangle.create();
        }
        return options;
    }
    updateScale(sx, sy) {
        const options = this.graph.options;
        const dx = sx / this.sx;
        const dy = sy / this.sy;
        this.sx = sx;
        this.sy = sy;
        this.graph.translate(options.x * dx, options.y * dy);
        this.graph.resizeGraph(options.width * dx, options.height * dy);
    }
    scrollbarPosition(left, top, options) {
        if (left == null && top == null) {
            return {
                left: this.container.scrollLeft,
                top: this.container.scrollTop,
            };
        }
        const prop = {};
        if (typeof left === 'number') {
            prop.scrollLeft = left;
        }
        if (typeof top === 'number') {
            prop.scrollTop = top;
        }
        if (options && options.animation) {
            this.$container.animate(prop, options.animation);
        }
        else {
            this.$container.prop(prop);
        }
        return this;
    }
    /**
     * Try to scroll to ensure that the position (x,y) on the graph (in local
     * coordinates) is at the center of the viewport. If only one of the
     * coordinates is specified, only scroll in the specified dimension and
     * keep the other coordinate unchanged.
     */
    scrollToPoint(x, y, options) {
        const size = this.getClientSize();
        const ctm = this.graph.matrix();
        const prop = {};
        if (typeof x === 'number') {
            prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);
        }
        if (typeof y === 'number') {
            prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);
        }
        if (options && options.animation) {
            this.$container.animate(prop, options.animation);
        }
        else {
            this.$container.prop(prop);
        }
        return this;
    }
    /**
     * Try to scroll to ensure that the center of graph content is at the
     * center of the viewport.
     */
    scrollToContent(options) {
        const sx = this.sx;
        const sy = this.sy;
        const center = this.graph.getContentArea().getCenter();
        return this.scrollToPoint(center.x * sx, center.y * sy, options);
    }
    /**
     * Try to scroll to ensure that the center of cell is at the center of
     * the viewport.
     */
    scrollToCell(cell, options) {
        const sx = this.sx;
        const sy = this.sy;
        const center = cell.getBBox().getCenter();
        return this.scrollToPoint(center.x * sx, center.y * sy, options);
    }
    /**
     * The center methods are more aggressive than the scroll methods. These
     * methods position the graph so that a specific point on the graph lies
     * at the center of the viewport, adding paddings around the paper if
     * necessary (e.g. if the requested point lies in a corner of the paper).
     * This means that the requested point will always move into the center
     * of the viewport. (Use the scroll functions to avoid adding paddings
     * and only scroll the viewport as far as the graph boundary.)
     */
    /**
     * Position the center of graph to the center of the viewport.
     */
    center(optons) {
        return this.centerPoint(optons);
    }
    centerPoint(x, y, options) {
        const ctm = this.graph.matrix();
        const sx = ctm.a;
        const sy = ctm.d;
        const tx = -ctm.e;
        const ty = -ctm.f;
        const tWidth = tx + this.graph.options.width;
        const tHeight = ty + this.graph.options.height;
        let localOptions;
        this.storeClientSize(); // avoid multilple reflow
        if (typeof x === 'number' || typeof y === 'number') {
            localOptions = options;
            const visibleCenter = this.getVisibleArea().getCenter();
            if (typeof x === 'number') {
                x *= sx; // eslint-disable-line
            }
            else {
                x = visibleCenter.x; // eslint-disable-line
            }
            if (typeof y === 'number') {
                y *= sy; // eslint-disable-line
            }
            else {
                y = visibleCenter.y; // eslint-disable-line
            }
        }
        else {
            localOptions = x;
            x = (tx + tWidth) / 2; // eslint-disable-line
            y = (ty + tHeight) / 2; // eslint-disable-line
        }
        if (localOptions && localOptions.padding) {
            return this.positionPoint({ x, y }, '50%', '50%', localOptions);
        }
        const padding = this.getPadding();
        const clientSize = this.getClientSize();
        const cx = clientSize.width / 2;
        const cy = clientSize.height / 2;
        const left = cx - padding.left - x + tx;
        const right = cx - padding.right + x - tWidth;
        const top = cy - padding.top - y + ty;
        const bottom = cy - padding.bottom + y - tHeight;
        this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));
        const result = this.scrollToPoint(x, y, localOptions || undefined);
        this.restoreClientSize();
        return result;
    }
    centerContent(options) {
        return this.positionContent('center', options);
    }
    centerCell(cell, options) {
        return this.positionCell(cell, 'center', options);
    }
    /**
     * The position methods are a more general version of the center methods.
     * They position the graph so that a specific point on the graph lies at
     * requested coordinates inside the viewport.
     */
    /**
     *
     */
    positionContent(pos, options) {
        const rect = this.graph.getContentArea(options);
        return this.positionRect(rect, pos, options);
    }
    positionCell(cell, pos, options) {
        const bbox = cell.getBBox();
        return this.positionRect(bbox, pos, options);
    }
    positionRect(rect, pos, options) {
        const bbox = Rectangle.create(rect);
        switch (pos) {
            case 'center':
                return this.positionPoint(bbox.getCenter(), '50%', '50%', options);
            case 'top':
                return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);
            case 'top-right':
                return this.positionPoint(bbox.getTopRight(), '100%', 0, options);
            case 'right':
                return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);
            case 'bottom-right':
                return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);
            case 'bottom':
                return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);
            case 'bottom-left':
                return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);
            case 'left':
                return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);
            case 'top-left':
                return this.positionPoint(bbox.getTopLeft(), 0, 0, options);
            default:
                return this;
        }
    }
    positionPoint(point, x, y, options = {}) {
        const { padding: pad } = options, localOptions = __rest$6(options, ["padding"]);
        const padding = normalizeSides(pad);
        const clientRect = Rectangle.fromSize(this.getClientSize());
        const targetRect = clientRect.clone().moveAndExpand({
            x: padding.left,
            y: padding.top,
            width: -padding.right - padding.left,
            height: -padding.top - padding.bottom,
        });
        // eslint-disable-next-line
        x = normalizePercentage(x, Math.max(0, targetRect.width));
        if (x < 0) {
            x = targetRect.width + x; // eslint-disable-line
        }
        // eslint-disable-next-line
        y = normalizePercentage(y, Math.max(0, targetRect.height));
        if (y < 0) {
            y = targetRect.height + y; // eslint-disable-line
        }
        const origin = targetRect.getTopLeft().translate(x, y);
        const diff = clientRect.getCenter().diff(origin);
        const scale = this.zoom();
        const rawDiff = diff.scale(1 / scale, 1 / scale);
        const result = Point.create(point).translate(rawDiff);
        return this.centerPoint(result.x, result.y, localOptions);
    }
    zoom(factor, options) {
        if (factor == null) {
            return this.sx;
        }
        options = options || {}; // eslint-disable-line
        let cx;
        let cy;
        const clientSize = this.getClientSize();
        const center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);
        let sx = factor;
        let sy = factor;
        if (!options.absolute) {
            sx += this.sx;
            sy += this.sy;
        }
        if (options.scaleGrid) {
            sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
            sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
        }
        if (options.maxScale) {
            sx = Math.min(options.maxScale, sx);
            sy = Math.min(options.maxScale, sy);
        }
        if (options.minScale) {
            sx = Math.max(options.minScale, sx);
            sy = Math.max(options.minScale, sy);
        }
        sx = this.graph.transform.clampScale(sx);
        sy = this.graph.transform.clampScale(sy);
        if (options.center) {
            const fx = sx / this.sx;
            const fy = sy / this.sy;
            cx = options.center.x - (options.center.x - center.x) / fx;
            cy = options.center.y - (options.center.y - center.y) / fy;
        }
        else {
            cx = center.x;
            cy = center.y;
        }
        this.beforeManipulation();
        this.graph.transform.scale(sx, sy);
        this.centerPoint(cx, cy);
        this.afterManipulation();
        return this;
    }
    zoomToRect(rect, options = {}) {
        const area = Rectangle.create(rect);
        const graph = this.graph;
        options.contentArea = area;
        if (options.viewportArea == null) {
            options.viewportArea = {
                x: graph.options.x,
                y: graph.options.y,
                width: this.$container.width(),
                height: this.$container.height(),
            };
        }
        this.beforeManipulation();
        graph.transform.scaleContentToFitImpl(options, false);
        const center = area.getCenter();
        this.centerPoint(center.x, center.y);
        this.afterManipulation();
        return this;
    }
    zoomToFit(options = {}) {
        return this.zoomToRect(this.graph.getContentArea(options), options);
    }
    transitionToPoint(x, y, options) {
        if (typeof x === 'object') {
            options = y; // eslint-disable-line
            y = x.y; // eslint-disable-line
            x = x.x; // eslint-disable-line
        }
        else {
            y = y; // eslint-disable-line
        }
        if (options == null) {
            options = {}; // eslint-disable-line
        }
        let transform;
        let transformOrigin;
        const scale = this.sx;
        const targetScale = Math.max(options.scale || scale, 0.000001);
        const clientSize = this.getClientSize();
        const targetPoint = new Point(x, y);
        const localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);
        if (scale === targetScale) {
            const translate = localPoint.diff(targetPoint).scale(scale, scale).round();
            transform = `translate(${translate.x}px,${translate.y}px)`;
        }
        else {
            const delta = (targetScale / (scale - targetScale)) * targetPoint.distance(localPoint);
            const range = localPoint.clone().move(targetPoint, delta);
            const origin = this.localToBackgroundPoint(range).round();
            transform = `scale(${targetScale / scale})`;
            transformOrigin = `${origin.x}px ${origin.y}px`;
        }
        const onTransitionEnd = options.onTransitionEnd;
        this.$container.addClass(Util$1.transitionClassName);
        this.$content
            .off(Util$1.transitionEventName)
            .on(Util$1.transitionEventName, (e) => {
            this.syncTransition(targetScale, { x: x, y: y });
            if (typeof onTransitionEnd === 'function') {
                call(onTransitionEnd, this, e.originalEvent);
            }
        })
            .css({
            transform,
            transformOrigin,
            transition: 'transform',
            transitionDuration: options.duration || '1s',
            transitionDelay: options.delay,
            transitionTimingFunction: options.timing,
        });
        return this;
    }
    syncTransition(scale, p) {
        this.beforeManipulation();
        this.graph.scale(scale);
        this.removeTransition();
        this.centerPoint(p.x, p.y);
        this.afterManipulation();
        return this;
    }
    removeTransition() {
        this.$container.removeClass(Util$1.transitionClassName);
        this.$content.off(Util$1.transitionEventName).css({
            transform: '',
            transformOrigin: '',
            transition: '',
            transitionDuration: '',
            transitionDelay: '',
            transitionTimingFunction: '',
        });
        return this;
    }
    transitionToRect(rectangle, options = {}) {
        const rect = Rectangle.create(rectangle);
        const maxScale = options.maxScale || Infinity;
        const minScale = options.minScale || Number.MIN_VALUE;
        const scaleGrid = options.scaleGrid || null;
        const PIXEL_SIZE = options.visibility || 1;
        const center = options.center
            ? Point.create(options.center)
            : rect.getCenter();
        const clientSize = this.getClientSize();
        const w = clientSize.width * PIXEL_SIZE;
        const h = clientSize.height * PIXEL_SIZE;
        let scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);
        scale = Math.min(scale, maxScale);
        if (scaleGrid) {
            scale = Math.floor(scale / scaleGrid) * scaleGrid;
        }
        scale = Math.max(minScale, scale);
        return this.transitionToPoint(center, Object.assign({ scale }, options));
    }
    startPanning(evt) {
        const e = this.normalizeEvent(evt);
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.trigger('pan:start', { e });
        this.$(document.body).on({
            'mousemove.panning touchmove.panning': this.pan.bind(this),
            'mouseup.panning touchend.panning': this.stopPanning.bind(this),
            'mouseleave.panning': this.stopPanning.bind(this),
        });
        this.$(window).on('mouseup.panning', this.stopPanning.bind(this));
    }
    pan(evt) {
        const e = this.normalizeEvent(evt);
        const dx = e.clientX - this.clientX;
        const dy = e.clientY - this.clientY;
        this.container.scrollTop -= dy;
        this.container.scrollLeft -= dx;
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.trigger('panning', { e });
    }
    stopPanning(e) {
        this.$(document.body).off('.panning');
        this.$(window).off('.panning');
        this.trigger('pan:stop', { e });
    }
    clientToLocalPoint(a, b) {
        let x = typeof a === 'object' ? a.x : a;
        let y = typeof a === 'object' ? a.y : b;
        const ctm = this.graph.matrix();
        x += this.container.scrollLeft - this.padding.left - ctm.e;
        y += this.container.scrollTop - this.padding.top - ctm.f;
        return new Point(x / ctm.a, y / ctm.d);
    }
    localToBackgroundPoint(x, y) {
        const p = typeof x === 'object' ? Point.create(x) : new Point(x, y);
        const ctm = this.graph.matrix();
        const padding = this.padding;
        return transformPoint(p, ctm).translate(padding.left, padding.top);
    }
    resize(width, height) {
        let w = width != null ? width : this.container.offsetWidth;
        let h = height != null ? height : this.container.offsetHeight;
        if (typeof w === 'number') {
            w = Math.round(w);
        }
        if (typeof h === 'number') {
            h = Math.round(h);
        }
        this.options.width = w;
        this.options.height = h;
        this.$container.css({ width: w, height: h });
        this.update();
    }
    getClientSize() {
        if (this.cachedClientSize) {
            return this.cachedClientSize;
        }
        return {
            width: this.container.clientWidth,
            height: this.container.clientHeight,
        };
    }
    autoScroll(clientX, clientY) {
        const buffer = 10;
        const container = this.container;
        const rect = container.getBoundingClientRect();
        let dx = 0;
        let dy = 0;
        if (clientX <= rect.left + buffer) {
            dx = -buffer;
        }
        if (clientY <= rect.top + buffer) {
            dy = -buffer;
        }
        if (clientX >= rect.right - buffer) {
            dx = buffer;
        }
        if (clientY >= rect.bottom - buffer) {
            dy = buffer;
        }
        if (dx !== 0) {
            container.scrollLeft += dx;
        }
        if (dy !== 0) {
            container.scrollTop += dy;
        }
        return {
            scrollerX: dx,
            scrollerY: dy,
        };
    }
    addPadding(left, right, top, bottom) {
        let padding = this.getPadding();
        this.padding = {
            left: Math.round(padding.left + (left || 0)),
            top: Math.round(padding.top + (top || 0)),
            bottom: Math.round(padding.bottom + (bottom || 0)),
            right: Math.round(padding.right + (right || 0)),
        };
        padding = this.padding;
        this.$content.css({
            width: padding.left + this.graph.options.width + padding.right,
            height: padding.top + this.graph.options.height + padding.bottom,
        });
        const container = this.graph.container;
        container.style.left = `${this.padding.left}px`;
        container.style.top = `${this.padding.top}px`;
        return this;
    }
    getPadding() {
        const padding = this.options.padding;
        if (typeof padding === 'function') {
            return normalizeSides(call(padding, this, this));
        }
        return normalizeSides(padding);
    }
    /**
     * Returns the untransformed size and origin of the current viewport.
     */
    getVisibleArea() {
        const ctm = this.graph.matrix();
        const size = this.getClientSize();
        const box = {
            x: this.container.scrollLeft || 0,
            y: this.container.scrollTop || 0,
            width: size.width,
            height: size.height,
        };
        const area = transformRectangle(box, ctm.inverse());
        area.x -= (this.padding.left || 0) / this.sx;
        area.y -= (this.padding.top || 0) / this.sy;
        return area;
    }
    isCellVisible(cell, options = {}) {
        const bbox = cell.getBBox();
        const area = this.getVisibleArea();
        return options.strict
            ? area.containsRect(bbox)
            : area.isIntersectWithRect(bbox);
    }
    isPointVisible(point) {
        return this.getVisibleArea().containsPoint(point);
    }
    /**
     * Lock the current viewport by disabling user scrolling.
     */
    lock() {
        this.$container.css('overflow', 'hidden');
        return this;
    }
    /**
     * Enable user scrolling if previously locked.
     */
    unlock() {
        this.$container.css('overflow', 'scroll');
        return this;
    }
    onRemove() {
        this.stopListening();
    }
    dispose() {
        this.$(this.graph.container).insertBefore(this.$container);
        this.remove();
    }
}
__decorate$i([
    View.dispose()
], Scroller.prototype, "dispose", null);
(function (Scroller) {
    class Background extends BackgroundManager {
        constructor(scroller) {
            super(scroller.graph);
            this.scroller = scroller;
            if (scroller.options.background) {
                this.draw(scroller.options.background);
            }
        }
        get elem() {
            return this.scroller.background;
        }
        init() {
            this.graph.on('scale', this.update, this);
            this.graph.on('translate', this.update, this);
        }
        updateBackgroundOptions(options) {
            this.scroller.options.background = options;
        }
    }
    Scroller.Background = Background;
})(Scroller || (Scroller = {}));
var Util$1;
(function (Util) {
    Util.containerClass = 'graph-scroller';
    Util.panningClass = `${Util.containerClass}-panning`;
    Util.pannableClass = `${Util.containerClass}-pannable`;
    Util.pagedClass = `${Util.containerClass}-paged`;
    Util.contentClass = `${Util.containerClass}-content`;
    Util.backgroundClass = `${Util.containerClass}-background`;
    Util.transitionClassName = 'transition-in-progress';
    Util.transitionEventName = 'transitionend.graph-scroller-transition';
    Util.defaultOptions = {
        padding() {
            const size = this.getClientSize();
            const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;
            const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;
            const left = Math.max(size.width - minWidth, 0);
            const top = Math.max(size.height - minHeight, 0);
            return { left, top, right: left, bottom: top };
        },
        minVisibleWidth: 50,
        minVisibleHeight: 50,
        pageVisible: false,
        pageBreak: false,
        autoResize: true,
    };
    function getOptions(options) {
        const result = merge({}, Util.defaultOptions, options);
        if (result.pageWidth == null) {
            result.pageWidth = options.graph.options.width;
        }
        if (result.pageHeight == null) {
            result.pageHeight = options.graph.options.height;
        }
        return result;
    }
    Util.getOptions = getOptions;
})(Util$1 || (Util$1 = {}));

function notify(name, evt, view, args = {}) {
    if (view) {
        const graph = view.graph;
        const e = graph.view.normalizeEvent(evt);
        const localPoint = graph.snapToGrid(e.clientX, e.clientY);
        view.notify(name, Object.assign({ e,
            view, node: view.cell, cell: view.cell, x: localPoint.x, y: localPoint.y }, args));
    }
}

var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Selection extends View {
    constructor(options) {
        super();
        this.options = merge({}, Private$3.defaultOptions, options);
        if (this.options.model) {
            this.options.collection = this.options.model.collection;
        }
        if (this.options.collection) {
            this.collection = this.options.collection;
        }
        else {
            this.collection = new Collection([], {
                comparator: Private$3.depthComparator,
            });
            this.options.collection = this.collection;
        }
        this.boxCount = 0;
        this.createContainer();
        this.initHandles();
        this.startListening();
    }
    get graph() {
        return this.options.graph;
    }
    get boxClassName() {
        return this.prefixClassName(Private$3.classNames.box);
    }
    get $boxes() {
        return this.$container.children(`.${this.boxClassName}`);
    }
    get handleOptions() {
        return this.options;
    }
    startListening() {
        const graph = this.graph;
        const collection = this.collection;
        this.delegateEvents({
            [`mousedown .${this.boxClassName}`]: 'onSelectionBoxMouseDown',
            [`touchstart .${this.boxClassName}`]: 'onSelectionBoxMouseDown',
        }, true);
        graph.on('scale', this.onGraphTransformed, this);
        graph.on('translate', this.onGraphTransformed, this);
        graph.model.on('updated', this.onModelUpdated, this);
        collection.on('added', this.onCellAdded, this);
        collection.on('removed', this.onCellRemoved, this);
        collection.on('reseted', this.onReseted, this);
        collection.on('updated', this.onCollectionUpdated, this);
        collection.on('node:change:position', this.onNodePositionChanged, this);
        collection.on('cell:changed', this.onCellChanged, this);
    }
    stopListening() {
        const graph = this.graph;
        const collection = this.collection;
        this.undelegateEvents();
        graph.off('scale', this.onGraphTransformed, this);
        graph.off('translate', this.onGraphTransformed, this);
        graph.model.off('updated', this.onModelUpdated, this);
        collection.off('added', this.onCellAdded, this);
        collection.off('removed', this.onCellRemoved, this);
        collection.off('reseted', this.onReseted, this);
        collection.off('updated', this.onCollectionUpdated, this);
        collection.off('node:change:position', this.onNodePositionChanged, this);
        collection.off('cell:changed', this.onCellChanged, this);
    }
    onRemove() {
        this.stopListening();
    }
    onGraphTransformed() {
        this.updateSelectionBoxes({ async: false });
    }
    onCellChanged() {
        this.updateSelectionBoxes();
    }
    onNodePositionChanged({ node, options, }) {
        const { showNodeSelectionBox, pointerEvents } = this.options;
        const { ui, selection, translateBy, snapped } = options;
        const allowTranslating = (showNodeSelectionBox !== true || pointerEvents === 'none') &&
            !this.translating &&
            !selection;
        const translateByUi = ui && translateBy && node.id === translateBy;
        if (allowTranslating && (translateByUi || snapped)) {
            this.translating = true;
            const current = node.position();
            const previous = node.previous('position');
            const dx = current.x - previous.x;
            const dy = current.y - previous.y;
            if (dx !== 0 || dy !== 0) {
                this.translateSelectedNodes(dx, dy, node, options);
            }
            this.translating = false;
        }
    }
    onModelUpdated({ removed }) {
        if (removed && removed.length) {
            this.unselect(removed);
        }
    }
    isEmpty() {
        return this.length <= 0;
    }
    isSelected(cell) {
        return this.collection.has(cell);
    }
    get length() {
        return this.collection.length;
    }
    get cells() {
        return this.collection.toArray();
    }
    select(cells, options = {}) {
        options.dryrun = true;
        const items = this.filter(Array.isArray(cells) ? cells : [cells]);
        this.collection.add(items, options);
        return this;
    }
    unselect(cells, options = {}) {
        // dryrun to prevent cell be removed from graph
        options.dryrun = true;
        this.collection.remove(Array.isArray(cells) ? cells : [cells], options);
        return this;
    }
    reset(cells, options = {}) {
        if (cells) {
            if (options.batch) {
                const filterCells = this.filter(Array.isArray(cells) ? cells : [cells]);
                this.collection.reset(filterCells, Object.assign(Object.assign({}, options), { ui: true }));
                return this;
            }
            const prev = this.cells;
            const next = this.filter(Array.isArray(cells) ? cells : [cells]);
            const prevMap = {};
            const nextMap = {};
            prev.forEach((cell) => (prevMap[cell.id] = cell));
            next.forEach((cell) => (nextMap[cell.id] = cell));
            const added = [];
            const removed = [];
            next.forEach((cell) => {
                if (!prevMap[cell.id]) {
                    added.push(cell);
                }
            });
            prev.forEach((cell) => {
                if (!nextMap[cell.id]) {
                    removed.push(cell);
                }
            });
            if (removed.length) {
                this.unselect(removed, Object.assign(Object.assign({}, options), { ui: true }));
            }
            if (added.length) {
                this.select(added, Object.assign(Object.assign({}, options), { ui: true }));
            }
            if (removed.length === 0 && added.length === 0) {
                this.updateContainer();
            }
            return this;
        }
        return this.clean(options);
    }
    clean(options = {}) {
        if (this.length) {
            if (options.batch === false) {
                this.unselect(this.cells, options);
            }
            else {
                this.collection.reset([], Object.assign(Object.assign({}, options), { ui: true }));
            }
        }
        return this;
    }
    setFilter(filter) {
        this.options.filter = filter;
    }
    setContent(content) {
        this.options.content = content;
    }
    startSelecting(evt) {
        // Flow: startSelecting => adjustSelection => stopSelecting
        evt = this.normalizeEvent(evt); // eslint-disable-line
        this.clean();
        let x;
        let y;
        const graphContainer = this.graph.container;
        if (evt.offsetX != null &&
            evt.offsetY != null &&
            graphContainer.contains(evt.target)) {
            x = evt.offsetX;
            y = evt.offsetY;
        }
        else {
            const offset = this.$(graphContainer).offset();
            const scrollLeft = graphContainer.scrollLeft;
            const scrollTop = graphContainer.scrollTop;
            x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;
            y = evt.clientY - offset.top + window.pageYOffset + scrollTop;
        }
        this.$container.css({
            top: y,
            left: x,
            width: 1,
            height: 1,
        });
        this.setEventData(evt, {
            action: 'selecting',
            clientX: evt.clientX,
            clientY: evt.clientY,
            offsetX: x,
            offsetY: y,
            scrollerX: 0,
            scrollerY: 0,
            moving: false,
        });
        this.delegateDocumentEvents(Private$3.documentEvents, evt.data);
    }
    filter(cells) {
        const filter = this.options.filter;
        if (Array.isArray(filter)) {
            return cells.filter((cell) => !filter.includes(cell) && !filter.includes(cell.shape));
        }
        if (typeof filter === 'function') {
            return cells.filter((cell) => call(filter, this.graph, cell));
        }
        return cells;
    }
    stopSelecting(evt) {
        const graph = this.graph;
        const eventData = this.getEventData(evt);
        const action = eventData.action;
        switch (action) {
            case 'selecting': {
                let width = this.$container.width();
                let height = this.$container.height();
                const offset = this.$container.offset();
                const origin = graph.pageToLocal(offset.left, offset.top);
                const scale = graph.transform.getScale();
                width /= scale.sx;
                height /= scale.sy;
                const rect = new Rectangle(origin.x, origin.y, width, height);
                const cells = this.getCellViewsInArea(rect).map((view) => view.cell);
                this.reset(cells, { batch: true });
                this.hideRubberband();
                break;
            }
            case 'translating': {
                const client = graph.snapToGrid(evt.clientX, evt.clientY);
                if (!this.options.following) {
                    const data = eventData;
                    this.updateSelectedNodesPosition({
                        dx: data.clientX - data.originX,
                        dy: data.clientY - data.originY,
                    });
                }
                this.graph.model.stopBatch('move-selection');
                this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);
                break;
            }
            default: {
                this.clean();
                break;
            }
        }
    }
    onMouseUp(evt) {
        const action = this.getEventData(evt).action;
        if (action) {
            this.stopSelecting(evt);
            this.undelegateDocumentEvents();
        }
    }
    onSelectionBoxMouseDown(evt) {
        if (!this.options.following) {
            evt.stopPropagation();
        }
        const e = this.normalizeEvent(evt);
        if (this.options.movable) {
            this.startTranslating(e);
        }
        const activeView = this.getCellViewFromElem(e.target);
        this.setEventData(e, { activeView });
        const client = this.graph.snapToGrid(e.clientX, e.clientY);
        this.notifyBoxEvent('box:mousedown', e, client.x, client.y);
        this.delegateDocumentEvents(Private$3.documentEvents, e.data);
    }
    startTranslating(evt) {
        this.graph.model.startBatch('move-selection');
        const client = this.graph.snapToGrid(evt.clientX, evt.clientY);
        this.setEventData(evt, {
            action: 'translating',
            clientX: client.x,
            clientY: client.y,
            originX: client.x,
            originY: client.y,
        });
    }
    getSelectionOffset(client, data) {
        let dx = client.x - data.clientX;
        let dy = client.y - data.clientY;
        const restrict = this.graph.hook.getRestrictArea();
        if (restrict) {
            const cells = this.collection.toArray();
            const totalBBox = Cell.getCellsBBox(cells, { deep: true }) || Rectangle.create();
            const minDx = restrict.x - totalBBox.x;
            const minDy = restrict.y - totalBBox.y;
            const maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);
            const maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);
            if (dx < minDx) {
                dx = minDx;
            }
            if (dy < minDy) {
                dy = minDy;
            }
            if (maxDx < dx) {
                dx = maxDx;
            }
            if (maxDy < dy) {
                dy = maxDy;
            }
            if (!this.options.following) {
                const offsetX = client.x - data.originX;
                const offsetY = client.y - data.originY;
                dx = offsetX <= minDx || offsetX >= maxDx ? 0 : dx;
                dy = offsetY <= minDy || offsetY >= maxDy ? 0 : dy;
            }
        }
        return {
            dx,
            dy,
        };
    }
    updateSelectedNodesPosition(offset) {
        const { dx, dy } = offset;
        if (dx || dy) {
            if ((this.translateSelectedNodes(dx, dy), this.boxesUpdated)) {
                if (this.collection.length > 1) {
                    this.updateSelectionBoxes();
                }
            }
            else {
                const scale = this.graph.transform.getScale();
                this.$boxes.add(this.$selectionContainer).css({
                    left: `+=${dx * scale.sx}`,
                    top: `+=${dy * scale.sy}`,
                });
            }
        }
    }
    autoScrollGraph(x, y) {
        const scroller = this.graph.scroller.widget;
        if (scroller) {
            return scroller.autoScroll(x, y);
        }
        return { scrollerX: 0, scrollerY: 0 };
    }
    adjustSelection(evt) {
        const e = this.normalizeEvent(evt);
        const eventData = this.getEventData(e);
        const action = eventData.action;
        switch (action) {
            case 'selecting': {
                const data = eventData;
                if (data.moving !== true) {
                    this.$container.appendTo(this.graph.container);
                    this.showRubberband();
                    data.moving = true;
                }
                const { scrollerX, scrollerY } = this.autoScrollGraph(e.clientX, e.clientY);
                data.scrollerX += scrollerX;
                data.scrollerY += scrollerY;
                const dx = e.clientX - data.clientX + data.scrollerX;
                const dy = e.clientY - data.clientY + data.scrollerY;
                const left = parseInt(this.$container.css('left'), 10);
                const top = parseInt(this.$container.css('top'), 10);
                this.$container.css({
                    left: dx < 0 ? data.offsetX + dx : left,
                    top: dy < 0 ? data.offsetY + dy : top,
                    width: Math.abs(dx),
                    height: Math.abs(dy),
                });
                break;
            }
            case 'translating': {
                const client = this.graph.snapToGrid(e.clientX, e.clientY);
                const data = eventData;
                const offset = this.getSelectionOffset(client, data);
                if (this.options.following) {
                    this.updateSelectedNodesPosition(offset);
                }
                else {
                    this.updateContainerPosition(offset);
                }
                if (offset.dx) {
                    data.clientX = client.x;
                }
                if (offset.dy) {
                    data.clientY = client.y;
                }
                this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);
                break;
            }
            default:
                break;
        }
        this.boxesUpdated = false;
    }
    translateSelectedNodes(dx, dy, exclude, otherOptions) {
        const map = {};
        const excluded = [];
        if (exclude) {
            map[exclude.id] = true;
        }
        this.collection.toArray().forEach((cell) => {
            cell.getDescendants({ deep: true }).forEach((child) => {
                map[child.id] = true;
            });
        });
        if (otherOptions && otherOptions.translateBy) {
            const currentCell = this.graph.getCellById(otherOptions.translateBy);
            if (currentCell) {
                map[currentCell.id] = true;
                currentCell.getDescendants({ deep: true }).forEach((child) => {
                    map[child.id] = true;
                });
                excluded.push(currentCell);
            }
        }
        this.collection.toArray().forEach((cell) => {
            if (!map[cell.id]) {
                const options = Object.assign(Object.assign({}, otherOptions), { selection: this.cid, exclude: excluded });
                cell.translate(dx, dy, options);
                this.graph.model.getConnectedEdges(cell).forEach((edge) => {
                    if (!map[edge.id]) {
                        edge.translate(dx, dy, options);
                        map[edge.id] = true;
                    }
                });
            }
        });
    }
    getCellViewsInArea(rect) {
        const graph = this.graph;
        const options = {
            strict: this.options.strict,
        };
        let views = [];
        if (this.options.rubberNode) {
            if (this.options.useCellGeometry) {
                views = views.concat(graph.model
                    .getNodesInArea(rect, options)
                    .map((node) => graph.renderer.findViewByCell(node))
                    .filter((view) => view != null));
            }
            else {
                views = views.concat(graph.renderer.findViewsInArea(rect, options));
            }
        }
        if (this.options.rubberEdge) {
            if (this.options.useCellGeometry) {
                views = views.concat(graph.model
                    .getEdgesInArea(rect, options)
                    .map((edge) => graph.renderer.findViewByCell(edge))
                    .filter((view) => view != null));
            }
            else {
                views = views.concat(graph.renderer.findEdgeViewsInArea(rect, options));
            }
        }
        return views;
    }
    notifyBoxEvent(name, e, x, y) {
        const data = this.getEventData(e);
        const view = data.activeView;
        this.trigger(name, { e, view, x, y, cell: view.cell });
    }
    getSelectedClassName(cell) {
        return this.prefixClassName(`${cell.isNode() ? 'node' : 'edge'}-selected`);
    }
    addCellSelectedClassName(cell) {
        const view = this.graph.renderer.findViewByCell(cell);
        if (view) {
            view.addClass(this.getSelectedClassName(cell));
        }
    }
    removeCellUnSelectedClassName(cell) {
        const view = this.graph.renderer.findViewByCell(cell);
        if (view) {
            view.removeClass(this.getSelectedClassName(cell));
        }
    }
    destroySelectionBox(cell) {
        this.removeCellUnSelectedClassName(cell);
        if (this.canShowSelectionBox(cell)) {
            this.$container.find(`[data-cell-id="${cell.id}"]`).remove();
            if (this.$boxes.length === 0) {
                this.hide();
            }
            this.boxCount = Math.max(0, this.boxCount - 1);
        }
    }
    destroyAllSelectionBoxes(cells) {
        cells.forEach((cell) => this.removeCellUnSelectedClassName(cell));
        this.hide();
        this.$boxes.remove();
        this.boxCount = 0;
    }
    hide() {
        this.$container
            .removeClass(this.prefixClassName(Private$3.classNames.rubberband))
            .removeClass(this.prefixClassName(Private$3.classNames.selected));
    }
    showRubberband() {
        this.$container.addClass(this.prefixClassName(Private$3.classNames.rubberband));
    }
    hideRubberband() {
        this.$container.removeClass(this.prefixClassName(Private$3.classNames.rubberband));
    }
    showSelected() {
        this.$container
            .removeAttr('style')
            .addClass(this.prefixClassName(Private$3.classNames.selected));
    }
    createContainer() {
        this.container = document.createElement('div');
        this.$container = this.$(this.container);
        this.$container.addClass(this.prefixClassName(Private$3.classNames.root));
        if (this.options.className) {
            this.$container.addClass(this.options.className);
        }
        this.$selectionContainer = this.$('<div/>').addClass(this.prefixClassName(Private$3.classNames.inner));
        this.$selectionContent = this.$('<div/>').addClass(this.prefixClassName(Private$3.classNames.content));
        this.$selectionContainer.append(this.$selectionContent);
        this.$selectionContainer.attr('data-selection-length', this.collection.length);
        this.$container.prepend(this.$selectionContainer);
        this.$handleContainer = this.$selectionContainer;
    }
    updateContainerPosition(offset) {
        if (offset.dx || offset.dy) {
            this.$selectionContainer.css({
                left: `+=${offset.dx}`,
                top: `+=${offset.dy}`,
            });
        }
    }
    updateContainer() {
        const origin = { x: Infinity, y: Infinity };
        const corner = { x: 0, y: 0 };
        const cells = this.collection
            .toArray()
            .filter((cell) => this.canShowSelectionBox(cell));
        cells.forEach((cell) => {
            const view = this.graph.renderer.findViewByCell(cell);
            if (view) {
                const bbox = view.getBBox({
                    useCellGeometry: this.options.useCellGeometry,
                });
                origin.x = Math.min(origin.x, bbox.x);
                origin.y = Math.min(origin.y, bbox.y);
                corner.x = Math.max(corner.x, bbox.x + bbox.width);
                corner.y = Math.max(corner.y, bbox.y + bbox.height);
            }
        });
        this.$selectionContainer
            .css({
            position: 'absolute',
            pointerEvents: 'none',
            left: origin.x,
            top: origin.y,
            width: corner.x - origin.x,
            height: corner.y - origin.y,
        })
            .attr('data-selection-length', this.collection.length);
        const boxContent = this.options.content;
        if (boxContent) {
            if (typeof boxContent === 'function') {
                const content = call(boxContent, this.graph, this, this.$selectionContent[0]);
                if (content) {
                    this.$selectionContent.html(content);
                }
            }
            else {
                this.$selectionContent.html(boxContent);
            }
        }
        if (this.collection.length > 0 && !this.container.parentNode) {
            this.$container.appendTo(this.graph.container);
        }
        else if (this.collection.length <= 0 && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
    canShowSelectionBox(cell) {
        return ((cell.isNode() && this.options.showNodeSelectionBox === true) ||
            (cell.isEdge() && this.options.showEdgeSelectionBox === true));
    }
    createSelectionBox(cell) {
        this.addCellSelectedClassName(cell);
        if (this.canShowSelectionBox(cell)) {
            const view = this.graph.renderer.findViewByCell(cell);
            if (view) {
                const bbox = view.getBBox({
                    useCellGeometry: this.options.useCellGeometry,
                });
                const className = this.boxClassName;
                this.$('<div/>')
                    .addClass(className)
                    .addClass(`${className}-${cell.isNode() ? 'node' : 'edge'}`)
                    .attr('data-cell-id', cell.id)
                    .css({
                    position: 'absolute',
                    left: bbox.x,
                    top: bbox.y,
                    width: bbox.width,
                    height: bbox.height,
                    pointerEvents: this.options.pointerEvents || 'auto',
                })
                    .appendTo(this.container);
                this.showSelected();
                this.boxCount += 1;
            }
        }
    }
    updateSelectionBoxes(options = {}) {
        if (this.collection.length > 0) {
            this.boxesUpdated = true;
            this.graph.renderer.requestViewUpdate(this, 1, 2, options);
        }
    }
    confirmUpdate() {
        if (this.boxCount) {
            this.hide();
            this.$boxes.each((_, elem) => {
                const cellId = this.$(elem).remove().attr('data-cell-id');
                const cell = this.collection.get(cellId);
                if (cell) {
                    this.createSelectionBox(cell);
                }
            });
            this.updateContainer();
        }
        return 0;
    }
    getCellViewFromElem(elem) {
        const id = elem.getAttribute('data-cell-id');
        if (id) {
            const cell = this.collection.get(id);
            if (cell) {
                return this.graph.renderer.findViewByCell(cell);
            }
        }
        return null;
    }
    onCellRemoved({ cell }) {
        this.destroySelectionBox(cell);
        this.updateContainer();
    }
    onReseted({ previous, current }) {
        this.destroyAllSelectionBoxes(previous);
        current.forEach((cell) => {
            this.listenCellRemoveEvent(cell);
            this.createSelectionBox(cell);
        });
        this.updateContainer();
    }
    onCellAdded({ cell }) {
        // The collection do not known the cell was removed when cell was
        // removed by interaction(such as, by "delete" shortcut), so we should
        // manually listen to cell's remove evnet.
        this.listenCellRemoveEvent(cell);
        this.createSelectionBox(cell);
        this.updateContainer();
    }
    listenCellRemoveEvent(cell) {
        cell.off('removed', this.onCellRemoved, this);
        cell.on('removed', this.onCellRemoved, this);
    }
    onCollectionUpdated({ added, removed, options, }) {
        added.forEach((cell) => {
            this.trigger('cell:selected', { cell, options });
            this.graph.trigger('cell:selected', { cell, options });
            if (cell.isNode()) {
                this.trigger('node:selected', { cell, options, node: cell });
                this.graph.trigger('node:selected', { cell, options, node: cell });
            }
            else if (cell.isEdge()) {
                this.trigger('edge:selected', { cell, options, edge: cell });
                this.graph.trigger('edge:selected', { cell, options, edge: cell });
            }
        });
        removed.forEach((cell) => {
            this.trigger('cell:unselected', { cell, options });
            this.graph.trigger('cell:unselected', { cell, options });
            if (cell.isNode()) {
                this.trigger('node:unselected', { cell, options, node: cell });
                this.graph.trigger('node:unselected', { cell, options, node: cell });
            }
            else if (cell.isEdge()) {
                this.trigger('edge:unselected', { cell, options, edge: cell });
                this.graph.trigger('edge:unselected', { cell, options, edge: cell });
            }
        });
        const args = {
            added,
            removed,
            options,
            selected: this.cells.filter((cell) => !!this.graph.getCellById(cell.id)),
        };
        this.trigger('selection:changed', args);
        this.graph.trigger('selection:changed', args);
    }
    // #region handle
    deleteSelectedCells() {
        const cells = this.collection.toArray();
        this.clean();
        this.graph.model.removeCells(cells, { selection: this.cid });
    }
    startRotate({ e }) {
        const cells = this.collection.toArray();
        const center = Cell.getCellsBBox(cells).getCenter();
        const client = this.graph.snapToGrid(e.clientX, e.clientY);
        const angles = cells.reduce((memo, cell) => {
            memo[cell.id] = Angle.normalize(cell.getAngle());
            return memo;
        }, {});
        this.setEventData(e, {
            center,
            angles,
            start: client.theta(center),
        });
    }
    doRotate({ e }) {
        const data = this.getEventData(e);
        const grid = this.graph.options.rotating.grid;
        const gridSize = typeof grid === 'function'
            ? call(grid, this.graph, null)
            : grid;
        const client = this.graph.snapToGrid(e.clientX, e.clientY);
        const delta = data.start - client.theta(data.center);
        if (!data.rotated) {
            data.rotated = true;
        }
        if (Math.abs(delta) > 0.001) {
            this.collection.toArray().forEach((node) => {
                const angle = Util$3.snapToGrid(data.angles[node.id] + delta, gridSize || 15);
                node.rotate(angle, {
                    absolute: true,
                    center: data.center,
                    selection: this.cid,
                });
            });
            this.updateSelectionBoxes();
        }
    }
    stopRotate({ e }) {
        const data = this.getEventData(e);
        if (data.rotated) {
            data.rotated = false;
            this.collection.toArray().forEach((node) => {
                notify('node:rotated', e, this.graph.findViewByCell(node));
            });
        }
    }
    startResize({ e }) {
        const gridSize = this.graph.getGridSize();
        const cells = this.collection.toArray();
        const bbox = Cell.getCellsBBox(cells);
        const bboxes = cells.map((cell) => cell.getBBox());
        const maxWidth = bboxes.reduce((maxWidth, bbox) => {
            return bbox.width < maxWidth ? bbox.width : maxWidth;
        }, Infinity);
        const maxHeight = bboxes.reduce((maxHeight, bbox) => {
            return bbox.height < maxHeight ? bbox.height : maxHeight;
        }, Infinity);
        this.setEventData(e, {
            bbox,
            cells: this.graph.model.getSubGraph(cells),
            minWidth: (gridSize * bbox.width) / maxWidth,
            minHeight: (gridSize * bbox.height) / maxHeight,
        });
    }
    doResize({ e, dx, dy }) {
        const data = this.eventData(e);
        const bbox = data.bbox;
        const width = bbox.width;
        const height = bbox.height;
        const newWidth = Math.max(width + dx, data.minWidth);
        const newHeight = Math.max(height + dy, data.minHeight);
        if (!data.resized) {
            data.resized = true;
        }
        if (Math.abs(width - newWidth) > 0.001 ||
            Math.abs(height - newHeight) > 0.001) {
            this.graph.model.resizeCells(newWidth, newHeight, data.cells, {
                selection: this.cid,
            });
            bbox.width = newWidth;
            bbox.height = newHeight;
            this.updateSelectionBoxes();
        }
    }
    stopResize({ e }) {
        const data = this.eventData(e);
        if (data.resized) {
            data.resized = false;
            this.collection.toArray().forEach((node) => {
                notify('node:resized', e, this.graph.findViewByCell(node));
            });
        }
    }
    // #endregion
    dispose() {
        this.clean();
        this.remove();
    }
}
__decorate$h([
    View.dispose()
], Selection.prototype, "dispose", null);
applyMixins(Selection, Handle);
// private
// -------
var Private$3;
(function (Private) {
    const base = 'widget-selection';
    Private.classNames = {
        root: base,
        inner: `${base}-inner`,
        box: `${base}-box`,
        content: `${base}-content`,
        rubberband: `${base}-rubberband`,
        selected: `${base}-selected`,
    };
    Private.documentEvents = {
        mousemove: 'adjustSelection',
        touchmove: 'adjustSelection',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
        touchcancel: 'onMouseUp',
    };
    Private.defaultOptions = {
        movable: true,
        following: true,
        strict: false,
        useCellGeometry: false,
        content(selection) {
            return template('<%= length %> node<%= length > 1 ? "s":"" %> selected.')({ length: selection.length });
        },
        handles: [
            {
                name: 'remove',
                position: 'nw',
                events: {
                    mousedown: 'deleteSelectedCells',
                },
            },
            {
                name: 'rotate',
                position: 'sw',
                events: {
                    mousedown: 'startRotate',
                    mousemove: 'doRotate',
                    mouseup: 'stopRotate',
                },
            },
            {
                name: 'resize',
                position: 'se',
                events: {
                    mousedown: 'startResize',
                    mousemove: 'doResize',
                    mouseup: 'stopResize',
                },
            },
        ],
    };
    function depthComparator(cell) {
        return cell.getAncestors().length;
    }
    Private.depthComparator = depthComparator;
})(Private$3 || (Private$3 = {}));

class Transform extends Widget {
    get node() {
        return this.cell;
    }
    get containerClassName() {
        return this.prefixClassName('widget-transform');
    }
    get resizeClassName() {
        return `${this.containerClassName}-resize`;
    }
    get rotateClassName() {
        return `${this.containerClassName}-rotate`;
    }
    init(options) {
        this.options = Object.assign(Object.assign({}, Private$2.defaultOptions), options);
        this.render();
        this.startListening();
    }
    startListening() {
        this.delegateEvents({
            [`mousedown .${this.resizeClassName}`]: 'startResizing',
            [`touchstart .${this.resizeClassName}`]: 'startResizing',
            [`mousedown .${this.rotateClassName}`]: 'startRotating',
            [`touchstart .${this.rotateClassName}`]: 'startRotating',
        });
        this.model.on('*', this.update, this);
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
        this.node.on('removed', this.remove, this);
        this.model.on('reseted', this.remove, this);
        this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);
        this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);
        super.startListening();
    }
    stopListening() {
        this.undelegateEvents();
        this.model.off('*', this.update, this);
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
        this.node.off('removed', this.remove, this);
        this.model.off('reseted', this.remove, this);
        this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);
        this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);
        super.stopListening();
    }
    renderHandles() {
        this.container = document.createElement('div');
        this.$container = this.$(this.container);
        const $knob = this.$('<div/>').prop('draggable', false);
        const $rotate = $knob.clone().addClass(this.rotateClassName);
        const $resizes = Private$2.POSITIONS.map((pos) => {
            return $knob
                .clone()
                .addClass(this.resizeClassName)
                .attr('data-position', pos);
        });
        this.empty();
        this.$container.append($resizes, $rotate);
    }
    render() {
        this.renderHandles();
        this.view.addClass(Private$2.NODE_CLS);
        this.$container
            .addClass(this.containerClassName)
            .toggleClass('no-orth-resize', this.options.preserveAspectRatio || !this.options.orthogonalResizing)
            .toggleClass('no-resize', !this.options.resizable)
            .toggleClass('no-rotate', !this.options.rotatable);
        if (this.options.className) {
            this.$container.addClass(this.options.className);
        }
        this.graph.container.appendChild(this.container);
        return this.update();
    }
    update() {
        const ctm = this.graph.matrix();
        const bbox = this.node.getBBox();
        bbox.x *= ctm.a;
        bbox.x += ctm.e;
        bbox.y *= ctm.d;
        bbox.y += ctm.f;
        bbox.width *= ctm.a;
        bbox.height *= ctm.d;
        const angle = Angle.normalize(this.node.getAngle());
        const transform = angle !== 0 ? `rotate(${angle}deg)` : '';
        this.$container.css({
            transform,
            width: bbox.width,
            height: bbox.height,
            left: bbox.x,
            top: bbox.y,
        });
        this.updateResizerDirections();
        return this;
    }
    remove() {
        this.view.removeClass(Private$2.NODE_CLS);
        return super.remove();
    }
    onKnobMouseDown() {
        this.startHandle();
    }
    onKnobMouseUp() {
        this.stopHandle();
    }
    updateResizerDirections() {
        // Update the directions on the resizer divs while the node being rotated.
        // The directions are represented by cardinal points (N,S,E,W). For example
        // the div originally pointed to north needs to be changed to point to south
        // if the node was rotated by 180 degrees.
        const angle = Angle.normalize(this.node.getAngle());
        const shift = Math.floor(angle * (Private$2.DIRECTIONS.length / 360));
        if (shift !== this.prevShift) {
            // Create the current directions array based on the calculated shift.
            const directions = Private$2.DIRECTIONS.slice(shift).concat(Private$2.DIRECTIONS.slice(0, shift));
            const className = (dir) => `${this.containerClassName}-cursor-${dir}`;
            this.$container
                .find(`.${this.resizeClassName}`)
                .removeClass(Private$2.DIRECTIONS.map((dir) => className(dir)).join(' '))
                .each((index, elem) => {
                this.$(elem).addClass(className(directions[index]));
            });
            this.prevShift = shift;
        }
    }
    getTrueDirection(dir) {
        const angle = Angle.normalize(this.node.getAngle());
        let index = Private$2.POSITIONS.indexOf(dir);
        index += Math.floor(angle * (Private$2.POSITIONS.length / 360));
        index %= Private$2.POSITIONS.length;
        return Private$2.POSITIONS[index];
    }
    toValidResizeDirection(dir) {
        return ({
            top: 'top-left',
            bottom: 'bottom-right',
            left: 'bottom-left',
            right: 'top-right',
        }[dir] || dir);
    }
    startResizing(evt) {
        evt.stopPropagation();
        this.model.startBatch('resize', { cid: this.cid });
        const dir = this.$(evt.target).attr('data-position');
        const view = this.graph.findViewByCell(this.node);
        this.prepareResizing(evt, dir);
        this.startAction(evt);
        notify('node:resize:mousedown', evt, view);
    }
    prepareResizing(evt, relativeDirection) {
        const trueDirection = this.getTrueDirection(relativeDirection);
        let rx = 0;
        let ry = 0;
        relativeDirection.split('-').forEach((direction) => {
            rx = { left: -1, right: 1 }[direction] || rx;
            ry = { top: -1, bottom: 1 }[direction] || ry;
        });
        const direction = this.toValidResizeDirection(relativeDirection);
        const selector = {
            'top-right': 'bottomLeft',
            'top-left': 'bottomRight',
            'bottom-left': 'topRight',
            'bottom-right': 'topLeft',
        }[direction];
        const angle = Angle.normalize(this.node.getAngle());
        this.setEventData(evt, {
            selector,
            direction,
            trueDirection,
            relativeDirection,
            angle,
            resizeX: rx,
            resizeY: ry,
            action: 'resizing',
        });
    }
    startRotating(evt) {
        evt.stopPropagation();
        this.model.startBatch('rotate', { cid: this.cid });
        const view = this.graph.findViewByCell(this.node);
        const center = this.node.getBBox().getCenter();
        const e = this.normalizeEvent(evt);
        const client = this.graph.snapToGrid(e.clientX, e.clientY);
        this.setEventData(evt, {
            center,
            action: 'rotating',
            angle: Angle.normalize(this.node.getAngle()),
            start: Point.create(client).theta(center),
        });
        this.startAction(evt);
        notify('node:rotate:mousedown', evt, view);
    }
    onMouseMove(evt) {
        const view = this.graph.findViewByCell(this.node);
        let data = this.getEventData(evt);
        if (data.action) {
            const e = this.normalizeEvent(evt);
            let clientX = e.clientX;
            let clientY = e.clientY;
            const scroller = this.graph.scroller.widget;
            const restrict = this.options.restrictedResizing;
            if (restrict === true || typeof restrict === 'number') {
                const factor = restrict === true ? 0 : restrict;
                const fix = scroller ? Math.max(factor, 8) : factor;
                const rect = this.graph.container.getBoundingClientRect();
                clientX = clamp$1(clientX, rect.left + fix, rect.right - fix);
                clientY = clamp$1(clientY, rect.top + fix, rect.bottom - fix);
            }
            else if (this.options.autoScrollOnResizing && scroller) {
                scroller.autoScroll(clientX, clientY);
            }
            const pos = this.graph.snapToGrid(clientX, clientY);
            const gridSize = this.graph.getGridSize();
            const node = this.node;
            const options = this.options;
            if (data.action === 'resizing') {
                data = data;
                if (!data.resized) {
                    if (view) {
                        view.addClass('node-resizing');
                        notify('node:resize', evt, view);
                    }
                    data.resized = true;
                }
                const currentBBox = node.getBBox();
                const requestedSize = Point.create(pos)
                    .rotate(data.angle, currentBBox.getCenter())
                    .diff(currentBBox[data.selector]);
                let width = data.resizeX
                    ? requestedSize.x * data.resizeX
                    : currentBBox.width;
                let height = data.resizeY
                    ? requestedSize.y * data.resizeY
                    : currentBBox.height;
                const rawWidth = width;
                const rawHeight = height;
                width = Util$3.snapToGrid(width, gridSize);
                height = Util$3.snapToGrid(height, gridSize);
                width = Math.max(width, options.minWidth || gridSize);
                height = Math.max(height, options.minHeight || gridSize);
                width = Math.min(width, options.maxWidth || Infinity);
                height = Math.min(height, options.maxHeight || Infinity);
                if (options.preserveAspectRatio) {
                    const candidateWidth = (currentBBox.width * height) / currentBBox.height;
                    const candidateHeight = (currentBBox.height * width) / currentBBox.width;
                    if (width < candidateWidth) {
                        height = candidateHeight;
                    }
                    else {
                        width = candidateWidth;
                    }
                }
                const relativeDirection = data.relativeDirection;
                if (options.allowReverse &&
                    (rawWidth <= -width || rawHeight <= -height)) {
                    let reverted;
                    if (relativeDirection === 'left') {
                        if (rawWidth <= -width) {
                            reverted = 'right';
                        }
                    }
                    else if (relativeDirection === 'right') {
                        if (rawWidth <= -width) {
                            reverted = 'left';
                        }
                    }
                    else if (relativeDirection === 'top') {
                        if (rawHeight <= -height) {
                            reverted = 'bottom';
                        }
                    }
                    else if (relativeDirection === 'bottom') {
                        if (rawHeight <= -height) {
                            reverted = 'top';
                        }
                    }
                    else if (relativeDirection === 'top-left') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'bottom-right';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'top-right';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'bottom-left';
                        }
                    }
                    else if (relativeDirection === 'top-right') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'bottom-left';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'top-left';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'bottom-right';
                        }
                    }
                    else if (relativeDirection === 'bottom-left') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'top-right';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'bottom-right';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'top-left';
                        }
                    }
                    else if (relativeDirection === 'bottom-right') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'top-left';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'bottom-left';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'top-right';
                        }
                    }
                    const revertedDir = reverted;
                    this.stopHandle();
                    const $handle = this.$container.find(`.${this.resizeClassName}[data-position="${revertedDir}"]`);
                    this.startHandle($handle[0]);
                    this.prepareResizing(evt, revertedDir);
                    this.onMouseMove(evt);
                }
                if (currentBBox.width !== width || currentBBox.height !== height) {
                    const resizeOptions = {
                        ui: true,
                        direction: data.direction,
                        relativeDirection: data.relativeDirection,
                        trueDirection: data.trueDirection,
                        minWidth: options.minWidth,
                        minHeight: options.minHeight,
                        maxWidth: options.maxWidth,
                        maxHeight: options.maxHeight,
                        preserveAspectRatio: options.preserveAspectRatio === true,
                    };
                    node.resize(width, height, resizeOptions);
                    notify('node:resizing', evt, view);
                }
                notify('node:resize:mousemove', evt, view);
            }
            else if (data.action === 'rotating') {
                data = data;
                if (!data.rotated) {
                    if (view) {
                        view.addClass('node-rotating');
                        notify('node:rotate', evt, view);
                    }
                    data.rotated = true;
                }
                const currentAngle = node.getAngle();
                const theta = data.start - Point.create(pos).theta(data.center);
                let target = data.angle + theta;
                if (options.rotateGrid) {
                    target = Util$3.snapToGrid(target, options.rotateGrid);
                }
                target = Angle.normalize(target);
                if (currentAngle !== target) {
                    node.rotate(target, { absolute: true });
                    notify('node:rotating', evt, view);
                }
                notify('node:rotate:mousemove', evt, view);
            }
        }
    }
    onMouseUp(evt) {
        const view = this.graph.findViewByCell(this.node);
        const data = this.getEventData(evt);
        if (data.action) {
            this.stopAction(evt);
            this.model.stopBatch(data.action === 'resizing' ? 'resize' : 'rotate', {
                cid: this.cid,
            });
            if (data.action === 'resizing') {
                notify('node:resize:mouseup', evt, view);
            }
            else if (data.action === 'rotating') {
                notify('node:rotate:mouseup', evt, view);
            }
        }
    }
    startHandle(handle) {
        this.handle = handle || null;
        this.$container.addClass(`${this.containerClassName}-active`);
        if (handle) {
            this.$(handle).addClass(`${this.containerClassName}-active-handle`);
            const pos = handle.getAttribute('data-position');
            if (pos) {
                const dir = Private$2.DIRECTIONS[Private$2.POSITIONS.indexOf(pos)];
                this.$container.addClass(`${this.containerClassName}-cursor-${dir}`);
            }
        }
    }
    stopHandle() {
        this.$container.removeClass(`${this.containerClassName}-active`);
        if (this.handle) {
            this.$(this.handle).removeClass(`${this.containerClassName}-active-handle`);
            const pos = this.handle.getAttribute('data-position');
            if (pos) {
                const dir = Private$2.DIRECTIONS[Private$2.POSITIONS.indexOf(pos)];
                this.$container.removeClass(`${this.containerClassName}-cursor-${dir}`);
            }
            this.handle = null;
        }
    }
    startAction(evt) {
        this.startHandle(evt.target);
        this.graph.view.undelegateEvents();
        this.delegateDocumentEvents(Private$2.documentEvents, evt.data);
    }
    stopAction(evt) {
        this.stopHandle();
        this.undelegateDocumentEvents();
        this.graph.view.delegateEvents();
        const view = this.graph.findViewByCell(this.node);
        const data = this.getEventData(evt);
        if (view) {
            view.removeClass(`node-${data.action}`);
            if (data.action === 'resizing' && data.resized) {
                notify('node:resized', evt, view);
            }
            else if (data.action === 'rotating' && data.rotated) {
                notify('node:rotated', evt, view);
            }
        }
    }
    onRemove() {
        this.stopListening();
        super.onRemove();
    }
}
var Private$2;
(function (Private) {
    Private.NODE_CLS = 'has-widget-transform';
    Private.DIRECTIONS = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
    Private.POSITIONS = [
        'top-left',
        'top',
        'top-right',
        'right',
        'bottom-right',
        'bottom',
        'bottom-left',
        'left',
    ];
    Private.documentEvents = {
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
    };
    Private.defaultOptions = {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Infinity,
        maxHeight: Infinity,
        rotateGrid: 15,
        rotatable: true,
        preserveAspectRatio: false,
        orthogonalResizing: true,
        restrictedResizing: false,
        autoScrollOnResizing: true,
        allowReverse: true,
    };
})(Private$2 || (Private$2 = {}));

var __rest$5 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Options;
(function (Options) {
    function parseOptionGroup(graph, arg, options) {
        const result = {};
        Object.keys(options || {}).forEach((key) => {
            const val = options[key];
            result[key] = typeof val === 'function' ? val.call(graph, arg) : val;
        });
        return result;
    }
    Options.parseOptionGroup = parseOptionGroup;
})(Options || (Options = {}));
(function (Options) {
    function get(options) {
        const { grid, panning, selecting, embedding, snapline, resizing, rotating, knob, clipboard, history, scroller, minimap, keyboard, mousewheel } = options, others = __rest$5(options
        // size
        // ----
        , ["grid", "panning", "selecting", "embedding", "snapline", "resizing", "rotating", "knob", "clipboard", "history", "scroller", "minimap", "keyboard", "mousewheel"]);
        // size
        // ----
        const container = options.container;
        if (container != null) {
            if (others.width == null) {
                others.width = container.clientWidth;
            }
            if (others.height == null) {
                others.height = container.clientHeight;
            }
        }
        else {
            throw new Error(`Ensure the container of the graph is specified and valid`);
        }
        const result = merge({}, Options.defaults, others);
        // grid
        // ----
        const defaultGrid = { size: 10, visible: false };
        if (typeof grid === 'number') {
            result.grid = { size: grid, visible: false };
        }
        else if (typeof grid === 'boolean') {
            result.grid = Object.assign(Object.assign({}, defaultGrid), { visible: grid });
        }
        else {
            result.grid = Object.assign(Object.assign({}, defaultGrid), grid);
        }
        // booleas
        // -------
        const booleas = [
            'panning',
            'selecting',
            'embedding',
            'snapline',
            'resizing',
            'rotating',
            'knob',
            'clipboard',
            'history',
            'scroller',
            'minimap',
            'keyboard',
            'mousewheel',
        ];
        booleas.forEach((key) => {
            const val = options[key];
            if (typeof val === 'boolean') {
                result[key].enabled = val;
            }
            else {
                result[key] = Object.assign(Object.assign({}, result[key]), val);
            }
        });
        // background
        // ----------
        if (result.background &&
            result.scroller.enabled &&
            result.scroller.background == null) {
            result.scroller.background = result.background;
            delete result.background;
        }
        return result;
    }
    Options.get = get;
})(Options || (Options = {}));
(function (Options) {
    Options.defaults = {
        x: 0,
        y: 0,
        grid: {
            size: 10,
            visible: false,
        },
        scaling: {
            min: 0.01,
            max: 16,
        },
        background: false,
        highlighting: {
            default: {
                name: 'stroke',
                args: {
                    padding: 3,
                },
            },
            nodeAvailable: {
                name: 'className',
                args: {
                    className: Util$3.prefix('available-node'),
                },
            },
            magnetAvailable: {
                name: 'className',
                args: {
                    className: Util$3.prefix('available-magnet'),
                },
            },
        },
        connecting: {
            snap: false,
            multi: true,
            // TODO: Unannotation the next line when the `multi` option was removed in the next major version.
            // allowMulti: true,
            dangling: true,
            // TODO: Unannotation the next line when the `dangling` option was removed in the next major version.
            // allowBlank: true,
            allowLoop: true,
            allowNode: true,
            allowEdge: false,
            allowPort: true,
            highlight: false,
            anchor: 'center',
            edgeAnchor: 'ratio',
            connectionPoint: 'boundary',
            strategy: null,
            router: 'normal',
            connector: 'normal',
            validateConnection({ type, sourceView, targetView }) {
                const view = type === 'target' ? targetView : sourceView;
                return view != null;
            },
            createEdge() {
                return new Edge();
            },
        },
        transforming: {
            clearAll: true,
            clearOnBlankMouseDown: true,
        },
        resizing: {
            enabled: false,
            minWidth: 0,
            minHeight: 0,
            maxWidth: Number.MAX_SAFE_INTEGER,
            maxHeight: Number.MAX_SAFE_INTEGER,
            orthogonal: true,
            restricted: false,
            autoScroll: true,
            preserveAspectRatio: false,
            allowReverse: true,
        },
        rotating: {
            enabled: false,
            grid: 15,
        },
        translating: {
            restrict: false,
        },
        knob: {
            enabled: false,
            clearAll: true,
            clearOnBlankMouseDown: true,
        },
        embedding: {
            enabled: false,
            findParent: 'bbox',
            frontOnly: true,
            validate: () => true,
        },
        selecting: {
            enabled: false,
            rubberband: false,
            rubberNode: true,
            rubberEdge: false,
            pointerEvents: 'auto',
            multiple: true,
            multipleSelectionModifiers: ['ctrl', 'meta'],
            movable: true,
            strict: false,
            useCellGeometry: false,
            selectCellOnMoved: false,
            selectNodeOnMoved: false,
            selectEdgeOnMoved: false,
            content: null,
            handles: null,
        },
        panning: {
            enabled: false,
            eventTypes: ['leftMouseDown'],
        },
        snapline: {
            enabled: false,
        },
        clipboard: {
            enabled: false,
        },
        history: {
            enabled: false,
        },
        scroller: {
            enabled: false,
        },
        keyboard: {
            enabled: false,
        },
        mousewheel: {
            enabled: false,
            factor: 1.2,
            zoomAtMousePosition: true,
        },
        async: false,
        frozen: false,
        sorting: 'exact',
        moveThreshold: 0,
        clickThreshold: 0,
        magnetThreshold: 0,
        preventDefaultDblClick: true,
        preventDefaultMouseDown: false,
        preventDefaultContextMenu: true,
        preventDefaultBlankAction: true,
        interacting: {
            edgeLabelMovable: false,
        },
        guard: () => false,
    };
})(Options || (Options = {}));

var __rest$4 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class DefsManager extends Base {
    get cid() {
        return this.graph.view.cid;
    }
    get svg() {
        return this.view.svg;
    }
    get defs() {
        return this.view.defs;
    }
    isDefined(id) {
        return this.svg.getElementById(id) != null;
    }
    filter(options) {
        let filterId = options.id;
        const name = options.name;
        if (!filterId) {
            filterId = `filter-${name}-${this.cid}-${hashcode$1(JSON.stringify(options))}`;
        }
        if (!this.isDefined(filterId)) {
            const fn = Filter.registry.get(name);
            if (fn == null) {
                return Filter.registry.onNotFound(name);
            }
            const markup = fn(options.args || {});
            // Set the filter area to be 3x the bounding box of the cell
            // and center the filter around the cell.
            const attrs = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: 'objectBoundingBox' }, options.attrs), { id: filterId });
            Vector.create(Markup.sanitize(markup), attrs).appendTo(this.defs);
        }
        return filterId;
    }
    gradient(options) {
        let id = options.id;
        const type = options.type;
        if (!id) {
            id = `gradient-${type}-${this.cid}-${hashcode$1(JSON.stringify(options))}`;
        }
        if (!this.isDefined(id)) {
            const stops = options.stops;
            const arr = stops.map((stop) => {
                const opacity = stop.opacity != null && Number.isFinite(stop.opacity)
                    ? stop.opacity
                    : 1;
                return `<stop offset="${stop.offset}" stop-color="${stop.color}" stop-opacity="${opacity}"/>`;
            });
            const markup = `<${type}>${arr.join('')}</${type}>`;
            const attrs = Object.assign({ id }, options.attrs);
            Vector.create(markup, attrs).appendTo(this.defs);
        }
        return id;
    }
    marker(options) {
        const { id, refX, refY, markerUnits, markerOrient, tagName, children } = options, attrs = __rest$4(options, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
        let markerId = id;
        if (!markerId) {
            markerId = `marker-${this.cid}-${hashcode$1(JSON.stringify(options))}`;
        }
        if (!this.isDefined(markerId)) {
            if (tagName !== 'path') {
                // remove unnecessary d attribute inherit from standard edge.
                delete attrs.d;
            }
            const pathMarker = Vector.create('marker', {
                refX,
                refY,
                id: markerId,
                overflow: 'visible',
                orient: markerOrient != null ? markerOrient : 'auto',
                markerUnits: markerUnits || 'userSpaceOnUse',
            }, children
                ? children.map((_a) => {
                    var { tagName } = _a, other = __rest$4(_a, ["tagName"]);
                    return Vector.create(`${tagName}` || 'path', kebablizeAttrs(Object.assign(Object.assign({}, attrs), other)));
                })
                : [Vector.create(tagName || 'path', kebablizeAttrs(attrs))]);
            this.defs.appendChild(pathMarker.node);
        }
        return markerId;
    }
    remove(id) {
        const elem = this.svg.getElementById(id);
        if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }
}

var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$3 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class GridManager extends Base {
    get elem() {
        return this.view.grid;
    }
    get grid() {
        return this.options.grid;
    }
    init() {
        this.startListening();
        this.draw(this.grid);
    }
    startListening() {
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
    }
    stopListening() {
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
    }
    setVisible(visible) {
        if (this.grid.visible !== visible) {
            this.grid.visible = visible;
            this.update();
        }
    }
    getGridSize() {
        return this.grid.size;
    }
    setGridSize(size) {
        this.grid.size = Math.max(size, 1);
        this.update();
    }
    show() {
        this.setVisible(true);
        this.update();
    }
    hide() {
        this.setVisible(false);
        this.update();
    }
    clear() {
        this.elem.style.backgroundImage = '';
    }
    draw(options) {
        this.clear();
        this.instance = null;
        Object.assign(this.grid, options);
        this.patterns = this.resolveGrid(options);
        this.update();
    }
    update(options = {}) {
        const gridSize = this.grid.size;
        if (gridSize <= 1 || !this.grid.visible) {
            return this.clear();
        }
        const ctm = this.graph.matrix();
        const grid = this.getInstance();
        const items = Array.isArray(options) ? options : [options];
        this.patterns.forEach((settings, index) => {
            const id = `pattern_${index}`;
            const sx = ctm.a || 1;
            const sy = ctm.d || 1;
            const { update, markup } = settings, others = __rest$3(settings, ["update", "markup"]);
            const options = Object.assign(Object.assign(Object.assign({}, others), items[index]), { sx,
                sy, ox: ctm.e || 0, oy: ctm.f || 0, width: gridSize * sx, height: gridSize * sy });
            if (!grid.has(id)) {
                grid.add(id, Vector.create('pattern', { id, patternUnits: 'userSpaceOnUse' }, Vector.createVectors(markup)).node);
            }
            const patternElem = grid.get(id);
            if (typeof update === 'function') {
                update(patternElem.childNodes[0], options);
            }
            let x = options.ox % options.width;
            if (x < 0) {
                x += options.width;
            }
            let y = options.oy % options.height;
            if (y < 0) {
                y += options.height;
            }
            attr$1(patternElem, {
                x,
                y,
                width: options.width,
                height: options.height,
            });
        });
        const base64 = new XMLSerializer().serializeToString(grid.root);
        const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;
        this.elem.style.backgroundImage = url;
    }
    getInstance() {
        if (!this.instance) {
            this.instance = new Grid();
        }
        return this.instance;
    }
    resolveGrid(options) {
        if (!options) {
            return [];
        }
        const type = options.type;
        if (type == null) {
            return [
                Object.assign(Object.assign({}, Grid.presets.dot), options.args),
            ];
        }
        const items = Grid.registry.get(type);
        if (items) {
            let args = options.args || [];
            if (!Array.isArray(args)) {
                args = [args];
            }
            return Array.isArray(items)
                ? items.map((item, index) => (Object.assign(Object.assign({}, item), args[index])))
                : [Object.assign(Object.assign({}, items), args[0])];
        }
        return Grid.registry.onNotFound(type);
    }
    dispose() {
        this.stopListening();
        this.clear();
    }
}
__decorate$g([
    Base.dispose()
], GridManager.prototype, "dispose", null);

class CoordManager extends Base {
    getClientMatrix() {
        return createSVGMatrix(this.view.stage.getScreenCTM());
    }
    /**
     * Returns coordinates of the graph viewport, relative to the window.
     */
    getClientOffset() {
        // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
        const rect = this.view.svg.getBoundingClientRect();
        return new Point(rect.left, rect.top);
    }
    /**
     * Returns coordinates of the graph viewport, relative to the document.
     */
    getPageOffset() {
        // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
        return this.getClientOffset().translate(window.scrollX, window.scrollY);
    }
    snapToGrid(x, y) {
        const p = typeof x === 'number'
            ? this.clientToLocalPoint(x, y)
            : this.clientToLocalPoint(x.x, x.y);
        return p.snapToGrid(this.graph.getGridSize());
    }
    localToGraphPoint(x, y) {
        const localPoint = Point.create(x, y);
        return transformPoint(localPoint, this.graph.matrix());
    }
    localToClientPoint(x, y) {
        const localPoint = Point.create(x, y);
        return transformPoint(localPoint, this.getClientMatrix());
    }
    localToPagePoint(x, y) {
        const p = typeof x === 'number'
            ? this.localToGraphPoint(x, y)
            : this.localToGraphPoint(x);
        return p.translate(this.getPageOffset());
    }
    localToGraphRect(x, y, width, height) {
        const localRect = Rectangle.create(x, y, width, height);
        return transformRectangle(localRect, this.graph.matrix());
    }
    localToClientRect(x, y, width, height) {
        const localRect = Rectangle.create(x, y, width, height);
        return transformRectangle(localRect, this.getClientMatrix());
    }
    localToPageRect(x, y, width, height) {
        const rect = typeof x === 'number'
            ? this.localToGraphRect(x, y, width, height)
            : this.localToGraphRect(x);
        return rect.translate(this.getPageOffset());
    }
    graphToLocalPoint(x, y) {
        const graphPoint = Point.create(x, y);
        return transformPoint(graphPoint, this.graph.matrix().inverse());
    }
    clientToLocalPoint(x, y) {
        const clientPoint = Point.create(x, y);
        return transformPoint(clientPoint, this.getClientMatrix().inverse());
    }
    clientToGraphPoint(x, y) {
        const clientPoint = Point.create(x, y);
        return transformPoint(clientPoint, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
    }
    pageToLocalPoint(x, y) {
        const pagePoint = Point.create(x, y);
        const graphPoint = pagePoint.diff(this.getPageOffset());
        return this.graphToLocalPoint(graphPoint);
    }
    graphToLocalRect(x, y, width, height) {
        const graphRect = Rectangle.create(x, y, width, height);
        return transformRectangle(graphRect, this.graph.matrix().inverse());
    }
    clientToLocalRect(x, y, width, height) {
        const clientRect = Rectangle.create(x, y, width, height);
        return transformRectangle(clientRect, this.getClientMatrix().inverse());
    }
    clientToGraphRect(x, y, width, height) {
        const clientRect = Rectangle.create(x, y, width, height);
        return transformRectangle(clientRect, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
    }
    pageToLocalRect(x, y, width, height) {
        const graphRect = Rectangle.create(x, y, width, height);
        const pageOffset = this.getPageOffset();
        graphRect.x -= pageOffset.x;
        graphRect.y -= pageOffset.y;
        return this.graphToLocalRect(graphRect);
    }
}

var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SnaplineManager extends Base {
    constructor() {
        super(...arguments);
        this.widget = this.graph.hook.createSnapline();
    }
    dispose() {
        this.widget.dispose();
    }
}
__decorate$f([
    Base.dispose()
], SnaplineManager.prototype, "dispose", null);

// eslint-disable-next-line
var ModifierKey;
(function (ModifierKey) {
    function parse(modifiers) {
        const or = [];
        const and = [];
        if (Array.isArray(modifiers)) {
            or.push(...modifiers);
        }
        else {
            modifiers.split('|').forEach((item) => {
                if (item.indexOf('&') === -1) {
                    or.push(item);
                }
                else {
                    and.push(...item.split('&'));
                }
            });
        }
        return { or, and };
    }
    ModifierKey.parse = parse;
    function equals(modifiers1, modifiers2) {
        if (modifiers1 != null && modifiers2 != null) {
            const m1 = parse(modifiers1);
            const m2 = parse(modifiers2);
            const or1 = m1.or.sort();
            const or2 = m2.or.sort();
            const and1 = m1.and.sort();
            const and2 = m2.and.sort();
            const equal = (a1, a2) => {
                return (a1.length === a2.length &&
                    (a1.length === 0 || a1.every((a, i) => a === a2[i])));
            };
            return equal(or1, or2) && equal(and1, and2);
        }
        if (modifiers1 == null && modifiers2 == null) {
            return true;
        }
        return false;
    }
    ModifierKey.equals = equals;
    function isMatch(e, modifiers, strict) {
        if (modifiers == null ||
            (Array.isArray(modifiers) && modifiers.length === 0)) {
            return strict
                ? e.altKey !== true &&
                    e.ctrlKey !== true &&
                    e.metaKey !== true &&
                    e.shiftKey !== true
                : true;
        }
        const { or, and } = parse(modifiers);
        const match = (key) => {
            const name = `${key.toLowerCase()}Key`;
            return e[name] === true;
        };
        return or.some((key) => match(key)) && and.every((key) => match(key));
    }
    ModifierKey.isMatch = isMatch;
})(ModifierKey || (ModifierKey = {}));

var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ScrollerManager extends Base {
    get widgetOptions() {
        return this.options.scroller;
    }
    get pannable() {
        if (this.widgetOptions) {
            if (typeof this.widgetOptions.pannable === 'object') {
                return this.widgetOptions.pannable.enabled;
            }
            return !!this.widgetOptions.pannable;
        }
        return false;
    }
    init() {
        this.widget = this.graph.hook.createScroller();
        this.startListening();
        this.updateClassName();
        if (this.widget) {
            this.widget.center();
        }
    }
    startListening() {
        let eventTypes = [];
        const pannable = this.widgetOptions.pannable;
        if (typeof pannable === 'object') {
            eventTypes = pannable.eventTypes || [];
        }
        else {
            eventTypes = ['leftMouseDown'];
        }
        if (eventTypes.includes('leftMouseDown')) {
            this.graph.on('blank:mousedown', this.preparePanning, this);
            this.graph.on('node:unhandled:mousedown', this.preparePanning, this);
            this.graph.on('edge:unhandled:mousedown', this.preparePanning, this);
        }
        if (eventTypes.includes('rightMouseDown')) {
            this.onRightMouseDown = this.onRightMouseDown.bind(this);
            this.view.$(this.widget.container).on('mousedown', this.onRightMouseDown);
        }
    }
    stopListening() {
        let eventTypes = [];
        const pannable = this.widgetOptions.pannable;
        if (typeof pannable === 'object') {
            eventTypes = pannable.eventTypes || [];
        }
        else {
            eventTypes = ['leftMouseDown'];
        }
        if (eventTypes.includes('leftMouseDown')) {
            this.graph.off('blank:mousedown', this.preparePanning, this);
            this.graph.off('node:unhandled:mousedown', this.preparePanning, this);
            this.graph.off('edge:unhandled:mousedown', this.preparePanning, this);
        }
        if (eventTypes.includes('rightMouseDown')) {
            this.view
                .$(this.widget.container)
                .off('mousedown', this.onRightMouseDown);
        }
    }
    onRightMouseDown(e) {
        if (e.button === 2 && this.allowPanning(e, true) && this.widget) {
            this.updateClassName(true);
            this.widget.startPanning(e);
            this.widget.once('pan:stop', () => this.updateClassName(false));
        }
    }
    preparePanning({ e }) {
        if (this.widget) {
            if (this.allowPanning(e, true) ||
                (this.allowPanning(e) && !this.graph.selection.allowRubberband(e, true))) {
                this.updateClassName(true);
                this.widget.startPanning(e);
                this.widget.once('pan:stop', () => this.updateClassName(false));
            }
        }
    }
    allowPanning(e, strict) {
        return (this.widget &&
            this.pannable &&
            ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict) &&
            this.graph.hook.allowPanning(e));
    }
    updateClassName(isPanning) {
        if (this.widget == null) {
            return;
        }
        const container = this.widget.container;
        const pannable = this.view.prefixClassName('graph-scroller-pannable');
        if (this.pannable) {
            addClass(container, pannable);
            container.dataset.panning = (!!isPanning).toString(); // Use dataset to control scroller panning style to avoid reflow caused by changing classList
        }
        else {
            removeClass(container, pannable);
        }
    }
    enablePanning() {
        if (!this.pannable) {
            this.widgetOptions.pannable = true;
            this.updateClassName();
            // if (
            //   ModifierKey.equals(
            //     this.graph.options.scroller.modifiers,
            //     this.graph.options.selecting.modifiers,
            //   )
            // ) {
            //   this.graph.selection.disableRubberband()
            // }
        }
    }
    disablePanning() {
        if (this.pannable) {
            this.widgetOptions.pannable = false;
            this.updateClassName();
        }
    }
    lock() {
        if (this.widget) {
            this.widget.lock();
        }
    }
    unlock() {
        if (this.widget) {
            this.widget.unlock();
        }
    }
    update() {
        if (this.widget) {
            this.widget.update();
        }
    }
    enableAutoResize() {
        if (this.widget) {
            this.widget.enableAutoResize();
        }
    }
    disableAutoResize() {
        if (this.widget) {
            this.widget.disableAutoResize();
        }
    }
    resize(width, height) {
        if (this.widget) {
            this.widget.resize(width, height);
        }
    }
    dispose() {
        if (this.widget) {
            this.widget.dispose();
        }
        this.stopListening();
    }
}
__decorate$e([
    Base.dispose()
], ScrollerManager.prototype, "dispose", null);

var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class ClipboardManager extends Base {
    get commonOptions() {
        const _a = this.instanceOptions, { enabled } = _a, others = __rest$2(_a, ["enabled"]);
        return others;
    }
    get instanceOptions() {
        return this.options.clipboard;
    }
    get cells() {
        return this.widget.cells;
    }
    get disabled() {
        return this.instanceOptions.enabled !== true;
    }
    init() {
        this.widget = this.graph.hook.createClipboard();
        this.widget.deserialize(this.instanceOptions);
    }
    enable() {
        if (this.disabled) {
            this.instanceOptions.enabled = true;
        }
    }
    disable() {
        if (!this.disabled) {
            this.instanceOptions.enabled = false;
        }
    }
    copy(cells, options = {}) {
        if (!this.disabled) {
            this.widget.copy(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
            this.graph.trigger('clipboard:changed', { cells });
        }
    }
    cut(cells, options = {}) {
        if (!this.disabled) {
            this.widget.cut(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
            this.graph.trigger('clipboard:changed', { cells });
        }
    }
    paste(options = {}, graph = this.graph) {
        if (!this.disabled) {
            return this.widget.paste(graph, Object.assign(Object.assign({}, this.commonOptions), options));
        }
        return [];
    }
    clean(force) {
        if (!this.disabled || force) {
            this.widget.clean();
            this.graph.trigger('clipboard:changed', { cells: [] });
        }
    }
    isEmpty() {
        return this.widget.isEmpty();
    }
    dispose() {
        this.clean(true);
    }
}
__decorate$d([
    Base.dispose()
], ClipboardManager.prototype, "dispose", null);

var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class HighlightManager extends Base {
    constructor() {
        super(...arguments);
        this.highlights = {};
    }
    init() {
        this.startListening();
    }
    startListening() {
        this.graph.on('cell:highlight', this.onCellHighlight, this);
        this.graph.on('cell:unhighlight', this.onCellUnhighlight, this);
    }
    stopListening() {
        this.graph.off('cell:highlight', this.onCellHighlight, this);
        this.graph.off('cell:unhighlight', this.onCellUnhighlight, this);
    }
    onCellHighlight({ view: cellView, magnet, options = {}, }) {
        const resolved = this.resolveHighlighter(options);
        if (!resolved) {
            return;
        }
        const key = this.getHighlighterId(magnet, resolved);
        if (!this.highlights[key]) {
            const highlighter = resolved.highlighter;
            highlighter.highlight(cellView, magnet, Object.assign({}, resolved.args));
            this.highlights[key] = {
                cellView,
                magnet,
                highlighter,
                args: resolved.args,
            };
        }
    }
    onCellUnhighlight({ magnet, options = {}, }) {
        const resolved = this.resolveHighlighter(options);
        if (!resolved) {
            return;
        }
        const id = this.getHighlighterId(magnet, resolved);
        this.unhighlight(id);
    }
    resolveHighlighter(options) {
        const graphOptions = this.options;
        let highlighterDef = options.highlighter;
        if (highlighterDef == null) {
            // check for built-in types
            const type = options.type;
            highlighterDef =
                (type && graphOptions.highlighting[type]) ||
                    graphOptions.highlighting.default;
        }
        if (highlighterDef == null) {
            return null;
        }
        const def = typeof highlighterDef === 'string'
            ? {
                name: highlighterDef,
            }
            : highlighterDef;
        const name = def.name;
        const highlighter = Highlighter.registry.get(name);
        if (highlighter == null) {
            return Highlighter.registry.onNotFound(name);
        }
        Highlighter.check(name, highlighter);
        return {
            name,
            highlighter,
            args: def.args || {},
        };
    }
    getHighlighterId(magnet, options) {
        ensureId(magnet);
        return options.name + magnet.id + JSON.stringify(options.args);
    }
    unhighlight(id) {
        const highlight = this.highlights[id];
        if (highlight) {
            highlight.highlighter.unhighlight(highlight.cellView, highlight.magnet, highlight.args);
            delete this.highlights[id];
        }
    }
    dispose() {
        Object.keys(this.highlights).forEach((id) => this.unhighlight(id));
        this.stopListening();
    }
}
__decorate$c([
    HighlightManager.dispose()
], HighlightManager.prototype, "dispose", null);

var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class TransformManager extends Base {
    constructor() {
        super(...arguments);
        this.widgets = new Map();
    }
    get container() {
        return this.graph.view.container;
    }
    get viewport() {
        return this.graph.view.viewport;
    }
    get isSelectionEnabled() {
        return this.options.selecting.enabled === true;
    }
    init() {
        this.startListening();
        this.resize();
    }
    startListening() {
        this.graph.on('node:mouseup', this.onNodeMouseUp, this);
        this.graph.on('node:selected', this.onNodeSelected, this);
        this.graph.on('node:unselected', this.onNodeUnSelected, this);
    }
    stopListening() {
        this.graph.off('node:mouseup', this.onNodeMouseUp, this);
        this.graph.off('node:selected', this.onNodeSelected, this);
        this.graph.off('node:unselected', this.onNodeUnSelected, this);
    }
    onNodeMouseUp({ node }) {
        if (!this.isSelectionEnabled) {
            const widget = this.graph.hook.createTransform(node, { clearAll: true });
            if (widget) {
                this.widgets.set(node, widget);
            }
        }
    }
    onNodeSelected({ node }) {
        if (this.isSelectionEnabled) {
            const widget = this.graph.hook.createTransform(node, { clearAll: false });
            if (widget) {
                this.widgets.set(node, widget);
            }
        }
    }
    onNodeUnSelected({ node }) {
        if (this.isSelectionEnabled) {
            const widget = this.widgets.get(node);
            if (widget) {
                widget.dispose();
            }
            this.widgets.delete(node);
        }
    }
    /**
     * Returns the current transformation matrix of the graph.
     */
    getMatrix() {
        const transform = this.viewport.getAttribute('transform');
        if (transform !== this.viewportTransformString) {
            // `getCTM`: top-left relative to the SVG element
            // `getScreenCTM`: top-left relative to the document
            this.viewportMatrix = this.viewport.getCTM();
            this.viewportTransformString = transform;
        }
        // Clone the cached current transformation matrix.
        // If no matrix previously stored the identity matrix is returned.
        return createSVGMatrix(this.viewportMatrix);
    }
    /**
     * Sets new transformation with the given `matrix`
     */
    setMatrix(matrix) {
        const ctm = createSVGMatrix(matrix);
        const transform = matrixToTransformString(ctm);
        this.viewport.setAttribute('transform', transform);
        this.viewportMatrix = ctm;
        this.viewportTransformString = transform;
    }
    resize(width, height) {
        let w = width === undefined ? this.options.width : width;
        let h = height === undefined ? this.options.height : height;
        this.options.width = w;
        this.options.height = h;
        if (typeof w === 'number') {
            w = Math.round(w);
        }
        if (typeof h === 'number') {
            h = Math.round(h);
        }
        this.container.style.width = w == null ? '' : `${w}px`;
        this.container.style.height = h == null ? '' : `${h}px`;
        const size = this.getComputedSize();
        this.graph.trigger('resize', Object.assign({}, size));
        return this;
    }
    getComputedSize() {
        let w = this.options.width;
        let h = this.options.height;
        if (!isNumber(w)) {
            w = this.container.clientWidth;
        }
        if (!isNumber(h)) {
            h = this.container.clientHeight;
        }
        return { width: w, height: h };
    }
    getScale() {
        return matrixToScale(this.getMatrix());
    }
    scale(sx, sy = sx, ox = 0, oy = 0, options = {}) {
        sx = this.clampScale(sx); // eslint-disable-line
        sy = this.clampScale(sy); // eslint-disable-line
        if (ox || oy) {
            const ts = this.getTranslation();
            const tx = ts.tx - ox * (sx - 1);
            const ty = ts.ty - oy * (sy - 1);
            if (tx !== ts.tx || ty !== ts.ty) {
                this.translate(tx, ty);
            }
        }
        const matrix = this.getMatrix();
        matrix.a = sx;
        matrix.d = sy;
        this.setMatrix(matrix);
        this.graph.trigger('scale', Object.assign({ sx, sy, ox, oy }, options));
        return this;
    }
    clampScale(scale) {
        const range = this.graph.options.scaling;
        return clamp$1(scale, range.min || 0.01, range.max || 16);
    }
    getZoom() {
        return this.getScale().sx;
    }
    zoom(factor, options) {
        options = options || {}; // eslint-disable-line
        let sx = factor;
        let sy = factor;
        const scale = this.getScale();
        const clientSize = this.getComputedSize();
        let cx = clientSize.width / 2;
        let cy = clientSize.height / 2;
        if (!options.absolute) {
            sx += scale.sx;
            sy += scale.sy;
        }
        if (options.scaleGrid) {
            sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
            sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
        }
        if (options.maxScale) {
            sx = Math.min(options.maxScale, sx);
            sy = Math.min(options.maxScale, sy);
        }
        if (options.minScale) {
            sx = Math.max(options.minScale, sx);
            sy = Math.max(options.minScale, sy);
        }
        if (options.center) {
            cx = options.center.x;
            cy = options.center.y;
        }
        sx = this.clampScale(sx);
        sy = this.clampScale(sy);
        if (cx || cy) {
            const ts = this.getTranslation();
            const tx = cx - (cx - ts.tx) * (sx / scale.sx);
            const ty = cy - (cy - ts.ty) * (sy / scale.sy);
            if (tx !== ts.tx || ty !== ts.ty) {
                this.translate(tx, ty, { ui: options.ui });
            }
        }
        this.scale(sx, sy, 0, 0, { ui: options.ui });
        return this;
    }
    getRotation() {
        return matrixToRotation(this.getMatrix());
    }
    rotate(angle, cx, cy) {
        if (cx == null || cy == null) {
            const bbox = getBBox(this.graph.view.stage);
            cx = bbox.width / 2; // eslint-disable-line
            cy = bbox.height / 2; // eslint-disable-line
        }
        const ctm = this.getMatrix()
            .translate(cx, cy)
            .rotate(angle)
            .translate(-cx, -cy);
        this.setMatrix(ctm);
        return this;
    }
    getTranslation() {
        return matrixToTranslation(this.getMatrix());
    }
    translate(tx, ty, options = {}) {
        const matrix = this.getMatrix();
        matrix.e = tx || 0;
        matrix.f = ty || 0;
        this.setMatrix(matrix);
        const ts = this.getTranslation();
        this.options.x = ts.tx;
        this.options.y = ts.ty;
        this.graph.trigger('translate', Object.assign(Object.assign({}, ts), options));
        return this;
    }
    setOrigin(ox, oy) {
        return this.translate(ox || 0, oy || 0);
    }
    fitToContent(gridWidth, gridHeight, padding, options) {
        if (typeof gridWidth === 'object') {
            const opts = gridWidth;
            gridWidth = opts.gridWidth || 1; // eslint-disable-line
            gridHeight = opts.gridHeight || 1; // eslint-disable-line
            padding = opts.padding || 0; // eslint-disable-line
            options = opts; // eslint-disable-line
        }
        else {
            gridWidth = gridWidth || 1; // eslint-disable-line
            gridHeight = gridHeight || 1; // eslint-disable-line
            padding = padding || 0; // eslint-disable-line
            if (options == null) {
                options = {}; // eslint-disable-line
            }
        }
        const paddings = normalizeSides(padding);
        const border = options.border || 0;
        const contentArea = options.contentArea
            ? Rectangle.create(options.contentArea)
            : this.getContentArea(options);
        if (border > 0) {
            contentArea.inflate(border);
        }
        const scale = this.getScale();
        const translate = this.getTranslation();
        const sx = scale.sx;
        const sy = scale.sy;
        contentArea.x *= sx;
        contentArea.y *= sy;
        contentArea.width *= sx;
        contentArea.height *= sy;
        let width = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) *
            gridWidth;
        let height = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;
        let tx = 0;
        let ty = 0;
        if ((options.allowNewOrigin === 'negative' && contentArea.x < 0) ||
            (options.allowNewOrigin === 'positive' && contentArea.x >= 0) ||
            options.allowNewOrigin === 'any') {
            tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;
            tx += paddings.left;
            width += tx;
        }
        if ((options.allowNewOrigin === 'negative' && contentArea.y < 0) ||
            (options.allowNewOrigin === 'positive' && contentArea.y >= 0) ||
            options.allowNewOrigin === 'any') {
            ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;
            ty += paddings.top;
            height += ty;
        }
        width += paddings.right;
        height += paddings.bottom;
        // Make sure the resulting width and height are greater than minimum.
        width = Math.max(width, options.minWidth || 0);
        height = Math.max(height, options.minHeight || 0);
        // Make sure the resulting width and height are lesser than maximum.
        width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);
        height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);
        const size = this.getComputedSize();
        const sizeChanged = width !== size.width || height !== size.height;
        const originChanged = tx !== translate.tx || ty !== translate.ty;
        // Change the dimensions only if there is a size discrepency or an origin change
        if (originChanged) {
            this.translate(tx, ty);
        }
        if (sizeChanged) {
            this.resize(width, height);
        }
        return new Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);
    }
    scaleContentToFit(options = {}) {
        this.scaleContentToFitImpl(options);
    }
    scaleContentToFitImpl(options = {}, translate = true) {
        let contentBBox;
        let contentLocalOrigin;
        if (options.contentArea) {
            const contentArea = options.contentArea;
            contentBBox = this.graph.localToGraph(contentArea);
            contentLocalOrigin = Point.create(contentArea);
        }
        else {
            contentBBox = this.getContentBBox(options);
            contentLocalOrigin = this.graph.graphToLocal(contentBBox);
        }
        if (!contentBBox.width || !contentBBox.height) {
            return;
        }
        const padding = normalizeSides(options.padding);
        const minScale = options.minScale || 0;
        const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
        const minScaleX = options.minScaleX || minScale;
        const maxScaleX = options.maxScaleX || maxScale;
        const minScaleY = options.minScaleY || minScale;
        const maxScaleY = options.maxScaleY || maxScale;
        let fittingBox;
        if (options.viewportArea) {
            fittingBox = options.viewportArea;
        }
        else {
            const computedSize = this.getComputedSize();
            const currentTranslate = this.getTranslation();
            fittingBox = {
                x: currentTranslate.tx,
                y: currentTranslate.ty,
                width: computedSize.width,
                height: computedSize.height,
            };
        }
        fittingBox = Rectangle.create(fittingBox).moveAndExpand({
            x: padding.left,
            y: padding.top,
            width: -padding.left - padding.right,
            height: -padding.top - padding.bottom,
        });
        const currentScale = this.getScale();
        let newSX = (fittingBox.width / contentBBox.width) * currentScale.sx;
        let newSY = (fittingBox.height / contentBBox.height) * currentScale.sy;
        if (options.preserveAspectRatio !== false) {
            newSX = newSY = Math.min(newSX, newSY);
        }
        // snap scale to a grid
        const gridSize = options.scaleGrid;
        if (gridSize) {
            newSX = gridSize * Math.floor(newSX / gridSize);
            newSY = gridSize * Math.floor(newSY / gridSize);
        }
        // scale min/max boundaries
        newSX = clamp$1(newSX, minScaleX, maxScaleX);
        newSY = clamp$1(newSY, minScaleY, maxScaleY);
        this.scale(newSX, newSY);
        if (translate) {
            const origin = this.options;
            const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;
            const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;
            this.translate(newOX, newOY);
        }
    }
    getContentArea(options = {}) {
        if (options.useCellGeometry) {
            return this.model.getAllCellsBBox() || new Rectangle();
        }
        return getBBox(this.graph.view.stage);
    }
    getContentBBox(options = {}) {
        return this.graph.localToGraph(this.getContentArea(options));
    }
    getGraphArea() {
        const rect = Rectangle.fromSize(this.getComputedSize());
        return this.graph.graphToLocal(rect);
    }
    zoomToRect(rect, options = {}) {
        const area = Rectangle.create(rect);
        const graph = this.graph;
        options.contentArea = area;
        if (options.viewportArea == null) {
            options.viewportArea = {
                x: graph.options.x,
                y: graph.options.y,
                width: this.options.width,
                height: this.options.height,
            };
        }
        this.scaleContentToFitImpl(options, false);
        const center = area.getCenter();
        this.centerPoint(center.x, center.y);
        return this;
    }
    zoomToFit(options = {}) {
        return this.zoomToRect(this.getContentArea(options), options);
    }
    centerPoint(x, y) {
        const clientSize = this.getComputedSize();
        const scale = this.getScale();
        const ts = this.getTranslation();
        const cx = clientSize.width / 2;
        const cy = clientSize.height / 2;
        x = typeof x === 'number' ? x : cx; // eslint-disable-line
        y = typeof y === 'number' ? y : cy; // eslint-disable-line
        x = cx - x * scale.sx; // eslint-disable-line
        y = cy - y * scale.sy; // eslint-disable-line
        if (ts.tx !== x || ts.ty !== y) {
            this.translate(x, y);
        }
    }
    centerContent(options) {
        const rect = this.graph.getContentArea(options);
        const center = rect.getCenter();
        this.centerPoint(center.x, center.y);
    }
    centerCell(cell) {
        return this.positionCell(cell, 'center');
    }
    positionPoint(point, x, y) {
        const clientSize = this.getComputedSize();
        // eslint-disable-next-line
        x = normalizePercentage(x, Math.max(0, clientSize.width));
        if (x < 0) {
            x = clientSize.width + x; // eslint-disable-line
        }
        // eslint-disable-next-line
        y = normalizePercentage(y, Math.max(0, clientSize.height));
        if (y < 0) {
            y = clientSize.height + y; // eslint-disable-line
        }
        const ts = this.getTranslation();
        const scale = this.getScale();
        const dx = x - point.x * scale.sx;
        const dy = y - point.y * scale.sy;
        if (ts.tx !== dx || ts.ty !== dy) {
            this.translate(dx, dy);
        }
    }
    positionRect(rect, pos) {
        const bbox = Rectangle.create(rect);
        switch (pos) {
            case 'center':
                return this.positionPoint(bbox.getCenter(), '50%', '50%');
            case 'top':
                return this.positionPoint(bbox.getTopCenter(), '50%', 0);
            case 'top-right':
                return this.positionPoint(bbox.getTopRight(), '100%', 0);
            case 'right':
                return this.positionPoint(bbox.getRightMiddle(), '100%', '50%');
            case 'bottom-right':
                return this.positionPoint(bbox.getBottomRight(), '100%', '100%');
            case 'bottom':
                return this.positionPoint(bbox.getBottomCenter(), '50%', '100%');
            case 'bottom-left':
                return this.positionPoint(bbox.getBottomLeft(), 0, '100%');
            case 'left':
                return this.positionPoint(bbox.getLeftMiddle(), 0, '50%');
            case 'top-left':
                return this.positionPoint(bbox.getTopLeft(), 0, 0);
            default:
                return this;
        }
    }
    positionCell(cell, pos) {
        const bbox = cell.getBBox();
        return this.positionRect(bbox, pos);
    }
    positionContent(pos, options) {
        const rect = this.graph.getContentArea(options);
        return this.positionRect(rect, pos);
    }
    dispose() {
        this.widgets.forEach((widget) => widget.dispose());
        this.widgets.clear();
        this.stopListening();
    }
}
__decorate$b([
    TransformManager.dispose()
], TransformManager.prototype, "dispose", null);

var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SelectionManager extends Base {
    constructor() {
        super(...arguments);
        this.movedMap = new WeakMap();
        this.unselectMap = new WeakMap();
    }
    get widgetOptions() {
        return this.options.selecting;
    }
    get rubberbandDisabled() {
        return (this.widgetOptions.enabled !== true ||
            this.widgetOptions.rubberband !== true);
    }
    get disabled() {
        return this.widgetOptions.enabled !== true;
    }
    get length() {
        return this.widget.length;
    }
    get cells() {
        return this.widget.cells;
    }
    init() {
        this.widget = this.graph.hook.createSelection();
        this.startListening();
    }
    startListening() {
        this.graph.on('blank:mousedown', this.onBlankMouseDown, this);
        this.graph.on('blank:click', this.onBlankClick, this);
        this.graph.on('cell:mousemove', this.onCellMouseMove, this);
        this.graph.on('cell:mouseup', this.onCellMouseUp, this);
        this.widget.on('box:mousedown', this.onBoxMouseDown, this);
    }
    stopListening() {
        this.graph.off('blank:mousedown', this.onBlankMouseDown, this);
        this.graph.off('blank:click', this.onBlankClick, this);
        this.graph.off('cell:mousemove', this.onCellMouseMove, this);
        this.graph.off('cell:mouseup', this.onCellMouseUp, this);
        this.widget.off('box:mousedown', this.onBoxMouseDown, this);
    }
    onBlankMouseDown({ e }) {
        if (this.allowRubberband(e, true) ||
            (this.allowRubberband(e) &&
                !this.graph.scroller.allowPanning(e, true) &&
                !this.graph.panning.allowPanning(e, true))) {
            this.startRubberband(e);
        }
    }
    onBlankClick() {
        this.clean();
    }
    allowRubberband(e, strict) {
        return (!this.rubberbandDisabled &&
            ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict) &&
            this.graph.hook.allowRubberband(e));
    }
    allowMultipleSelection(e) {
        return (this.isMultiple() &&
            ModifierKey.isMatch(e, this.widgetOptions.multipleSelectionModifiers));
    }
    onCellMouseMove({ cell }) {
        this.movedMap.set(cell, true);
    }
    onCellMouseUp({ e, cell }) {
        const options = this.widgetOptions;
        let disabled = this.disabled;
        if (!disabled && this.movedMap.has(cell)) {
            disabled = options.selectCellOnMoved === false;
            if (!disabled) {
                disabled = options.selectNodeOnMoved === false && cell.isNode();
            }
            if (!disabled) {
                disabled = options.selectEdgeOnMoved === false && cell.isEdge();
            }
        }
        if (!disabled) {
            if (!this.allowMultipleSelection(e)) {
                this.reset(cell);
            }
            else if (this.unselectMap.has(cell)) {
                this.unselectMap.delete(cell);
            }
            else if (this.isSelected(cell)) {
                this.unselect(cell);
            }
            else {
                this.select(cell);
            }
        }
        this.movedMap.delete(cell);
    }
    onBoxMouseDown({ e, cell }) {
        if (!this.disabled) {
            if (this.allowMultipleSelection(e)) {
                this.unselect(cell);
                this.unselectMap.set(cell, true);
            }
        }
    }
    isEmpty() {
        return this.length <= 0;
    }
    isSelected(cell) {
        return this.widget.isSelected(cell);
    }
    getCells(cells) {
        return (Array.isArray(cells) ? cells : [cells])
            .map((cell) => typeof cell === 'string' ? this.graph.getCellById(cell) : cell)
            .filter((cell) => cell != null);
    }
    select(cells, options = {}) {
        const selected = this.getCells(cells);
        if (selected.length) {
            if (this.isMultiple()) {
                this.widget.select(selected, options);
            }
            else {
                this.reset(selected.slice(0, 1), options);
            }
        }
        return this;
    }
    unselect(cells, options = {}) {
        this.widget.unselect(this.getCells(cells), options);
        return this;
    }
    reset(cells, options = {}) {
        this.widget.reset(cells ? this.getCells(cells) : [], options);
        return this;
    }
    clean(options = {}) {
        this.widget.clean(options);
        return this;
    }
    enable() {
        if (this.disabled) {
            this.widgetOptions.enabled = true;
        }
        return this;
    }
    disable() {
        if (!this.disabled) {
            this.widgetOptions.enabled = false;
        }
        return this;
    }
    startRubberband(e) {
        if (!this.rubberbandDisabled) {
            this.widget.startSelecting(e);
        }
        return this;
    }
    enableRubberband() {
        if (this.rubberbandDisabled) {
            this.widgetOptions.rubberband = true;
            // if (
            //   ModifierKey.equals(
            //     this.graph.options.scroller.modifiers,
            //     this.graph.options.selecting.modifiers,
            //   )
            // ) {
            //   this.graph.scroller.disablePanning()
            // }
        }
        return this;
    }
    disableRubberband() {
        if (!this.rubberbandDisabled) {
            this.widgetOptions.rubberband = false;
        }
        return this;
    }
    isMultiple() {
        return this.widgetOptions.multiple !== false;
    }
    enableMultiple() {
        this.widgetOptions.multiple = true;
        return this;
    }
    disableMultiple() {
        this.widgetOptions.multiple = false;
        return this;
    }
    setModifiers(modifiers) {
        this.widgetOptions.modifiers = modifiers;
        return this;
    }
    setContent(content) {
        this.widget.setContent(content);
        return this;
    }
    setFilter(filter) {
        this.widget.setFilter(filter);
        return this;
    }
    dispose() {
        this.stopListening();
        this.widget.dispose();
    }
}
__decorate$a([
    Base.dispose()
], SelectionManager.prototype, "dispose", null);

var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class HistoryManager extends Basecoat {
    constructor(options) {
        super();
        this.batchCommands = null;
        this.batchLevel = 0;
        this.lastBatchIndex = -1;
        this.freezed = false;
        this.handlers = [];
        this.graph = options.graph;
        this.model = options.graph.model;
        this.options = Util.getOptions(options);
        this.validator = new HistoryManager.Validator({
            history: this,
            cancelInvalid: this.options.cancelInvalid,
        });
        this.clean();
        this.startListening();
    }
    get disabled() {
        return this.options.enabled !== true;
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
        }
    }
    undo(options = {}) {
        if (!this.disabled) {
            const cmd = this.undoStack.pop();
            if (cmd) {
                this.revertCommand(cmd, options);
                this.redoStack.push(cmd);
                this.notify('undo', cmd, options);
            }
        }
        return this;
    }
    redo(options = {}) {
        if (!this.disabled) {
            const cmd = this.redoStack.pop();
            if (cmd) {
                this.applyCommand(cmd, options);
                this.undoStack.push(cmd);
                this.notify('redo', cmd, options);
            }
        }
        return this;
    }
    /**
     * Same as `undo()` but does not store the undo-ed command to the
     * `redoStack`. Canceled command therefore cannot be redo-ed.
     */
    cancel(options = {}) {
        if (!this.disabled) {
            const cmd = this.undoStack.pop();
            if (cmd) {
                this.revertCommand(cmd, options);
                this.redoStack = [];
                this.notify('cancel', cmd, options);
            }
        }
        return this;
    }
    clean(options = {}) {
        this.undoStack = [];
        this.redoStack = [];
        this.notify('clean', null, options);
        return this;
    }
    canUndo() {
        return !this.disabled && this.undoStack.length > 0;
    }
    canRedo() {
        return !this.disabled && this.redoStack.length > 0;
    }
    validate(events, ...callbacks) {
        this.validator.validate(events, ...callbacks);
        return this;
    }
    dispose() {
        this.validator.dispose();
        this.clean();
        this.stopListening();
    }
    startListening() {
        this.model.on('batch:start', this.initBatchCommand, this);
        this.model.on('batch:stop', this.storeBatchCommand, this);
        if (this.options.eventNames) {
            this.options.eventNames.forEach((name, index) => {
                this.handlers[index] = this.addCommand.bind(this, name);
                this.model.on(name, this.handlers[index]);
            });
        }
        this.validator.on('invalid', (args) => this.trigger('invalid', args));
    }
    stopListening() {
        this.model.off('batch:start', this.initBatchCommand, this);
        this.model.off('batch:stop', this.storeBatchCommand, this);
        if (this.options.eventNames) {
            this.options.eventNames.forEach((name, index) => {
                this.model.off(name, this.handlers[index]);
            });
            this.handlers.length = 0;
        }
        this.validator.off('invalid');
    }
    createCommand(options) {
        return {
            batch: options ? options.batch : false,
            data: {},
        };
    }
    revertCommand(cmd, options) {
        this.freezed = true;
        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];
        for (let i = cmds.length - 1; i >= 0; i -= 1) {
            const cmd = cmds[i];
            const localOptions = Object.assign(Object.assign({}, options), pick(cmd.options, this.options.revertOptionsList || []));
            this.executeCommand(cmd, true, localOptions);
        }
        this.freezed = false;
    }
    applyCommand(cmd, options) {
        this.freezed = true;
        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];
        for (let i = 0; i < cmds.length; i += 1) {
            const cmd = cmds[i];
            const localOptions = Object.assign(Object.assign({}, options), pick(cmd.options, this.options.applyOptionsList || []));
            this.executeCommand(cmd, false, localOptions);
        }
        this.freezed = false;
    }
    executeCommand(cmd, revert, options) {
        const model = this.model;
        // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)
        const cell = model.getCell(cmd.data.id);
        const event = cmd.event;
        if ((Util.isAddEvent(event) && revert) ||
            (Util.isRemoveEvent(event) && !revert)) {
            cell && cell.remove(options);
        }
        else if ((Util.isAddEvent(event) && !revert) ||
            (Util.isRemoveEvent(event) && revert)) {
            const data = cmd.data;
            if (data.node) {
                model.addNode(data.props, options);
            }
            else if (data.edge) {
                model.addEdge(data.props, options);
            }
        }
        else if (Util.isChangeEvent(event)) {
            const data = cmd.data;
            const key = data.key;
            if (key && cell) {
                const value = revert ? data.prev[key] : data.next[key];
                cell.prop(key, value, options);
            }
        }
        else {
            const executeCommand = this.options.executeCommand;
            if (executeCommand) {
                call(executeCommand, this, cmd, revert, options);
            }
        }
    }
    addCommand(event, args) {
        if (this.freezed || this.disabled) {
            return;
        }
        const eventArgs = args;
        const options = eventArgs.options || {};
        if (options.dryrun) {
            return;
        }
        if ((Util.isAddEvent(event) && this.options.ignoreAdd) ||
            (Util.isRemoveEvent(event) && this.options.ignoreRemove) ||
            (Util.isChangeEvent(event) && this.options.ignoreChange)) {
            return;
        }
        // before
        // ------
        const before = this.options.beforeAddCommand;
        if (before != null &&
            call(before, this, event, args) === false) {
            return;
        }
        if (event === 'cell:change:*') {
            // eslint-disable-next-line
            event = `cell:change:${eventArgs.key}`;
        }
        const cell = eventArgs.cell;
        const isModelChange = Model.isModel(cell);
        let cmd;
        if (this.batchCommands) {
            // In most cases we are working with same object, doing
            // same action etc. translate an object piece by piece.
            cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)];
            // Check if we are start working with new object or performing different
            // action with it. Note, that command is uninitialized when lastCmdIndex
            // equals -1. In that case we are done, command we were looking for is
            // already set
            const diffId = (isModelChange && !cmd.modelChange) || cmd.data.id !== cell.id;
            const diffName = cmd.event !== event;
            if (this.lastBatchIndex >= 0 && (diffId || diffName)) {
                // Trying to find command first, which was performing same
                // action with the object as we are doing now with cell.
                const index = this.batchCommands.findIndex((cmd) => ((isModelChange && cmd.modelChange) || cmd.data.id === cell.id) &&
                    cmd.event === event);
                if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {
                    cmd = this.createCommand({ batch: true });
                }
                else {
                    cmd = this.batchCommands[index];
                    this.batchCommands.splice(index, 1);
                }
                this.batchCommands.push(cmd);
                this.lastBatchIndex = this.batchCommands.length - 1;
            }
        }
        else {
            cmd = this.createCommand({ batch: false });
        }
        // add & remove
        // ------------
        if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {
            const data = cmd.data;
            cmd.event = event;
            cmd.options = options;
            data.id = cell.id;
            data.props = cloneDeep(cell.toJSON());
            if (cell.isEdge()) {
                data.edge = true;
            }
            else if (cell.isNode()) {
                data.node = true;
            }
            return this.push(cmd, options);
        }
        // change:*
        // --------
        if (Util.isChangeEvent(event)) {
            const key = args.key;
            const data = cmd.data;
            if (!cmd.batch || !cmd.event) {
                // Do this only once. Set previous data and action (also
                // serves as a flag so that we don't repeat this branche).
                cmd.event = event;
                cmd.options = options;
                data.key = key;
                if (data.prev == null) {
                    data.prev = {};
                }
                data.prev[key] = clone(cell.previous(key));
                if (isModelChange) {
                    cmd.modelChange = true;
                }
                else {
                    data.id = cell.id;
                }
            }
            if (data.next == null) {
                data.next = {};
            }
            data.next[key] = clone(cell.prop(key));
            return this.push(cmd, options);
        }
        // others
        // ------
        const afterAddCommand = this.options.afterAddCommand;
        if (afterAddCommand) {
            call(afterAddCommand, this, event, args, cmd);
        }
        this.push(cmd, options);
    }
    /**
     * Gather multiple changes into a single command. These commands could
     * be reverted with single `undo()` call. From the moment the function
     * is called every change made on model is not stored into the undoStack.
     * Changes are temporarily kept until `storeBatchCommand()` is called.
     */
    // eslint-disable-next-line
    initBatchCommand(options) {
        if (this.freezed) {
            return;
        }
        if (this.batchCommands) {
            this.batchLevel += 1;
        }
        else {
            this.batchCommands = [this.createCommand({ batch: true })];
            this.batchLevel = 0;
            this.lastBatchIndex = -1;
        }
    }
    /**
     * Store changes temporarily kept in the undoStack. You have to call this
     * function as many times as `initBatchCommand()` been called.
     */
    storeBatchCommand(options) {
        if (this.freezed) {
            return;
        }
        if (this.batchCommands && this.batchLevel <= 0) {
            const cmds = this.filterBatchCommand(this.batchCommands);
            if (cmds.length > 0) {
                this.redoStack = [];
                this.undoStack.push(cmds);
                this.consolidateCommands();
                this.notify('add', cmds, options);
            }
            this.batchCommands = null;
            this.lastBatchIndex = -1;
            this.batchLevel = 0;
        }
        else if (this.batchCommands && this.batchLevel > 0) {
            this.batchLevel -= 1;
        }
    }
    filterBatchCommand(batchCommands) {
        let cmds = batchCommands.slice();
        const result = [];
        while (cmds.length > 0) {
            const cmd = cmds.shift();
            const evt = cmd.event;
            const id = cmd.data.id;
            if (evt != null && (id != null || cmd.modelChange)) {
                if (Util.isAddEvent(evt)) {
                    const index = cmds.findIndex((c) => Util.isRemoveEvent(c.event) && c.data.id === id);
                    if (index >= 0) {
                        cmds = cmds.filter((c, i) => index < i || c.data.id !== id);
                        continue;
                    }
                }
                else if (Util.isRemoveEvent(evt)) {
                    const index = cmds.findIndex((c) => Util.isAddEvent(c.event) && c.data.id === id);
                    if (index >= 0) {
                        cmds.splice(index, 1);
                        continue;
                    }
                }
                else if (Util.isChangeEvent(evt)) {
                    const data = cmd.data;
                    if (isEqual(data.prev, data.next)) {
                        continue;
                    }
                }
                else {
                    // pass
                }
                result.push(cmd);
            }
        }
        return result;
    }
    notify(event, cmd, options) {
        const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];
        this.emit(event, { cmds, options });
        this.emit('change', { cmds, options });
    }
    push(cmd, options) {
        this.redoStack = [];
        if (cmd.batch) {
            this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);
            this.emit('batch', { cmd, options });
        }
        else {
            this.undoStack.push(cmd);
            this.consolidateCommands();
            this.notify('add', cmd, options);
        }
    }
    /**
     * Conditionally combine multiple undo items into one.
     *
     * Currently this is only used combine a `cell:changed:position` event
     * followed by multiple `cell:change:parent` and `cell:change:children`
     * events, such that a "move + embed" action can be undone in one step.
     *
     * See https://github.com/antvis/X6/issues/2421
     *
     * This is an ugly WORKAROUND. It does not solve deficiencies in the batch
     * system itself.
     */
    consolidateCommands() {
        var _a;
        const lastCommandGroup = this.undoStack[this.undoStack.length - 1];
        const penultimateCommandGroup = this.undoStack[this.undoStack.length - 2];
        // We are looking for at least one cell:change:parent
        // and one cell:change:children
        if (!Array.isArray(lastCommandGroup)) {
            return;
        }
        const eventTypes = new Set(lastCommandGroup.map((cmd) => cmd.event));
        if (eventTypes.size !== 2 ||
            !eventTypes.has('cell:change:parent') ||
            !eventTypes.has('cell:change:children')) {
            return;
        }
        // We are looking for events from user interactions
        if (!lastCommandGroup.every((cmd) => { var _a; return cmd.batch && ((_a = cmd.options) === null || _a === void 0 ? void 0 : _a.ui); })) {
            return;
        }
        // We are looking for a command group with exactly one event, whose event
        // type is cell:change:position, and is from user interactions
        if (!Array.isArray(penultimateCommandGroup) ||
            penultimateCommandGroup.length !== 1) {
            return;
        }
        const maybePositionChange = penultimateCommandGroup[0];
        if (maybePositionChange.event !== 'cell:change:position' ||
            !((_a = maybePositionChange.options) === null || _a === void 0 ? void 0 : _a.ui)) {
            return;
        }
        // Actually consolidating the commands we get
        penultimateCommandGroup.push(...lastCommandGroup);
        this.undoStack.pop();
    }
}
__decorate$9([
    Basecoat.dispose()
], HistoryManager.prototype, "dispose", null);
(function (HistoryManager) {
    /**
     * Runs a set of callbacks to determine if a command is valid. This is
     * useful for checking if a certain action in your application does
     * lead to an invalid state of the graph.
     */
    class Validator extends Basecoat {
        constructor(options) {
            super();
            this.map = {};
            this.command = options.history;
            this.cancelInvalid = options.cancelInvalid !== false;
            this.command.on('add', this.onCommandAdded, this);
        }
        onCommandAdded({ cmds }) {
            return Array.isArray(cmds)
                ? cmds.every((cmd) => this.isValidCommand(cmd))
                : this.isValidCommand(cmds);
        }
        isValidCommand(cmd) {
            if (cmd.options && cmd.options.validation === false) {
                return true;
            }
            const callbacks = (cmd.event && this.map[cmd.event]) || [];
            let handoverErr = null;
            callbacks.forEach((routes) => {
                let i = 0;
                const rollup = (err) => {
                    const fn = routes[i];
                    i += 1;
                    try {
                        if (fn) {
                            fn(err, cmd, rollup);
                        }
                        else {
                            handoverErr = err;
                            return;
                        }
                    }
                    catch (err) {
                        rollup(err);
                    }
                };
                rollup(handoverErr);
            });
            if (handoverErr) {
                if (this.cancelInvalid) {
                    this.command.cancel();
                }
                this.emit('invalid', { err: handoverErr });
                return false;
            }
            return true;
        }
        validate(events, ...callbacks) {
            const evts = Array.isArray(events) ? events : events.split(/\s+/);
            callbacks.forEach((callback) => {
                if (typeof callback !== 'function') {
                    throw new Error(`${evts.join(' ')} requires callback functions.`);
                }
            });
            evts.forEach((event) => {
                if (this.map[event] == null) {
                    this.map[event] = [];
                }
                this.map[event].push(callbacks);
            });
            return this;
        }
        dispose() {
            this.command.off('add', this.onCommandAdded, this);
        }
    }
    __decorate$9([
        Basecoat.dispose()
    ], Validator.prototype, "dispose", null);
    HistoryManager.Validator = Validator;
})(HistoryManager || (HistoryManager = {}));
var Util;
(function (Util) {
    function isAddEvent(event) {
        return event === 'cell:added';
    }
    Util.isAddEvent = isAddEvent;
    function isRemoveEvent(event) {
        return event === 'cell:removed';
    }
    Util.isRemoveEvent = isRemoveEvent;
    function isChangeEvent(event) {
        return event != null && event.startsWith('cell:change:');
    }
    Util.isChangeEvent = isChangeEvent;
    function getOptions(options) {
        const { graph } = options, others = __rest$1(options, ["graph"]);
        const reservedNames = [
            'cell:added',
            'cell:removed',
            'cell:change:*',
        ];
        const batchEvents = [
            'batch:start',
            'batch:stop',
        ];
        const eventNames = options.eventNames
            ? options.eventNames.filter((event) => !(Util.isChangeEvent(event) ||
                reservedNames.includes(event) ||
                batchEvents.includes(event)))
            : reservedNames;
        return Object.assign(Object.assign({}, others), { eventNames, applyOptionsList: options.applyOptionsList || ['propertyPath'], revertOptionsList: options.revertOptionsList || ['propertyPath'] });
    }
    Util.getOptions = getOptions;
    function sortBatchCommands(cmds) {
        const results = [];
        for (let i = 0, ii = cmds.length; i < ii; i += 1) {
            const cmd = cmds[i];
            let index = null;
            if (Util.isAddEvent(cmd.event)) {
                const id = cmd.data.id;
                for (let j = 0; j < i; j += 1) {
                    if (cmds[j].data.id === id) {
                        index = j;
                        break;
                    }
                }
            }
            if (index !== null) {
                results.splice(index, 0, cmd);
            }
            else {
                results.push(cmd);
            }
        }
        return results;
    }
    Util.sortBatchCommands = sortBatchCommands;
})(Util || (Util = {}));

var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MiniMapManager extends Base {
    get widgetOptions() {
        return this.options.minimap;
    }
    init() {
        this.widget = this.graph.hook.createMiniMap();
    }
    dispose() {
        if (this.widget) {
            this.widget.dispose();
        }
    }
}
__decorate$8([
    Base.dispose()
], MiniMapManager.prototype, "dispose", null);

var mousetrap$1 = {exports: {}};

/*global define:false */
var mousetrap = mousetrap$1.exports;

var hasRequiredMousetrap;

function requireMousetrap () {
	if (hasRequiredMousetrap) return mousetrap$1.exports;
	hasRequiredMousetrap = 1;
	(function (module) {
		/**
		 * Copyright 2012-2017 Craig Campbell
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 * http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 * Mousetrap is a simple keyboard shortcut library for Javascript with
		 * no external dependencies
		 *
		 * @version 1.6.5
		 * @url craig.is/killing/mice
		 */
		(function(window, document, undefined$1) {

		    // Check if mousetrap is used inside browser, if not, return
		    if (!window) {
		        return;
		    }

		    /**
		     * mapping of special keycodes to their corresponding keys
		     *
		     * everything in this dictionary cannot use keypress events
		     * so it has to be here to map to the correct keycodes for
		     * keyup/keydown events
		     *
		     * @type {Object}
		     */
		    var _MAP = {
		        8: 'backspace',
		        9: 'tab',
		        13: 'enter',
		        16: 'shift',
		        17: 'ctrl',
		        18: 'alt',
		        20: 'capslock',
		        27: 'esc',
		        32: 'space',
		        33: 'pageup',
		        34: 'pagedown',
		        35: 'end',
		        36: 'home',
		        37: 'left',
		        38: 'up',
		        39: 'right',
		        40: 'down',
		        45: 'ins',
		        46: 'del',
		        91: 'meta',
		        93: 'meta',
		        224: 'meta'
		    };

		    /**
		     * mapping for special characters so they can support
		     *
		     * this dictionary is only used incase you want to bind a
		     * keyup or keydown event to one of these keys
		     *
		     * @type {Object}
		     */
		    var _KEYCODE_MAP = {
		        106: '*',
		        107: '+',
		        109: '-',
		        110: '.',
		        111 : '/',
		        186: ';',
		        187: '=',
		        188: ',',
		        189: '-',
		        190: '.',
		        191: '/',
		        192: '`',
		        219: '[',
		        220: '\\',
		        221: ']',
		        222: '\''
		    };

		    /**
		     * this is a mapping of keys that require shift on a US keypad
		     * back to the non shift equivelents
		     *
		     * this is so you can use keyup events with these keys
		     *
		     * note that this will only work reliably on US keyboards
		     *
		     * @type {Object}
		     */
		    var _SHIFT_MAP = {
		        '~': '`',
		        '!': '1',
		        '@': '2',
		        '#': '3',
		        '$': '4',
		        '%': '5',
		        '^': '6',
		        '&': '7',
		        '*': '8',
		        '(': '9',
		        ')': '0',
		        '_': '-',
		        '+': '=',
		        ':': ';',
		        '\"': '\'',
		        '<': ',',
		        '>': '.',
		        '?': '/',
		        '|': '\\'
		    };

		    /**
		     * this is a list of special strings you can use to map
		     * to modifier keys when you specify your keyboard shortcuts
		     *
		     * @type {Object}
		     */
		    var _SPECIAL_ALIASES = {
		        'option': 'alt',
		        'command': 'meta',
		        'return': 'enter',
		        'escape': 'esc',
		        'plus': '+',
		        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
		    };

		    /**
		     * variable to store the flipped version of _MAP from above
		     * needed to check if we should use keypress or not when no action
		     * is specified
		     *
		     * @type {Object|undefined}
		     */
		    var _REVERSE_MAP;

		    /**
		     * loop through the f keys, f1 to f19 and add them to the map
		     * programatically
		     */
		    for (var i = 1; i < 20; ++i) {
		        _MAP[111 + i] = 'f' + i;
		    }

		    /**
		     * loop through to map numbers on the numeric keypad
		     */
		    for (i = 0; i <= 9; ++i) {

		        // This needs to use a string cause otherwise since 0 is falsey
		        // mousetrap will never fire for numpad 0 pressed as part of a keydown
		        // event.
		        //
		        // @see https://github.com/ccampbell/mousetrap/pull/258
		        _MAP[i + 96] = i.toString();
		    }

		    /**
		     * cross browser add event method
		     *
		     * @param {Element|HTMLDocument} object
		     * @param {string} type
		     * @param {Function} callback
		     * @returns void
		     */
		    function _addEvent(object, type, callback) {
		        if (object.addEventListener) {
		            object.addEventListener(type, callback, false);
		            return;
		        }

		        object.attachEvent('on' + type, callback);
		    }

		    /**
		     * takes the event and returns the key character
		     *
		     * @param {Event} e
		     * @return {string}
		     */
		    function _characterFromEvent(e) {

		        // for keypress events we should return the character as is
		        if (e.type == 'keypress') {
		            var character = String.fromCharCode(e.which);

		            // if the shift key is not pressed then it is safe to assume
		            // that we want the character to be lowercase.  this means if
		            // you accidentally have caps lock on then your key bindings
		            // will continue to work
		            //
		            // the only side effect that might not be desired is if you
		            // bind something like 'A' cause you want to trigger an
		            // event when capital A is pressed caps lock will no longer
		            // trigger the event.  shift+a will though.
		            if (!e.shiftKey) {
		                character = character.toLowerCase();
		            }

		            return character;
		        }

		        // for non keypress events the special maps are needed
		        if (_MAP[e.which]) {
		            return _MAP[e.which];
		        }

		        if (_KEYCODE_MAP[e.which]) {
		            return _KEYCODE_MAP[e.which];
		        }

		        // if it is not in the special map

		        // with keydown and keyup events the character seems to always
		        // come in as an uppercase character whether you are pressing shift
		        // or not.  we should make sure it is always lowercase for comparisons
		        return String.fromCharCode(e.which).toLowerCase();
		    }

		    /**
		     * checks if two arrays are equal
		     *
		     * @param {Array} modifiers1
		     * @param {Array} modifiers2
		     * @returns {boolean}
		     */
		    function _modifiersMatch(modifiers1, modifiers2) {
		        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
		    }

		    /**
		     * takes a key event and figures out what the modifiers are
		     *
		     * @param {Event} e
		     * @returns {Array}
		     */
		    function _eventModifiers(e) {
		        var modifiers = [];

		        if (e.shiftKey) {
		            modifiers.push('shift');
		        }

		        if (e.altKey) {
		            modifiers.push('alt');
		        }

		        if (e.ctrlKey) {
		            modifiers.push('ctrl');
		        }

		        if (e.metaKey) {
		            modifiers.push('meta');
		        }

		        return modifiers;
		    }

		    /**
		     * prevents default for this event
		     *
		     * @param {Event} e
		     * @returns void
		     */
		    function _preventDefault(e) {
		        if (e.preventDefault) {
		            e.preventDefault();
		            return;
		        }

		        e.returnValue = false;
		    }

		    /**
		     * stops propogation for this event
		     *
		     * @param {Event} e
		     * @returns void
		     */
		    function _stopPropagation(e) {
		        if (e.stopPropagation) {
		            e.stopPropagation();
		            return;
		        }

		        e.cancelBubble = true;
		    }

		    /**
		     * determines if the keycode specified is a modifier key or not
		     *
		     * @param {string} key
		     * @returns {boolean}
		     */
		    function _isModifier(key) {
		        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
		    }

		    /**
		     * reverses the map lookup so that we can look for specific keys
		     * to see what can and can't use keypress
		     *
		     * @return {Object}
		     */
		    function _getReverseMap() {
		        if (!_REVERSE_MAP) {
		            _REVERSE_MAP = {};
		            for (var key in _MAP) {

		                // pull out the numeric keypad from here cause keypress should
		                // be able to detect the keys from the character
		                if (key > 95 && key < 112) {
		                    continue;
		                }

		                if (_MAP.hasOwnProperty(key)) {
		                    _REVERSE_MAP[_MAP[key]] = key;
		                }
		            }
		        }
		        return _REVERSE_MAP;
		    }

		    /**
		     * picks the best action based on the key combination
		     *
		     * @param {string} key - character for key
		     * @param {Array} modifiers
		     * @param {string=} action passed in
		     */
		    function _pickBestAction(key, modifiers, action) {

		        // if no action was picked in we should try to pick the one
		        // that we think would work best for this key
		        if (!action) {
		            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
		        }

		        // modifier keys don't work as expected with keypress,
		        // switch to keydown
		        if (action == 'keypress' && modifiers.length) {
		            action = 'keydown';
		        }

		        return action;
		    }

		    /**
		     * Converts from a string key combination to an array
		     *
		     * @param  {string} combination like "command+shift+l"
		     * @return {Array}
		     */
		    function _keysFromString(combination) {
		        if (combination === '+') {
		            return ['+'];
		        }

		        combination = combination.replace(/\+{2}/g, '+plus');
		        return combination.split('+');
		    }

		    /**
		     * Gets info for a specific key combination
		     *
		     * @param  {string} combination key combination ("command+s" or "a" or "*")
		     * @param  {string=} action
		     * @returns {Object}
		     */
		    function _getKeyInfo(combination, action) {
		        var keys;
		        var key;
		        var i;
		        var modifiers = [];

		        // take the keys from this pattern and figure out what the actual
		        // pattern is all about
		        keys = _keysFromString(combination);

		        for (i = 0; i < keys.length; ++i) {
		            key = keys[i];

		            // normalize key names
		            if (_SPECIAL_ALIASES[key]) {
		                key = _SPECIAL_ALIASES[key];
		            }

		            // if this is not a keypress event then we should
		            // be smart about using shift keys
		            // this will only work for US keyboards however
		            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
		                key = _SHIFT_MAP[key];
		                modifiers.push('shift');
		            }

		            // if this key is a modifier then add it to the list of modifiers
		            if (_isModifier(key)) {
		                modifiers.push(key);
		            }
		        }

		        // depending on what the key combination is
		        // we will try to pick the best event for it
		        action = _pickBestAction(key, modifiers, action);

		        return {
		            key: key,
		            modifiers: modifiers,
		            action: action
		        };
		    }

		    function _belongsTo(element, ancestor) {
		        if (element === null || element === document) {
		            return false;
		        }

		        if (element === ancestor) {
		            return true;
		        }

		        return _belongsTo(element.parentNode, ancestor);
		    }

		    function Mousetrap(targetElement) {
		        var self = this;

		        targetElement = targetElement || document;

		        if (!(self instanceof Mousetrap)) {
		            return new Mousetrap(targetElement);
		        }

		        /**
		         * element to attach key events to
		         *
		         * @type {Element}
		         */
		        self.target = targetElement;

		        /**
		         * a list of all the callbacks setup via Mousetrap.bind()
		         *
		         * @type {Object}
		         */
		        self._callbacks = {};

		        /**
		         * direct map of string combinations to callbacks used for trigger()
		         *
		         * @type {Object}
		         */
		        self._directMap = {};

		        /**
		         * keeps track of what level each sequence is at since multiple
		         * sequences can start out with the same sequence
		         *
		         * @type {Object}
		         */
		        var _sequenceLevels = {};

		        /**
		         * variable to store the setTimeout call
		         *
		         * @type {null|number}
		         */
		        var _resetTimer;

		        /**
		         * temporary state where we will ignore the next keyup
		         *
		         * @type {boolean|string}
		         */
		        var _ignoreNextKeyup = false;

		        /**
		         * temporary state where we will ignore the next keypress
		         *
		         * @type {boolean}
		         */
		        var _ignoreNextKeypress = false;

		        /**
		         * are we currently inside of a sequence?
		         * type of action ("keyup" or "keydown" or "keypress") or false
		         *
		         * @type {boolean|string}
		         */
		        var _nextExpectedAction = false;

		        /**
		         * resets all sequence counters except for the ones passed in
		         *
		         * @param {Object} doNotReset
		         * @returns void
		         */
		        function _resetSequences(doNotReset) {
		            doNotReset = doNotReset || {};

		            var activeSequences = false,
		                key;

		            for (key in _sequenceLevels) {
		                if (doNotReset[key]) {
		                    activeSequences = true;
		                    continue;
		                }
		                _sequenceLevels[key] = 0;
		            }

		            if (!activeSequences) {
		                _nextExpectedAction = false;
		            }
		        }

		        /**
		         * finds all callbacks that match based on the keycode, modifiers,
		         * and action
		         *
		         * @param {string} character
		         * @param {Array} modifiers
		         * @param {Event|Object} e
		         * @param {string=} sequenceName - name of the sequence we are looking for
		         * @param {string=} combination
		         * @param {number=} level
		         * @returns {Array}
		         */
		        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
		            var i;
		            var callback;
		            var matches = [];
		            var action = e.type;

		            // if there are no events related to this keycode
		            if (!self._callbacks[character]) {
		                return [];
		            }

		            // if a modifier key is coming up on its own we should allow it
		            if (action == 'keyup' && _isModifier(character)) {
		                modifiers = [character];
		            }

		            // loop through all callbacks for the key that was pressed
		            // and see if any of them match
		            for (i = 0; i < self._callbacks[character].length; ++i) {
		                callback = self._callbacks[character][i];

		                // if a sequence name is not specified, but this is a sequence at
		                // the wrong level then move onto the next match
		                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
		                    continue;
		                }

		                // if the action we are looking for doesn't match the action we got
		                // then we should keep going
		                if (action != callback.action) {
		                    continue;
		                }

		                // if this is a keypress event and the meta key and control key
		                // are not pressed that means that we need to only look at the
		                // character, otherwise check the modifiers as well
		                //
		                // chrome will not fire a keypress if meta or control is down
		                // safari will fire a keypress if meta or meta+shift is down
		                // firefox will fire a keypress if meta or control is down
		                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

		                    // when you bind a combination or sequence a second time it
		                    // should overwrite the first one.  if a sequenceName or
		                    // combination is specified in this call it does just that
		                    //
		                    // @todo make deleting its own method?
		                    var deleteCombo = !sequenceName && callback.combo == combination;
		                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
		                    if (deleteCombo || deleteSequence) {
		                        self._callbacks[character].splice(i, 1);
		                    }

		                    matches.push(callback);
		                }
		            }

		            return matches;
		        }

		        /**
		         * actually calls the callback function
		         *
		         * if your callback function returns false this will use the jquery
		         * convention - prevent default and stop propogation on the event
		         *
		         * @param {Function} callback
		         * @param {Event} e
		         * @returns void
		         */
		        function _fireCallback(callback, e, combo, sequence) {

		            // if this event should not happen stop here
		            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
		                return;
		            }

		            if (callback(e, combo) === false) {
		                _preventDefault(e);
		                _stopPropagation(e);
		            }
		        }

		        /**
		         * handles a character key event
		         *
		         * @param {string} character
		         * @param {Array} modifiers
		         * @param {Event} e
		         * @returns void
		         */
		        self._handleKey = function(character, modifiers, e) {
		            var callbacks = _getMatches(character, modifiers, e);
		            var i;
		            var doNotReset = {};
		            var maxLevel = 0;
		            var processedSequenceCallback = false;

		            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
		            for (i = 0; i < callbacks.length; ++i) {
		                if (callbacks[i].seq) {
		                    maxLevel = Math.max(maxLevel, callbacks[i].level);
		                }
		            }

		            // loop through matching callbacks for this key event
		            for (i = 0; i < callbacks.length; ++i) {

		                // fire for all sequence callbacks
		                // this is because if for example you have multiple sequences
		                // bound such as "g i" and "g t" they both need to fire the
		                // callback for matching g cause otherwise you can only ever
		                // match the first one
		                if (callbacks[i].seq) {

		                    // only fire callbacks for the maxLevel to prevent
		                    // subsequences from also firing
		                    //
		                    // for example 'a option b' should not cause 'option b' to fire
		                    // even though 'option b' is part of the other sequence
		                    //
		                    // any sequences that do not match here will be discarded
		                    // below by the _resetSequences call
		                    if (callbacks[i].level != maxLevel) {
		                        continue;
		                    }

		                    processedSequenceCallback = true;

		                    // keep a list of which sequences were matches for later
		                    doNotReset[callbacks[i].seq] = 1;
		                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
		                    continue;
		                }

		                // if there were no sequence matches but we are still here
		                // that means this is a regular match so we should fire that
		                if (!processedSequenceCallback) {
		                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
		                }
		            }

		            // if the key you pressed matches the type of sequence without
		            // being a modifier (ie "keyup" or "keypress") then we should
		            // reset all sequences that were not matched by this event
		            //
		            // this is so, for example, if you have the sequence "h a t" and you
		            // type "h e a r t" it does not match.  in this case the "e" will
		            // cause the sequence to reset
		            //
		            // modifier keys are ignored because you can have a sequence
		            // that contains modifiers such as "enter ctrl+space" and in most
		            // cases the modifier key will be pressed before the next key
		            //
		            // also if you have a sequence such as "ctrl+b a" then pressing the
		            // "b" key will trigger a "keypress" and a "keydown"
		            //
		            // the "keydown" is expected when there is a modifier, but the
		            // "keypress" ends up matching the _nextExpectedAction since it occurs
		            // after and that causes the sequence to reset
		            //
		            // we ignore keypresses in a sequence that directly follow a keydown
		            // for the same character
		            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
		            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
		                _resetSequences(doNotReset);
		            }

		            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
		        };

		        /**
		         * handles a keydown event
		         *
		         * @param {Event} e
		         * @returns void
		         */
		        function _handleKeyEvent(e) {

		            // normalize e.which for key events
		            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
		            if (typeof e.which !== 'number') {
		                e.which = e.keyCode;
		            }

		            var character = _characterFromEvent(e);

		            // no character found then stop
		            if (!character) {
		                return;
		            }

		            // need to use === for the character check because the character can be 0
		            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
		                _ignoreNextKeyup = false;
		                return;
		            }

		            self.handleKey(character, _eventModifiers(e), e);
		        }

		        /**
		         * called to set a 1 second timeout on the specified sequence
		         *
		         * this is so after each key press in the sequence you have 1 second
		         * to press the next key before you have to start over
		         *
		         * @returns void
		         */
		        function _resetSequenceTimer() {
		            clearTimeout(_resetTimer);
		            _resetTimer = setTimeout(_resetSequences, 1000);
		        }

		        /**
		         * binds a key sequence to an event
		         *
		         * @param {string} combo - combo specified in bind call
		         * @param {Array} keys
		         * @param {Function} callback
		         * @param {string=} action
		         * @returns void
		         */
		        function _bindSequence(combo, keys, callback, action) {

		            // start off by adding a sequence level record for this combination
		            // and setting the level to 0
		            _sequenceLevels[combo] = 0;

		            /**
		             * callback to increase the sequence level for this sequence and reset
		             * all other sequences that were active
		             *
		             * @param {string} nextAction
		             * @returns {Function}
		             */
		            function _increaseSequence(nextAction) {
		                return function() {
		                    _nextExpectedAction = nextAction;
		                    ++_sequenceLevels[combo];
		                    _resetSequenceTimer();
		                };
		            }

		            /**
		             * wraps the specified callback inside of another function in order
		             * to reset all sequence counters as soon as this sequence is done
		             *
		             * @param {Event} e
		             * @returns void
		             */
		            function _callbackAndReset(e) {
		                _fireCallback(callback, e, combo);

		                // we should ignore the next key up if the action is key down
		                // or keypress.  this is so if you finish a sequence and
		                // release the key the final key will not trigger a keyup
		                if (action !== 'keyup') {
		                    _ignoreNextKeyup = _characterFromEvent(e);
		                }

		                // weird race condition if a sequence ends with the key
		                // another sequence begins with
		                setTimeout(_resetSequences, 10);
		            }

		            // loop through keys one at a time and bind the appropriate callback
		            // function.  for any key leading up to the final one it should
		            // increase the sequence. after the final, it should reset all sequences
		            //
		            // if an action is specified in the original bind call then that will
		            // be used throughout.  otherwise we will pass the action that the
		            // next key in the sequence should match.  this allows a sequence
		            // to mix and match keypress and keydown events depending on which
		            // ones are better suited to the key provided
		            for (var i = 0; i < keys.length; ++i) {
		                var isFinal = i + 1 === keys.length;
		                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
		                _bindSingle(keys[i], wrappedCallback, action, combo, i);
		            }
		        }

		        /**
		         * binds a single keyboard combination
		         *
		         * @param {string} combination
		         * @param {Function} callback
		         * @param {string=} action
		         * @param {string=} sequenceName - name of sequence if part of sequence
		         * @param {number=} level - what part of the sequence the command is
		         * @returns void
		         */
		        function _bindSingle(combination, callback, action, sequenceName, level) {

		            // store a direct mapped reference for use with Mousetrap.trigger
		            self._directMap[combination + ':' + action] = callback;

		            // make sure multiple spaces in a row become a single space
		            combination = combination.replace(/\s+/g, ' ');

		            var sequence = combination.split(' ');
		            var info;

		            // if this pattern is a sequence of keys then run through this method
		            // to reprocess each pattern one key at a time
		            if (sequence.length > 1) {
		                _bindSequence(combination, sequence, callback, action);
		                return;
		            }

		            info = _getKeyInfo(combination, action);

		            // make sure to initialize array if this is the first time
		            // a callback is added for this key
		            self._callbacks[info.key] = self._callbacks[info.key] || [];

		            // remove an existing match if there is one
		            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

		            // add this call back to the array
		            // if it is a sequence put it at the beginning
		            // if not put it at the end
		            //
		            // this is important because the way these are processed expects
		            // the sequence ones to come first
		            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
		                callback: callback,
		                modifiers: info.modifiers,
		                action: info.action,
		                seq: sequenceName,
		                level: level,
		                combo: combination
		            });
		        }

		        /**
		         * binds multiple combinations to the same callback
		         *
		         * @param {Array} combinations
		         * @param {Function} callback
		         * @param {string|undefined} action
		         * @returns void
		         */
		        self._bindMultiple = function(combinations, callback, action) {
		            for (var i = 0; i < combinations.length; ++i) {
		                _bindSingle(combinations[i], callback, action);
		            }
		        };

		        // start!
		        _addEvent(targetElement, 'keypress', _handleKeyEvent);
		        _addEvent(targetElement, 'keydown', _handleKeyEvent);
		        _addEvent(targetElement, 'keyup', _handleKeyEvent);
		    }

		    /**
		     * binds an event to mousetrap
		     *
		     * can be a single key, a combination of keys separated with +,
		     * an array of keys, or a sequence of keys separated by spaces
		     *
		     * be sure to list the modifier keys first to make sure that the
		     * correct key ends up getting bound (the last key in the pattern)
		     *
		     * @param {string|Array} keys
		     * @param {Function} callback
		     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
		     * @returns void
		     */
		    Mousetrap.prototype.bind = function(keys, callback, action) {
		        var self = this;
		        keys = keys instanceof Array ? keys : [keys];
		        self._bindMultiple.call(self, keys, callback, action);
		        return self;
		    };

		    /**
		     * unbinds an event to mousetrap
		     *
		     * the unbinding sets the callback function of the specified key combo
		     * to an empty function and deletes the corresponding key in the
		     * _directMap dict.
		     *
		     * TODO: actually remove this from the _callbacks dictionary instead
		     * of binding an empty function
		     *
		     * the keycombo+action has to be exactly the same as
		     * it was defined in the bind method
		     *
		     * @param {string|Array} keys
		     * @param {string} action
		     * @returns void
		     */
		    Mousetrap.prototype.unbind = function(keys, action) {
		        var self = this;
		        return self.bind.call(self, keys, function() {}, action);
		    };

		    /**
		     * triggers an event that has already been bound
		     *
		     * @param {string} keys
		     * @param {string=} action
		     * @returns void
		     */
		    Mousetrap.prototype.trigger = function(keys, action) {
		        var self = this;
		        if (self._directMap[keys + ':' + action]) {
		            self._directMap[keys + ':' + action]({}, keys);
		        }
		        return self;
		    };

		    /**
		     * resets the library back to its initial state.  this is useful
		     * if you want to clear out the current keyboard shortcuts and bind
		     * new ones - for example if you switch to another page
		     *
		     * @returns void
		     */
		    Mousetrap.prototype.reset = function() {
		        var self = this;
		        self._callbacks = {};
		        self._directMap = {};
		        return self;
		    };

		    /**
		     * should we stop this event before firing off callbacks
		     *
		     * @param {Event} e
		     * @param {Element} element
		     * @return {boolean}
		     */
		    Mousetrap.prototype.stopCallback = function(e, element) {
		        var self = this;

		        // if the element has the class "mousetrap" then no need to stop
		        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
		            return false;
		        }

		        if (_belongsTo(element, self.target)) {
		            return false;
		        }

		        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
		        // not the initial event target in the shadow tree. Note that not all events cross the
		        // shadow boundary.
		        // For shadow trees with `mode: 'open'`, the initial event target is the first element in
		        // the events composed path. For shadow trees with `mode: 'closed'`, the initial event
		        // target cannot be obtained.
		        if ('composedPath' in e && typeof e.composedPath === 'function') {
		            // For open shadow trees, update `element` so that the following check works.
		            var initialEventTarget = e.composedPath()[0];
		            if (initialEventTarget !== e.target) {
		                element = initialEventTarget;
		            }
		        }

		        // stop for input, select, and textarea
		        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
		    };

		    /**
		     * exposes _handleKey publicly so it can be overwritten by extensions
		     */
		    Mousetrap.prototype.handleKey = function() {
		        var self = this;
		        return self._handleKey.apply(self, arguments);
		    };

		    /**
		     * allow custom key mappings
		     */
		    Mousetrap.addKeycodes = function(object) {
		        for (var key in object) {
		            if (object.hasOwnProperty(key)) {
		                _MAP[key] = object[key];
		            }
		        }
		        _REVERSE_MAP = null;
		    };

		    /**
		     * Init the global mousetrap functions
		     *
		     * This method is needed to allow the global mousetrap functions to work
		     * now that mousetrap is a constructor function.
		     */
		    Mousetrap.init = function() {
		        var documentMousetrap = Mousetrap(document);
		        for (var method in documentMousetrap) {
		            if (method.charAt(0) !== '_') {
		                Mousetrap[method] = (function(method) {
		                    return function() {
		                        return documentMousetrap[method].apply(documentMousetrap, arguments);
		                    };
		                } (method));
		            }
		        }
		    };

		    Mousetrap.init();

		    // expose mousetrap to the global object
		    window.Mousetrap = Mousetrap;

		    // expose as a common js module
		    if ('object' !== 'undefined' && module.exports) {
		        module.exports = Mousetrap;
		    }

		    // expose mousetrap as an AMD module
		    if (typeof undefined$1 === 'function' && undefined$1.amd) {
		        undefined$1(function() {
		            return Mousetrap;
		        });
		    }
		}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null); 
	} (mousetrap$1));
	return mousetrap$1.exports;
}

var mousetrapExports = requireMousetrap();
var Mousetrap = /*@__PURE__*/getDefaultExportFromCjs(mousetrapExports);

var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Keyboard extends Disposable {
    constructor(options) {
        super();
        this.options = options;
        const scroller = this.graph.scroller.widget;
        this.container = scroller ? scroller.container : this.graph.container;
        if (options.global) {
            this.target = document;
        }
        else {
            this.target = this.container;
            if (!this.disabled) {
                // ensure the container focusable
                this.target.setAttribute('tabindex', '-1');
            }
            // change to mouseup eventprevent page stalling caused by focus
            this.graph.on('cell:mouseup', this.focus, this);
            this.graph.on('blank:mouseup', this.focus, this);
        }
        this.mousetrap = Keyboard.createMousetrap(this);
    }
    get graph() {
        return this.options.graph;
    }
    get disabled() {
        return this.options.enabled !== true;
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
            this.graph.options.keyboard.enabled = true;
            if (this.target instanceof HTMLElement) {
                this.target.setAttribute('tabindex', '-1');
            }
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
            this.graph.options.keyboard.enabled = false;
            if (this.target instanceof HTMLElement) {
                this.target.removeAttribute('tabindex');
            }
        }
    }
    on(keys, callback, action) {
        this.mousetrap.bind(this.getKeys(keys), callback, action);
    }
    off(keys, action) {
        this.mousetrap.unbind(this.getKeys(keys), action);
    }
    focus(e) {
        const isInputEvent = this.isInputEvent(e.e);
        if (isInputEvent) {
            return;
        }
        const target = this.target;
        target.focus({
            preventScroll: true,
        });
    }
    getKeys(keys) {
        return (Array.isArray(keys) ? keys : [keys]).map((key) => this.formatkey(key));
    }
    formatkey(key) {
        const formated = key
            .toLowerCase()
            .replace(/\s/g, '')
            .replace('delete', 'del')
            .replace('cmd', 'command');
        const formatFn = this.options.format;
        if (formatFn) {
            return call(formatFn, this.graph, formated);
        }
        return formated;
    }
    isGraphEvent(e) {
        const target = (e.srcElement || e.target);
        const currentTarget = e.currentTarget;
        if (target) {
            if (target === this.target ||
                currentTarget === this.target ||
                target === document.body) {
                return true;
            }
            return contains(this.container, target);
        }
        return false;
    }
    isInputEvent(e) {
        var _a;
        const target = e.target;
        const tagName = (_a = target === null || target === void 0 ? void 0 : target.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        return ['input', 'textarea'].includes(tagName);
    }
    isEnabledForEvent(e) {
        const allowed = !this.disabled && this.isGraphEvent(e);
        const isInputEvent = this.isInputEvent(e);
        if (allowed) {
            const code = e.keyCode || e.which;
            if (isInputEvent && (code === 8 || code === 46)) {
                return false;
            }
            if (this.options.guard) {
                return call(this.options.guard, this.graph, e);
            }
        }
        return allowed;
    }
    dispose() {
        this.mousetrap.reset();
    }
}
__decorate$7([
    Disposable.dispose()
], Keyboard.prototype, "dispose", null);
(function (Keyboard) {
    function createMousetrap(keyboard) {
        const mousetrap = new Mousetrap(keyboard.target);
        const stopCallback = mousetrap.stopCallback;
        mousetrap.stopCallback = (e, elem, combo) => {
            if (keyboard.isEnabledForEvent(e)) {
                if (stopCallback) {
                    return stopCallback.call(mousetrap, e, elem, combo);
                }
                return false;
            }
            return true;
        };
        return mousetrap;
    }
    Keyboard.createMousetrap = createMousetrap;
})(Keyboard || (Keyboard = {}));

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MouseWheel extends Disposable {
    constructor(options) {
        super();
        this.options = options;
        this.cumulatedFactor = 1;
        const scroller = this.graph.scroller.widget;
        this.container = scroller ? scroller.container : this.graph.container;
        this.target = this.options.global ? document : this.container;
        this.mousewheelHandle = new MouseWheelHandle(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
        if (this.options.enabled) {
            this.enable(true);
        }
    }
    get graph() {
        return this.options.graph;
    }
    get disabled() {
        return this.options.enabled !== true;
    }
    enable(force) {
        if (this.disabled || force) {
            this.options.enabled = true;
            this.graph.options.mousewheel.enabled = true;
            this.mousewheelHandle.enable();
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
            this.graph.options.mousewheel.enabled = false;
            this.mousewheelHandle.disable();
        }
    }
    allowMouseWheel(evt) {
        const e = (evt.originalEvent || evt);
        const guard = this.options.guard;
        return ((guard == null || guard.call(this.graph, e)) &&
            ModifierKey.isMatch(e, this.options.modifiers));
    }
    onMouseWheel(evt) {
        const e = (evt.originalEvent || evt);
        const guard = this.options.guard;
        if ((guard == null || guard.call(this.graph, e)) &&
            ModifierKey.isMatch(e, this.options.modifiers)) {
            const factor = this.options.factor || 1.2;
            if (this.currentScale == null) {
                this.startPos = { x: evt.clientX, y: evt.clientY };
                this.currentScale = this.graph.scroller.widget
                    ? this.graph.scroller.widget.zoom()
                    : this.graph.transform.getScale().sx;
            }
            const delta = evt.deltaY;
            if (delta < 0) {
                // zoomin
                // ------
                // Switches to 1% zoom steps below 15%
                if (this.currentScale < 0.15) {
                    this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale;
                }
                else {
                    // Uses to 5% zoom steps for better grid rendering in
                    // webkit and to avoid rounding errors for zoom steps
                    this.cumulatedFactor =
                        Math.round(this.currentScale * factor * 20) / 20 / this.currentScale;
                }
            }
            else {
                // zoomout
                // -------
                // Switches to 1% zoom steps below 15%
                if (this.currentScale <= 0.15) {
                    this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale;
                }
                else {
                    // Uses to 5% zoom steps for better grid rendering in
                    // webkit and to avoid rounding errors for zoom steps
                    this.cumulatedFactor =
                        Math.round(this.currentScale * (1 / factor) * 20) /
                            20 /
                            this.currentScale;
                }
            }
            this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) /
                this.currentScale);
            const scroller = this.graph.scroller.widget;
            const currentScale = this.currentScale;
            let targetScale = this.graph.transform.clampScale(currentScale * this.cumulatedFactor);
            const minScale = this.options.minScale || Number.MIN_SAFE_INTEGER;
            const maxScale = this.options.maxScale || Number.MAX_SAFE_INTEGER;
            targetScale = clamp$1(targetScale, minScale, maxScale);
            if (targetScale !== currentScale) {
                if (scroller) {
                    if (this.options.zoomAtMousePosition) {
                        const origin = this.graph.coord.clientToLocalPoint(this.startPos);
                        scroller.zoom(targetScale, {
                            absolute: true,
                            center: origin.clone(),
                        });
                    }
                    else {
                        scroller.zoom(targetScale, { absolute: true });
                    }
                }
                else {
                    if (this.options.zoomAtMousePosition) {
                        const origin = this.graph.coord.clientToGraphPoint(this.startPos);
                        this.graph.transform.zoom(targetScale, {
                            absolute: true,
                            center: origin.clone(),
                            ui: true,
                        });
                    }
                    else {
                        this.graph.transform.zoom(targetScale, { absolute: true, ui: true });
                    }
                }
            }
            this.currentScale = null;
            this.cumulatedFactor = 1;
        }
    }
    dispose() {
        this.disable();
    }
}
__decorate$6([
    Disposable.dispose()
], MouseWheel.prototype, "dispose", null);

var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PrintManager extends Base {
    show(options = {}) {
        const localOptions = Object.assign(Object.assign({}, PrintManager.defaultOptions), options);
        const $pages = this.createPrintPages(localOptions);
        localOptions.ready($pages, ($pages) => this.showPrintWindow($pages, localOptions), {
            sheetSize: this.getSheetSize(localOptions),
        });
    }
    get className() {
        return this.view.prefixClassName('graph-print');
    }
    showPrintWindow($pages, options) {
        if ($pages) {
            const $body = JQuery(document.body);
            const $container = JQuery(this.view.container);
            const bodyClassName = this.view.prefixClassName('graph-printing');
            $body.addClass(bodyClassName);
            const $detached = $container.children().detach();
            $pages.forEach(($page) => {
                $page
                    .removeClass(`${this.className}-preview`)
                    .addClass(`${this.className}-ready`)
                    .appendTo($body);
            });
            let ret = false;
            const cb = () => {
                if (!ret) {
                    ret = true;
                    $body.removeClass(bodyClassName);
                    $pages.forEach(($page) => $page.remove());
                    $container.append($detached);
                    JQuery(`#${this.styleSheetId}`).remove();
                    this.graph.trigger('after:print', options);
                    JQuery(window).off('afterprint', cb);
                }
            };
            JQuery(window).one('afterprint', cb);
            setTimeout(cb, 200);
            window.print();
        }
    }
    createPrintPage(pageArea, options) {
        this.graph.trigger('before:print', options);
        const $page = JQuery('<div/>').addClass(this.className);
        const $wrap = JQuery('<div/>')
            .addClass(this.view.prefixClassName('graph-print-inner'))
            .css('position', 'relative');
        if (options.size) {
            $page.addClass(`${this.className}-size-${options.size}`);
        }
        const vSVG = Vector.create(this.view.svg).clone();
        const vStage = vSVG.findOne(`.${this.view.prefixClassName('graph-svg-stage')}`);
        $wrap.append(vSVG.node);
        const sheetSize = this.getSheetSize(options);
        const graphArea = this.graph.transform.getGraphArea();
        const s = this.graph.transform.getScale();
        const ts = this.graph.translate();
        const matrix = createSVGMatrix().translate(ts.tx / s.sx, ts.ty / s.sy);
        const info = this.getPageInfo(graphArea, pageArea, sheetSize);
        const scale = info.scale;
        const bbox = info.bbox;
        $wrap.css({
            left: 0,
            top: 0,
        });
        vSVG.attr({
            width: bbox.width * scale,
            height: bbox.height * scale,
            style: 'position:relative',
            viewBox: [bbox.x, bbox.y, bbox.width, bbox.height].join(' '),
        });
        vStage.attr('transform', matrixToTransformString(matrix));
        $page.append($wrap);
        $page.addClass(`${this.className}-preview`);
        return {
            $page,
            sheetSize,
        };
    }
    createPrintPages(options) {
        let ret;
        const area = this.getPrintArea(options);
        const $pages = [];
        if (options.page) {
            const pageSize = this.getPageSize(area, options.page);
            const pageAreas = this.getPageAreas(area, pageSize);
            pageAreas.forEach((pageArea) => {
                ret = this.createPrintPage(pageArea, options);
                $pages.push(ret.$page);
            });
        }
        else {
            ret = this.createPrintPage(area, options);
            $pages.push(ret.$page);
        }
        if (ret) {
            const size = {
                width: ret.sheetSize.cssWidth,
                height: ret.sheetSize.cssHeight,
            };
            this.updatePrintStyle(size, options);
        }
        return $pages;
    }
    get styleSheetId() {
        return this.view.prefixClassName('graph-print-style');
    }
    updatePrintStyle(size, options) {
        const sizeCSS = Object.keys(size).reduce((memo, key) => `${memo} ${key}:${size[key]};`, '');
        const margin = normalizeSides(options.margin);
        const marginUnit = options.marginUnit || '';
        const sheetUnit = options.sheetUnit || '';
        const css = `
      @media print {
        .${this.className}.${this.className}-ready {
          ${sizeCSS}
        }

        @page {
          margin:
          ${[
            margin.top + marginUnit,
            margin.right + marginUnit,
            margin.bottom + marginUnit,
            margin.left + marginUnit,
        ].join(' ')};
          size: ${options.sheet.width + sheetUnit} ${options.sheet.height + sheetUnit};

        .${this.className}.${this.className}-preview {
          ${sizeCSS}
        }
      }`;
        const id = this.styleSheetId;
        const $style = JQuery(`#${id}`);
        if ($style.length) {
            $style.html(css);
        }
        else {
            JQuery('head').append(`'<style type="text/css" id="${id}">${css}</style>'`);
        }
    }
    getPrintArea(options) {
        let area = options.area;
        if (!area) {
            const padding = normalizeSides(options.padding);
            area = this.graph.getContentArea().moveAndExpand({
                x: -padding.left,
                y: -padding.top,
                width: padding.left + padding.right,
                height: padding.top + padding.bottom,
            });
        }
        return area;
    }
    getPageSize(area, poster) {
        if (typeof poster === 'object') {
            const raw = poster;
            const page = {
                width: raw.width,
                height: raw.height,
            };
            if (page.width == null) {
                page.width = Math.ceil(area.width / (raw.columns || 1));
            }
            if (page.height == null) {
                page.height = Math.ceil(area.height / (raw.rows || 1));
            }
            return page;
        }
        return {
            width: area.width,
            height: area.height,
        };
    }
    getPageAreas(area, pageSize) {
        const pages = [];
        const width = pageSize.width;
        const height = pageSize.height;
        for (let w = 0, n = 0; w < area.height && n < 200; w += height, n += 1) {
            for (let h = 0, m = 0; h < area.width && m < 200; h += width, m += 1) {
                pages.push(new Rectangle(area.x + h, area.y + w, width, height));
            }
        }
        return pages;
    }
    getSheetSize(options) {
        const sheet = options.sheet;
        const margin = normalizeSides(options.margin);
        const marginUnit = options.marginUnit || '';
        const sheetUnit = options.sheetUnit || '';
        const cssWidth = 
        // eslint-disable-next-line
        `calc(${sheet.width}${sheetUnit} - ${margin.left + margin.right}${marginUnit})`;
        const cssHeight = 
        // eslint-disable-next-line
        `calc(${sheet.height}${sheetUnit} - ${margin.top + margin.bottom}${marginUnit})`;
        const ret = Unit.measure(cssWidth, cssHeight);
        return {
            cssWidth,
            cssHeight,
            width: ret.width,
            height: ret.height,
        };
    }
    getPageInfo(graphArea, pageArea, sheetSize) {
        const bbox = new Rectangle(pageArea.x - graphArea.x, pageArea.y - graphArea.y, pageArea.width, pageArea.height);
        const pageRatio = bbox.width / bbox.height;
        const graphRatio = sheetSize.width / sheetSize.height;
        return {
            bbox,
            scale: graphRatio < pageRatio
                ? sheetSize.width / bbox.width
                : sheetSize.height / bbox.height,
            fitHorizontal: graphRatio < pageRatio,
        };
    }
    dispose() { }
}
__decorate$5([
    Base.dispose()
], PrintManager.prototype, "dispose", null);
(function (PrintManager) {
    PrintManager.defaultOptions = {
        page: false,
        sheet: {
            width: 210,
            height: 297,
        },
        sheetUnit: 'mm',
        margin: 0.4,
        marginUnit: 'in',
        padding: 5,
        ready: ($pages, readyToPrint) => readyToPrint($pages),
    };
})(PrintManager || (PrintManager = {}));

class FormatManager extends Base {
    toSVG(callback, options = {}) {
        this.graph.trigger('before:export', options);
        const rawSVG = this.view.svg;
        const vSVG = Vector.create(rawSVG).clone();
        let clonedSVG = vSVG.node;
        const vStage = vSVG.findOne(`.${this.view.prefixClassName('graph-svg-stage')}`);
        const viewBox = options.viewBox || this.graph.graphToLocal(this.graph.getContentBBox());
        const dimension = options.preserveDimensions;
        if (dimension) {
            const size = typeof dimension === 'boolean' ? viewBox : dimension;
            vSVG.attr({
                width: size.width,
                height: size.height,
            });
        }
        vSVG
            .removeAttribute('style')
            .attr('viewBox', [viewBox.x, viewBox.y, viewBox.width, viewBox.height].join(' '));
        vStage.removeAttribute('transform');
        // Stores all the CSS declarations from external stylesheets to the
        // `style` attribute of the SVG document nodes.
        // This is achieved in three steps.
        // -----------------------------------
        // 1. Disabling all the stylesheets in the page and therefore collecting
        //    only default style values. This, together with the step 2, makes it
        //    possible to discard default CSS property values and store only those
        //    that differ.
        //
        // 2. Enabling back all the stylesheets in the page and collecting styles
        //    that differ from the default values.
        //
        // 3. Applying the difference between default values and the ones set by
        //    custom stylesheets onto the `style` attribute of each of the nodes
        //    in SVG.
        if (options.copyStyles !== false) {
            const document = rawSVG.ownerDocument;
            const raws = Array.from(rawSVG.querySelectorAll('*'));
            const clones = Array.from(clonedSVG.querySelectorAll('*'));
            const styleSheetCount = document.styleSheets.length;
            const styleSheetsCopy = [];
            for (let k = styleSheetCount - 1; k >= 0; k -= 1) {
                // There is a bug (bugSS) in Chrome 14 and Safari. When you set
                // `stylesheet.disable = true` it will also remove it from
                // `document.styleSheets`. So we need to store all stylesheets before
                // we disable them. Later on we put them back to `document.styleSheets`
                // if needed.
                // See the bug `https://code.google.com/p/chromium/issues/detail?id=88310`.
                styleSheetsCopy[k] = document.styleSheets[k];
                document.styleSheets[k].disabled = true;
            }
            const defaultComputedStyles = {};
            raws.forEach((elem, index) => {
                const computedStyle = window.getComputedStyle(elem, null);
                // We're making a deep copy of the `computedStyle` so that it's not affected
                // by that next step when all the stylesheets are re-enabled again.
                const defaultComputedStyle = {};
                Object.keys(computedStyle).forEach((property) => {
                    defaultComputedStyle[property] =
                        computedStyle.getPropertyValue(property);
                });
                defaultComputedStyles[index] = defaultComputedStyle;
            });
            // Copy all stylesheets back
            if (styleSheetCount !== document.styleSheets.length) {
                styleSheetsCopy.forEach((copy, index) => {
                    document.styleSheets[index] = copy;
                });
            }
            for (let i = 0; i < styleSheetCount; i += 1) {
                document.styleSheets[i].disabled = false;
            }
            const customStyles = {};
            raws.forEach((elem, index) => {
                const computedStyle = window.getComputedStyle(elem, null);
                const defaultComputedStyle = defaultComputedStyles[index];
                const customStyle = {};
                Object.keys(computedStyle).forEach((property) => {
                    if (!isNumeric(property) &&
                        computedStyle.getPropertyValue(property) !==
                            defaultComputedStyle[property]) {
                        customStyle[property] = computedStyle.getPropertyValue(property);
                    }
                });
                customStyles[index] = customStyle;
            });
            clones.forEach((elem, index) => {
                JQuery(elem).css(customStyles[index]);
            });
        }
        const stylesheet = options.stylesheet;
        if (typeof stylesheet === 'string') {
            const cDATASection = rawSVG
                .ownerDocument.implementation.createDocument(null, 'xml', null)
                .createCDATASection(stylesheet);
            vSVG.prepend(Vector.create('style', {
                type: 'text/css',
            }, [cDATASection]));
        }
        const format = () => {
            const beforeSerialize = options.beforeSerialize;
            if (typeof beforeSerialize === 'function') {
                const ret = call(beforeSerialize, this.graph, clonedSVG);
                if (ret instanceof SVGSVGElement) {
                    clonedSVG = ret;
                }
            }
            const dataUri = new XMLSerializer()
                .serializeToString(clonedSVG)
                .replace(/&nbsp;/g, '\u00a0');
            this.graph.trigger('after:export', options);
            callback(dataUri);
        };
        if (options.serializeImages) {
            const deferrals = vSVG.find('image').map((vImage) => {
                return new Promise((resolve) => {
                    const url = vImage.attr('xlink:href') || vImage.attr('href');
                    DataUri.imageToDataUri(url, (err, dataUri) => {
                        if (!err && dataUri) {
                            vImage.attr('xlink:href', dataUri);
                        }
                        resolve();
                    });
                });
            });
            Promise.all(deferrals).then(format);
        }
        else {
            format();
        }
    }
    toDataURL(callback, options) {
        let viewBox = options.viewBox || this.graph.getContentBBox();
        const padding = normalizeSides(options.padding);
        if (options.width && options.height) {
            if (padding.left + padding.right >= options.width) {
                padding.left = padding.right = 0;
            }
            if (padding.top + padding.bottom >= options.height) {
                padding.top = padding.bottom = 0;
            }
        }
        const expanding = new Rectangle(-padding.left, -padding.top, padding.left + padding.right, padding.top + padding.bottom);
        if (options.width && options.height) {
            const width = viewBox.width + padding.left + padding.right;
            const height = viewBox.height + padding.top + padding.bottom;
            expanding.scale(width / options.width, height / options.height);
        }
        viewBox = Rectangle.create(viewBox).moveAndExpand(expanding);
        const rawSize = typeof options.width === 'number' && typeof options.height === 'number'
            ? { width: options.width, height: options.height }
            : viewBox;
        let scale = options.ratio ? parseFloat(options.ratio) : 1;
        if (!Number.isFinite(scale) || scale === 0) {
            scale = 1;
        }
        const size = {
            width: Math.max(Math.round(rawSize.width * scale), 1),
            height: Math.max(Math.round(rawSize.height * scale), 1),
        };
        {
            const imgDataCanvas = document.createElement('canvas');
            const context2D = imgDataCanvas.getContext('2d');
            imgDataCanvas.width = size.width;
            imgDataCanvas.height = size.height;
            const x = size.width - 1;
            const y = size.height - 1;
            context2D.fillStyle = 'rgb(1,1,1)';
            context2D.fillRect(x, y, 1, 1);
            const data = context2D.getImageData(x, y, 1, 1).data;
            if (data[0] !== 1 || data[1] !== 1 || data[2] !== 1) {
                throw new Error('size exceeded');
            }
        }
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = size.width;
            canvas.height = size.height;
            const context = canvas.getContext('2d');
            context.fillStyle = options.backgroundColor || 'white';
            context.fillRect(0, 0, size.width, size.height);
            try {
                context.drawImage(img, 0, 0, size.width, size.height);
                const dataUri = canvas.toDataURL(options.type, options.quality);
                callback(dataUri);
            }
            catch (error) {
                // pass
            }
        };
        this.toSVG((dataUri) => {
            img.src = `data:image/svg+xml,${encodeURIComponent(dataUri)}`;
        }, Object.assign(Object.assign({}, options), { viewBox, serializeImages: true, preserveDimensions: Object.assign({}, size) }));
    }
    toPNG(callback, options = {}) {
        this.toDataURL(callback, Object.assign(Object.assign({}, options), { type: 'image/png' }));
    }
    toJPEG(callback, options = {}) {
        this.toDataURL(callback, Object.assign(Object.assign({}, options), { type: 'image/jpeg' }));
    }
}

class KnobManager extends Base {
    constructor() {
        super(...arguments);
        this.widgets = new Map();
    }
    get isSelectionEnabled() {
        return this.options.selecting.enabled === true;
    }
    init() {
        this.startListening();
    }
    startListening() {
        this.graph.on('node:mouseup', this.onNodeMouseUp, this);
        this.graph.on('node:selected', this.onNodeSelected, this);
        this.graph.on('node:unselected', this.onNodeUnSelected, this);
    }
    stopListening() {
        this.graph.off('node:mouseup', this.onNodeMouseUp, this);
        this.graph.off('node:selected', this.onNodeSelected, this);
        this.graph.off('node:unselected', this.onNodeUnSelected, this);
    }
    onNodeMouseUp({ node }) {
        if (!this.isSelectionEnabled) {
            const widgets = this.graph.hook.createKnob(node, { clearAll: true });
            if (widgets) {
                this.widgets.set(node, widgets);
            }
        }
    }
    onNodeSelected({ node }) {
        if (this.isSelectionEnabled) {
            const widgets = this.graph.hook.createKnob(node, { clearAll: false });
            if (widgets) {
                this.widgets.set(node, widgets);
            }
        }
    }
    onNodeUnSelected({ node }) {
        if (this.isSelectionEnabled) {
            const widgets = this.widgets.get(node);
            if (widgets) {
                widgets.forEach((widget) => widget.dispose());
            }
            this.widgets.delete(node);
        }
    }
}

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PanningManager extends Base {
    get widgetOptions() {
        return this.options.panning;
    }
    get pannable() {
        return this.widgetOptions && this.widgetOptions.enabled === true;
    }
    init() {
        this.startListening();
        this.updateClassName();
    }
    startListening() {
        const eventTypes = this.widgetOptions.eventTypes;
        if (!eventTypes) {
            return;
        }
        if (eventTypes.includes('leftMouseDown')) {
            this.graph.on('blank:mousedown', this.preparePanning, this);
            this.graph.on('node:unhandled:mousedown', this.preparePanning, this);
            this.graph.on('edge:unhandled:mousedown', this.preparePanning, this);
        }
        if (eventTypes.includes('rightMouseDown')) {
            this.onRightMouseDown = this.onRightMouseDown.bind(this);
            this.view.$(this.graph.container).on('mousedown', this.onRightMouseDown);
        }
        if (eventTypes.includes('mouseWheel')) {
            this.mousewheelHandle = new MouseWheelHandle(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
            this.mousewheelHandle.enable();
        }
    }
    stopListening() {
        const eventTypes = this.widgetOptions.eventTypes;
        if (!eventTypes) {
            return;
        }
        if (eventTypes.includes('leftMouseDown')) {
            this.graph.off('blank:mousedown', this.preparePanning, this);
            this.graph.off('node:unhandled:mousedown', this.preparePanning, this);
            this.graph.off('edge:unhandled:mousedown', this.preparePanning, this);
        }
        if (eventTypes.includes('rightMouseDown')) {
            this.view.$(this.graph.container).off('mousedown', this.onRightMouseDown);
        }
        if (eventTypes.includes('mouseWheel')) {
            if (this.mousewheelHandle) {
                this.mousewheelHandle.disable();
            }
        }
    }
    preparePanning({ e }) {
        if (this.allowPanning(e, true) ||
            (this.allowPanning(e) && !this.graph.selection.allowRubberband(e, true))) {
            this.startPanning(e);
        }
    }
    allowPanning(e, strict) {
        return (this.pannable &&
            ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict) &&
            this.graph.hook.allowPanning(e));
    }
    startPanning(evt) {
        const e = this.view.normalizeEvent(evt);
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.panning = true;
        this.updateClassName();
        this.view.$(document.body).on({
            'mousemove.panning touchmove.panning': this.pan.bind(this),
            'mouseup.panning touchend.panning': this.stopPanning.bind(this),
            'mouseleave.panning': this.stopPanning.bind(this),
        });
        this.view.$(window).on('mouseup.panning', this.stopPanning.bind(this));
    }
    pan(evt) {
        const e = this.view.normalizeEvent(evt);
        const dx = e.clientX - this.clientX;
        const dy = e.clientY - this.clientY;
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        const ts = this.graph.transform.getTranslation();
        const tx = ts.tx + dx;
        const ty = ts.ty + dy;
        this.graph.transform.translate(tx, ty, { ui: true });
    }
    // eslint-disable-next-line
    stopPanning(e) {
        this.panning = false;
        this.updateClassName();
        this.view.$(document.body).off('.panning');
        this.view.$(window).off('.panning');
    }
    updateClassName() {
        const container = this.view.container;
        const panning = this.view.prefixClassName('graph-panning');
        const pannable = this.view.prefixClassName('graph-pannable');
        if (this.pannable) {
            if (this.panning) {
                addClass(container, panning);
                removeClass(container, pannable);
            }
            else {
                removeClass(container, panning);
                addClass(container, pannable);
            }
        }
        else {
            removeClass(container, panning);
            removeClass(container, pannable);
        }
    }
    onRightMouseDown(e) {
        if (e.button === 2 && this.allowPanning(e, true)) {
            this.startPanning(e);
        }
    }
    allowMouseWheel(e) {
        return this.pannable && !e.ctrlKey;
    }
    onMouseWheel(e, deltaX, deltaY) {
        if (!e.ctrlKey) {
            this.graph.translateBy(-deltaX, -deltaY);
        }
    }
    autoPanning(x, y) {
        const buffer = 10;
        const graphArea = this.graph.getGraphArea();
        let dx = 0;
        let dy = 0;
        if (x <= graphArea.left + buffer) {
            dx = -buffer;
        }
        if (y <= graphArea.top + buffer) {
            dy = -buffer;
        }
        if (x >= graphArea.right - buffer) {
            dx = buffer;
        }
        if (y >= graphArea.bottom - buffer) {
            dy = buffer;
        }
        if (dx !== 0 || dy !== 0) {
            this.graph.translateBy(-dx, -dy);
        }
    }
    enablePanning() {
        if (!this.pannable) {
            this.widgetOptions.enabled = true;
            this.updateClassName();
        }
    }
    disablePanning() {
        if (this.pannable) {
            this.widgetOptions.enabled = false;
            this.updateClassName();
        }
    }
    dispose() {
        this.stopListening();
    }
}
__decorate$4([
    Base.dispose()
], PanningManager.prototype, "dispose", null);

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SizeManager extends Base {
    hasScroller() {
        return this.graph.scroller.widget != null;
    }
    getContainer() {
        return this.hasScroller()
            ? this.graph.scroller.widget.container
            : this.graph.container;
    }
    init() {
        const autoResize = this.options.autoResize;
        if (autoResize) {
            const target = typeof autoResize === 'boolean'
                ? this.getContainer()
                : autoResize;
            SizeSensor.bind(target, () => {
                const container = this.getContainer();
                // container is border-box
                const width = container.offsetWidth;
                const height = container.offsetHeight;
                this.resize(width, height);
            });
        }
    }
    resize(width, height) {
        if (this.hasScroller()) {
            this.resizeScroller(width, height);
        }
        else {
            this.resizeGraph(width, height);
        }
    }
    resizeGraph(width, height) {
        this.graph.transform.resize(width, height);
    }
    resizeScroller(width, height) {
        this.graph.scroller.resize(width, height);
    }
    resizePage(width, height) {
        const instance = this.graph.scroller.widget;
        if (instance) {
            instance.updatePageSize(width, height);
        }
    }
    dispose() {
        SizeSensor.clear(this.getContainer());
    }
}
__decorate$3([
    Base.dispose()
], SizeManager.prototype, "dispose", null);

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Decorator;
(function (Decorator) {
    function hook(nullable, hookName) {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            const name = hookName || methodName;
            descriptor.value = function (...args) {
                const hook = this.options[name];
                if (hook != null) {
                    this.getNativeValue = raw.bind(this, ...args);
                    const ret = call(hook, this.graph, ...args);
                    this.getNativeValue = null;
                    if (ret != null || (nullable === true && ret === null)) {
                        return ret;
                    }
                }
                return raw.call(this, ...args);
            };
        };
    }
    Decorator.hook = hook;
    function after(hookName) {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            const name = hookName || methodName;
            descriptor.value = function (...args) {
                let ret = raw.call(this, ...args);
                const hook = this.options[name];
                if (hook != null) {
                    ret = call(hook, this.graph, ...args) && ret;
                }
                return ret;
            };
        };
    }
    Decorator.after = after;
})(Decorator || (Decorator = {}));
class Hook extends Base {
    createModel() {
        if (this.options.model) {
            return this.options.model;
        }
        const model = new Model();
        model.graph = this.graph;
        return model;
    }
    createView() {
        return new GraphView(this.graph);
    }
    createRenderer() {
        return new Renderer(this.graph);
    }
    createDefsManager() {
        return new DefsManager(this.graph);
    }
    createGridManager() {
        return new GridManager(this.graph);
    }
    createCoordManager() {
        return new CoordManager(this.graph);
    }
    createKnobManager() {
        return new KnobManager(this.graph);
    }
    createTransform(node, widgetOptions) {
        const options = this.getTransformOptions(node);
        if (options.resizable || options.rotatable) {
            return new Transform(Object.assign(Object.assign({ node, graph: this.graph }, options), widgetOptions));
        }
        if (options.clearAll) {
            Transform.removeInstances(this.graph);
        }
        return null;
    }
    createKnob(node, widgetOptions) {
        const options = Options.parseOptionGroup(this.graph, node, this.options.knob);
        const localOptions = Object.assign(Object.assign({}, options), widgetOptions);
        if (localOptions.clearAll) {
            Knob.removeInstances(this.graph);
        }
        localOptions.clearAll = false;
        const knob = node.prop('knob');
        const widgets = [];
        const meta = Array.isArray(knob) ? knob : [knob];
        meta.forEach((knob, index) => {
            if (knob) {
                if (knob.enabled === false) {
                    return;
                }
                if (typeof knob.enabled === 'function' &&
                    knob.enabled.call(this.graph, node) === false) {
                    return;
                }
            }
            else {
                return;
            }
            if (options.enabled) {
                widgets.push(new Knob(Object.assign({ node,
                    index, graph: this.graph }, localOptions)));
            }
        });
        return widgets;
    }
    getTransformOptions(node) {
        const resizing = Options.parseOptionGroup(this.graph, node, this.options.resizing);
        const rotating = Options.parseOptionGroup(this.graph, node, this.options.rotating);
        const transforming = Options.parseOptionGroup(this.graph, node, this.options.transforming);
        const options = Object.assign(Object.assign({}, transforming), { resizable: resizing.enabled, minWidth: resizing.minWidth, maxWidth: resizing.maxWidth, minHeight: resizing.minHeight, maxHeight: resizing.maxHeight, orthogonalResizing: resizing.orthogonal, restrictedResizing: resizing.restrict != null ? resizing.restrict : resizing.restricted, autoScrollOnResizing: resizing.autoScroll, preserveAspectRatio: resizing.preserveAspectRatio, allowReverse: resizing.allowReverse, rotatable: rotating.enabled, rotateGrid: rotating.grid });
        return options;
    }
    createTransformManager() {
        return new TransformManager(this.graph);
    }
    createHighlightManager() {
        return new HighlightManager(this.graph);
    }
    createBackgroundManager() {
        return new BackgroundManager(this.graph);
    }
    createClipboard() {
        return new Clipboard();
    }
    createClipboardManager() {
        return new ClipboardManager(this.graph);
    }
    createSnapline() {
        return new Snapline(Object.assign({ graph: this.graph }, this.options.snapline));
    }
    createSnaplineManager() {
        return new SnaplineManager(this.graph);
    }
    createSelection() {
        return new Selection(Object.assign({ graph: this.graph }, this.options.selecting));
    }
    createSelectionManager() {
        return new SelectionManager(this.graph);
    }
    // eslint-disable-next-line
    allowRubberband(e) {
        return true;
    }
    createHistoryManager() {
        return new HistoryManager(Object.assign({ graph: this.graph }, this.options.history));
    }
    createScroller() {
        if (this.options.scroller.enabled) {
            return new Scroller(Object.assign({ graph: this.graph }, this.options.scroller));
        }
        return null;
    }
    createScrollerManager() {
        return new ScrollerManager(this.graph);
    }
    // eslint-disable-next-line
    allowPanning(e) {
        return true;
    }
    createMiniMap() {
        const _a = this.options.minimap, { enabled } = _a, options = __rest(_a, ["enabled"]);
        if (enabled) {
            return new MiniMap(Object.assign({ graph: this.graph }, options));
        }
        return null;
    }
    createMiniMapManager() {
        return new MiniMapManager(this.graph);
    }
    createKeyboard() {
        return new Keyboard(Object.assign({ graph: this.graph }, this.options.keyboard));
    }
    createMouseWheel() {
        return new MouseWheel(Object.assign({ graph: this.graph }, this.options.mousewheel));
    }
    createPrintManager() {
        return new PrintManager(this.graph);
    }
    createFormatManager() {
        return new FormatManager(this.graph);
    }
    createPanningManager() {
        return new PanningManager(this.graph);
    }
    createSizeManager() {
        return new SizeManager(this.graph);
    }
    allowConnectToBlank(edge) {
        const options = this.options.connecting;
        const allowBlank = options.allowBlank != null ? options.allowBlank : options.dangling;
        if (typeof allowBlank !== 'function') {
            return !!allowBlank;
        }
        const edgeView = this.graph.findViewByCell(edge);
        const sourceCell = edge.getSourceCell();
        const targetCell = edge.getTargetCell();
        const sourceView = this.graph.findViewByCell(sourceCell);
        const targetView = this.graph.findViewByCell(targetCell);
        return call(allowBlank, this.graph, {
            edge,
            edgeView,
            sourceCell,
            targetCell,
            sourceView,
            targetView,
            sourcePort: edge.getSourcePortId(),
            targetPort: edge.getTargetPortId(),
            sourceMagnet: edgeView.sourceMagnet,
            targetMagnet: edgeView.targetMagnet,
        });
    }
    validateEdge(edge, type, initialTerminal) {
        if (!this.allowConnectToBlank(edge)) {
            const sourceId = edge.getSourceCellId();
            const targetId = edge.getTargetCellId();
            if (!(sourceId && targetId)) {
                return false;
            }
        }
        const validate = this.options.connecting.validateEdge;
        if (validate) {
            return call(validate, this.graph, {
                edge,
                type,
                previous: initialTerminal,
            });
        }
        return true;
    }
    validateMagnet(cellView, magnet, e) {
        if (magnet.getAttribute('magnet') !== 'passive') {
            const validate = this.options.connecting.validateMagnet;
            if (validate) {
                return call(validate, this.graph, {
                    e,
                    magnet,
                    view: cellView,
                    cell: cellView.cell,
                });
            }
            return true;
        }
        return false;
    }
    getDefaultEdge(sourceView, sourceMagnet) {
        let edge;
        const create = this.options.connecting.createEdge;
        if (create) {
            edge = call(create, this.graph, {
                sourceMagnet,
                sourceView,
                sourceCell: sourceView.cell,
            });
        }
        if (edge == null) {
            edge = new Edge();
        }
        return edge;
    }
    validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {
        const options = this.options.connecting;
        const allowLoop = options.allowLoop;
        const allowNode = options.allowNode;
        const allowEdge = options.allowEdge;
        const allowPort = options.allowPort;
        const allowMulti = options.allowMulti != null ? options.allowMulti : options.multi;
        const validate = options.validateConnection;
        const edge = edgeView ? edgeView.cell : null;
        const terminalView = terminalType === 'target' ? targetView : sourceView;
        const terminalMagnet = terminalType === 'target' ? targetMagnet : sourceMagnet;
        let valid = true;
        const doValidate = (validate) => {
            const sourcePort = terminalType === 'source'
                ? candidateTerminal
                    ? candidateTerminal.port
                    : null
                : edge
                    ? edge.getSourcePortId()
                    : null;
            const targetPort = terminalType === 'target'
                ? candidateTerminal
                    ? candidateTerminal.port
                    : null
                : edge
                    ? edge.getTargetPortId()
                    : null;
            return call(validate, this.graph, {
                edge,
                edgeView,
                sourceView,
                targetView,
                sourcePort,
                targetPort,
                sourceMagnet,
                targetMagnet,
                sourceCell: sourceView ? sourceView.cell : null,
                targetCell: targetView ? targetView.cell : null,
                type: terminalType,
            });
        };
        if (allowLoop != null) {
            if (typeof allowLoop === 'boolean') {
                if (!allowLoop && sourceView === targetView) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowLoop);
            }
        }
        if (valid && allowPort != null) {
            if (typeof allowPort === 'boolean') {
                if (!allowPort && terminalMagnet) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowPort);
            }
        }
        if (valid && allowEdge != null) {
            if (typeof allowEdge === 'boolean') {
                if (!allowEdge && EdgeView.isEdgeView(terminalView)) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowEdge);
            }
        }
        // When judging nodes, the influence of the ports should be excluded,
        // because the ports and nodes have the same terminalView
        if (valid && allowNode != null && terminalMagnet == null) {
            if (typeof allowNode === 'boolean') {
                if (!allowNode && NodeView.isNodeView(terminalView)) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowNode);
            }
        }
        if (valid && allowMulti != null && edgeView) {
            const edge = edgeView.cell;
            const source = terminalType === 'source'
                ? candidateTerminal
                : edge.getSource();
            const target = terminalType === 'target'
                ? candidateTerminal
                : edge.getTarget();
            const terminalCell = candidateTerminal
                ? this.graph.getCellById(candidateTerminal.cell)
                : null;
            if (source && target && source.cell && target.cell && terminalCell) {
                if (typeof allowMulti === 'function') {
                    valid = doValidate(allowMulti);
                }
                else {
                    const connectedEdges = this.model.getConnectedEdges(terminalCell, {
                        outgoing: terminalType === 'source',
                        incoming: terminalType === 'target',
                    });
                    if (connectedEdges.length) {
                        if (allowMulti === 'withPort') {
                            const exist = connectedEdges.some((link) => {
                                const s = link.getSource();
                                const t = link.getTarget();
                                return (s &&
                                    t &&
                                    s.cell === source.cell &&
                                    t.cell === target.cell &&
                                    s.port != null &&
                                    s.port === source.port &&
                                    t.port != null &&
                                    t.port === target.port);
                            });
                            if (exist) {
                                valid = false;
                            }
                        }
                        else if (!allowMulti) {
                            const exist = connectedEdges.some((link) => {
                                const s = link.getSource();
                                const t = link.getTarget();
                                return (s && t && s.cell === source.cell && t.cell === target.cell);
                            });
                            if (exist) {
                                valid = false;
                            }
                        }
                    }
                }
            }
        }
        if (valid && validate != null) {
            valid = doValidate(validate);
        }
        return valid;
    }
    getRestrictArea(view) {
        const restrict = this.options.translating.restrict;
        const area = typeof restrict === 'function'
            ? call(restrict, this.graph, view)
            : restrict;
        if (typeof area === 'number') {
            return this.graph.transform.getGraphArea().inflate(area);
        }
        if (area === true) {
            return this.graph.transform.getGraphArea();
        }
        return area || null;
    }
    onViewUpdated(view, flag, options) {
        if (flag & Renderer.FLAG_INSERT || options.mounting) {
            return;
        }
        this.graph.renderer.requestConnectedEdgesUpdate(view, options);
    }
    onViewPostponed(view, flag, options) {
        return this.graph.renderer.forcePostponedViewUpdate(view, flag);
    }
    getCellView(cell) {
        return null;
    }
    createCellView(cell) {
        const options = { graph: this.graph };
        const ctor = this.getCellView(cell);
        if (ctor) {
            return new ctor(cell, options); // eslint-disable-line new-cap
        }
        const view = cell.view;
        if (view != null && typeof view === 'string') {
            const def = CellView.registry.get(view);
            if (def) {
                return new def(cell, options); // eslint-disable-line new-cap
            }
            return CellView.registry.onNotFound(view);
        }
        if (cell.isNode()) {
            return new NodeView(cell, options);
        }
        if (cell.isEdge()) {
            return new EdgeView(cell, options);
        }
        return null;
    }
    getHTMLComponent(node) {
        let ret = node.getHTML();
        if (typeof ret === 'string') {
            ret = HTML.componentRegistry.get(ret) || ret;
        }
        if (isPlainObject(ret)) {
            ret = ret.render;
        }
        if (typeof ret === 'function') {
            return call(ret, this.graph, node);
        }
        return ret;
    }
    shouldUpdateHTMLComponent(node) {
        let html = node.getHTML();
        if (typeof html === 'string') {
            html = HTML.componentRegistry.get(html) || html;
        }
        if (isPlainObject(html)) {
            const shouldUpdate = html
                .shouldComponentUpdate;
            if (typeof shouldUpdate === 'function') {
                return call(shouldUpdate, this.graph, node);
            }
            return !!shouldUpdate;
        }
        return false;
    }
    onEdgeLabelRendered(args) { } // eslint-disable-line
    onPortRendered(args) { } // eslint-disable-line
    onToolItemCreated(args) { } // eslint-disable-line
}
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createModel", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createView", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createRenderer", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createDefsManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createGridManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createCoordManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createKnobManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createTransform", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createKnob", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createTransformManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createHighlightManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createBackgroundManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createClipboard", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createClipboardManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createSnapline", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createSnaplineManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createSelection", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createSelectionManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "allowRubberband", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createHistoryManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createScroller", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createScrollerManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "allowPanning", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createMiniMap", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createMiniMapManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createKeyboard", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createMouseWheel", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createPrintManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createFormatManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createPanningManager", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "createSizeManager", null);
__decorate$2([
    Decorator.after()
], Hook.prototype, "onViewUpdated", null);
__decorate$2([
    Decorator.after()
], Hook.prototype, "onViewPostponed", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "getCellView", null);
__decorate$2([
    Decorator.hook(true)
], Hook.prototype, "createCellView", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "getHTMLComponent", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "shouldUpdateHTMLComponent", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "onEdgeLabelRendered", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "onPortRendered", null);
__decorate$2([
    Decorator.hook()
], Hook.prototype, "onToolItemCreated", null);

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Graph extends Basecoat {
    constructor(options) {
        super();
        this.options = Options.get(options);
        this.css = new CSSManager(this);
        this.hook = new Hook(this);
        this.view = this.hook.createView();
        this.defs = this.hook.createDefsManager();
        this.coord = this.hook.createCoordManager();
        this.transform = this.hook.createTransformManager();
        this.knob = this.hook.createKnobManager();
        this.highlight = this.hook.createHighlightManager();
        this.grid = this.hook.createGridManager();
        this.background = this.hook.createBackgroundManager();
        this.model = this.hook.createModel();
        this.renderer = this.hook.createRenderer();
        this.clipboard = this.hook.createClipboardManager();
        this.snapline = this.hook.createSnaplineManager();
        this.selection = this.hook.createSelectionManager();
        this.history = this.hook.createHistoryManager();
        this.scroller = this.hook.createScrollerManager();
        this.minimap = this.hook.createMiniMapManager();
        this.keyboard = this.hook.createKeyboard();
        this.mousewheel = this.hook.createMouseWheel();
        this.print = this.hook.createPrintManager();
        this.format = this.hook.createFormatManager();
        this.panning = this.hook.createPanningManager();
        this.size = this.hook.createSizeManager();
    }
    get container() {
        return this.view.container;
    }
    get [Symbol.toStringTag]() {
        return Graph.toStringTag;
    }
    // #region model
    isNode(cell) {
        return cell.isNode();
    }
    isEdge(cell) {
        return cell.isEdge();
    }
    resetCells(cells, options = {}) {
        this.model.resetCells(cells, options);
        return this;
    }
    clearCells(options = {}) {
        this.model.clear(options);
        return this;
    }
    toJSON(options = {}) {
        return this.model.toJSON(options);
    }
    parseJSON(data) {
        return this.model.parseJSON(data);
    }
    fromJSON(data, options = {}) {
        this.model.fromJSON(data, options);
        return this;
    }
    getCellById(id) {
        return this.model.getCell(id);
    }
    addNode(node, options = {}) {
        return this.model.addNode(node, options);
    }
    addNodes(nodes, options = {}) {
        return this.addCell(nodes.map((node) => (Node$1.isNode(node) ? node : this.createNode(node))), options);
    }
    createNode(metadata) {
        return this.model.createNode(metadata);
    }
    removeNode(node, options = {}) {
        return this.model.removeCell(node, options);
    }
    addEdge(edge, options = {}) {
        return this.model.addEdge(edge, options);
    }
    addEdges(edges, options = {}) {
        return this.addCell(edges.map((edge) => (Edge$1.isEdge(edge) ? edge : this.createEdge(edge))), options);
    }
    removeEdge(edge, options = {}) {
        return this.model.removeCell(edge, options);
    }
    createEdge(metadata) {
        return this.model.createEdge(metadata);
    }
    addCell(cell, options = {}) {
        this.model.addCell(cell, options);
        return this;
    }
    removeCell(cell, options = {}) {
        return this.model.removeCell(cell, options);
    }
    removeCells(cells, options = {}) {
        return this.model.removeCells(cells, options);
    }
    removeConnectedEdges(cell, options = {}) {
        return this.model.removeConnectedEdges(cell, options);
    }
    disconnectConnectedEdges(cell, options = {}) {
        this.model.disconnectConnectedEdges(cell, options);
        return this;
    }
    hasCell(cell) {
        return this.model.has(cell);
    }
    /**
     * **Deprecation Notice:** `getCell` is deprecated and will be moved in next
     * major release. Use `getCellById()` instead.
     *
     * @deprecated
     */
    getCell(id) {
        return this.model.getCell(id);
    }
    getCells() {
        return this.model.getCells();
    }
    getCellCount() {
        return this.model.total();
    }
    /**
     * Returns all the nodes in the graph.
     */
    getNodes() {
        return this.model.getNodes();
    }
    /**
     * Returns all the edges in the graph.
     */
    getEdges() {
        return this.model.getEdges();
    }
    /**
     * Returns all outgoing edges for the node.
     */
    getOutgoingEdges(cell) {
        return this.model.getOutgoingEdges(cell);
    }
    /**
     * Returns all incoming edges for the node.
     */
    getIncomingEdges(cell) {
        return this.model.getIncomingEdges(cell);
    }
    /**
     * Returns edges connected with cell.
     */
    getConnectedEdges(cell, options = {}) {
        return this.model.getConnectedEdges(cell, options);
    }
    /**
     * Returns an array of all the roots of the graph.
     */
    getRootNodes() {
        return this.model.getRoots();
    }
    /**
     * Returns an array of all the leafs of the graph.
     */
    getLeafNodes() {
        return this.model.getLeafs();
    }
    /**
     * Returns `true` if the node is a root node, i.e.
     * there is no  edges coming to the node.
     */
    isRootNode(cell) {
        return this.model.isRoot(cell);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e.
     * there is no edges going out from the node.
     */
    isLeafNode(cell) {
        return this.model.isLeaf(cell);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */
    getNeighbors(cell, options = {}) {
        return this.model.getNeighbors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */
    isNeighbor(cell1, cell2, options = {}) {
        return this.model.isNeighbor(cell1, cell2, options);
    }
    getSuccessors(cell, options = {}) {
        return this.model.getSuccessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */
    isSuccessor(cell1, cell2, options = {}) {
        return this.model.isSuccessor(cell1, cell2, options);
    }
    getPredecessors(cell, options = {}) {
        return this.model.getPredecessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */
    isPredecessor(cell1, cell2, options = {}) {
        return this.model.isPredecessor(cell1, cell2, options);
    }
    getCommonAncestor(...cells) {
        return this.model.getCommonAncestor(...cells);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */
    getSubGraph(cells, options = {}) {
        return this.model.getSubGraph(cells, options);
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */
    cloneSubGraph(cells, options = {}) {
        return this.model.cloneSubGraph(cells, options);
    }
    cloneCells(cells) {
        return this.model.cloneCells(cells);
    }
    getNodesFromPoint(x, y) {
        return this.model.getNodesFromPoint(x, y);
    }
    getNodesInArea(x, y, w, h, options) {
        return this.model.getNodesInArea(x, y, w, h, options);
    }
    getNodesUnderNode(node, options = {}) {
        return this.model.getNodesUnderNode(node, options);
    }
    searchCell(cell, iterator, options = {}) {
        this.model.search(cell, iterator, options);
        return this;
    }
    /** *
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */
    getShortestPath(source, target, options = {}) {
        return this.model.getShortestPath(source, target, options);
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */
    getAllCellsBBox() {
        return this.model.getAllCellsBBox();
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */
    getCellsBBox(cells, options = {}) {
        return this.model.getCellsBBox(cells, options);
    }
    startBatch(name, data = {}) {
        this.model.startBatch(name, data);
    }
    stopBatch(name, data = {}) {
        this.model.stopBatch(name, data);
    }
    batchUpdate(arg1, arg2, arg3) {
        const name = typeof arg1 === 'string' ? arg1 : 'update';
        const execute = typeof arg1 === 'string' ? arg2 : arg1;
        const data = typeof arg2 === 'function' ? arg3 : arg2;
        this.startBatch(name, data);
        const result = execute();
        this.stopBatch(name, data);
        return result;
    }
    updateCellId(cell, newId) {
        return this.model.updateCellId(cell, newId);
    }
    // #endregion
    // #region view
    isFrozen() {
        return this.renderer.isFrozen();
    }
    freeze(options = {}) {
        this.renderer.freeze(options);
        return this;
    }
    unfreeze(options = {}) {
        this.renderer.unfreeze(options);
        return this;
    }
    isAsync() {
        return this.renderer.isAsync();
    }
    setAsync(async) {
        this.renderer.setAsync(async);
        return this;
    }
    findView(ref) {
        if (Cell.isCell(ref)) {
            return this.findViewByCell(ref);
        }
        return this.findViewByElem(ref);
    }
    findViews(ref) {
        if (Rectangle.isRectangleLike(ref)) {
            return this.findViewsInArea(ref);
        }
        if (Point.isPointLike(ref)) {
            return this.findViewsFromPoint(ref);
        }
        return [];
    }
    findViewByCell(cell) {
        return this.renderer.findViewByCell(cell);
    }
    findViewByElem(elem) {
        return this.renderer.findViewByElem(elem);
    }
    findViewsFromPoint(x, y) {
        const p = typeof x === 'number' ? { x, y: y } : x;
        return this.renderer.findViewsFromPoint(p);
    }
    findViewsInArea(x, y, width, height, options) {
        const rect = typeof x === 'number'
            ? {
                x,
                y: y,
                width: width,
                height: height,
            }
            : x;
        const localOptions = typeof x === 'number'
            ? options
            : y;
        return this.renderer.findViewsInArea(rect, localOptions);
    }
    isViewMounted(view) {
        return this.renderer.isViewMounted(view);
    }
    getMountedViews() {
        return this.renderer.getMountedViews();
    }
    getUnmountedViews() {
        return this.renderer.getUnmountedViews();
    }
    matrix(mat) {
        if (typeof mat === 'undefined') {
            return this.transform.getMatrix();
        }
        this.transform.setMatrix(mat);
        return this;
    }
    resize(width, height) {
        this.size.resize(width, height);
        return this;
    }
    resizeGraph(width, height) {
        this.size.resizeGraph(width, height);
        return this;
    }
    resizeScroller(width, height) {
        this.size.resizeScroller(width, height);
        return this;
    }
    resizePage(width, height) {
        this.size.resizePage(width, height);
        return this;
    }
    scale(sx, sy = sx, cx = 0, cy = 0) {
        if (typeof sx === 'undefined') {
            return this.transform.getScale();
        }
        this.transform.scale(sx, sy, cx, cy);
        return this;
    }
    zoom(factor, options) {
        const scroller = this.scroller.widget;
        if (scroller) {
            if (typeof factor === 'undefined') {
                return scroller.zoom();
            }
            scroller.zoom(factor, options);
        }
        else {
            if (typeof factor === 'undefined') {
                return this.transform.getZoom();
            }
            this.transform.zoom(factor, options);
        }
        return this;
    }
    zoomTo(factor, options = {}) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
        }
        else {
            this.transform.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
        }
        return this;
    }
    zoomToRect(rect, options = {}) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.zoomToRect(rect, options);
        }
        else {
            this.transform.zoomToRect(rect, options);
        }
        return this;
    }
    zoomToFit(options = {}) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.zoomToFit(options);
        }
        else {
            this.transform.zoomToFit(options);
        }
        return this;
    }
    rotate(angle, cx, cy) {
        if (typeof angle === 'undefined') {
            return this.transform.getRotation();
        }
        this.transform.rotate(angle, cx, cy);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'undefined') {
            return this.transform.getTranslation();
        }
        this.transform.translate(tx, ty);
        return this;
    }
    translateBy(dx, dy) {
        const ts = this.translate();
        const tx = ts.tx + dx;
        const ty = ts.ty + dy;
        return this.translate(tx, ty);
    }
    /**
     * **Deprecation Notice:** `getArea` is deprecated and will be moved in next
     * major release. Use `getGraphArea()` instead.
     *
     * @deprecated
     */
    getArea() {
        return this.transform.getGraphArea();
    }
    getGraphArea() {
        return this.transform.getGraphArea();
    }
    getContentArea(options = {}) {
        return this.transform.getContentArea(options);
    }
    getContentBBox(options = {}) {
        return this.transform.getContentBBox(options);
    }
    fitToContent(gridWidth, gridHeight, padding, options) {
        return this.transform.fitToContent(gridWidth, gridHeight, padding, options);
    }
    scaleContentToFit(options = {}) {
        this.transform.scaleContentToFit(options);
        return this;
    }
    /**
     * Position the center of graph to the center of the viewport.
     */
    center(optons) {
        return this.centerPoint(optons);
    }
    centerPoint(x, y, options) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.centerPoint(x, y, options);
        }
        else {
            this.transform.centerPoint(x, y);
        }
        return this;
    }
    centerContent(options) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.centerContent(options);
        }
        else {
            this.transform.centerContent(options);
        }
        return this;
    }
    centerCell(cell, options) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.centerCell(cell, options);
        }
        else {
            this.transform.centerCell(cell);
        }
        return this;
    }
    positionPoint(point, x, y, options = {}) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.positionPoint(point, x, y, options);
        }
        else {
            this.transform.positionPoint(point, x, y);
        }
        return this;
    }
    positionRect(rect, direction, options) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.positionRect(rect, direction, options);
        }
        else {
            this.transform.positionRect(rect, direction);
        }
        return this;
    }
    positionCell(cell, direction, options) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.positionCell(cell, direction, options);
        }
        else {
            this.transform.positionCell(cell, direction);
        }
        return this;
    }
    positionContent(pos, options) {
        const scroller = this.scroller.widget;
        if (scroller) {
            scroller.positionContent(pos, options);
        }
        else {
            this.transform.positionContent(pos, options);
        }
        return this;
    }
    // #endregion
    // #region coord
    getClientMatrix() {
        return this.coord.getClientMatrix();
    }
    /**
     * Returns coordinates of the graph viewport, relative to the window.
     */
    getClientOffset() {
        return this.coord.getClientOffset();
    }
    /**
     * Returns coordinates of the graph viewport, relative to the document.
     */
    getPageOffset() {
        return this.coord.getPageOffset();
    }
    snapToGrid(x, y) {
        return this.coord.snapToGrid(x, y);
    }
    pageToLocal(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.pageToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.pageToLocalRect(x, y, width, height);
        }
        return this.coord.pageToLocalPoint(x, y);
    }
    localToPage(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.localToPageRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToPageRect(x, y, width, height);
        }
        return this.coord.localToPagePoint(x, y);
    }
    clientToLocal(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.clientToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.clientToLocalRect(x, y, width, height);
        }
        return this.coord.clientToLocalPoint(x, y);
    }
    localToClient(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.localToClientRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToClientRect(x, y, width, height);
        }
        return this.coord.localToClientPoint(x, y);
    }
    localToGraph(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.localToGraphRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToGraphRect(x, y, width, height);
        }
        return this.coord.localToGraphPoint(x, y);
    }
    graphToLocal(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.graphToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.graphToLocalRect(x, y, width, height);
        }
        return this.coord.graphToLocalPoint(x, y);
    }
    clientToGraph(x, y, width, height) {
        if (Rectangle.isRectangleLike(x)) {
            return this.coord.clientToGraphRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.clientToGraphRect(x, y, width, height);
        }
        return this.coord.clientToGraphPoint(x, y);
    }
    // #endregion
    // #region defs
    defineFilter(options) {
        return this.defs.filter(options);
    }
    defineGradient(options) {
        return this.defs.gradient(options);
    }
    defineMarker(options) {
        return this.defs.marker(options);
    }
    // #endregion
    // #region grid
    getGridSize() {
        return this.grid.getGridSize();
    }
    setGridSize(gridSize) {
        this.grid.setGridSize(gridSize);
        return this;
    }
    showGrid() {
        this.grid.show();
        return this;
    }
    hideGrid() {
        this.grid.hide();
        return this;
    }
    clearGrid() {
        this.grid.clear();
        return this;
    }
    drawGrid(options) {
        this.grid.draw(options);
        return this;
    }
    // #endregion
    // #region background
    updateBackground() {
        this.background.update();
        return this;
    }
    drawBackground(options, onGraph) {
        const scroller = this.scroller.widget;
        if (scroller != null && (this.options.background == null || !onGraph)) {
            scroller.backgroundManager.draw(options);
        }
        else {
            this.background.draw(options);
        }
        return this;
    }
    clearBackground(onGraph) {
        const scroller = this.scroller.widget;
        if (scroller != null && (this.options.background == null || !onGraph)) {
            scroller.backgroundManager.clear();
        }
        else {
            this.background.clear();
        }
        return this;
    }
    // #endregion
    // #region clipboard
    isClipboardEnabled() {
        return !this.clipboard.disabled;
    }
    enableClipboard() {
        this.clipboard.enable();
        return this;
    }
    disableClipboard() {
        this.clipboard.disable();
        return this;
    }
    toggleClipboard(enabled) {
        if (enabled != null) {
            if (enabled !== this.isClipboardEnabled()) {
                if (enabled) {
                    this.enableClipboard();
                }
                else {
                    this.disableClipboard();
                }
            }
        }
        else if (this.isClipboardEnabled()) {
            this.disableClipboard();
        }
        else {
            this.enableClipboard();
        }
        return this;
    }
    isClipboardEmpty() {
        return this.clipboard.isEmpty();
    }
    getCellsInClipboard() {
        return this.clipboard.cells;
    }
    cleanClipboard() {
        this.clipboard.clean();
        return this;
    }
    copy(cells, options = {}) {
        this.clipboard.copy(cells, options);
        return this;
    }
    cut(cells, options = {}) {
        this.clipboard.cut(cells, options);
        return this;
    }
    paste(options = {}, graph = this) {
        return this.clipboard.paste(options, graph);
    }
    // #endregion
    // #region redo/undo
    isHistoryEnabled() {
        return !this.history.disabled;
    }
    enableHistory() {
        this.history.enable();
        return this;
    }
    disableHistory() {
        this.history.disable();
        return this;
    }
    toggleHistory(enabled) {
        if (enabled != null) {
            if (enabled !== this.isHistoryEnabled()) {
                if (enabled) {
                    this.enableHistory();
                }
                else {
                    this.disableHistory();
                }
            }
        }
        else if (this.isHistoryEnabled()) {
            this.disableHistory();
        }
        else {
            this.enableHistory();
        }
        return this;
    }
    undo(options = {}) {
        this.history.undo(options);
        return this;
    }
    undoAndCancel(options = {}) {
        this.history.cancel(options);
        return this;
    }
    redo(options = {}) {
        this.history.redo(options);
        return this;
    }
    canUndo() {
        return this.history.canUndo();
    }
    canRedo() {
        return this.history.canRedo();
    }
    cleanHistory(options = {}) {
        this.history.clean(options);
    }
    // #endregion
    // #region keyboard
    isKeyboardEnabled() {
        return !this.keyboard.disabled;
    }
    enableKeyboard() {
        this.keyboard.enable();
        return this;
    }
    disableKeyboard() {
        this.keyboard.disable();
        return this;
    }
    toggleKeyboard(enabled) {
        if (enabled != null) {
            if (enabled !== this.isKeyboardEnabled()) {
                if (enabled) {
                    this.enableKeyboard();
                }
                else {
                    this.disableKeyboard();
                }
            }
        }
        else if (this.isKeyboardEnabled()) {
            this.disableKeyboard();
        }
        else {
            this.enableKeyboard();
        }
        return this;
    }
    bindKey(keys, callback, action) {
        this.keyboard.on(keys, callback, action);
        return this;
    }
    unbindKey(keys, action) {
        this.keyboard.off(keys, action);
        return this;
    }
    // #endregion
    // #region mousewheel
    isMouseWheelEnabled() {
        return !this.mousewheel.disabled;
    }
    enableMouseWheel() {
        this.mousewheel.enable();
        return this;
    }
    disableMouseWheel() {
        this.mousewheel.disable();
        return this;
    }
    toggleMouseWheel(enabled) {
        if (enabled == null) {
            if (this.isMouseWheelEnabled()) {
                this.disableMouseWheel();
            }
            else {
                this.enableMouseWheel();
            }
        }
        else if (enabled) {
            this.enableMouseWheel();
        }
        else {
            this.disableMouseWheel();
        }
        return this;
    }
    // #endregion
    // #region panning
    isPannable() {
        const scroller = this.scroller.widget;
        if (scroller) {
            return this.scroller.pannable;
        }
        return this.panning.pannable;
    }
    enablePanning() {
        const scroller = this.scroller.widget;
        if (scroller) {
            this.scroller.enablePanning();
        }
        else {
            this.panning.enablePanning();
        }
        return this;
    }
    disablePanning() {
        const scroller = this.scroller.widget;
        if (scroller) {
            this.scroller.disablePanning();
        }
        else {
            this.panning.disablePanning();
        }
        return this;
    }
    togglePanning(pannable) {
        if (pannable == null) {
            if (this.isPannable()) {
                this.disablePanning();
            }
            else {
                this.enablePanning();
            }
        }
        else if (pannable !== this.isPannable()) {
            if (pannable) {
                this.enablePanning();
            }
            else {
                this.disablePanning();
            }
        }
        return this;
    }
    // #endregion
    // #region scroller
    lockScroller() {
        var _a;
        (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.lock();
    }
    unlockScroller() {
        var _a;
        (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.unlock();
    }
    updateScroller() {
        var _a;
        (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.update();
    }
    getScrollbarPosition() {
        const scroller = this.scroller.widget;
        return scroller.scrollbarPosition();
    }
    setScrollbarPosition(left, top, options) {
        const scroller = this.scroller.widget;
        scroller.scrollbarPosition(left, top, options);
        return this;
    }
    /**
     * Try to scroll to ensure that the position (x,y) on the graph (in local
     * coordinates) is at the center of the viewport. If only one of the
     * coordinates is specified, only scroll in the specified dimension and
     * keep the other coordinate unchanged.
     */
    scrollToPoint(x, y, options) {
        const scroller = this.scroller.widget;
        scroller.scrollToPoint(x, y, options);
        return this;
    }
    /**
     * Try to scroll to ensure that the center of graph content is at the
     * center of the viewport.
     */
    scrollToContent(options) {
        const scroller = this.scroller.widget;
        scroller.scrollToContent(options);
        return this;
    }
    /**
     * Try to scroll to ensure that the center of cell is at the center of
     * the viewport.
     */
    scrollToCell(cell, options) {
        const scroller = this.scroller.widget;
        scroller.scrollToCell(cell, options);
        return this;
    }
    transitionToPoint(x, y, options) {
        const scroller = this.scroller.widget;
        scroller.transitionToPoint(x, y, options);
        return this;
    }
    transitionToRect(rect, options = {}) {
        const scroller = this.scroller.widget;
        scroller.transitionToRect(rect, options);
        return this;
    }
    // #endregion
    // #region selection
    isSelectionEnabled() {
        return !this.selection.disabled;
    }
    enableSelection() {
        this.selection.enable();
        return this;
    }
    disableSelection() {
        this.selection.disable();
        return this;
    }
    toggleSelection(enabled) {
        if (enabled != null) {
            if (enabled !== this.isSelectionEnabled()) {
                if (enabled) {
                    this.enableSelection();
                }
                else {
                    this.disableSelection();
                }
            }
        }
        else if (this.isSelectionEnabled()) {
            this.disableSelection();
        }
        else {
            this.enableSelection();
        }
        return this;
    }
    isMultipleSelection() {
        return this.selection.isMultiple();
    }
    enableMultipleSelection() {
        this.selection.enableMultiple();
        return this;
    }
    disableMultipleSelection() {
        this.selection.disableMultiple();
        return this;
    }
    toggleMultipleSelection(multiple) {
        if (multiple != null) {
            if (multiple !== this.isMultipleSelection()) {
                if (multiple) {
                    this.enableMultipleSelection();
                }
                else {
                    this.disableMultipleSelection();
                }
            }
        }
        else if (this.isMultipleSelection()) {
            this.disableMultipleSelection();
        }
        else {
            this.enableMultipleSelection();
        }
        return this;
    }
    isSelectionMovable() {
        return this.selection.widget.options.movable !== false;
    }
    enableSelectionMovable() {
        this.selection.widget.options.movable = true;
        return this;
    }
    disableSelectionMovable() {
        this.selection.widget.options.movable = false;
        return this;
    }
    toggleSelectionMovable(movable) {
        if (movable != null) {
            if (movable !== this.isSelectionMovable()) {
                if (movable) {
                    this.enableSelectionMovable();
                }
                else {
                    this.disableSelectionMovable();
                }
            }
        }
        else if (this.isSelectionMovable()) {
            this.disableSelectionMovable();
        }
        else {
            this.enableSelectionMovable();
        }
        return this;
    }
    isRubberbandEnabled() {
        return !this.selection.rubberbandDisabled;
    }
    enableRubberband() {
        this.selection.enableRubberband();
        return this;
    }
    disableRubberband() {
        this.selection.disableRubberband();
        return this;
    }
    toggleRubberband(enabled) {
        if (enabled != null) {
            if (enabled !== this.isRubberbandEnabled()) {
                if (enabled) {
                    this.enableRubberband();
                }
                else {
                    this.disableRubberband();
                }
            }
        }
        else if (this.isRubberbandEnabled()) {
            this.disableRubberband();
        }
        else {
            this.enableRubberband();
        }
        return this;
    }
    isStrictRubberband() {
        return this.selection.widget.options.strict === true;
    }
    enableStrictRubberband() {
        this.selection.widget.options.strict = true;
        return this;
    }
    disableStrictRubberband() {
        this.selection.widget.options.strict = false;
        return this;
    }
    toggleStrictRubberband(strict) {
        if (strict != null) {
            if (strict !== this.isStrictRubberband()) {
                if (strict) {
                    this.enableStrictRubberband();
                }
                else {
                    this.disableStrictRubberband();
                }
            }
        }
        else if (this.isStrictRubberband()) {
            this.disableStrictRubberband();
        }
        else {
            this.enableStrictRubberband();
        }
        return this;
    }
    setRubberbandModifiers(modifiers) {
        this.selection.setModifiers(modifiers);
    }
    setSelectionFilter(filter) {
        this.selection.setFilter(filter);
        return this;
    }
    setSelectionDisplayContent(content) {
        this.selection.setContent(content);
        return this;
    }
    isSelectionEmpty() {
        return this.selection.isEmpty();
    }
    cleanSelection(options) {
        this.selection.clean(options);
        return this;
    }
    resetSelection(cells, options) {
        this.selection.reset(cells, options);
        return this;
    }
    getSelectedCells() {
        return this.selection.cells;
    }
    getSelectedCellCount() {
        return this.selection.length;
    }
    isSelected(cell) {
        return this.selection.isSelected(cell);
    }
    select(cells, options) {
        this.selection.select(cells, options);
        return this;
    }
    unselect(cells, options) {
        this.selection.unselect(cells, options);
        return this;
    }
    // #endregion
    // #region snapline
    isSnaplineEnabled() {
        return !this.snapline.widget.disabled;
    }
    enableSnapline() {
        this.snapline.widget.enable();
        return this;
    }
    disableSnapline() {
        this.snapline.widget.disable();
        return this;
    }
    toggleSnapline(enabled) {
        if (enabled != null) {
            if (enabled !== this.isSnaplineEnabled()) {
                if (enabled) {
                    this.enableSnapline();
                }
                else {
                    this.disableSnapline();
                }
            }
        }
        else {
            if (this.isSnaplineEnabled()) {
                this.disableSnapline();
            }
            else {
                this.enableSnapline();
            }
            return this;
        }
    }
    hideSnapline() {
        this.snapline.widget.hide();
        return this;
    }
    setSnaplineFilter(filter) {
        this.snapline.widget.setFilter(filter);
        return this;
    }
    isSnaplineOnResizingEnabled() {
        return this.snapline.widget.options.resizing === true;
    }
    enableSnaplineOnResizing() {
        this.snapline.widget.options.resizing = true;
        return this;
    }
    disableSnaplineOnResizing() {
        this.snapline.widget.options.resizing = false;
        return this;
    }
    toggleSnaplineOnResizing(enableOnResizing) {
        if (enableOnResizing != null) {
            if (enableOnResizing !== this.isSnaplineOnResizingEnabled()) {
                if (enableOnResizing) {
                    this.enableSnaplineOnResizing();
                }
                else {
                    this.disableSnaplineOnResizing();
                }
            }
        }
        else if (this.isSnaplineOnResizingEnabled()) {
            this.disableSnaplineOnResizing();
        }
        else {
            this.enableSnaplineOnResizing();
        }
        return this;
    }
    isSharpSnapline() {
        return this.snapline.widget.options.sharp === true;
    }
    enableSharpSnapline() {
        this.snapline.widget.options.sharp = true;
        return this;
    }
    disableSharpSnapline() {
        this.snapline.widget.options.sharp = false;
        return this;
    }
    toggleSharpSnapline(sharp) {
        if (sharp != null) {
            if (sharp !== this.isSharpSnapline()) {
                if (sharp) {
                    this.enableSharpSnapline();
                }
                else {
                    this.disableSharpSnapline();
                }
            }
        }
        else if (this.isSharpSnapline()) {
            this.disableSharpSnapline();
        }
        else {
            this.enableSharpSnapline();
        }
        return this;
    }
    getSnaplineTolerance() {
        return this.snapline.widget.options.tolerance;
    }
    setSnaplineTolerance(tolerance) {
        this.snapline.widget.options.tolerance = tolerance;
        return this;
    }
    // #endregion
    // #region tools
    removeTools() {
        this.emit('tools:remove');
        return this;
    }
    hideTools() {
        this.emit('tools:hide');
        return this;
    }
    showTools() {
        this.emit('tools:show');
        return this;
    }
    // #endregion
    // #region format
    toSVG(callback, options = {}) {
        this.format.toSVG(callback, options);
    }
    toDataURL(callback, options) {
        this.format.toDataURL(callback, options);
    }
    toPNG(callback, options = {}) {
        this.format.toPNG(callback, options);
    }
    toJPEG(callback, options = {}) {
        this.format.toJPEG(callback, options);
    }
    // #endregion
    // #region print
    printPreview(options) {
        this.print.show(options);
    }
    // #endregion
    // #region dispose
    dispose() {
        this.clearCells();
        this.off();
        this.css.dispose();
        this.hook.dispose();
        this.defs.dispose();
        this.grid.dispose();
        this.coord.dispose();
        this.transform.dispose();
        this.knob.dispose();
        this.highlight.dispose();
        this.background.dispose();
        this.clipboard.dispose();
        this.snapline.dispose();
        this.selection.dispose();
        this.history.dispose();
        this.keyboard.dispose();
        this.mousewheel.dispose();
        this.print.dispose();
        this.format.dispose();
        this.minimap.dispose();
        this.panning.dispose();
        this.scroller.dispose();
        this.view.dispose();
        this.renderer.dispose();
        this.size.dispose();
    }
}
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "lockScroller", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "unlockScroller", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "updateScroller", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "getScrollbarPosition", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "setScrollbarPosition", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "scrollToPoint", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "scrollToContent", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "scrollToCell", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "transitionToPoint", null);
__decorate$1([
    Decorator$1.checkScroller()
], Graph.prototype, "transitionToRect", null);
__decorate$1([
    Basecoat.dispose()
], Graph.prototype, "dispose", null);
(function (Graph) {
    /* eslint-disable @typescript-eslint/no-unused-vars */
    Graph.View = GraphView;
    Graph.Hook = Hook;
    Graph.Renderer = Renderer;
    Graph.Keyboard = Keyboard;
    Graph.MouseWheel = MouseWheel;
    Graph.BaseManager = Base;
    Graph.DefsManager = DefsManager;
    Graph.GridManager = GridManager;
    Graph.CoordManager = CoordManager;
    Graph.PrintManager = PrintManager;
    Graph.FormatManager = FormatManager;
    Graph.MiniMapManager = MiniMapManager;
    Graph.HistoryManager = HistoryManager;
    Graph.SnaplineManager = SnaplineManager;
    Graph.ScrollerManager = ScrollerManager;
    Graph.ClipboardManager = ClipboardManager;
    Graph.TransformManager = TransformManager;
    Graph.HighlightManager = HighlightManager;
    Graph.BackgroundManager = BackgroundManager;
    Graph.SelectionManager = SelectionManager;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.toStringTag = `X6.${Graph.name}`;
    function isGraph(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Graph) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const graph = instance;
        if ((tag == null || tag === Graph.toStringTag) &&
            graph.hook != null &&
            graph.view != null &&
            graph.model != null) {
            return true;
        }
        return false;
    }
    Graph.isGraph = isGraph;
})(Graph || (Graph = {}));
(function (Graph) {
    function render(options, data) {
        const graph = options instanceof HTMLElement
            ? new Graph({ container: options })
            : new Graph(options);
        if (data != null) {
            graph.fromJSON(data);
        }
        return graph;
    }
    Graph.render = render;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.registerNode = Node$1.registry.register;
    Graph.registerEdge = Edge$1.registry.register;
    Graph.registerView = CellView.registry.register;
    Graph.registerAttr = Attr.registry.register;
    Graph.registerGrid = Grid.registry.register;
    Graph.registerFilter = Filter.registry.register;
    Graph.registerNodeTool = NodeTool.registry.register;
    Graph.registerEdgeTool = EdgeTool.registry.register;
    Graph.registerBackground = Background.registry.register;
    Graph.registerHighlighter = Highlighter.registry.register;
    Graph.registerPortLayout = PortLayout.registry.register;
    Graph.registerPortLabelLayout = PortLabelLayout.registry.register;
    Graph.registerMarker = Marker.registry.register;
    Graph.registerRouter = Router.registry.register;
    Graph.registerConnector = Connector.registry.register;
    Graph.registerAnchor = NodeAnchor.registry.register;
    Graph.registerEdgeAnchor = EdgeAnchor.registry.register;
    Graph.registerConnectionPoint = ConnectionPoint.registry.register;
    Graph.registerConnectionStrategy = ConnectionStrategy.registry.register;
    Graph.registerHTMLComponent = HTML.componentRegistry.register;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.unregisterNode = Node$1.registry.unregister;
    Graph.unregisterEdge = Edge$1.registry.unregister;
    Graph.unregisterView = CellView.registry.unregister;
    Graph.unregisterAttr = Attr.registry.unregister;
    Graph.unregisterGrid = Grid.registry.unregister;
    Graph.unregisterFilter = Filter.registry.unregister;
    Graph.unregisterNodeTool = NodeTool.registry.unregister;
    Graph.unregisterEdgeTool = EdgeTool.registry.unregister;
    Graph.unregisterBackground = Background.registry.unregister;
    Graph.unregisterHighlighter = Highlighter.registry.unregister;
    Graph.unregisterPortLayout = PortLayout.registry.unregister;
    Graph.unregisterPortLabelLayout = PortLabelLayout.registry.unregister;
    Graph.unregisterMarker = Marker.registry.unregister;
    Graph.unregisterRouter = Router.registry.unregister;
    Graph.unregisterConnector = Connector.registry.unregister;
    Graph.unregisterAnchor = NodeAnchor.registry.unregister;
    Graph.unregisterEdgeAnchor = EdgeAnchor.registry.unregister;
    Graph.unregisterConnectionPoint = ConnectionPoint.registry.unregister;
    Graph.unregisterConnectionStrategy = ConnectionStrategy.registry.unregister;
    Graph.unregisterHTMLComponent = HTML.componentRegistry.unregister;
})(Graph || (Graph = {}));

class Clipboard {
    constructor() {
        this.cells = [];
    }
    copy(cells, graph, options = {}) {
        this.options = Object.assign({}, options);
        const model = Model.isModel(graph) ? graph : graph.model;
        const cloned = model.cloneSubGraph(cells, options);
        // sort asc by cell type
        this.cells = sortBy(Object.keys(cloned).map((key) => cloned[key]), (cell) => (cell.isEdge() ? 2 : 1));
        this.serialize(options);
    }
    cut(cells, graph, options = {}) {
        this.copy(cells, graph, options);
        const model = Graph.isGraph(graph) ? graph.model : graph;
        model.batchUpdate('cut', () => {
            cells.forEach((cell) => cell.remove());
        });
    }
    paste(graph, options = {}) {
        const localOptions = Object.assign(Object.assign({}, this.options), options);
        const { offset, edgeProps, nodeProps } = localOptions;
        let dx = 20;
        let dy = 20;
        if (offset) {
            dx = typeof offset === 'number' ? offset : offset.dx;
            dy = typeof offset === 'number' ? offset : offset.dy;
        }
        this.deserialize(localOptions);
        const cells = this.cells;
        cells.forEach((cell) => {
            cell.model = null;
            cell.removeProp('zIndex');
            if (dx || dy) {
                cell.translate(dx, dy);
            }
            if (nodeProps && cell.isNode()) {
                cell.prop(nodeProps);
            }
            if (edgeProps && cell.isEdge()) {
                cell.prop(edgeProps);
            }
        });
        const model = Graph.isGraph(graph) ? graph.model : graph;
        model.batchUpdate('paste', () => {
            model.addCells(this.cells);
        });
        this.copy(cells, graph, options);
        return cells;
    }
    serialize(options) {
        if (options.useLocalStorage !== false) {
            Storage.save(this.cells);
        }
    }
    deserialize(options) {
        if (options.useLocalStorage) {
            const cells = Storage.fetch();
            if (cells) {
                this.cells = cells;
            }
        }
    }
    isEmpty() {
        return this.cells.length <= 0;
    }
    clean() {
        this.options = {};
        this.cells = [];
        Storage.clean();
    }
}
var Storage;
(function (Storage) {
    const LOCAL_STORAGE_KEY = `${Config.prefixCls}.clipboard.cells`;
    function save(cells) {
        if (window.localStorage) {
            const data = cells.map((cell) => cell.toJSON());
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
        }
    }
    Storage.save = save;
    function fetch() {
        if (window.localStorage) {
            const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
            const cells = raw ? JSON.parse(raw) : [];
            if (cells) {
                return Model.fromJSON(cells);
            }
        }
    }
    Storage.fetch = fetch;
    function clean() {
        if (window.localStorage) {
            localStorage.removeItem(LOCAL_STORAGE_KEY);
        }
    }
    Storage.clean = clean;
})(Storage || (Storage = {}));

class NodePreset {
    constructor(halo) {
        this.halo = halo;
    }
    get options() {
        return this.halo.options;
    }
    get graph() {
        return this.halo.graph;
    }
    get model() {
        return this.halo.model;
    }
    get view() {
        return this.halo.view;
    }
    get cell() {
        return this.halo.cell;
    }
    get node() {
        return this.cell;
    }
    getPresets() {
        return {
            className: 'type-node',
            handles: [
                {
                    name: 'remove',
                    position: 'nw',
                    events: {
                        mousedown: this.removeCell.bind(this),
                    },
                    icon: null,
                },
                {
                    name: 'resize',
                    position: 'se',
                    events: {
                        mousedown: this.startResize.bind(this),
                        mousemove: this.doResize.bind(this),
                        mouseup: this.stopResize.bind(this),
                    },
                    icon: null,
                },
                {
                    name: 'clone',
                    position: 'n',
                    events: {
                        mousedown: this.startClone.bind(this),
                        mousemove: this.doClone.bind(this),
                        mouseup: this.stopClone.bind(this),
                    },
                    icon: null,
                },
                {
                    name: 'link',
                    position: 'e',
                    events: {
                        mousedown: this.startLink.bind(this),
                        mousemove: this.doLink.bind(this),
                        mouseup: this.stopLink.bind(this),
                    },
                    icon: null,
                },
                {
                    name: 'fork',
                    position: 'ne',
                    events: {
                        mousedown: this.startFork.bind(this),
                        mousemove: this.doFork.bind(this),
                        mouseup: this.stopFork.bind(this),
                    },
                    icon: null,
                },
                {
                    name: 'unlink',
                    position: 'w',
                    events: {
                        mousedown: this.unlink.bind(this),
                    },
                    icon: null,
                },
                {
                    name: 'rotate',
                    position: 'sw',
                    events: {
                        mousedown: this.startRotate.bind(this),
                        mousemove: this.doRotate.bind(this),
                        mouseup: this.stopRotate.bind(this),
                    },
                    icon: null,
                },
            ],
            bbox(view) {
                if (this.options.useCellGeometry) {
                    const node = view.cell;
                    return node.getBBox();
                }
                return view.getBBox();
            },
            content(view) {
                const template$1 = template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');
                const cell = view.cell;
                const bbox = cell.getBBox();
                return template$1({
                    x: Math.floor(bbox.x),
                    y: Math.floor(bbox.y),
                    width: Math.floor(bbox.width),
                    height: Math.floor(bbox.height),
                    angle: Math.floor(cell.getAngle()),
                });
            },
            magnet(view) {
                return view.container;
            },
            tinyThreshold: 40,
            smallThreshold: 80,
            loopEdgePreferredSide: 'top',
            loopEdgeWidth: 40,
            rotateGrid: 15,
            rotateEmbeds: false,
        };
    }
    removeCell() {
        this.model.removeConnectedEdges(this.cell);
        this.cell.remove();
    }
    // #region create edge
    startLink({ x, y }) {
        this.halo.startBatch();
        const graph = this.graph;
        const edge = this.createEdgeConnectedToSource();
        edge.setTarget({ x, y });
        this.model.addEdge(edge, {
            validation: false,
            halo: this.halo.cid,
            async: false,
        });
        graph.view.undelegateEvents();
        this.edgeView = graph.renderer.findViewByCell(edge);
        this.edgeView.prepareArrowheadDragging('target', {
            x,
            y,
            fallbackAction: 'remove',
        });
    }
    createEdgeConnectedToSource() {
        const magnet = this.getMagnet(this.view, 'source');
        const terminal = this.getEdgeTerminal(this.view, magnet);
        const edge = this.graph.hook.getDefaultEdge(this.view, magnet);
        edge.setSource(terminal);
        return edge;
    }
    getMagnet(view, terminal) {
        const magnet = this.options.magnet;
        if (typeof magnet === 'function') {
            const val = call(magnet, this.halo, view, terminal);
            if (val instanceof SVGElement) {
                return val;
            }
        }
        throw new Error('`magnet()` has to return an SVGElement');
    }
    getEdgeTerminal(view, magnet) {
        const terminal = {
            cell: view.cell.id,
        };
        if (magnet !== view.container) {
            const port = magnet.getAttribute('port');
            if (port) {
                terminal.port = port;
            }
            else {
                terminal.selector = view.getSelector(magnet);
            }
        }
        return terminal;
    }
    doLink({ e, x, y }) {
        if (this.edgeView) {
            this.edgeView.onMouseMove(e, x, y);
        }
    }
    stopLink({ e, x, y }) {
        const edgeView = this.edgeView;
        if (edgeView) {
            edgeView.onMouseUp(e, x, y);
            const edge = edgeView.cell;
            if (edge.hasLoop()) {
                this.makeLoopEdge(edge);
            }
            this.halo.stopBatch();
            this.halo.trigger('action:edge:addde', { edge });
            this.edgeView = null;
        }
        this.graph.view.delegateEvents();
    }
    makeLoopEdge(edge) {
        let vertex1 = null;
        let vertex2 = null;
        const loopEdgeWidth = this.options.loopEdgeWidth;
        const graphOptions = this.graph.options;
        const graphRect = new Rectangle(0, 0, graphOptions.width, graphOptions.height);
        const bbox = this.graph.graphToLocal(this.view.getBBox());
        const found = [
            this.options.loopEdgePreferredSide,
            'top',
            'bottom',
            'left',
            'right',
        ].some((position) => {
            let point = null;
            let dx = 0;
            let dy = 0;
            switch (position) {
                case 'top':
                    point = new Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);
                    dx = loopEdgeWidth / 2;
                    break;
                case 'bottom':
                    point = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);
                    dx = loopEdgeWidth / 2;
                    break;
                case 'left':
                    point = new Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);
                    dy = loopEdgeWidth / 2;
                    break;
                case 'right':
                    point = new Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);
                    dy = loopEdgeWidth / 2;
                    break;
                default:
                    break;
            }
            if (point) {
                vertex1 = point.translate(-dx, -dy);
                vertex2 = point.translate(dx, dy);
                return (graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2));
            }
            return false;
        });
        if (found && vertex1 && vertex2) {
            edge.setVertices([vertex1, vertex2]);
        }
    }
    // #endregion
    // #region resize
    startResize({ e }) {
        this.halo.startBatch();
        this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(Angle.normalize(this.node.getAngle()) / 45)];
        this.view.addClass('node-resizing');
        notify('node:resize', e, this.view);
    }
    doResize({ e, dx, dy }) {
        const size = this.node.getSize();
        const width = Math.max(size.width + (this.flip ? dx : dy), 1);
        const height = Math.max(size.height + (this.flip ? dy : dx), 1);
        this.node.resize(width, height, {
            absolute: true,
        });
        notify('node:resizing', e, this.view);
    }
    stopResize({ e }) {
        this.view.removeClass('node-resizing');
        notify('node:resized', e, this.view);
        this.halo.stopBatch();
    }
    // #endregion
    // #region clone
    startClone({ e, x, y }) {
        this.halo.startBatch();
        const options = this.options;
        const cloned = options.clone(this.cell, {
            clone: true,
        });
        if (!Cell.isCell(cloned)) {
            throw new Error("option 'clone()' has to return a cell");
        }
        this.centerNodeAtCursor(cloned, x, y);
        this.model.addCell(cloned, {
            halo: this.halo.cid,
            async: false,
        });
        const cloneView = this.graph.renderer.findViewByCell(cloned);
        cloneView.onMouseDown(e, x, y);
        this.halo.setEventData(e, { cloneView });
    }
    centerNodeAtCursor(cell, x, y) {
        const center = cell.getBBox().getCenter();
        const dx = x - center.x;
        const dy = y - center.y;
        cell.translate(dx, dy);
    }
    doClone({ e, x, y }) {
        const view = this.halo.getEventData(e).cloneView;
        if (view) {
            view.onMouseMove(e, x, y);
        }
    }
    stopClone({ e, x, y }) {
        const nodeView = this.halo.getEventData(e).cloneView;
        if (nodeView) {
            nodeView.onMouseUp(e, x, y);
        }
        this.halo.stopBatch();
    }
    // #endregion
    // #region fork
    startFork({ e, x, y }) {
        this.halo.startBatch();
        const cloned = this.options.clone(this.cell, {
            fork: true,
        });
        if (!Cell.isCell(cloned)) {
            throw new Error("option 'clone()' has to return a cell");
        }
        this.centerNodeAtCursor(cloned, x, y);
        this.model.addCell(cloned, {
            halo: this.halo.cid,
            async: false,
        });
        const edge = this.createEdgeConnectedToSource();
        const cloneView = this.graph.renderer.findViewByCell(cloned);
        const magnet = this.getMagnet(cloneView, 'target');
        const terminal = this.getEdgeTerminal(cloneView, magnet);
        edge.setTarget(terminal);
        this.model.addEdge(edge, {
            halo: this.halo.cid,
            async: false,
        });
        cloneView.onMouseDown(e, x, y);
        this.halo.setEventData(e, { cloneView });
    }
    doFork({ e, x, y }) {
        const view = this.halo.getEventData(e).cloneView;
        if (view) {
            view.onMouseMove(e, x, y);
        }
    }
    stopFork({ e, x, y }) {
        const view = this.halo.getEventData(e).cloneView;
        if (view) {
            view.onMouseUp(e, x, y);
        }
        this.halo.stopBatch();
    }
    // #endregion
    // #region rotate
    startRotate({ e, x, y }) {
        this.halo.startBatch();
        const center = this.node.getBBox().getCenter();
        const nodes = [this.node];
        if (this.options.rotateEmbeds) {
            this.node
                .getDescendants({
                deep: true,
            })
                .reduce((memo, cell) => {
                if (cell.isNode()) {
                    memo.push(cell);
                }
                return memo;
            }, nodes);
        }
        this.halo.setEventData(e, {
            center,
            nodes,
            rotateStartAngles: nodes.map((node) => node.getAngle()),
            clientStartAngle: new Point(x, y).theta(center),
        });
        nodes.forEach((node) => {
            const view = this.graph.findViewByCell(node);
            if (view) {
                view.addClass('node-rotating');
                notify('node:rotate', e, view);
            }
        });
    }
    doRotate({ e, x, y }) {
        const data = this.halo.getEventData(e);
        const delta = data.clientStartAngle - new Point(x, y).theta(data.center);
        data.nodes.forEach((node, index) => {
            const startAngle = data.rotateStartAngles[index];
            const targetAngle = Util$3.snapToGrid(startAngle + delta, this.options.rotateGrid);
            node.rotate(targetAngle, {
                absolute: true,
                center: data.center,
                halo: this.halo.cid,
            });
            notify('node:rotating', e, this.graph.findViewByCell(node));
        });
    }
    stopRotate({ e }) {
        const data = this.halo.getEventData(e);
        data.nodes.forEach((node) => {
            const view = this.graph.findViewByCell(node);
            view.removeClass('node-rotating');
            notify('node:rotated', e, view);
        });
        this.halo.stopBatch();
    }
    // #endregion
    // #region unlink
    unlink() {
        this.halo.startBatch();
        this.model.removeConnectedEdges(this.cell);
        this.halo.stopBatch();
    }
}

class EdgePreset {
    constructor(halo) {
        this.halo = halo;
    }
    get options() {
        return this.halo.options;
    }
    get graph() {
        return this.halo.graph;
    }
    get model() {
        return this.halo.model;
    }
    get view() {
        return this.halo.view;
    }
    get cell() {
        return this.halo.cell;
    }
    get edge() {
        return this.cell;
    }
    getPresets() {
        return {
            className: 'type-edge',
            handles: [
                {
                    name: 'remove',
                    position: 'nw',
                    icon: null,
                    events: {
                        mousedown: this.removeEdge.bind(this),
                    },
                },
                {
                    name: 'direction',
                    position: 'se',
                    icon: null,
                    events: {
                        mousedown: this.directionSwap.bind(this),
                    },
                },
            ],
            content: false,
            bbox(view) {
                return view.graph.localToGraph(view.getPointAtRatio(0.5));
            },
            tinyThreshold: -1,
            smallThreshold: -1,
        };
    }
    removeEdge() {
        this.cell.remove();
    }
    directionSwap() {
        const source = this.edge.getSource();
        const target = this.edge.getTarget();
        this.edge.prop({
            source: target,
            target: source,
        });
    }
}

class Halo extends Widget {
    get type() {
        return this.options.type || 'surround';
    }
    get handleOptions() {
        return this.options;
    }
    init(options) {
        this.options = merge(Halo.defaultOptions, this.cell.isNode()
            ? new NodePreset(this).getPresets()
            : this.cell.isEdge()
                ? new EdgePreset(this).getPresets()
                : null, options);
        this.render();
        this.initHandles();
        this.update();
        this.startListening();
    }
    startListening() {
        const model = this.model;
        const graph = this.graph;
        const cell = this.view.cell;
        cell.on('removed', this.remove, this);
        model.on('reseted', this.remove, this);
        graph.on('halo:destroy', this.remove, this);
        model.on('*', this.update, this);
        graph.on('scale', this.update, this);
        graph.on('translate', this.update, this);
        super.startListening();
    }
    stopListening() {
        const model = this.model;
        const graph = this.graph;
        const cell = this.view.cell;
        this.undelegateEvents();
        cell.off('removed', this.remove, this);
        model.off('reseted', this.remove, this);
        graph.off('halo:destroy', this.remove, this);
        model.off('*', this.update, this);
        graph.off('scale', this.update, this);
        graph.off('translate', this.update, this);
        super.stopListening();
    }
    render() {
        const options = this.options;
        const cls = this.prefixClassName('widget-halo');
        this.view.addClass(Private$1.NODE_CLS);
        this.container = document.createElement('div');
        this.$container = this.$(this.container)
            .addClass(cls)
            .attr('data-shape', this.view.cell.shape);
        if (options.className) {
            this.$container.addClass(options.className);
        }
        this.$handleContainer = this.$('<div/>')
            .addClass(`${cls}-handles`)
            .appendTo(this.container);
        this.$content = this.$('<div/>')
            .addClass(`${cls}-content`)
            .appendTo(this.container);
        this.$container.appendTo(this.graph.container);
        return this;
    }
    remove() {
        this.stopBatch();
        this.view.removeClass(Private$1.NODE_CLS);
        return super.remove();
    }
    update() {
        if (this.isRendered()) {
            this.updateContent();
            const bbox = this.getBBox();
            const tinyThreshold = this.options.tinyThreshold || 0;
            const smallThreshold = this.options.smallThreshold || 0;
            this.$handleContainer.toggleClass(`${this.handleClassName}-tiny`, bbox.width < tinyThreshold && bbox.height < tinyThreshold);
            const className = `${this.handleClassName}-small`;
            this.$handleContainer.toggleClass(className, !this.$handleContainer.hasClass(className) &&
                bbox.width < smallThreshold &&
                bbox.height < smallThreshold);
            this.$container.css({
                width: bbox.width,
                height: bbox.height,
                left: bbox.x,
                top: bbox.y,
            });
            if (this.hasHandle('unlink')) {
                this.toggleUnlink();
            }
            if (this.type === 'surround' || this.type === 'toolbar') {
                if (this.hasHandle('fork')) {
                    this.toggleFork();
                }
            }
        }
    }
    updateContent() {
        const content = this.options.content;
        if (typeof content === 'function') {
            const ret = call(content, this, this.view, this.$content[0]);
            if (ret) {
                this.$content.html(ret);
            }
        }
        else if (content) {
            this.$content.html(content);
        }
        else {
            this.$content.remove();
        }
    }
    getBBox() {
        const view = this.view;
        const bbox = this.options.bbox;
        const rect = typeof bbox === 'function' ? call(bbox, this, view) : bbox;
        return Rectangle.create(Object.assign({ x: 0, y: 0, width: 1, height: 1 }, rect));
    }
    removeCell() {
        this.cell.remove();
    }
    toggleFork() {
        const cell = this.view.cell.clone();
        const view = this.graph.hook.createCellView(cell);
        const valid = this.graph.hook.validateConnection(this.view, null, view, null, 'target');
        this.$handleContainer.children('.fork').toggleClass('hidden', !valid);
        view.remove();
    }
    toggleUnlink() {
        const hasEdges = this.model.getConnectedEdges(this.view.cell).length > 0;
        this.$handleContainer.children('.unlink').toggleClass('hidden', !hasEdges);
    }
    // #region batch
    startBatch() {
        this.model.startBatch('halo', {
            halo: this.cid,
        });
    }
    stopBatch() {
        if (this.model.hasActiveBatch('halo')) {
            this.model.stopBatch('halo', {
                halo: this.cid,
            });
        }
    }
}
(function (Halo) {
    Halo.defaultOptions = {
        type: 'surround',
        clearAll: true,
        clearOnBlankMouseDown: true,
        useCellGeometry: false,
        clone: (cell) => cell.clone().removeZIndex(),
    };
})(Halo || (Halo = {}));
Object.getOwnPropertyNames(Handle.prototype).forEach((name) => {
    if (name !== 'constructor') {
        Object.defineProperty(Halo.prototype, name, Object.getOwnPropertyDescriptor(Handle.prototype, name));
    }
});
var Private$1;
(function (Private) {
    Private.NODE_CLS = 'has-widget-halo';
})(Private$1 || (Private$1 = {}));

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Dnd extends View {
    constructor(options) {
        super();
        this.options = Object.assign(Object.assign({}, Dnd.defaults), options);
        this.container = document.createElement('div');
        this.$container = this.$(this.container).addClass(this.prefixClassName('widget-dnd'));
        this.draggingGraph = new Graph(Object.assign(Object.assign({}, this.options.delegateGraphOptions), { container: document.createElement('div'), width: 1, height: 1 }));
        this.$container.append(this.draggingGraph.container);
    }
    get targetScroller() {
        const target = this.options.target;
        return Graph.isGraph(target) ? target.scroller.widget : target;
    }
    get targetGraph() {
        const target = this.options.target;
        return Graph.isGraph(target) ? target : target.graph;
    }
    get targetModel() {
        return this.targetGraph.model;
    }
    get snapline() {
        return this.targetGraph.snapline.widget;
    }
    start(node, evt) {
        const e = evt;
        e.preventDefault();
        this.targetModel.startBatch('dnd');
        this.$container
            .addClass('dragging')
            .appendTo(this.options.draggingContainer || document.body);
        this.sourceNode = node;
        this.prepareDragging(node, e.clientX, e.clientY);
        const local = this.updateNodePosition(e.clientX, e.clientY);
        if (this.isSnaplineEnabled()) {
            this.snapline.captureCursorOffset({
                e,
                node,
                cell: node,
                view: this.draggingView,
                x: local.x,
                y: local.y,
            });
            this.draggingNode.on('change:position', this.snap, this);
        }
        this.delegateDocumentEvents(Dnd.documentEvents, e.data);
    }
    isSnaplineEnabled() {
        return this.snapline && !this.snapline.disabled;
    }
    prepareDragging(sourceNode, clientX, clientY) {
        const draggingGraph = this.draggingGraph;
        const draggingModel = draggingGraph.model;
        const draggingNode = this.options.getDragNode(sourceNode, {
            sourceNode,
            draggingGraph,
            targetGraph: this.targetGraph,
        });
        draggingNode.position(0, 0);
        let padding = 5;
        if (this.isSnaplineEnabled()) {
            padding += this.snapline.options.tolerance || 0;
        }
        if (this.isSnaplineEnabled() || this.options.scaled) {
            const scale = this.targetGraph.transform.getScale();
            draggingGraph.scale(scale.sx, scale.sy);
            padding *= Math.max(scale.sx, scale.sy);
        }
        else {
            draggingGraph.scale(1, 1);
        }
        this.clearDragging();
        if (this.options.animation) {
            this.$container.stop(true, true);
        }
        draggingModel.resetCells([draggingNode]);
        const delegateView = draggingGraph.findViewByCell(draggingNode);
        delegateView.undelegateEvents();
        delegateView.cell.off('changed');
        draggingGraph.fitToContent({
            padding,
            allowNewOrigin: 'any',
        });
        const bbox = delegateView.getBBox();
        this.geometryBBox = delegateView.getBBox({ useCellGeometry: true });
        this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());
        this.draggingNode = draggingNode;
        this.draggingView = delegateView;
        this.draggingBBox = draggingNode.getBBox();
        this.padding = padding;
        this.originOffset = this.updateGraphPosition(clientX, clientY);
    }
    updateGraphPosition(clientX, clientY) {
        const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        const delta = this.delta;
        const nodeBBox = this.geometryBBox;
        const padding = this.padding || 5;
        const offset = {
            left: clientX - delta.x - nodeBBox.width / 2 - padding,
            top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop,
        };
        if (this.draggingGraph) {
            this.$container.offset(offset);
        }
        return offset;
    }
    updateNodePosition(x, y) {
        const local = this.targetGraph.clientToLocal(x, y);
        const bbox = this.draggingBBox;
        local.x -= bbox.width / 2;
        local.y -= bbox.height / 2;
        this.draggingNode.position(local.x, local.y);
        return local;
    }
    snap({ cell, current, options, }) {
        const node = cell;
        if (options.snapped) {
            const bbox = this.draggingBBox;
            node.position(bbox.x + options.tx, bbox.y + options.ty, { silent: true });
            this.draggingView.translate();
            node.position(current.x, current.y, { silent: true });
            this.snapOffset = {
                x: options.tx,
                y: options.ty,
            };
        }
        else {
            this.snapOffset = null;
        }
    }
    onDragging(evt) {
        const draggingView = this.draggingView;
        if (draggingView) {
            evt.preventDefault();
            const e = this.normalizeEvent(evt);
            const clientX = e.clientX;
            const clientY = e.clientY;
            this.updateGraphPosition(clientX, clientY);
            const local = this.updateNodePosition(clientX, clientY);
            const embeddingMode = this.targetGraph.options.embedding.enabled;
            const isValidArea = (embeddingMode || this.isSnaplineEnabled()) &&
                this.isInsideValidArea({
                    x: clientX,
                    y: clientY,
                });
            if (embeddingMode) {
                draggingView.setEventData(e, {
                    graph: this.targetGraph,
                    candidateEmbedView: this.candidateEmbedView,
                });
                const data = draggingView.getEventData(e);
                if (isValidArea) {
                    draggingView.processEmbedding(e, data);
                }
                else {
                    draggingView.clearEmbedding(data);
                }
                this.candidateEmbedView = data.candidateEmbedView;
            }
            // update snapline
            if (this.isSnaplineEnabled()) {
                if (isValidArea) {
                    this.snapline.snapOnMoving({
                        e,
                        view: draggingView,
                        x: local.x,
                        y: local.y,
                    });
                }
                else {
                    this.snapline.hide();
                }
            }
        }
    }
    onDragEnd(evt) {
        const draggingNode = this.draggingNode;
        if (draggingNode) {
            const e = this.normalizeEvent(evt);
            const draggingView = this.draggingView;
            const draggingBBox = this.draggingBBox;
            const snapOffset = this.snapOffset;
            let x = draggingBBox.x;
            let y = draggingBBox.y;
            if (snapOffset) {
                x += snapOffset.x;
                y += snapOffset.y;
            }
            draggingNode.position(x, y, { silent: true });
            const ret = this.drop(draggingNode, { x: e.clientX, y: e.clientY });
            const callback = (node) => {
                if (node) {
                    this.onDropped(draggingNode);
                    if (this.targetGraph.options.embedding.enabled && draggingView) {
                        draggingView.setEventData(e, {
                            cell: node,
                            graph: this.targetGraph,
                            candidateEmbedView: this.candidateEmbedView,
                        });
                        draggingView.finalizeEmbedding(e, draggingView.getEventData(e));
                    }
                }
                else {
                    this.onDropInvalid();
                }
                this.candidateEmbedView = null;
                this.targetModel.stopBatch('dnd');
            };
            if (isAsync(ret)) {
                // stop dragging
                this.undelegateDocumentEvents();
                ret.then(callback); // eslint-disable-line
            }
            else {
                callback(ret);
            }
        }
    }
    clearDragging() {
        if (this.draggingNode) {
            this.sourceNode = null;
            this.draggingNode.remove();
            this.draggingNode = null;
            this.draggingView = null;
            this.delta = null;
            this.padding = null;
            this.snapOffset = null;
            this.originOffset = null;
            this.undelegateDocumentEvents();
        }
    }
    onDropped(draggingNode) {
        if (this.draggingNode === draggingNode) {
            this.clearDragging();
            this.$container.removeClass('dragging').remove();
        }
    }
    onDropInvalid() {
        const draggingNode = this.draggingNode;
        if (draggingNode) {
            const anim = this.options.animation;
            if (anim) {
                const duration = (typeof anim === 'object' && anim.duration) || 150;
                const easing = (typeof anim === 'object' && anim.easing) || 'swing';
                this.draggingView = null;
                this.$container.animate(this.originOffset, duration, easing, () => this.onDropped(draggingNode));
            }
            else {
                this.onDropped(draggingNode);
            }
        }
    }
    isInsideValidArea(p) {
        let targetRect;
        let dndRect = null;
        const targetGraph = this.targetGraph;
        const targetScroller = this.targetScroller;
        if (this.options.dndContainer) {
            dndRect = this.getDropArea(this.options.dndContainer);
        }
        const isInsideDndRect = dndRect && dndRect.containsPoint(p);
        if (targetScroller) {
            if (targetScroller.options.autoResize) {
                targetRect = this.getDropArea(targetScroller.container);
            }
            else {
                const outter = this.getDropArea(targetScroller.container);
                targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(outter);
            }
        }
        else {
            targetRect = this.getDropArea(targetGraph.container);
        }
        return !isInsideDndRect && targetRect && targetRect.containsPoint(p);
    }
    getDropArea(elem) {
        const $elem = this.$(elem);
        const offset = $elem.offset();
        const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
        return Rectangle.create({
            x: offset.left + parseInt($elem.css('border-left-width'), 10) - scrollLeft,
            y: offset.top + parseInt($elem.css('border-top-width'), 10) - scrollTop,
            width: $elem.innerWidth(),
            height: $elem.innerHeight(),
        });
    }
    drop(draggingNode, pos) {
        if (this.isInsideValidArea(pos)) {
            const targetGraph = this.targetGraph;
            const targetModel = targetGraph.model;
            const local = targetGraph.clientToLocal(pos);
            const sourceNode = this.sourceNode;
            const droppingNode = this.options.getDropNode(draggingNode, {
                sourceNode,
                draggingNode,
                targetGraph: this.targetGraph,
                draggingGraph: this.draggingGraph,
            });
            const bbox = droppingNode.getBBox();
            local.x += bbox.x - bbox.width / 2;
            local.y += bbox.y - bbox.height / 2;
            const gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();
            droppingNode.position(Util$3.snapToGrid(local.x, gridSize), Util$3.snapToGrid(local.y, gridSize));
            droppingNode.removeZIndex();
            const validateNode = this.options.validateNode;
            const ret = validateNode
                ? validateNode(droppingNode, {
                    sourceNode,
                    draggingNode,
                    droppingNode,
                    targetGraph,
                    draggingGraph: this.draggingGraph,
                })
                : true;
            if (typeof ret === 'boolean') {
                if (ret) {
                    targetModel.addCell(droppingNode, { stencil: this.cid });
                    return droppingNode;
                }
                return null;
            }
            return toDeferredBoolean(ret).then((valid) => {
                if (valid) {
                    targetModel.addCell(droppingNode, { stencil: this.cid });
                    return droppingNode;
                }
                return null;
            });
        }
        return null;
    }
    onRemove() {
        if (this.draggingGraph) {
            this.draggingGraph.view.remove();
            this.draggingGraph.dispose();
        }
    }
    dispose() {
        this.remove();
    }
}
__decorate([
    View.dispose()
], Dnd.prototype, "dispose", null);
(function (Dnd) {
    Dnd.defaults = {
        animation: false,
        getDragNode: (sourceNode) => sourceNode.clone(),
        getDropNode: (draggingNode) => draggingNode.clone(),
    };
    Dnd.documentEvents = {
        mousemove: 'onDragging',
        touchmove: 'onDragging',
        mouseup: 'onDragEnd',
        touchend: 'onDragEnd',
        touchcancel: 'onDragEnd',
    };
})(Dnd || (Dnd = {}));

function grid(cells, options = {}) {
    const model = Model.isModel(cells)
        ? cells
        : new Model().resetCells(cells, {
            sort: false,
            dryrun: true,
        });
    const nodes = model.getNodes();
    const columns = options.columns || 1;
    const rows = Math.ceil(nodes.length / columns);
    const dx = options.dx || 0;
    const dy = options.dy || 0;
    const centre = options.center !== false;
    const resizeToFit = options.resizeToFit === true;
    const marginX = options.marginX || 0;
    const marginY = options.marginY || 0;
    const columnWidths = [];
    let columnWidth = options.columnWidth;
    if (columnWidth === 'compact') {
        for (let j = 0; j < columns; j += 1) {
            const items = GridLayout.getNodesInColumn(nodes, j, columns);
            columnWidths.push(GridLayout.getMaxDim(items, 'width') + dx);
        }
    }
    else {
        if (columnWidth == null || columnWidth === 'auto') {
            columnWidth = GridLayout.getMaxDim(nodes, 'width') + dx;
        }
        for (let i = 0; i < columns; i += 1) {
            columnWidths.push(columnWidth);
        }
    }
    const columnLefts = GridLayout.accumulate(columnWidths, marginX);
    const rowHeights = [];
    let rowHeight = options.rowHeight;
    if (rowHeight === 'compact') {
        for (let i = 0; i < rows; i += 1) {
            const items = GridLayout.getNodesInRow(nodes, i, columns);
            rowHeights.push(GridLayout.getMaxDim(items, 'height') + dy);
        }
    }
    else {
        if (rowHeight == null || rowHeight === 'auto') {
            rowHeight = GridLayout.getMaxDim(nodes, 'height') + dy;
        }
        for (let i = 0; i < rows; i += 1) {
            rowHeights.push(rowHeight);
        }
    }
    const rowTops = GridLayout.accumulate(rowHeights, marginY);
    model.startBatch('layout');
    nodes.forEach((node, index) => {
        const rowIndex = index % columns;
        const columnIndex = Math.floor(index / columns);
        const columnWidth = columnWidths[rowIndex];
        const rowHeight = rowHeights[columnIndex];
        let cx = 0;
        let cy = 0;
        let size = node.getSize();
        if (resizeToFit) {
            let width = columnWidth - 2 * dx;
            let height = rowHeight - 2 * dy;
            const calcHeight = size.height * (size.width ? width / size.width : 1);
            const calcWidth = size.width * (size.height ? height / size.height : 1);
            if (rowHeight < calcHeight) {
                width = calcWidth;
            }
            else {
                height = calcHeight;
            }
            size = {
                width,
                height,
            };
            node.setSize(size, options);
        }
        if (centre) {
            cx = (columnWidth - size.width) / 2;
            cy = (rowHeight - size.height) / 2;
        }
        node.position(columnLefts[rowIndex] + dx + cx, rowTops[columnIndex] + dy + cy, options);
    });
    model.stopBatch('layout');
}
var GridLayout;
(function (GridLayout) {
    function getMaxDim(nodes, name) {
        return nodes.reduce((memo, node) => Math.max(node.getSize()[name], memo), 0);
    }
    GridLayout.getMaxDim = getMaxDim;
    function getNodesInRow(nodes, rowIndex, columnCount) {
        const res = [];
        for (let i = columnCount * rowIndex, ii = i + columnCount; i < ii; i += 1) {
            res.push(nodes[i]);
        }
        return res;
    }
    GridLayout.getNodesInRow = getNodesInRow;
    function getNodesInColumn(nodes, columnIndex, columnCount) {
        const res = [];
        for (let i = columnIndex, ii = nodes.length; i < ii; i += columnCount) {
            res.push(nodes[i]);
        }
        return res;
    }
    GridLayout.getNodesInColumn = getNodesInColumn;
    function accumulate(items, start) {
        return items.reduce((memo, item, i) => {
            memo.push(memo[i] + item);
            return memo;
        }, [start || 0]);
    }
    GridLayout.accumulate = accumulate;
})(GridLayout || (GridLayout = {}));

class Stencil extends View {
    constructor(options) {
        super();
        this.graphs = {};
        this.$groups = {};
        this.options = Object.assign(Object.assign({}, Stencil.defaultOptions), options);
        this.dnd = new Dnd(this.options);
        this.onSearch = debounce$1(this.onSearch, 200);
        this.container = document.createElement('div');
        this.$container = this.$(this.container)
            .addClass(this.prefixClassName(ClassNames.base))
            .attr('data-not-found-text', this.options.notFoundText || 'No matches found');
        this.options.collapsable =
            options.collapsable &&
                options.groups &&
                options.groups.some((group) => group.collapsable !== false);
        if (this.options.collapsable) {
            this.$container.addClass('collapsable');
            const collapsed = options.groups &&
                options.groups.every((group) => group.collapsed || group.collapsable === false);
            if (collapsed) {
                this.$container.addClass('collapsed');
            }
        }
        this.$('<div/>')
            .addClass(this.prefixClassName(ClassNames.title))
            .html(this.options.title)
            .appendTo(this.$container);
        if (options.search) {
            this.$container.addClass('searchable').append(this.renderSearch());
        }
        this.$content = this.$('<div/>')
            .addClass(this.prefixClassName(ClassNames.content))
            .appendTo(this.$container);
        const globalGraphOptions = options.stencilGraphOptions || {};
        if (options.groups && options.groups.length) {
            options.groups.forEach((group) => {
                const $group = this.$('<div/>')
                    .addClass(this.prefixClassName(ClassNames.group))
                    .attr('data-name', group.name);
                if ((group.collapsable == null && options.collapsable) ||
                    group.collapsable !== false) {
                    $group.addClass('collapsable');
                }
                $group.toggleClass('collapsed', group.collapsed === true);
                const $title = this.$('<h3/>')
                    .addClass(this.prefixClassName(ClassNames.groupTitle))
                    .html(group.title || group.name);
                const $content = this.$('<div/>').addClass(this.prefixClassName(ClassNames.groupContent));
                const graphOptionsInGroup = group.graphOptions;
                const graph = new Graph(Object.assign(Object.assign(Object.assign({}, globalGraphOptions), graphOptionsInGroup), { container: document.createElement('div'), model: globalGraphOptions.model || new Model(), width: group.graphWidth || options.stencilGraphWidth, height: group.graphHeight || options.stencilGraphHeight, interacting: false, preventDefaultBlankAction: false }));
                $content.append(graph.container);
                $group.append($title, $content).appendTo(this.$content);
                this.$groups[group.name] = $group;
                this.graphs[group.name] = graph;
            });
        }
        else {
            const graph = new Graph(Object.assign(Object.assign({}, globalGraphOptions), { container: document.createElement('div'), model: globalGraphOptions.model || new Model(), width: options.stencilGraphWidth, height: options.stencilGraphHeight, interacting: false, preventDefaultBlankAction: false }));
            this.$content.append(graph.container);
            this.graphs[Private.defaultGroupName] = graph;
        }
        this.startListening();
        return this;
    }
    get targetScroller() {
        const target = this.options.target;
        return Graph.isGraph(target) ? target.scroller.widget : target;
    }
    get targetGraph() {
        const target = this.options.target;
        return Graph.isGraph(target) ? target : target.graph;
    }
    get targetModel() {
        return this.targetGraph.model;
    }
    renderSearch() {
        return this.$('<div/>')
            .addClass(this.prefixClassName(ClassNames.search))
            .append(this.$('<input/>')
            .attr({
            type: 'search',
            placeholder: this.options.placeholder || 'Search',
        })
            .addClass(this.prefixClassName(ClassNames.searchText)));
    }
    startListening() {
        const title = this.prefixClassName(ClassNames.title);
        const searchText = this.prefixClassName(ClassNames.searchText);
        const groupTitle = this.prefixClassName(ClassNames.groupTitle);
        this.delegateEvents({
            [`click .${title}`]: 'onTitleClick',
            [`touchstart .${title}`]: 'onTitleClick',
            [`click .${groupTitle}`]: 'onGroupTitleClick',
            [`touchstart .${groupTitle}`]: 'onGroupTitleClick',
            [`input .${searchText}`]: 'onSearch',
            [`focusin .${searchText}`]: 'onSearchFocusIn',
            [`focusout .${searchText}`]: 'onSearchFocusOut',
        });
        Object.keys(this.graphs).forEach((groupName) => {
            const graph = this.graphs[groupName];
            graph.on('cell:mousedown', this.onDragStart, this);
        });
    }
    stopListening() {
        this.undelegateEvents();
        Object.keys(this.graphs).forEach((groupName) => {
            const graph = this.graphs[groupName];
            graph.off('cell:mousedown', this.onDragStart, this);
        });
    }
    load(data, groupName) {
        if (Array.isArray(data)) {
            this.loadGroup(data, groupName);
        }
        else if (this.options.groups) {
            Object.keys(this.options.groups).forEach((groupName) => {
                if (data[groupName]) {
                    this.loadGroup(data[groupName], groupName);
                }
            });
        }
        return this;
    }
    loadGroup(cells, groupName) {
        const model = this.getModel(groupName);
        if (model) {
            const nodes = cells.map((cell) => Node$1.isNode(cell) ? cell : Node$1.create(cell));
            model.resetCells(nodes);
        }
        const group = this.getGroup(groupName);
        let height = this.options.stencilGraphHeight;
        if (group && group.graphHeight != null) {
            height = group.graphHeight;
        }
        const layout = (group && group.layout) || this.options.layout;
        if (layout && model) {
            call(layout, this, model, group);
        }
        if (!height) {
            const graph = this.getGraph(groupName);
            graph.fitToContent({
                minWidth: graph.options.width,
                gridHeight: 1,
                padding: (group && group.graphPadding) ||
                    this.options.stencilGraphPadding ||
                    10,
            });
        }
        return this;
    }
    onDragStart(args) {
        const { e, node } = args;
        this.dnd.start(node, e);
    }
    filter(keyword, filter) {
        const found = Object.keys(this.graphs).reduce((memo, groupName) => {
            const graph = this.graphs[groupName];
            const name = groupName === Private.defaultGroupName ? null : groupName;
            const items = graph.model.getNodes().filter((cell) => {
                let matched = false;
                if (typeof filter === 'function') {
                    matched = call(filter, this, cell, keyword, name, this);
                }
                else if (typeof filter === 'boolean') {
                    matched = filter;
                }
                else {
                    matched = this.isCellMatched(cell, keyword, filter, keyword.toLowerCase() !== keyword);
                }
                const view = graph.renderer.findViewByCell(cell);
                if (view) {
                    view.$(view.container).toggleClass('unmatched', !matched);
                }
                return matched;
            });
            const found = items.length > 0;
            const options = this.options;
            const model = new Model();
            model.resetCells(items);
            if (options.layout) {
                call(options.layout, this, model, this.getGroup(groupName));
            }
            if (this.$groups[groupName]) {
                this.$groups[groupName].toggleClass('unmatched', !found);
            }
            graph.fitToContent({
                gridWidth: 1,
                gridHeight: 1,
                padding: options.stencilGraphPadding || 10,
            });
            return memo || found;
        }, false);
        this.$container.toggleClass('not-found', !found);
    }
    isCellMatched(cell, keyword, filters, ignoreCase) {
        if (keyword && filters) {
            return Object.keys(filters).some((shape) => {
                if (shape === '*' || cell.shape === shape) {
                    const filter = filters[shape];
                    if (typeof filter === 'boolean') {
                        return filter;
                    }
                    const paths = Array.isArray(filter) ? filter : [filter];
                    return paths.some((path) => {
                        let val = cell.getPropByPath(path);
                        if (val != null) {
                            val = `${val}`;
                            if (!ignoreCase) {
                                val = val.toLowerCase();
                            }
                            return val.indexOf(keyword) >= 0;
                        }
                        return false;
                    });
                }
                return false;
            });
        }
        return true;
    }
    onSearch(evt) {
        this.filter(evt.target.value, this.options.search);
    }
    onSearchFocusIn() {
        this.$container.addClass('is-focused');
    }
    onSearchFocusOut() {
        this.$container.removeClass('is-focused');
    }
    onTitleClick() {
        if (this.options.collapsable) {
            this.$container.toggleClass('collapsed');
            if (this.$container.hasClass('collapsed')) {
                this.collapseGroups();
            }
            else {
                this.expandGroups();
            }
        }
    }
    onGroupTitleClick(evt) {
        const $group = this.$(evt.target).closest(`.${this.prefixClassName(ClassNames.group)}`);
        this.toggleGroup($group.attr('data-name') || '');
        const allCollapsed = Object.keys(this.$groups).every((name) => {
            const group = this.getGroup(name);
            const $group = this.$groups[name];
            return ((group && group.collapsable === false) || $group.hasClass('collapsed'));
        });
        this.$container.toggleClass('collapsed', allCollapsed);
    }
    getModel(groupName) {
        const graph = this.getGraph(groupName);
        return graph ? graph.model : null;
    }
    getGraph(groupName) {
        return this.graphs[groupName || Private.defaultGroupName];
    }
    getGroup(groupName) {
        const groups = this.options.groups;
        if (groupName != null && groups && groups.length) {
            return groups.find((group) => group.name === groupName);
        }
        return null;
    }
    toggleGroup(groupName) {
        if (this.isGroupCollapsed(groupName)) {
            this.expandGroup(groupName);
        }
        else {
            this.collapseGroup(groupName);
        }
        return this;
    }
    collapseGroup(groupName) {
        if (this.isGroupCollapsable(groupName)) {
            const $group = this.$groups[groupName];
            if ($group && !this.isGroupCollapsed(groupName)) {
                this.trigger('group:collapse', { name: groupName });
                $group.addClass('collapsed');
            }
        }
        return this;
    }
    expandGroup(groupName) {
        if (this.isGroupCollapsable(groupName)) {
            const $group = this.$groups[groupName];
            if ($group && this.isGroupCollapsed(groupName)) {
                this.trigger('group:expand', { name: groupName });
                $group.removeClass('collapsed');
            }
        }
        return this;
    }
    isGroupCollapsable(groupName) {
        const $group = this.$groups[groupName];
        return $group.hasClass('collapsable');
    }
    isGroupCollapsed(groupName) {
        const $group = this.$groups[groupName];
        return $group && $group.hasClass('collapsed');
    }
    collapseGroups() {
        Object.keys(this.$groups).forEach((groupName) => this.collapseGroup(groupName));
        return this;
    }
    expandGroups() {
        Object.keys(this.$groups).forEach((groupName) => this.expandGroup(groupName));
        return this;
    }
    resizeGroup(groupName, size) {
        const graph = this.graphs[groupName];
        if (graph) {
            graph.resize(size.width, size.height);
        }
        return this;
    }
    onRemove() {
        Object.keys(this.graphs).forEach((groupName) => {
            const graph = this.graphs[groupName];
            graph.view.remove();
            delete this.graphs[groupName];
        });
        this.dnd.remove();
        this.stopListening();
        this.undelegateDocumentEvents();
    }
}
(function (Stencil) {
    Stencil.defaultOptions = Object.assign({ stencilGraphWidth: 200, stencilGraphHeight: 800, title: 'Stencil', collapsable: false, placeholder: 'Search', notFoundText: 'No matches found', layout(model, group) {
            const options = {
                columnWidth: this.options.stencilGraphWidth / 2 - 10,
                columns: 2,
                rowHeight: 80,
                resizeToFit: false,
                dx: 10,
                dy: 10,
            };
            grid(model, Object.assign(Object.assign(Object.assign({}, options), this.options.layoutOptions), (group ? group.layoutOptions : {})));
        } }, Dnd.defaults);
})(Stencil || (Stencil = {}));
var ClassNames;
(function (ClassNames) {
    ClassNames.base = 'widget-stencil';
    ClassNames.title = `${ClassNames.base}-title`;
    ClassNames.search = `${ClassNames.base}-search`;
    ClassNames.searchText = `${ClassNames.search}-text`;
    ClassNames.content = `${ClassNames.base}-content`;
    ClassNames.group = `${ClassNames.base}-group`;
    ClassNames.groupTitle = `${ClassNames.group}-title`;
    ClassNames.groupContent = `${ClassNames.group}-content`;
})(ClassNames || (ClassNames = {}));
var Private;
(function (Private) {
    Private.defaultGroupName = '__default__';
})(Private || (Private = {}));

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get AutoSave () { return AutoSave; },
	Clipboard: Clipboard,
	get Dnd () { return Dnd; },
	get Halo () { return Halo; },
	Knob: Knob,
	MiniMap: MiniMap,
	get Scroller () { return Scroller; },
	Selection: Selection,
	Snapline: Snapline,
	get Stencil () { return Stencil; },
	Transform: Transform
});

var util$5 = {};

var util$4 = {};

var polyfill = {};

var platform = {};

var hasRequiredPlatform;

function requirePlatform () {
	if (hasRequiredPlatform) return platform;
	hasRequiredPlatform = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Platform = void 0;
		/* eslint-disable no-underscore-dangle */
		var _IS_MAC = false;
		var _IS_IOS = false;
		var _IS_WINDOWS = false;
		var _IS_IE = false;
		var _IS_IE11 = false;
		var _IS_EDGE = false;
		var _IS_NETSCAPE = false;
		var _IS_CHROME_APP = false;
		var _IS_CHROME = false;
		var _IS_OPERA = false;
		var _IS_FIREFOX = false;
		var _IS_SAFARI = false;
		var _SUPPORT_TOUCH = false;
		var _SUPPORT_POINTER = false;
		var _SUPPORT_PASSIVE = false;
		var _NO_FOREIGNOBJECT = false;
		if (typeof navigator === 'object') {
		    var ua = navigator.userAgent;
		    _IS_MAC = ua.indexOf('Macintosh') >= 0;
		    _IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g);
		    _IS_WINDOWS = ua.indexOf('Windows') >= 0;
		    _IS_IE = ua.indexOf('MSIE') >= 0;
		    _IS_IE11 = !!ua.match(/Trident\/7\./);
		    _IS_EDGE = !!ua.match(/Edge\//);
		    _IS_NETSCAPE =
		        ua.indexOf('Mozilla/') >= 0 &&
		            ua.indexOf('MSIE') < 0 &&
		            ua.indexOf('Edge/') < 0;
		    _IS_CHROME = ua.indexOf('Chrome/') >= 0 && ua.indexOf('Edge/') < 0;
		    _IS_OPERA = ua.indexOf('Opera/') >= 0 || ua.indexOf('OPR/') >= 0;
		    _IS_FIREFOX = ua.indexOf('Firefox/') >= 0;
		    _IS_SAFARI =
		        ua.indexOf('AppleWebKit/') >= 0 &&
		            ua.indexOf('Chrome/') < 0 &&
		            ua.indexOf('Edge/') < 0;
		    if (typeof document === 'object') {
		        _NO_FOREIGNOBJECT =
		            !document.createElementNS ||
		                "" + document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject') !== '[object SVGForeignObjectElement]' ||
		                ua.indexOf('Opera/') >= 0;
		    }
		}
		if (typeof window === 'object') {
		    _IS_CHROME_APP =
		        window.chrome != null &&
		            window.chrome.app != null &&
		            window.chrome.app.runtime != null;
		    _SUPPORT_POINTER = window.PointerEvent != null && !_IS_MAC;
		}
		if (typeof document === 'object') {
		    _SUPPORT_TOUCH = 'ontouchstart' in document.documentElement;
		    try {
		        var options = Object.defineProperty({}, 'passive', {
		            get: function () {
		                _SUPPORT_PASSIVE = true;
		            },
		        });
		        var div = document.createElement('div');
		        if (div.addEventListener) {
		            div.addEventListener('click', function () { }, options);
		        }
		    }
		    catch (err) {
		        // pass
		    }
		}
		var Platform;
		(function (Platform) {
		    Platform.IS_MAC = _IS_MAC;
		    Platform.IS_IOS = _IS_IOS;
		    Platform.IS_WINDOWS = _IS_WINDOWS;
		    Platform.IS_IE = _IS_IE;
		    Platform.IS_IE11 = _IS_IE11;
		    Platform.IS_EDGE = _IS_EDGE;
		    /**
		     * A flag indicating whether the browser is Netscape (including Firefox).
		     */
		    Platform.IS_NETSCAPE = _IS_NETSCAPE;
		    /**
		     * A flag indicating whether the the this is running inside a Chrome App.
		     */
		    Platform.IS_CHROME_APP = _IS_CHROME_APP;
		    Platform.IS_CHROME = _IS_CHROME;
		    Platform.IS_OPERA = _IS_OPERA;
		    Platform.IS_FIREFOX = _IS_FIREFOX;
		    Platform.IS_SAFARI = _IS_SAFARI;
		    /**
		     * A flag indicating whether this device supports touchstart/-move/-end
		     * events (Apple iOS, Android, Chromebook and Chrome Browser on touch-enabled
		     * devices).
		     */
		    Platform.SUPPORT_TOUCH = _SUPPORT_TOUCH;
		    /**
		     * A flag indicating whether this device supports Microsoft pointer events.
		     */
		    Platform.SUPPORT_POINTER = _SUPPORT_POINTER;
		    Platform.SUPPORT_PASSIVE = _SUPPORT_PASSIVE;
		    /**
		     * A flag indicating whether foreignObject support is not available. This
		     * is the case for Opera, older SVG-based browsers and all versions of IE.
		     */
		    Platform.NO_FOREIGNOBJECT = _NO_FOREIGNOBJECT;
		    Platform.SUPPORT_FOREIGNOBJECT = !Platform.NO_FOREIGNOBJECT;
		})(Platform = exports.Platform || (exports.Platform = {}));
		(function (Platform) {
		    function getHMRStatus() {
		        var mod = window.module;
		        if (mod != null && mod.hot != null && mod.hot.status != null) {
		            return mod.hot.status();
		        }
		        return 'unkonwn';
		    }
		    Platform.getHMRStatus = getHMRStatus;
		    function isApplyingHMR() {
		        return getHMRStatus() === 'apply';
		    }
		    Platform.isApplyingHMR = isApplyingHMR;
		    // This function checks if the specified event is supported by the browser.
		    // Source: http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
		    var TAGNAMES = {
		        select: 'input',
		        change: 'input',
		        submit: 'form',
		        reset: 'form',
		        error: 'img',
		        load: 'img',
		        abort: 'img',
		    };
		    function isEventSupported(event) {
		        var elem = document.createElement(TAGNAMES[event] || 'div');
		        var eventName = "on" + event;
		        var isSupported = eventName in elem;
		        if (!isSupported) {
		            elem.setAttribute(eventName, 'return;');
		            isSupported = typeof elem[eventName] === 'function';
		        }
		        return isSupported;
		    }
		    Platform.isEventSupported = isEventSupported;
		})(Platform = exports.Platform || (exports.Platform = {}));
		
	} (platform));
	return platform;
}

var hasRequiredPolyfill;

function requirePolyfill () {
	if (hasRequiredPolyfill) return polyfill;
	hasRequiredPolyfill = 1;
	"use strict";
	var __importDefault = (polyfill && polyfill.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(polyfill, "__esModule", { value: true });
	var jquery_1 = __importDefault(requireJquery());
	requireJquery_mousewheel();
	var platform_1 = requirePlatform();
	if (platform_1.Platform.SUPPORT_PASSIVE) {
	    jquery_1.default.event.special.touchstart = {
	        setup: function (data, ns, handle) {
	            if (!this.addEventListener) {
	                return false;
	            }
	            this.addEventListener('touchstart', handle, {
	                passive: true,
	            });
	        },
	    };
	    var hook = jquery_1.default.event.special.mousewheel;
	    if (hook) {
	        var setup_1 = hook.setup;
	        hook.setup = function () {
	            var _this = this;
	            var addEventListener = this.addEventListener;
	            if (!addEventListener) {
	                return false;
	            }
	            this.addEventListener = function (name, handler) {
	                addEventListener.call(_this, name, handler, { passive: true });
	            };
	            setup_1.call(this);
	            this.addEventListener = addEventListener;
	        };
	    }
	}
	// compatible with NodeList.prototype.forEach() before chrome 51
	// https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
	if (window.NodeList && !NodeList.prototype.forEach) {
	    NodeList.prototype.forEach = Array.prototype.forEach;
	}
	// compatible with ParentNode.append() before chrome 54
	// https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/append()/append().md
	;
	(function (arr) {
	    arr.forEach(function (item) {
	        if (Object.prototype.hasOwnProperty.call(item, 'append')) {
	            return;
	        }
	        Object.defineProperty(item, 'append', {
	            configurable: true,
	            enumerable: true,
	            writable: true,
	            value: function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                var docFrag = document.createDocumentFragment();
	                args.forEach(function (arg) {
	                    var isNode = arg instanceof Node;
	                    docFrag.appendChild(isNode ? arg : document.createTextNode(String(arg)));
	                });
	                this.appendChild(docFrag);
	            },
	        });
	    });
	})([Element.prototype, Document.prototype, DocumentFragment.prototype]);
	
	return polyfill;
}

var lang$1 = {};

var lang = {};

var require$$0 = /*@__PURE__*/getAugmentedNamespace(lodash);

var hasRequiredLang$1;

function requireLang$1 () {
	if (hasRequiredLang$1) return lang;
	hasRequiredLang$1 = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isNumeric = exports.isWindow = exports.isFunction = exports.isArrayLike = exports.isArray = exports.isObject = exports.isBoolean = exports.isNumber = exports.isString = exports.isUndefined = exports.isNil = exports.isNull = void 0;
		var lodash_es_1 = require$$0;
		Object.defineProperty(exports, "isNull", { enumerable: true, get: function () { return lodash_es_1.isNull; } });
		Object.defineProperty(exports, "isNil", { enumerable: true, get: function () { return lodash_es_1.isNil; } });
		Object.defineProperty(exports, "isUndefined", { enumerable: true, get: function () { return lodash_es_1.isUndefined; } });
		Object.defineProperty(exports, "isString", { enumerable: true, get: function () { return lodash_es_1.isString; } });
		Object.defineProperty(exports, "isNumber", { enumerable: true, get: function () { return lodash_es_1.isNumber; } });
		Object.defineProperty(exports, "isBoolean", { enumerable: true, get: function () { return lodash_es_1.isBoolean; } });
		Object.defineProperty(exports, "isObject", { enumerable: true, get: function () { return lodash_es_1.isObject; } });
		Object.defineProperty(exports, "isArray", { enumerable: true, get: function () { return lodash_es_1.isArray; } });
		Object.defineProperty(exports, "isArrayLike", { enumerable: true, get: function () { return lodash_es_1.isArrayLike; } });
		Object.defineProperty(exports, "isFunction", { enumerable: true, get: function () { return lodash_es_1.isFunction; } });
		var isWindow = function (value) {
		    return value && value === value.window;
		};
		exports.isWindow = isWindow;
		var isNumeric = function (value) {
		    return !Array.isArray(value) && value - parseFloat(value) + 1 >= 0;
		};
		exports.isNumeric = isNumeric;
		
	} (lang));
	return lang;
}

var hasRequiredLang;

function requireLang () {
	if (hasRequiredLang) return lang$1;
	hasRequiredLang = 1;
	"use strict";
	var __createBinding = (lang$1 && lang$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (lang$1 && lang$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (lang$1 && lang$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(lang$1, "__esModule", { value: true });
	lang$1.Lang = void 0;
	var Lang = __importStar(requireLang$1());
	lang$1.Lang = Lang;
	
	return lang$1;
}

var array$1 = {};

var array = {};

var diff = {};

var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff;
	hasRequiredDiff = 1;
	"use strict";
	Object.defineProperty(diff, "__esModule", { value: true });
	diff.diff = void 0;
	function diff$1(oldList, newList, key) {
	    var oldMap = makeKeyIndexAndFree(oldList, key);
	    var newMap = makeKeyIndexAndFree(newList, key);
	    var newFree = newMap.free;
	    var oldKeyIndex = oldMap.keyIndex;
	    var newKeyIndex = newMap.keyIndex;
	    var moves = [];
	    var children = [];
	    var i = 0;
	    var item;
	    var itemKey;
	    var freeIndex = 0;
	    while (i < oldList.length) {
	        item = oldList[i];
	        itemKey = item[key];
	        if (itemKey) {
	            // eslint-disable-next-line
	            if (!newKeyIndex.hasOwnProperty(itemKey)) {
	                children.push(null);
	            }
	            else {
	                var newItemIndex = newKeyIndex[itemKey];
	                children.push(newList[newItemIndex]);
	            }
	        }
	        else {
	            freeIndex += 1;
	            var freeItem = newFree[freeIndex];
	            children.push(freeItem || null);
	        }
	        i += 1;
	    }
	    var simulateList = children.slice(0);
	    i = 0;
	    while (i < simulateList.length) {
	        if (simulateList[i] === null) {
	            remove(i);
	            removeSimulate(i);
	        }
	        else {
	            i += 1;
	        }
	    }
	    var j = (i = 0);
	    while (i < newList.length) {
	        item = newList[i];
	        itemKey = item[key];
	        var simulateItem = simulateList[j];
	        if (simulateItem) {
	            var simulateItemKey = simulateItem[key];
	            if (itemKey === simulateItemKey) {
	                j += 1;
	            }
	            else {
	                // eslint-disable-next-line
	                if (!oldKeyIndex.hasOwnProperty(itemKey)) {
	                    insert(i, item);
	                }
	                else {
	                    var nextSimulateItem = simulateList[j + 1];
	                    if (nextSimulateItem) {
	                        var nextItemKey = nextSimulateItem[key];
	                        if (nextItemKey === itemKey) {
	                            remove(i);
	                            removeSimulate(j);
	                            j += 1;
	                        }
	                        else {
	                            insert(i, item);
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            insert(i, item);
	        }
	        i += 1;
	    }
	    var k = simulateList.length - j;
	    while ((j += 1) < simulateList.length) {
	        k -= 1;
	        remove(k + i);
	    }
	    function remove(index) {
	        var move = { index: index, type: 0, item: null };
	        moves.push(move);
	    }
	    function insert(index, item) {
	        var move = { index: index, item: item, type: 1 };
	        moves.push(move);
	    }
	    function removeSimulate(index) {
	        simulateList.splice(index, 1);
	    }
	    return {
	        moves: moves,
	    };
	}
	diff.diff = diff$1;
	function makeKeyIndexAndFree(list, key) {
	    var keyIndex = {};
	    var free = [];
	    for (var i = 0, len = list.length; i < len; i += 1) {
	        var item = list[i];
	        var itemKey = item[key];
	        if (itemKey) {
	            keyIndex[itemKey] = i;
	        }
	        else {
	            free.push(item);
	        }
	    }
	    return {
	        keyIndex: keyIndex,
	        free: free,
	    };
	}
	
	return diff;
}

var hasRequiredArray$1;

function requireArray$1 () {
	if (hasRequiredArray$1) return array;
	hasRequiredArray$1 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (array && array.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (array && array.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.max = exports.difference = exports.groupBy = exports.sortBy = exports.sortedIndexBy = exports.sortedIndex = exports.union = exports.uniq = exports.isArrayLike = exports.isArray = void 0;
		var lodash_es_1 = require$$0;
		Object.defineProperty(exports, "isArray", { enumerable: true, get: function () { return lodash_es_1.isArray; } });
		Object.defineProperty(exports, "isArrayLike", { enumerable: true, get: function () { return lodash_es_1.isArrayLike; } });
		Object.defineProperty(exports, "uniq", { enumerable: true, get: function () { return lodash_es_1.uniq; } });
		Object.defineProperty(exports, "union", { enumerable: true, get: function () { return lodash_es_1.union; } });
		Object.defineProperty(exports, "sortedIndex", { enumerable: true, get: function () { return lodash_es_1.sortedIndex; } });
		Object.defineProperty(exports, "sortedIndexBy", { enumerable: true, get: function () { return lodash_es_1.sortedIndexBy; } });
		Object.defineProperty(exports, "sortBy", { enumerable: true, get: function () { return lodash_es_1.sortBy; } });
		Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return lodash_es_1.groupBy; } });
		Object.defineProperty(exports, "difference", { enumerable: true, get: function () { return lodash_es_1.difference; } });
		Object.defineProperty(exports, "max", { enumerable: true, get: function () { return lodash_es_1.max; } });
		__exportStar(requireDiff(), exports);
		
	} (array));
	return array;
}

var hasRequiredArray;

function requireArray () {
	if (hasRequiredArray) return array$1;
	hasRequiredArray = 1;
	"use strict";
	var __createBinding = (array$1 && array$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (array$1 && array$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (array$1 && array$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(array$1, "__esModule", { value: true });
	array$1.ArrayExt = void 0;
	var ArrayExt = __importStar(requireArray$1());
	array$1.ArrayExt = ArrayExt;
	
	return array$1;
}

var object$2 = {};

var object$1 = {};

var mixins = {};

var hasRequiredMixins;

function requireMixins () {
	if (hasRequiredMixins) return mixins;
	hasRequiredMixins = 1;
	"use strict";
	Object.defineProperty(mixins, "__esModule", { value: true });
	mixins.applyMixins = void 0;
	/**
	 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
	 */
	function applyMixins(derivedCtor) {
	    var baseCtors = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        baseCtors[_i - 1] = arguments[_i];
	    }
	    baseCtors.forEach(function (baseCtor) {
	        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
	            if (name !== 'constructor') {
	                Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
	            }
	        });
	    });
	}
	mixins.applyMixins = applyMixins;
	
	return mixins;
}

var inherit = {};

var hasRequiredInherit;

function requireInherit () {
	if (hasRequiredInherit) return inherit;
	hasRequiredInherit = 1;
	"use strict";
	var __extends = (inherit && inherit.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(inherit, "__esModule", { value: true });
	inherit.createClass = inherit.inherit = void 0;
	var extendStatics = Object.setPrototypeOf ||
	    ({ __proto__: [] } instanceof Array &&
	        function (d, b) {
	            d.__proto__ = b; // eslint-disable-line no-proto
	        }) ||
	    function (d, b) {
	        // eslint-disable-next-line no-restricted-syntax
	        for (var p in b) {
	            if (Object.prototype.hasOwnProperty.call(b, p)) {
	                d[p] = b[p];
	            }
	        }
	    };
	/**
	 * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309
	 */
	// eslint-disable-next-line
	function inherit$1(cls, base) {
	    extendStatics(cls, base);
	    function tmp() {
	        this.constructor = cls;
	    }
	    cls.prototype =
	        base === null
	            ? Object.create(base)
	            : ((tmp.prototype = base.prototype), new tmp());
	}
	inherit.inherit = inherit$1;
	var A = /** @class */ (function () {
	    function A() {
	    }
	    return A;
	}());
	var isNativeClass = /^\s*class\s+/.test("" + A) || /^\s*class\s*\{/.test("" + /** @class */ (function () {
	    function class_1() {
	    }
	    return class_1;
	}()));
	/**
	 * Extends class with specified class name.
	 */
	function createClass(className, base) {
	    var cls;
	    if (isNativeClass) {
	        cls = /** @class */ (function (_super) {
	            __extends(cls, _super);
	            function cls() {
	                return _super !== null && _super.apply(this, arguments) || this;
	            }
	            return cls;
	        }(base));
	    }
	    else {
	        cls = function () {
	            return base.apply(this, arguments); // eslint-disable-line
	        };
	        inherit$1(cls, base);
	    }
	    Object.defineProperty(cls, 'name', { value: className });
	    return cls;
	}
	inherit.createClass = createClass;
	
	return inherit;
}

var hasRequiredObject$2;

function requireObject$2 () {
	if (hasRequiredObject$2) return object$1;
	hasRequiredObject$2 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (object$1 && object$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (object$1 && object$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.flatten = exports.unsetByPath = exports.setByPath = exports.getByPath = exports.isMaliciousProp = exports.getBoolean = exports.getNumber = exports.getValue = exports.ensure = exports.defaultsDeep = exports.defaults = exports.cloneDeep = exports.clone = exports.isPlainObject = exports.isObject = exports.isEmpty = exports.isEqual = exports.extend = exports.merge = exports.forIn = exports.pick = exports.has = void 0;
		var lodash_es_1 = require$$0;
		Object.defineProperty(exports, "has", { enumerable: true, get: function () { return lodash_es_1.has; } });
		Object.defineProperty(exports, "pick", { enumerable: true, get: function () { return lodash_es_1.pick; } });
		Object.defineProperty(exports, "forIn", { enumerable: true, get: function () { return lodash_es_1.forIn; } });
		Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return lodash_es_1.merge; } });
		Object.defineProperty(exports, "extend", { enumerable: true, get: function () { return lodash_es_1.extend; } });
		Object.defineProperty(exports, "isEqual", { enumerable: true, get: function () { return lodash_es_1.isEqual; } });
		Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return lodash_es_1.isEmpty; } });
		Object.defineProperty(exports, "isObject", { enumerable: true, get: function () { return lodash_es_1.isObject; } });
		Object.defineProperty(exports, "isPlainObject", { enumerable: true, get: function () { return lodash_es_1.isPlainObject; } });
		Object.defineProperty(exports, "clone", { enumerable: true, get: function () { return lodash_es_1.clone; } });
		Object.defineProperty(exports, "cloneDeep", { enumerable: true, get: function () { return lodash_es_1.cloneDeep; } });
		Object.defineProperty(exports, "defaults", { enumerable: true, get: function () { return lodash_es_1.defaults; } });
		Object.defineProperty(exports, "defaultsDeep", { enumerable: true, get: function () { return lodash_es_1.defaultsDeep; } });
		__exportStar(requireMixins(), exports);
		__exportStar(requireInherit(), exports);
		function ensure(value, defaultValue) {
		    return value != null ? value : defaultValue;
		}
		exports.ensure = ensure;
		function getValue(obj, key, defaultValue) {
		    var value = obj != null ? obj[key] : null;
		    return defaultValue !== undefined ? ensure(value, defaultValue) : value;
		}
		exports.getValue = getValue;
		function getNumber(obj, key, defaultValue) {
		    var value = obj != null ? obj[key] : null;
		    if (value == null) {
		        return defaultValue;
		    }
		    value = +value;
		    if (Number.isNaN(value) || !Number.isFinite(value)) {
		        return defaultValue;
		    }
		    return value;
		}
		exports.getNumber = getNumber;
		function getBoolean(obj, key, defaultValue) {
		    var value = obj != null ? obj[key] : null;
		    if (value == null) {
		        return defaultValue;
		    }
		    return !!value;
		}
		exports.getBoolean = getBoolean;
		function isMaliciousProp(prop) {
		    return prop === '__proto__';
		}
		exports.isMaliciousProp = isMaliciousProp;
		function getByPath(obj, path, delimiter) {
		    if (delimiter === void 0) { delimiter = '/'; }
		    var ret;
		    var keys = Array.isArray(path) ? path : path.split(delimiter);
		    if (keys.length) {
		        ret = obj;
		        while (keys.length) {
		            var key = keys.shift();
		            if (Object(ret) === ret && key && key in ret) {
		                ret = ret[key];
		            }
		            else {
		                return undefined;
		            }
		        }
		    }
		    return ret;
		}
		exports.getByPath = getByPath;
		function setByPath(obj, path, value, delimiter) {
		    if (delimiter === void 0) { delimiter = '/'; }
		    var keys = Array.isArray(path) ? path : path.split(delimiter);
		    var lastKey = keys.pop();
		    if (lastKey && !isMaliciousProp(lastKey)) {
		        var diver_1 = obj;
		        keys.forEach(function (key) {
		            if (!isMaliciousProp(key)) {
		                if (diver_1[key] == null) {
		                    diver_1[key] = {};
		                }
		                diver_1 = diver_1[key];
		            }
		        });
		        diver_1[lastKey] = value;
		    }
		    return obj;
		}
		exports.setByPath = setByPath;
		function unsetByPath(obj, path, delimiter) {
		    if (delimiter === void 0) { delimiter = '/'; }
		    var keys = Array.isArray(path) ? path.slice() : path.split(delimiter);
		    var propertyToRemove = keys.pop();
		    if (propertyToRemove) {
		        if (keys.length > 0) {
		            var parent_1 = getByPath(obj, keys);
		            if (parent_1) {
		                delete parent_1[propertyToRemove];
		            }
		        }
		        else {
		            delete obj[propertyToRemove];
		        }
		    }
		    return obj;
		}
		exports.unsetByPath = unsetByPath;
		function flatten(obj, delim, stop) {
		    if (delim === void 0) { delim = '/'; }
		    var ret = {};
		    Object.keys(obj).forEach(function (key) {
		        var val = obj[key];
		        var deep = typeof val === 'object' || Array.isArray(val);
		        if (deep && stop && stop(val)) {
		            deep = false;
		        }
		        if (deep) {
		            var flatObject_1 = flatten(val, delim, stop);
		            Object.keys(flatObject_1).forEach(function (flatKey) {
		                ret[key + delim + flatKey] = flatObject_1[flatKey];
		            });
		        }
		        else {
		            ret[key] = val;
		        }
		    });
		    // eslint-disable-next-line no-restricted-syntax
		    for (var key in obj) {
		        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
		            continue;
		        }
		    }
		    return ret;
		}
		exports.flatten = flatten;
		
	} (object$1));
	return object$1;
}

var hasRequiredObject$1;

function requireObject$1 () {
	if (hasRequiredObject$1) return object$2;
	hasRequiredObject$1 = 1;
	"use strict";
	var __createBinding = (object$2 && object$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (object$2 && object$2.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (object$2 && object$2.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(object$2, "__esModule", { value: true });
	object$2.ObjectExt = void 0;
	var ObjectExt = __importStar(requireObject$2());
	object$2.ObjectExt = ObjectExt;
	
	return object$2;
}

var string$1 = {};

var string = {};

var _eval = {};

var hasRequired_eval;

function require_eval () {
	if (hasRequired_eval) return _eval;
	hasRequired_eval = 1;
	"use strict";
	Object.defineProperty(_eval, "__esModule", { value: true });
	_eval.exec = void 0;
	function exec(exp) {
	    var result = null;
	    try {
	        result = window.eval(exp); // eslint-disable-line
	    }
	    catch (e) {
	        // pass
	    }
	    return result;
	}
	_eval.exec = exec;
	
	return _eval;
}

var format = {};

var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format;
	hasRequiredFormat = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.titleCase = exports.sentenceCase = exports.pathCase = exports.dotCase = exports.constantCase = exports.pascalCase = exports.kebabCase = exports.camelCase = exports.upperFirst = exports.lowerFirst = void 0;
		var lodash_es_1 = require$$0;
		var lodash_es_2 = require$$0;
		// kebabCase,
		// startCase,
		// snakeCase,
		// lowerCase,
		// upperCase,
		// capitalize,
		Object.defineProperty(exports, "lowerFirst", { enumerable: true, get: function () { return lodash_es_2.lowerFirst; } });
		Object.defineProperty(exports, "upperFirst", { enumerable: true, get: function () { return lodash_es_2.upperFirst; } });
		Object.defineProperty(exports, "camelCase", { enumerable: true, get: function () { return lodash_es_2.camelCase; } });
		// @see: https://medium.com/@robertsavian/javascript-case-converters-using-lodash-4f2f964091cc
		var cacheStringFunction = function (fn) {
		    var cache = Object.create(null);
		    return (function (str) {
		        var hit = cache[str];
		        return hit || (cache[str] = fn(str));
		    });
		};
		exports.kebabCase = cacheStringFunction(function (s) {
		    return s.replace(/\B([A-Z])/g, '-$1').toLowerCase();
		});
		exports.pascalCase = cacheStringFunction(function (s) {
		    return (0, lodash_es_1.startCase)((0, lodash_es_1.camelCase)(s)).replace(/ /g, '');
		});
		exports.constantCase = cacheStringFunction(function (s) {
		    return (0, lodash_es_1.upperCase)(s).replace(/ /g, '_');
		});
		exports.dotCase = cacheStringFunction(function (s) {
		    return (0, lodash_es_1.lowerCase)(s).replace(/ /g, '.');
		});
		exports.pathCase = cacheStringFunction(function (s) {
		    return (0, lodash_es_1.lowerCase)(s).replace(/ /g, '/');
		});
		exports.sentenceCase = cacheStringFunction(function (s) {
		    return (0, lodash_es_1.upperFirst)((0, lodash_es_1.lowerCase)(s));
		});
		exports.titleCase = cacheStringFunction(function (s) {
		    return (0, lodash_es_1.startCase)((0, lodash_es_1.camelCase)(s));
		});
		
	} (format));
	return format;
}

var hashcode = {};

var hasRequiredHashcode;

function requireHashcode () {
	if (hasRequiredHashcode) return hashcode;
	hasRequiredHashcode = 1;
	"use strict";
	/* eslint-disable no-bitwise */
	Object.defineProperty(hashcode, "__esModule", { value: true });
	hashcode.hashcode = void 0;
	/**
	 * Return a simple hash code from a string.
	 * Source from: https://github.com/sindresorhus/fnv1a/blob/master/index.js#L25
	 */
	function hashcode$1(str) {
	    var hash = 2166136261;
	    var isUnicoded = false;
	    var string = str;
	    for (var i = 0, ii = string.length; i < ii; i += 1) {
	        var characterCode = string.charCodeAt(i);
	        // Non-ASCII characters trigger the Unicode escape logic
	        if (characterCode > 0x7f && !isUnicoded) {
	            string = unescape(encodeURIComponent(string));
	            characterCode = string.charCodeAt(i);
	            isUnicoded = true;
	        }
	        hash ^= characterCode;
	        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
	    }
	    return hash >>> 0;
	}
	hashcode.hashcode = hashcode$1;
	
	return hashcode;
}

var uuid = {};

var hasRequiredUuid;

function requireUuid () {
	if (hasRequiredUuid) return uuid;
	hasRequiredUuid = 1;
	"use strict";
	Object.defineProperty(uuid, "__esModule", { value: true });
	uuid.uuid = void 0;
	/* eslint-disable no-bitwise */
	function uuid$1() {
	    // credit: http://stackoverflow.com/posts/2117523/revisions
	    // return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
	    //   const r = (Math.random() * 16) | 0
	    //   const v = c === 'x' ? r : (r & 0x3) | 0x8
	    //   return v.toString(16)
	    // })
	    var res = '';
	    var template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
	    for (var i = 0, len = template.length; i < len; i += 1) {
	        var s = template[i];
	        var r = (Math.random() * 16) | 0;
	        var v = s === 'x' ? r : s === 'y' ? (r & 0x3) | 0x8 : s;
	        res += v.toString(16);
	    }
	    return res;
	}
	uuid.uuid = uuid$1;
	
	return uuid;
}

var html = {};

var hasRequiredHtml;

function requireHtml () {
	if (hasRequiredHtml) return html;
	hasRequiredHtml = 1;
	"use strict";
	var __importDefault = (html && html.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(html, "__esModule", { value: true });
	html.sanitizeHTML = void 0;
	var jquery_1 = __importDefault(requireJquery());
	function sanitizeHTML(html, options) {
	    // If documentContext (second parameter) is not specified or given as
	    // `null` or `undefined`, a new document is used. Inline events will not
	    // execute when the HTML is parsed; this includes, for example, sending
	    // GET requests for images.
	    if (options === void 0) { options = {}; }
	    // If keepScripts (last parameter) is `false`, scripts are not executed.
	    var nodes = jquery_1.default.parseHTML(html, null, false);
	    nodes.forEach(function (node) {
	        var elem = node;
	        if (elem) {
	            var attrs = elem.attributes;
	            if (attrs) {
	                for (var i = 0, ii = attrs.length; i < ii; i += 1) {
	                    var attr = attrs.item(i);
	                    if (attr) {
	                        var val = attr.value.toLowerCase();
	                        var name_1 = attr.name.toLowerCase();
	                        // Removes attribute name starts with "on" (e.g. onload,
	                        // onerror...).
	                        // Removes attribute value starts with "javascript:" pseudo
	                        // protocol (e.g. `href="javascript:alert(1)"`).
	                        if (name_1.startsWith('on') ||
	                            val.startsWith('javascript:') || // eslint-disable-line no-script-url
	                            // ref: https://lgtm.com/rules/1510852698359/
	                            val.startsWith('data:') ||
	                            val.startsWith('vbscript:')) {
	                            elem.removeAttribute(name_1);
	                        }
	                    }
	                }
	            }
	        }
	    });
	    if (options.raw) {
	        return nodes;
	    }
	    return (0, jquery_1.default)('<div/>').append(nodes).html();
	}
	html.sanitizeHTML = sanitizeHTML;
	
	return html;
}

var suggestion = {};

var hasRequiredSuggestion;

function requireSuggestion () {
	if (hasRequiredSuggestion) return suggestion;
	hasRequiredSuggestion = 1;
	"use strict";
	// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts
	Object.defineProperty(suggestion, "__esModule", { value: true });
	suggestion.getSpellingSuggestion = void 0;
	/**
	 * Given a name and a list of names that are not equal to the name, return a
	 * spelling suggestion if there is one that is close enough. Names less than
	 * length 3 only check for case-insensitive equality, not Levenshtein distance.
	 *
	 * - If there is a candidate that's the same except for case, return that.
	 * - If there is a candidate that's within one edit of the name, return that.
	 * - Otherwise, return the candidate with the smallest Levenshtein distance,
	 *     except for candidates:
	 *       * With no name
	 *       * Whose length differs from the target name by more than 0.34 of the
	 *         length of the name.
	 *       * Whose levenshtein distance is more than 0.4 of the length of the
	 *         name (0.4 allows 1 substitution/transposition for every 5 characters,
	 *         and 1 insertion/deletion at 3 characters)
	 */
	function getSpellingSuggestion(name, candidates, getName) {
	    var maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
	    // If the best result isn't better than this, don't bother.
	    var bestDistance = Math.floor(name.length * 0.4) + 1;
	    var bestCandidate;
	    var justCheckExactMatches = false;
	    var nameLowerCase = name.toLowerCase();
	    // eslint-disable-next-line
	    for (var _i = 0, candidates_1 = candidates; _i < candidates_1.length; _i++) {
	        var candidate = candidates_1[_i];
	        var candidateName = getName(candidate);
	        if (candidateName !== undefined &&
	            Math.abs(candidateName.length - nameLowerCase.length) <=
	                maximumLengthDifference) {
	            var candidateNameLowerCase = candidateName.toLowerCase();
	            if (candidateNameLowerCase === nameLowerCase) {
	                if (candidateName === name) {
	                    continue;
	                }
	                return candidate;
	            }
	            if (justCheckExactMatches) {
	                continue;
	            }
	            if (candidateName.length < 3) {
	                // Don't bother, user would have noticed a
	                // 2-character name having an extra character.
	                continue;
	            }
	            // Only care about a result better than the best so far.
	            var distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);
	            if (distance === undefined) {
	                continue;
	            }
	            if (distance < 3) {
	                justCheckExactMatches = true;
	                bestCandidate = candidate;
	            }
	            else {
	                // Debug.assert(distance < bestDistance)
	                bestDistance = distance;
	                bestCandidate = candidate;
	            }
	        }
	    }
	    return bestCandidate;
	}
	suggestion.getSpellingSuggestion = getSpellingSuggestion;
	function levenshteinWithMax(s1, s2, max) {
	    var previous = new Array(s2.length + 1); // eslint-disable-line
	    var current = new Array(s2.length + 1); // eslint-disable-line
	    /** Represents any value > max. We don't care about the particular value. */
	    var big = max + 1;
	    for (var i = 0; i <= s2.length; i += 1) {
	        previous[i] = i;
	    }
	    for (var i = 1; i <= s1.length; i += 1) {
	        var c1 = s1.charCodeAt(i - 1);
	        var minJ = i > max ? i - max : 1;
	        var maxJ = s2.length > max + i ? max + i : s2.length;
	        current[0] = i;
	        /** Smallest value of the matrix in the ith column. */
	        var colMin = i;
	        for (var j = 1; j < minJ; j += 1) {
	            current[j] = big;
	        }
	        for (var j = minJ; j <= maxJ; j += 1) {
	            var dist = c1 === s2.charCodeAt(j - 1)
	                ? previous[j - 1]
	                : Math.min(
	                /* delete */ previous[j] + 1, 
	                /* insert */ current[j - 1] + 1, 
	                /* substitute */ previous[j - 1] + 2);
	            current[j] = dist;
	            colMin = Math.min(colMin, dist);
	        }
	        for (var j = maxJ + 1; j <= s2.length; j += 1) {
	            current[j] = big;
	        }
	        if (colMin > max) {
	            // Give up -- everything in this column is > max
	            // and it can't get better in future columns.
	            return undefined;
	        }
	        var temp = previous;
	        previous = current;
	        current = temp;
	    }
	    var res = previous[s2.length];
	    return res > max ? undefined : res;
	}
	
	return suggestion;
}

var hasRequiredString$1;

function requireString$1 () {
	if (hasRequiredString$1) return string;
	hasRequiredString$1 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (string && string.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (string && string.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.eval = exports.uniqueId = exports.template = exports.truncate = exports.padStart = exports.padEnd = exports.pad = exports.repeat = exports.split = exports.endsWith = exports.startsWith = exports.unescape = exports.escape = exports.toString = exports.isString = void 0;
		var lodash_es_1 = require$$0;
		Object.defineProperty(exports, "isString", { enumerable: true, get: function () { return lodash_es_1.isString; } });
		Object.defineProperty(exports, "toString", { enumerable: true, get: function () { return lodash_es_1.toString; } });
		Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return lodash_es_1.escape; } });
		Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return lodash_es_1.unescape; } });
		Object.defineProperty(exports, "startsWith", { enumerable: true, get: function () { return lodash_es_1.startsWith; } });
		Object.defineProperty(exports, "endsWith", { enumerable: true, get: function () { return lodash_es_1.endsWith; } });
		Object.defineProperty(exports, "split", { enumerable: true, get: function () { return lodash_es_1.split; } });
		Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return lodash_es_1.repeat; } });
		Object.defineProperty(exports, "pad", { enumerable: true, get: function () { return lodash_es_1.pad; } });
		Object.defineProperty(exports, "padEnd", { enumerable: true, get: function () { return lodash_es_1.padEnd; } });
		Object.defineProperty(exports, "padStart", { enumerable: true, get: function () { return lodash_es_1.padStart; } });
		Object.defineProperty(exports, "truncate", { enumerable: true, get: function () { return lodash_es_1.truncate; } });
		Object.defineProperty(exports, "template", { enumerable: true, get: function () { return lodash_es_1.template; } });
		Object.defineProperty(exports, "uniqueId", { enumerable: true, get: function () { return lodash_es_1.uniqueId; } });
		var eval_1 = require_eval();
		Object.defineProperty(exports, "eval", { enumerable: true, get: function () { return eval_1.exec; } });
		__exportStar(requireFormat(), exports);
		__exportStar(requireHashcode(), exports);
		__exportStar(requireUuid(), exports);
		__exportStar(requireHtml(), exports);
		__exportStar(requireSuggestion(), exports);
		
	} (string));
	return string;
}

var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string$1;
	hasRequiredString = 1;
	"use strict";
	var __createBinding = (string$1 && string$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (string$1 && string$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (string$1 && string$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(string$1, "__esModule", { value: true });
	string$1.StringExt = void 0;
	var StringExt = __importStar(requireString$1());
	string$1.StringExt = StringExt;
	
	return string$1;
}

var number$1 = {};

var number = {};

var hasRequiredNumber$1;

function requireNumber$1 () {
	if (hasRequiredNumber$1) return number;
	hasRequiredNumber$1 = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.normalizeSides = exports.parseCssNumeric = exports.normalizePercentage = exports.isPercentage = exports.random = exports.mod = exports.isNumeric = exports.parseInt = exports.toSafeInteger = exports.toInteger = exports.toNumber = exports.toFinite = exports.inRange = exports.clamp = exports.isSafeInteger = exports.isInteger = exports.isFinite = exports.isNumber = exports.isNaN = void 0;
		var lodash_es_1 = require$$0;
		Object.defineProperty(exports, "isNaN", { enumerable: true, get: function () { return lodash_es_1.isNaN; } });
		Object.defineProperty(exports, "isNumber", { enumerable: true, get: function () { return lodash_es_1.isNumber; } });
		Object.defineProperty(exports, "isFinite", { enumerable: true, get: function () { return lodash_es_1.isFinite; } });
		Object.defineProperty(exports, "isInteger", { enumerable: true, get: function () { return lodash_es_1.isInteger; } });
		Object.defineProperty(exports, "isSafeInteger", { enumerable: true, get: function () { return lodash_es_1.isSafeInteger; } });
		Object.defineProperty(exports, "clamp", { enumerable: true, get: function () { return lodash_es_1.clamp; } });
		Object.defineProperty(exports, "inRange", { enumerable: true, get: function () { return lodash_es_1.inRange; } });
		Object.defineProperty(exports, "toFinite", { enumerable: true, get: function () { return lodash_es_1.toFinite; } });
		Object.defineProperty(exports, "toNumber", { enumerable: true, get: function () { return lodash_es_1.toNumber; } });
		Object.defineProperty(exports, "toInteger", { enumerable: true, get: function () { return lodash_es_1.toInteger; } });
		Object.defineProperty(exports, "toSafeInteger", { enumerable: true, get: function () { return lodash_es_1.toSafeInteger; } });
		Object.defineProperty(exports, "parseInt", { enumerable: true, get: function () { return lodash_es_1.parseInt; } });
		var lang_1 = requireLang$1();
		Object.defineProperty(exports, "isNumeric", { enumerable: true, get: function () { return lang_1.isNumeric; } });
		/**
		 * Returns the remainder of division of `n` by `m`. You should use this
		 * instead of the built-in operation as the built-in operation does not
		 * properly handle negative numbers.
		 */
		function mod(n, m) {
		    return ((n % m) + m) % m;
		}
		exports.mod = mod;
		function random(lower, upper) {
		    if (upper == null) {
		        upper = lower == null ? 1 : lower; // eslint-disable-line
		        lower = 0; // eslint-disable-line
		    }
		    else if (upper < lower) {
		        var tmp = lower;
		        lower = upper; // eslint-disable-line
		        upper = tmp; // eslint-disable-line
		    }
		    return Math.floor(Math.random() * (upper - lower + 1) + lower);
		}
		exports.random = random;
		function isPercentage(val) {
		    return typeof val === 'string' && val.slice(-1) === '%';
		}
		exports.isPercentage = isPercentage;
		function normalizePercentage(num, ref) {
		    if (num == null) {
		        return 0;
		    }
		    var raw;
		    if (typeof num === 'string') {
		        raw = parseFloat(num);
		        if (isPercentage(num)) {
		            raw /= 100;
		            if (Number.isFinite(raw)) {
		                return raw * ref;
		            }
		        }
		    }
		    else {
		        raw = num;
		    }
		    if (!Number.isFinite(raw)) {
		        return 0;
		    }
		    if (raw > 0 && raw < 1) {
		        return raw * ref;
		    }
		    return raw;
		}
		exports.normalizePercentage = normalizePercentage;
		function parseCssNumeric(val, units) {
		    function getUnit(regexp) {
		        var matches = new RegExp("(?:\\d+(?:\\.\\d+)*)(" + regexp + ")$").exec(val);
		        if (!matches) {
		            return null;
		        }
		        return matches[1];
		    }
		    var number = parseFloat(val);
		    if (Number.isNaN(number)) {
		        return null;
		    }
		    // determine the unit
		    var regexp;
		    if (units == null) {
		        // accept any unit, as well as no unit
		        regexp = '[A-Za-z]*';
		    }
		    else if (Array.isArray(units)) {
		        if (units.length === 0) {
		            return null;
		        }
		        regexp = units.join('|');
		    }
		    else if (typeof units === 'string') {
		        regexp = units;
		    }
		    var unit = getUnit(regexp);
		    if (unit === null) {
		        return null;
		    }
		    return {
		        unit: unit,
		        value: number,
		    };
		}
		exports.parseCssNumeric = parseCssNumeric;
		function normalizeSides(box) {
		    if (typeof box === 'object') {
		        var left = 0;
		        var top_1 = 0;
		        var right = 0;
		        var bottom = 0;
		        if (box.vertical != null && Number.isFinite(box.vertical)) {
		            top_1 = bottom = box.vertical;
		        }
		        if (box.horizontal != null && Number.isFinite(box.horizontal)) {
		            right = left = box.horizontal;
		        }
		        if (box.left != null && Number.isFinite(box.left))
		            left = box.left;
		        if (box.top != null && Number.isFinite(box.top))
		            top_1 = box.top;
		        if (box.right != null && Number.isFinite(box.right))
		            right = box.right;
		        if (box.bottom != null && Number.isFinite(box.bottom))
		            bottom = box.bottom;
		        return { top: top_1, right: right, bottom: bottom, left: left };
		    }
		    var val = 0;
		    if (box != null && Number.isFinite(box)) {
		        val = box;
		    }
		    return { top: val, right: val, bottom: val, left: val };
		}
		exports.normalizeSides = normalizeSides;
		
	} (number));
	return number;
}

var hasRequiredNumber;

function requireNumber () {
	if (hasRequiredNumber) return number$1;
	hasRequiredNumber = 1;
	"use strict";
	var __createBinding = (number$1 && number$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (number$1 && number$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (number$1 && number$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(number$1, "__esModule", { value: true });
	number$1.NumberExt = void 0;
	var NumberExt = __importStar(requireNumber$1());
	number$1.NumberExt = NumberExt;
	
	return number$1;
}

var _function$1 = {};

var main$2 = {};

var _function = {};

var hasRequired_function$1;

function require_function$1 () {
	if (hasRequired_function$1) return _function;
	hasRequired_function$1 = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.cacher = exports.call = exports.apply = exports.defer = exports.debounce = exports.noop = exports.once = exports.isFunction = void 0;
		var lodash_es_1 = require$$0;
		Object.defineProperty(exports, "isFunction", { enumerable: true, get: function () { return lodash_es_1.isFunction; } });
		Object.defineProperty(exports, "once", { enumerable: true, get: function () { return lodash_es_1.once; } });
		Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return lodash_es_1.noop; } });
		Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return lodash_es_1.debounce; } });
		Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return lodash_es_1.defer; } });
		function apply(fn, ctx, args) {
		    if (args) {
		        switch (args.length) {
		            case 0:
		                return fn.call(ctx);
		            case 1:
		                return fn.call(ctx, args[0]);
		            case 2:
		                return fn.call(ctx, args[0], args[1]);
		            case 3:
		                return fn.call(ctx, args[0], args[1], args[2]);
		            case 4:
		                return fn.call(ctx, args[0], args[1], args[2], args[3]);
		            case 5:
		                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);
		            case 6:
		                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);
		            default:
		                return fn.apply(ctx, args);
		        }
		    }
		    return fn.call(ctx);
		}
		exports.apply = apply;
		function call(fn, ctx) {
		    var args = [];
		    for (var _i = 2; _i < arguments.length; _i++) {
		        args[_i - 2] = arguments[_i];
		    }
		    return apply(fn, ctx, args);
		}
		exports.call = call;
		function repush(array, item) {
		    for (var i = 0, ii = array.length; i < ii; i += 1) {
		        if (array[i] === item) {
		            return array.push(array.splice(i, 1)[0]);
		        }
		    }
		}
		function cacher(fn, ctx, postProcessor) {
		    var keys = [];
		    var cache = {};
		    var f = function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var hasCache = false;
		        var key = args.join('\u2400');
		        if (key in cache) {
		            hasCache = true;
		            repush(keys, key);
		        }
		        else {
		            if (keys.length >= 1000) {
		                delete cache[keys.shift()];
		            }
		            keys.push(key);
		            cache[key] = apply(fn, ctx || null, args);
		        }
		        return postProcessor ? postProcessor(cache[key], hasCache) : cache[key];
		    };
		    return f;
		}
		exports.cacher = cacher;
		
	} (_function));
	return _function;
}

var async = {};

var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;
	"use strict";
	Object.defineProperty(async, "__esModule", { value: true });
	async.toDeferredBoolean = async.toAsyncBoolean = async.isAsync = async.isAsyncLike = void 0;
	function isAsyncLike(obj) {
	    return typeof obj === 'object' && obj.then && typeof obj.then === 'function';
	}
	async.isAsyncLike = isAsyncLike;
	function isAsync(obj) {
	    return obj != null && (obj instanceof Promise || isAsyncLike(obj));
	}
	async.isAsync = isAsync;
	function toAsyncBoolean() {
	    var inputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        inputs[_i] = arguments[_i];
	    }
	    var results = [];
	    inputs.forEach(function (arg) {
	        if (Array.isArray(arg)) {
	            results.push.apply(results, arg);
	        }
	        else {
	            results.push(arg);
	        }
	    });
	    var hasAsync = results.some(function (res) { return isAsync(res); });
	    if (hasAsync) {
	        var deferres = results.map(function (res) {
	            return isAsync(res) ? res : Promise.resolve(res !== false);
	        });
	        return Promise.all(deferres).then(function (arr) {
	            return arr.reduce(function (memo, item) { return item !== false && memo; }, true);
	        });
	    }
	    return results.every(function (res) { return res !== false; });
	}
	async.toAsyncBoolean = toAsyncBoolean;
	function toDeferredBoolean() {
	    var inputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        inputs[_i] = arguments[_i];
	    }
	    var ret = toAsyncBoolean(inputs);
	    return typeof ret === 'boolean' ? Promise.resolve(ret) : ret;
	}
	async.toDeferredBoolean = toDeferredBoolean;
	
	return async;
}

var hasRequiredMain$2;

function requireMain$2 () {
	if (hasRequiredMain$2) return main$2;
	hasRequiredMain$2 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (main$2 && main$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$2 && main$2.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(require_function$1(), exports);
		__exportStar(requireAsync(), exports);
		
	} (main$2));
	return main$2;
}

var hasRequired_function;

function require_function () {
	if (hasRequired_function) return _function$1;
	hasRequired_function = 1;
	"use strict";
	var __createBinding = (_function$1 && _function$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (_function$1 && _function$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (_function$1 && _function$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(_function$1, "__esModule", { value: true });
	_function$1.FunctionExt = void 0;
	var FunctionExt = __importStar(requireMain$2());
	_function$1.FunctionExt = FunctionExt;
	
	return _function$1;
}

var text$1 = {};

var main$1 = {};

var annotate = {};

var attr = {};

var elem = {};

var _class = {};

var hasRequired_class;

function require_class () {
	if (hasRequired_class) return _class;
	hasRequired_class = 1;
	"use strict";
	Object.defineProperty(_class, "__esModule", { value: true });
	_class.toggleClass = _class.removeClass = _class.addClass = _class.hasClass = _class.getClass = void 0;
	var rclass = /[\t\r\n\f]/g;
	var rnotwhite = /\S+/g;
	var fillSpaces = function (str) { return " " + str + " "; };
	function getClass(elem) {
	    return (elem && elem.getAttribute && elem.getAttribute('class')) || '';
	}
	_class.getClass = getClass;
	function hasClass(elem, selector) {
	    if (elem == null || selector == null) {
	        return false;
	    }
	    var classNames = fillSpaces(getClass(elem));
	    var className = fillSpaces(selector);
	    return elem.nodeType === 1
	        ? classNames.replace(rclass, ' ').includes(className)
	        : false;
	}
	_class.hasClass = hasClass;
	function addClass(elem, selector) {
	    if (elem == null || selector == null) {
	        return;
	    }
	    if (typeof selector === 'function') {
	        return addClass(elem, selector(getClass(elem)));
	    }
	    if (typeof selector === 'string' && elem.nodeType === 1) {
	        var classes = selector.match(rnotwhite) || [];
	        var oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
	        var newValue = classes.reduce(function (memo, cls) {
	            if (memo.indexOf(fillSpaces(cls)) < 0) {
	                return "" + memo + cls + " ";
	            }
	            return memo;
	        }, oldValue);
	        newValue = newValue.trim();
	        if (oldValue !== newValue) {
	            elem.setAttribute('class', newValue);
	        }
	    }
	}
	_class.addClass = addClass;
	function removeClass(elem, selector) {
	    if (elem == null) {
	        return;
	    }
	    if (typeof selector === 'function') {
	        return removeClass(elem, selector(getClass(elem)));
	    }
	    if ((!selector || typeof selector === 'string') && elem.nodeType === 1) {
	        var classes = (selector || '').match(rnotwhite) || [];
	        var oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
	        var newValue = classes.reduce(function (memo, cls) {
	            var className = fillSpaces(cls);
	            if (memo.indexOf(className) > -1) {
	                return memo.replace(className, ' ');
	            }
	            return memo;
	        }, oldValue);
	        newValue = selector ? newValue.trim() : '';
	        if (oldValue !== newValue) {
	            elem.setAttribute('class', newValue);
	        }
	    }
	}
	_class.removeClass = removeClass;
	function toggleClass(elem, selector, stateVal) {
	    if (elem == null || selector == null) {
	        return;
	    }
	    if (stateVal != null && typeof selector === 'string') {
	        stateVal ? addClass(elem, selector) : removeClass(elem, selector);
	        return;
	    }
	    if (typeof selector === 'function') {
	        return toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
	    }
	    if (typeof selector === 'string') {
	        var metches = selector.match(rnotwhite) || [];
	        metches.forEach(function (cls) {
	            hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls);
	        });
	    }
	}
	_class.toggleClass = toggleClass;
	
	return _class;
}

var hasRequiredElem;

function requireElem () {
	if (hasRequiredElem) return elem;
	hasRequiredElem = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isInputElement = exports.clickable = exports.isHTMLElement = exports.appendTo = exports.before = exports.prepend = exports.append = exports.empty = exports.remove = exports.contains = exports.findParentByClass = exports.findOne = exports.find = exports.index = exports.tagName = exports.parseXML = exports.createSvgDocument = exports.createSvgElement = exports.createElementNS = exports.createElement = exports.svgVersion = exports.ns = exports.isSVGGraphicsElement = exports.ensureId = exports.uniqueId = void 0;
		var class_1 = require_class();
		var idCounter = 0;
		function uniqueId() {
		    idCounter += 1;
		    return "v" + idCounter;
		}
		exports.uniqueId = uniqueId;
		function ensureId(elem) {
		    if (elem.id == null || elem.id === '') {
		        elem.id = uniqueId();
		    }
		    return elem.id;
		}
		exports.ensureId = ensureId;
		/**
		 * Returns true if object is an instance of SVGGraphicsElement.
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
		 */
		function isSVGGraphicsElement(elem) {
		    if (elem == null) {
		        return false;
		    }
		    return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;
		}
		exports.isSVGGraphicsElement = isSVGGraphicsElement;
		exports.ns = {
		    svg: 'http://www.w3.org/2000/svg',
		    xmlns: 'http://www.w3.org/2000/xmlns/',
		    xml: 'http://www.w3.org/XML/1998/namespace',
		    xlink: 'http://www.w3.org/1999/xlink',
		    xhtml: 'http://www.w3.org/1999/xhtml',
		};
		exports.svgVersion = '1.1';
		function createElement(tagName, doc) {
		    if (doc === void 0) { doc = document; }
		    return doc.createElement(tagName);
		}
		exports.createElement = createElement;
		function createElementNS(tagName, namespaceURI, doc) {
		    if (namespaceURI === void 0) { namespaceURI = exports.ns.xhtml; }
		    if (doc === void 0) { doc = document; }
		    return doc.createElementNS(namespaceURI, tagName);
		}
		exports.createElementNS = createElementNS;
		function createSvgElement(tagName, doc) {
		    if (doc === void 0) { doc = document; }
		    return createElementNS(tagName, exports.ns.svg, doc);
		}
		exports.createSvgElement = createSvgElement;
		function createSvgDocument(content) {
		    if (content) {
		        var xml = "<svg xmlns=\"" + exports.ns.svg + "\" xmlns:xlink=\"" + exports.ns.xlink + "\" version=\"" + exports.svgVersion + "\">" + content + "</svg>"; // lgtm[js/html-constructed-from-input]
		        var documentElement = parseXML(xml, { async: false }).documentElement;
		        return documentElement;
		    }
		    var svg = document.createElementNS(exports.ns.svg, 'svg');
		    svg.setAttributeNS(exports.ns.xmlns, 'xmlns:xlink', exports.ns.xlink);
		    svg.setAttribute('version', exports.svgVersion);
		    return svg;
		}
		exports.createSvgDocument = createSvgDocument;
		function parseXML(data, options) {
		    if (options === void 0) { options = {}; }
		    var xml;
		    try {
		        var parser = new DOMParser();
		        if (options.async != null) {
		            var instance = parser;
		            instance.async = options.async;
		        }
		        xml = parser.parseFromString(data, options.mimeType || 'text/xml');
		    }
		    catch (error) {
		        xml = undefined;
		    }
		    if (!xml || xml.getElementsByTagName('parsererror').length) {
		        throw new Error("Invalid XML: " + data);
		    }
		    return xml;
		}
		exports.parseXML = parseXML;
		function tagName(node, lowercase) {
		    if (lowercase === void 0) { lowercase = true; }
		    var nodeName = node.nodeName;
		    return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
		}
		exports.tagName = tagName;
		function index(elem) {
		    var index = 0;
		    var node = elem.previousSibling;
		    while (node) {
		        if (node.nodeType === 1) {
		            index += 1;
		        }
		        node = node.previousSibling;
		    }
		    return index;
		}
		exports.index = index;
		function find(elem, selector) {
		    return elem.querySelectorAll(selector);
		}
		exports.find = find;
		function findOne(elem, selector) {
		    return elem.querySelector(selector);
		}
		exports.findOne = findOne;
		function findParentByClass(elem, className, terminator) {
		    var ownerSVGElement = elem.ownerSVGElement;
		    var node = elem.parentNode;
		    while (node && node !== terminator && node !== ownerSVGElement) {
		        if ((0, class_1.hasClass)(node, className)) {
		            return node;
		        }
		        node = node.parentNode;
		    }
		    return null;
		}
		exports.findParentByClass = findParentByClass;
		function contains(parent, child) {
		    var bup = child && child.parentNode;
		    return (parent === bup ||
		        !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise
		    );
		}
		exports.contains = contains;
		function remove(elem) {
		    if (elem.parentNode) {
		        elem.parentNode.removeChild(elem);
		    }
		}
		exports.remove = remove;
		function empty(elem) {
		    while (elem.firstChild) {
		        elem.removeChild(elem.firstChild);
		    }
		}
		exports.empty = empty;
		function append(elem, elems) {
		    var arr = Array.isArray(elems) ? elems : [elems];
		    arr.forEach(function (child) {
		        if (child != null) {
		            elem.appendChild(child);
		        }
		    });
		}
		exports.append = append;
		function prepend(elem, elems) {
		    var child = elem.firstChild;
		    return child ? before(child, elems) : append(elem, elems);
		}
		exports.prepend = prepend;
		function before(elem, elems) {
		    var parent = elem.parentNode;
		    if (parent) {
		        var arr = Array.isArray(elems) ? elems : [elems];
		        arr.forEach(function (child) {
		            if (child != null) {
		                parent.insertBefore(child, elem);
		            }
		        });
		    }
		}
		exports.before = before;
		function appendTo(elem, target) {
		    if (target != null) {
		        target.appendChild(elem);
		    }
		}
		exports.appendTo = appendTo;
		// Determines whether a node is an HTML node
		function isHTMLElement(elem) {
		    try {
		        // Using W3 DOM2 (works for FF, Opera and Chrome)
		        return elem instanceof HTMLElement;
		    }
		    catch (e) {
		        // Browsers not supporting W3 DOM2 don't have HTMLElement and
		        // an exception is thrown and we end up here. Testing some
		        // properties that all elements have (works on IE7)
		        return (typeof elem === 'object' &&
		            elem.nodeType === 1 &&
		            typeof elem.style === 'object' &&
		            typeof elem.ownerDocument === 'object');
		    }
		}
		exports.isHTMLElement = isHTMLElement;
		function clickable(elem) {
		    if (!elem || !isHTMLElement(elem)) {
		        return false;
		    }
		    if (['a', 'button'].includes(tagName(elem))) {
		        return true;
		    }
		    if (elem.getAttribute('role') === 'button' ||
		        elem.getAttribute('type') === 'button') {
		        return true;
		    }
		    return clickable(elem.parentNode);
		}
		exports.clickable = clickable;
		function isInputElement(elem) {
		    var elemTagName = tagName(elem);
		    if (elemTagName === 'input') {
		        var type = elem.getAttribute('type');
		        if (type == null ||
		            ['text', 'password', 'number', 'email', 'search', 'tel', 'url'].includes(type)) {
		            return true;
		        }
		    }
		    return false;
		}
		exports.isInputElement = isInputElement;
		
	} (elem));
	return elem;
}

var hasRequiredAttr;

function requireAttr () {
	if (hasRequiredAttr) return attr;
	hasRequiredAttr = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.mergeAttrs = exports.styleToObject = exports.kebablizeAttrs = exports.qualifyAttr = exports.attr = exports.setAttributes = exports.setAttribute = exports.removeAttribute = exports.getAttribute = exports.CASE_SENSITIVE_ATTR = void 0;
		var elem_1 = requireElem();
		var format_1 = requireFormat();
		exports.CASE_SENSITIVE_ATTR = [
		    'viewBox',
		    'attributeName',
		    'attributeType',
		    'repeatCount',
		];
		function getAttribute(elem, name) {
		    return elem.getAttribute(name);
		}
		exports.getAttribute = getAttribute;
		function removeAttribute(elem, name) {
		    var qualified = qualifyAttr(name);
		    if (qualified.ns) {
		        if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
		            elem.removeAttributeNS(qualified.ns, qualified.local);
		        }
		    }
		    else if (elem.hasAttribute(name)) {
		        elem.removeAttribute(name);
		    }
		}
		exports.removeAttribute = removeAttribute;
		function setAttribute(elem, name, value) {
		    if (value == null) {
		        return removeAttribute(elem, name);
		    }
		    var qualified = qualifyAttr(name);
		    if (qualified.ns && typeof value === 'string') {
		        elem.setAttributeNS(qualified.ns, name, value);
		    }
		    else if (name === 'id') {
		        elem.id = "" + value;
		    }
		    else {
		        elem.setAttribute(name, "" + value);
		    }
		}
		exports.setAttribute = setAttribute;
		function setAttributes(elem, attrs) {
		    Object.keys(attrs).forEach(function (name) {
		        setAttribute(elem, name, attrs[name]);
		    });
		}
		exports.setAttributes = setAttributes;
		function attr(elem, name, value) {
		    if (name == null) {
		        var attrs = elem.attributes;
		        var ret = {};
		        for (var i = 0; i < attrs.length; i += 1) {
		            ret[attrs[i].name] = attrs[i].value;
		        }
		        return ret;
		    }
		    if (typeof name === 'string' && value === undefined) {
		        return elem.getAttribute(name);
		    }
		    if (typeof name === 'object') {
		        setAttributes(elem, name);
		    }
		    else {
		        setAttribute(elem, name, value);
		    }
		}
		exports.attr = attr;
		function qualifyAttr(name) {
		    if (name.indexOf(':') !== -1) {
		        var combinedKey = name.split(':');
		        return {
		            ns: elem_1.ns[combinedKey[0]],
		            local: combinedKey[1],
		        };
		    }
		    return {
		        ns: null,
		        local: name,
		    };
		}
		exports.qualifyAttr = qualifyAttr;
		function kebablizeAttrs(attrs) {
		    var result = {};
		    Object.keys(attrs).forEach(function (key) {
		        var name = exports.CASE_SENSITIVE_ATTR.includes(key) ? key : (0, format_1.kebabCase)(key);
		        result[name] = attrs[key];
		    });
		    return result;
		}
		exports.kebablizeAttrs = kebablizeAttrs;
		function styleToObject(styleString) {
		    var ret = {};
		    var styles = styleString.split(';');
		    styles.forEach(function (item) {
		        var section = item.trim();
		        if (section) {
		            var pair = section.split('=');
		            if (pair.length) {
		                ret[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
		            }
		        }
		    });
		    return ret;
		}
		exports.styleToObject = styleToObject;
		function mergeAttrs(target, source) {
		    Object.keys(source).forEach(function (attr) {
		        if (attr === 'class') {
		            target[attr] = target[attr]
		                ? target[attr] + " " + source[attr]
		                : source[attr];
		        }
		        else if (attr === 'style') {
		            var to = typeof target[attr] === 'object';
		            var so = typeof source[attr] === 'object';
		            var tt = void 0;
		            var ss = void 0;
		            if (to && so) {
		                tt = target[attr];
		                ss = source[attr];
		            }
		            else if (to) {
		                tt = target[attr];
		                ss = styleToObject(source[attr]);
		            }
		            else if (so) {
		                tt = styleToObject(target[attr]);
		                ss = source[attr];
		            }
		            else {
		                tt = styleToObject(target[attr]);
		                ss = styleToObject(source[attr]);
		            }
		            target[attr] = mergeAttrs(tt, ss);
		        }
		        else {
		            target[attr] = source[attr];
		        }
		    });
		    return target;
		}
		exports.mergeAttrs = mergeAttrs;
		
	} (attr));
	return attr;
}

var hasRequiredAnnotate;

function requireAnnotate () {
	if (hasRequiredAnnotate) return annotate;
	hasRequiredAnnotate = 1;
	"use strict";
	Object.defineProperty(annotate, "__esModule", { value: true });
	annotate.shiftAnnotations = annotate.findAnnotationsBetweenIndexes = annotate.findAnnotationsAtIndex = annotate.annotate = void 0;
	var object_1 = requireObject$1();
	var attr_1 = requireAttr();
	function annotate$1(t, annotations, opt) {
	    if (opt === void 0) { opt = {}; }
	    var offset = opt.offset || 0;
	    var compacted = [];
	    var ret = [];
	    var curr;
	    var prev;
	    var batch = null;
	    for (var i = 0; i < t.length; i += 1) {
	        curr = ret[i] = t[i];
	        for (var j = 0, jj = annotations.length; j < jj; j += 1) {
	            var annotation = annotations[j];
	            var start = annotation.start + offset;
	            var end = annotation.end + offset;
	            if (i >= start && i < end) {
	                if (typeof curr === 'string') {
	                    curr = ret[i] = {
	                        t: t[i],
	                        attrs: annotation.attrs,
	                    };
	                }
	                else {
	                    curr.attrs = (0, attr_1.mergeAttrs)((0, attr_1.mergeAttrs)({}, curr.attrs), annotation.attrs);
	                }
	                if (opt.includeAnnotationIndices) {
	                    if (curr.annotations == null) {
	                        curr.annotations = [];
	                    }
	                    curr.annotations.push(j);
	                }
	            }
	        }
	        prev = ret[i - 1];
	        if (!prev) {
	            batch = curr;
	        }
	        else if (object_1.ObjectExt.isObject(curr) && object_1.ObjectExt.isObject(prev)) {
	            batch = batch;
	            // Both previous item and the current one are annotations.
	            // If the attributes didn't change, merge the text.
	            if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
	                batch.t += curr.t;
	            }
	            else {
	                compacted.push(batch);
	                batch = curr;
	            }
	        }
	        else if (object_1.ObjectExt.isObject(curr)) {
	            // Previous item was a string, current item is an annotation.
	            batch = batch;
	            compacted.push(batch);
	            batch = curr;
	        }
	        else if (object_1.ObjectExt.isObject(prev)) {
	            // Previous item was an annotation, current item is a string.
	            batch = batch;
	            compacted.push(batch);
	            batch = curr;
	        }
	        else {
	            // Both previous and current item are strings.
	            batch = (batch || '') + curr;
	        }
	    }
	    if (batch != null) {
	        compacted.push(batch);
	    }
	    return compacted;
	}
	annotate.annotate = annotate$1;
	function findAnnotationsAtIndex(annotations, index) {
	    return annotations
	        ? annotations.filter(function (a) { return a.start < index && index <= a.end; })
	        : [];
	}
	annotate.findAnnotationsAtIndex = findAnnotationsAtIndex;
	function findAnnotationsBetweenIndexes(annotations, start, end) {
	    return annotations
	        ? annotations.filter(function (a) {
	            return (start >= a.start && start < a.end) ||
	                (end > a.start && end <= a.end) ||
	                (a.start >= start && a.end < end);
	        })
	        : [];
	}
	annotate.findAnnotationsBetweenIndexes = findAnnotationsBetweenIndexes;
	function shiftAnnotations(annotations, index, offset) {
	    if (annotations) {
	        annotations.forEach(function (a) {
	            if (a.start < index && a.end >= index) {
	                a.end += offset;
	            }
	            else if (a.start >= index) {
	                a.start += offset;
	                a.end += offset;
	            }
	        });
	    }
	    return annotations;
	}
	annotate.shiftAnnotations = shiftAnnotations;
	
	return annotate;
}

var sanitize = {};

var hasRequiredSanitize;

function requireSanitize () {
	if (hasRequiredSanitize) return sanitize;
	hasRequiredSanitize = 1;
	"use strict";
	Object.defineProperty(sanitize, "__esModule", { value: true });
	sanitize.sanitize = void 0;
	/**
	 * Replaces all spaces with the Unicode No-break space.
	 * ref: http://www.fileformat.info/info/unicode/char/a0/index.htm
	 *
	 * IE would otherwise collapse all spaces into one. This is useful
	 * e.g. in tests when you want to compare the actual DOM text content
	 * without having to add the unicode character in the place of all spaces.
	 */
	function sanitize$1(text) {
	    return text.replace(/ /g, '\u00A0');
	}
	sanitize.sanitize = sanitize$1;
	
	return sanitize;
}

var hasRequiredMain$1;

function requireMain$1 () {
	if (hasRequiredMain$1) return main$1;
	hasRequiredMain$1 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (main$1 && main$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$1 && main$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireAnnotate(), exports);
		__exportStar(requireSanitize(), exports);
		
	} (main$1));
	return main$1;
}

var hasRequiredText$1;

function requireText$1 () {
	if (hasRequiredText$1) return text$1;
	hasRequiredText$1 = 1;
	"use strict";
	var __createBinding = (text$1 && text$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (text$1 && text$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (text$1 && text$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(text$1, "__esModule", { value: true });
	text$1.Text = void 0;
	var Text = __importStar(requireMain$1());
	text$1.Text = Text;
	
	return text$1;
}

var json = {};

var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json;
	hasRequiredJson = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.JSONExt = void 0;
		/**
		 * The namespace for JSON-specific functions.
		 */
		var JSONExt;
		(function (JSONExt) {
		    /**
		     * A shared frozen empty JSONObject
		     */
		    JSONExt.emptyObject = Object.freeze({});
		    /**
		     * A shared frozen empty JSONArray
		     */
		    JSONExt.emptyArray = Object.freeze([]);
		    /**
		     * Test whether a JSON value is a primitive.
		     *
		     * @param value - The JSON value of interest.
		     *
		     * @returns `true` if the value is a primitive,`false` otherwise.
		     */
		    function isPrimitive(value) {
		        return (value === null ||
		            value === undefined ||
		            typeof value === 'boolean' ||
		            typeof value === 'number' ||
		            typeof value === 'string');
		    }
		    JSONExt.isPrimitive = isPrimitive;
		    function isArray(value) {
		        return Array.isArray(value);
		    }
		    JSONExt.isArray = isArray;
		    function isObject(value) {
		        return !isPrimitive(value) && !isArray(value);
		    }
		    JSONExt.isObject = isObject;
		    /**
		     * Compare two JSON values for deep equality.
		     *
		     * @param first - The first JSON value of interest.
		     *
		     * @param second - The second JSON value of interest.
		     *
		     * @returns `true` if the values are equivalent, `false` otherwise.
		     */
		    function deepEqual(first, second) {
		        // Check referential and primitive equality first.
		        if (first === second) {
		            return true;
		        }
		        // If one is a primitive, the `===` check ruled out the other.
		        if (isPrimitive(first) || isPrimitive(second)) {
		            return false;
		        }
		        // Test whether they are arrays.
		        var a1 = isArray(first);
		        var a2 = isArray(second);
		        // Bail if the types are different.
		        if (a1 !== a2) {
		            return false;
		        }
		        // If they are both arrays, compare them.
		        if (a1 && a2) {
		            return deepArrayEqual(first, second);
		        }
		        // At this point, they must both be objects.
		        return deepObjectEqual(first, second);
		    }
		    JSONExt.deepEqual = deepEqual;
		    /**
		     * Create a deep copy of a JSON value.
		     *
		     * @param value - The JSON value to copy.
		     *
		     * @returns A deep copy of the given JSON value.
		     */
		    function deepCopy(value) {
		        // Do nothing for primitive values.
		        if (isPrimitive(value)) {
		            return value;
		        }
		        // Deep copy an array.
		        if (isArray(value)) {
		            return deepArrayCopy(value);
		        }
		        // Deep copy an object.
		        return deepObjectCopy(value);
		    }
		    JSONExt.deepCopy = deepCopy;
		    /**
		     * Compare two JSON arrays for deep equality.
		     */
		    function deepArrayEqual(first, second) {
		        // Check referential equality first.
		        if (first === second) {
		            return true;
		        }
		        // Test the arrays for equal length.
		        if (first.length !== second.length) {
		            return false;
		        }
		        // Compare the values for equality.
		        for (var i = 0, n = first.length; i < n; i += 1) {
		            if (!deepEqual(first[i], second[i])) {
		                return false;
		            }
		        }
		        // At this point, the arrays are equal.
		        return true;
		    }
		    /**
		     * Compare two JSON objects for deep equality.
		     */
		    function deepObjectEqual(first, second) {
		        // Check referential equality first.
		        if (first === second) {
		            return true;
		        }
		        // Check for the first object's keys in the second object.
		        // eslint-disable-next-line
		        for (var key in first) {
		            if (!(key in second)) {
		                return false;
		            }
		        }
		        // Check for the second object's keys in the first object.
		        // eslint-disable-next-line
		        for (var key in second) {
		            if (!(key in first)) {
		                return false;
		            }
		        }
		        // Compare the values for equality.
		        // eslint-disable-next-line
		        for (var key in first) {
		            if (!deepEqual(first[key], second[key])) {
		                return false;
		            }
		        }
		        // At this point, the objects are equal.
		        return true;
		    }
		    /**
		     * Create a deep copy of a JSON array.
		     */
		    function deepArrayCopy(value) {
		        var result = new Array(value.length); // eslint-disable-line
		        for (var i = 0, n = value.length; i < n; i += 1) {
		            result[i] = deepCopy(value[i]);
		        }
		        return result;
		    }
		    /**
		     * Create a deep copy of a JSON object.
		     */
		    function deepObjectCopy(value) {
		        var result = {};
		        Object.keys(value).forEach(function (key) {
		            result[key] = deepCopy(value[key]);
		        });
		        return result;
		    }
		})(JSONExt = exports.JSONExt || (exports.JSONExt = {}));
		
	} (json));
	return json;
}

var datauri = {};

var hasRequiredDatauri;

function requireDatauri () {
	if (hasRequiredDatauri) return datauri;
	hasRequiredDatauri = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.DataUri = void 0;
		var DataUri;
		(function (DataUri) {
		    function isDataUrl(url) {
		        var prefix = 'data:';
		        return url.substr(0, prefix.length) === prefix;
		    }
		    DataUri.isDataUrl = isDataUrl;
		    /**
		     * Converts an image at `url` to base64-encoded data uri.
		     * The mime type of the image is inferred from the `url` file extension.
		     */
		    function imageToDataUri(url, callback) {
		        // No need to convert to data uri if it is already in data uri.
		        if (!url || isDataUrl(url)) {
		            // Keep the async nature of the function.
		            setTimeout(function () { return callback(null, url); });
		            return;
		        }
		        var onError = function () {
		            callback(new Error("Failed to load image: " + url));
		        };
		        var onLoad = window.FileReader
		            ? // chrome, IE10+
		                function (xhr) {
		                    if (xhr.status === 200) {
		                        var reader = new FileReader();
		                        reader.onload = function (evt) {
		                            var dataUri = evt.target.result;
		                            callback(null, dataUri);
		                        };
		                        reader.onerror = onError;
		                        reader.readAsDataURL(xhr.response);
		                    }
		                    else {
		                        onError();
		                    }
		                }
		            : function (xhr) {
		                var toString = function (u8a) {
		                    var CHUNK_SZ = 0x8000;
		                    var c = [];
		                    for (var i = 0; i < u8a.length; i += CHUNK_SZ) {
		                        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
		                    }
		                    return c.join('');
		                };
		                if (xhr.status === 200) {
		                    var suffix = url.split('.').pop() || 'png';
		                    if (suffix === 'svg') {
		                        suffix = 'svg+xml';
		                    }
		                    var meta = "data:image/" + suffix + ";base64,";
		                    var bytes = new Uint8Array(xhr.response);
		                    var base64 = meta + btoa(toString(bytes));
		                    callback(null, base64);
		                }
		                else {
		                    onError();
		                }
		            };
		        var xhr = new XMLHttpRequest();
		        xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';
		        xhr.open('GET', url, true);
		        xhr.addEventListener('error', onError);
		        xhr.addEventListener('load', function () { return onLoad(xhr); });
		        xhr.send();
		    }
		    DataUri.imageToDataUri = imageToDataUri;
		    function dataUriToBlob(dataUrl) {
		        var uri = dataUrl.replace(/\s/g, '');
		        uri = decodeURIComponent(uri);
		        var index = uri.indexOf(',');
		        var dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'
		        var mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'
		        var data = uri.slice(index + 1);
		        var decodedString;
		        if (dataType.indexOf('base64') >= 0) {
		            // data may be encoded in base64
		            decodedString = atob(data);
		        }
		        else {
		            // convert the decoded string to UTF-8
		            decodedString = unescape(encodeURIComponent(data));
		        }
		        // write the bytes of the string to a typed array
		        var ia = new Uint8Array(decodedString.length);
		        for (var i = 0; i < decodedString.length; i += 1) {
		            ia[i] = decodedString.charCodeAt(i);
		        }
		        return new Blob([ia], { type: mime });
		    }
		    DataUri.dataUriToBlob = dataUriToBlob;
		    function downloadBlob(blob, fileName) {
		        var msSaveBlob = window.navigator.msSaveBlob;
		        if (msSaveBlob) {
		            // requires IE 10+
		            // pulls up a save dialog
		            msSaveBlob(blob, fileName);
		        }
		        else {
		            // other browsers
		            // downloads directly in Chrome and Safari
		            // presents a save/open dialog in Firefox
		            // Firefox bug: `from` field in save dialog always shows `from:blob:`
		            // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327
		            var url = window.URL.createObjectURL(blob);
		            var link = document.createElement('a');
		            link.href = url;
		            link.download = fileName;
		            document.body.appendChild(link);
		            link.click();
		            document.body.removeChild(link);
		            // mark the url for garbage collection
		            window.URL.revokeObjectURL(url);
		        }
		    }
		    DataUri.downloadBlob = downloadBlob;
		    function downloadDataUri(dataUrl, fileName) {
		        var blob = dataUriToBlob(dataUrl);
		        downloadBlob(blob, fileName);
		    }
		    DataUri.downloadDataUri = downloadDataUri;
		    function parseViewBox(svg) {
		        var matches = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
		        if (matches && matches[2]) {
		            return matches[2].replace(/\s+/, ' ').split(' ');
		        }
		        return null;
		    }
		    function getNumber(str) {
		        var ret = parseFloat(str);
		        return Number.isNaN(ret) ? null : ret;
		    }
		    function svgToDataUrl(svg, options) {
		        if (options === void 0) { options = {}; }
		        var viewBox = null;
		        var getNumberFromViewBox = function (index) {
		            if (viewBox == null) {
		                viewBox = parseViewBox(svg);
		            }
		            if (viewBox != null) {
		                return getNumber(viewBox[index]);
		            }
		            return null;
		        };
		        var getNumberFromMatches = function (reg) {
		            var matches = svg.match(reg);
		            if (matches && matches[2]) {
		                return getNumber(matches[2]);
		            }
		            return null;
		        };
		        var w = options.width;
		        if (w == null) {
		            w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
		        }
		        if (w == null) {
		            w = getNumberFromViewBox(2);
		        }
		        if (w == null) {
		            throw new Error('Can not parse width from svg string');
		        }
		        var h = options.height;
		        if (h == null) {
		            h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
		        }
		        if (h == null) {
		            h = getNumberFromViewBox(3);
		        }
		        if (h == null) {
		            throw new Error('Can not parse height from svg string');
		        }
		        var decoded = encodeURIComponent(svg)
		            .replace(/'/g, '%27')
		            .replace(/"/g, '%22');
		        var header = 'data:image/svg+xml';
		        var dataUrl = header + "," + decoded;
		        return dataUrl;
		    }
		    DataUri.svgToDataUrl = svgToDataUrl;
		})(DataUri = exports.DataUri || (exports.DataUri = {}));
		
	} (datauri));
	return datauri;
}

var unit = {};

var hasRequiredUnit;

function requireUnit () {
	if (hasRequiredUnit) return unit;
	hasRequiredUnit = 1;
	(function (exports) {
		"use strict";
		var __importDefault = (unit && unit.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Unit = void 0;
		var jquery_1 = __importDefault(requireJquery());
		var millimeterSize;
		var supportedUnits = {
		    px: function (val) {
		        return val;
		    },
		    mm: function (val) {
		        return millimeterSize * val;
		    },
		    cm: function (val) {
		        return millimeterSize * val * 10;
		    },
		    in: function (val) {
		        return millimeterSize * val * 25.4;
		    },
		    pt: function (val) {
		        return millimeterSize * ((25.4 * val) / 72);
		    },
		    pc: function (val) {
		        return millimeterSize * ((25.4 * val) / 6);
		    },
		};
		// eslint-disable-next-line
		var Unit;
		(function (Unit) {
		    function measure(cssWidth, cssHeight, unit) {
		        var div = (0, jquery_1.default)('<div/>')
		            .css({
		            display: 'inline-block',
		            position: 'absolute',
		            left: -15000,
		            top: -15000,
		            width: cssWidth + (unit || ''),
		            height: cssHeight + (unit || ''),
		        })
		            .appendTo(document.body);
		        var size = {
		            width: div.width() || 0,
		            height: div.height() || 0,
		        };
		        div.remove();
		        return size;
		    }
		    Unit.measure = measure;
		    function toPx(val, unit) {
		        if (millimeterSize == null) {
		            millimeterSize = measure("1", "1", 'mm').width;
		        }
		        var convert = unit ? supportedUnits[unit] : null;
		        if (convert) {
		            return convert(val);
		        }
		        return val;
		    }
		    Unit.toPx = toPx;
		})(Unit = exports.Unit || (exports.Unit = {}));
		
	} (unit));
	return unit;
}

var dom = {};

var main = {};

var core = {};

var af = {};

var hasRequiredAf;

function requireAf () {
	if (hasRequiredAf) return af;
	hasRequiredAf = 1;
	"use strict";
	Object.defineProperty(af, "__esModule", { value: true });
	af.cancelAnimationFrame = af.requestAnimationFrame = void 0;
	af.requestAnimationFrame = (function () {
	    var raf;
	    var win = window;
	    if (win != null) {
	        raf =
	            win.requestAnimationFrame ||
	                win.webkitRequestAnimationFrame ||
	                win.mozRequestAnimationFrame ||
	                win.oRequestAnimationFrame ||
	                win.msRequestAnimationFrame;
	        if (raf != null) {
	            raf = raf.bind(win);
	        }
	    }
	    if (raf == null) {
	        var lastTime_1 = 0;
	        raf = function (callback) {
	            var currTime = new Date().getTime();
	            var timeToCall = Math.max(0, 16 - (currTime - lastTime_1));
	            var id = setTimeout(function () {
	                callback(currTime + timeToCall);
	            }, timeToCall);
	            lastTime_1 = currTime + timeToCall;
	            return id;
	        };
	    }
	    return raf;
	})();
	af.cancelAnimationFrame = (function () {
	    var caf;
	    var win = window;
	    if (win != null) {
	        caf =
	            win.cancelAnimationFrame ||
	                win.webkitCancelAnimationFrame ||
	                win.webkitCancelRequestAnimationFrame ||
	                win.msCancelAnimationFrame ||
	                win.msCancelRequestAnimationFrame ||
	                win.oCancelAnimationFrame ||
	                win.oCancelRequestAnimationFrame ||
	                win.mozCancelAnimationFrame ||
	                win.mozCancelRequestAnimationFrame;
	        if (caf) {
	            caf = caf.bind(win);
	        }
	    }
	    if (caf == null) {
	        caf = clearTimeout;
	    }
	    return caf;
	})();
	
	return af;
}

var style = {};

var prefix = {};

var hasRequiredPrefix;

function requirePrefix () {
	if (hasRequiredPrefix) return prefix;
	hasRequiredPrefix = 1;
	"use strict";
	Object.defineProperty(prefix, "__esModule", { value: true });
	prefix.getVendorPrefixedName = void 0;
	var hyphenPattern = /-(.)/g;
	function camelize(str) {
	    return str.replace(hyphenPattern, function (_, char) { return char.toUpperCase(); });
	}
	var memoized = {};
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	var testStyle = document ? document.createElement('div').style : {};
	function getWithPrefix(name) {
	    for (var i = 0; i < prefixes.length; i += 1) {
	        var prefixedName = prefixes[i] + name;
	        if (prefixedName in testStyle) {
	            return prefixedName;
	        }
	    }
	    return null;
	}
	function getVendorPrefixedName(property) {
	    var name = camelize(property);
	    if (memoized[name] == null) {
	        var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
	        memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
	    }
	    return memoized[name];
	}
	prefix.getVendorPrefixedName = getVendorPrefixedName;
	
	return prefix;
}

var hasRequiredStyle;

function requireStyle () {
	if (hasRequiredStyle) return style;
	hasRequiredStyle = 1;
	"use strict";
	Object.defineProperty(style, "__esModule", { value: true });
	style.hasScrollbars = style.getComputedStyle = style.setPrefixedStyle = void 0;
	var prefix_1 = requirePrefix();
	function setPrefixedStyle(style, name, value) {
	    var vendor = (0, prefix_1.getVendorPrefixedName)(name);
	    if (vendor != null) {
	        style[vendor] = value;
	    }
	    style[name] = value;
	}
	style.setPrefixedStyle = setPrefixedStyle;
	function getComputedStyle(elem, name) {
	    // IE9+
	    var computed = elem.ownerDocument &&
	        elem.ownerDocument.defaultView &&
	        elem.ownerDocument.defaultView.opener
	        ? elem.ownerDocument.defaultView.getComputedStyle(elem, null)
	        : window.getComputedStyle(elem, null);
	    if (computed && name) {
	        return computed.getPropertyValue(name) || computed[name];
	    }
	    return computed;
	}
	style.getComputedStyle = getComputedStyle;
	function hasScrollbars(container) {
	    var style = getComputedStyle(container);
	    return (style != null && (style.overflow === 'scroll' || style.overflow === 'auto'));
	}
	style.hasScrollbars = hasScrollbars;
	
	return style;
}

var selection = {};

var hasRequiredSelection;

function requireSelection () {
	if (hasRequiredSelection) return selection;
	hasRequiredSelection = 1;
	"use strict";
	Object.defineProperty(selection, "__esModule", { value: true });
	selection.clearSelection = void 0;
	selection.clearSelection = (function () {
	    var doc = document;
	    if (doc.selection) {
	        return function () {
	            doc.selection.empty();
	        };
	    }
	    if (window.getSelection) {
	        return function () {
	            var selection = window.getSelection();
	            if (selection) {
	                if (selection.empty) {
	                    selection.empty();
	                }
	                else if (selection.removeAllRanges) {
	                    selection.removeAllRanges();
	                }
	            }
	        };
	    }
	    return function () { };
	})();
	
	return selection;
}

var text = {};

var vector$1 = {};

var geometry$1 = {};

var angle = {};

var hasRequiredAngle;

function requireAngle () {
	if (hasRequiredAngle) return angle;
	hasRequiredAngle = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Angle = void 0;
		var Angle;
		(function (Angle) {
		    /**
		     * Converts radian angle to degree angle.
		     * @param rad The radians to convert.
		     */
		    function toDeg(rad) {
		        return ((180 * rad) / Math.PI) % 360;
		    }
		    Angle.toDeg = toDeg;
		    /**
		     * Converts degree angle to radian angle.
		     * @param deg The degree angle to convert.
		     * @param over360
		     */
		    Angle.toRad = function (deg, over360) {
		        if (over360 === void 0) { over360 = false; }
		        var d = over360 ? deg : deg % 360;
		        return (d * Math.PI) / 180;
		    };
		    /**
		     * Returns the angle in degrees and clamps its value between `0` and `360`.
		     */
		    function normalize(angle) {
		        return (angle % 360) + (angle < 0 ? 360 : 0);
		    }
		    Angle.normalize = normalize;
		})(Angle = exports.Angle || (exports.Angle = {}));
		
	} (angle));
	return angle;
}

var point = {};

var util$3 = {};

var hasRequiredUtil$4;

function requireUtil$4 () {
	if (hasRequiredUtil$4) return util$3;
	hasRequiredUtil$4 = 1;
	"use strict";
	Object.defineProperty(util$3, "__esModule", { value: true });
	util$3.squaredLength = util$3.containsPoint = util$3.snapToGrid = util$3.clamp = util$3.random = util$3.round = void 0;
	function round(num, precision) {
	    if (precision === void 0) { precision = 0; }
	    return Number.isInteger(num) ? num : +num.toFixed(precision);
	}
	util$3.round = round;
	function random(min, max) {
	    var mmin;
	    var mmax;
	    if (max == null) {
	        mmax = min == null ? 1 : min;
	        mmin = 0;
	    }
	    else {
	        mmax = max;
	        mmin = min == null ? 0 : min;
	    }
	    if (mmax < mmin) {
	        var temp = mmin;
	        mmin = mmax;
	        mmax = temp;
	    }
	    return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
	}
	util$3.random = random;
	function clamp(value, min, max) {
	    if (Number.isNaN(value)) {
	        return NaN;
	    }
	    if (Number.isNaN(min) || Number.isNaN(max)) {
	        return 0;
	    }
	    return min < max
	        ? value < min
	            ? min
	            : value > max
	                ? max
	                : value
	        : value < max
	            ? max
	            : value > min
	                ? min
	                : value;
	}
	util$3.clamp = clamp;
	function snapToGrid(value, gridSize) {
	    return gridSize * Math.round(value / gridSize);
	}
	util$3.snapToGrid = snapToGrid;
	function containsPoint(rect, point) {
	    return (point != null &&
	        rect != null &&
	        point.x >= rect.x &&
	        point.x <= rect.x + rect.width &&
	        point.y >= rect.y &&
	        point.y <= rect.y + rect.height);
	}
	util$3.containsPoint = containsPoint;
	function squaredLength(p1, p2) {
	    var dx = p1.x - p2.x;
	    var dy = p1.y - p2.y;
	    return dx * dx + dy * dy;
	}
	util$3.squaredLength = squaredLength;
	
	return util$3;
}

var geometry = {};

var hasRequiredGeometry$1;

function requireGeometry$1 () {
	if (hasRequiredGeometry$1) return geometry;
	hasRequiredGeometry$1 = 1;
	"use strict";
	Object.defineProperty(geometry, "__esModule", { value: true });
	geometry.Geometry = void 0;
	var Geometry = /** @class */ (function () {
	    function Geometry() {
	    }
	    Geometry.prototype.valueOf = function () {
	        return this.toJSON();
	    };
	    Geometry.prototype.toString = function () {
	        return JSON.stringify(this.toJSON());
	    };
	    return Geometry;
	}());
	geometry.Geometry = Geometry;
	
	return geometry;
}

var hasRequiredPoint;

function requirePoint () {
	if (hasRequiredPoint) return point;
	hasRequiredPoint = 1;
	(function (exports) {
		"use strict";
		var __extends = (point && point.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		var __createBinding = (point && point.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (point && point.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (point && point.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Point = void 0;
		var util = __importStar(requireUtil$4());
		var angle_1 = requireAngle();
		var geometry_1 = requireGeometry$1();
		var Point = /** @class */ (function (_super) {
		    __extends(Point, _super);
		    function Point(x, y) {
		        var _this = _super.call(this) || this;
		        _this.x = x == null ? 0 : x;
		        _this.y = y == null ? 0 : y;
		        return _this;
		    }
		    Object.defineProperty(Point.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Point.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    /**
		     * Rounds the point to the given precision.
		     */
		    Point.prototype.round = function (precision) {
		        if (precision === void 0) { precision = 0; }
		        this.x = util.round(this.x, precision);
		        this.y = util.round(this.y, precision);
		        return this;
		    };
		    Point.prototype.add = function (x, y) {
		        var p = Point.create(x, y);
		        this.x += p.x;
		        this.y += p.y;
		        return this;
		    };
		    Point.prototype.update = function (x, y) {
		        var p = Point.create(x, y);
		        this.x = p.x;
		        this.y = p.y;
		        return this;
		    };
		    Point.prototype.translate = function (dx, dy) {
		        var t = Point.create(dx, dy);
		        this.x += t.x;
		        this.y += t.y;
		        return this;
		    };
		    /**
		     * Rotate the point by `degree` around `center`.
		     */
		    Point.prototype.rotate = function (degree, center) {
		        var p = Point.rotate(this, degree, center);
		        this.x = p.x;
		        this.y = p.y;
		        return this;
		    };
		    /**
		     * Scale point by `sx` and `sy` around the given `origin`. If origin is not
		     * specified, the point is scaled around `0,0`.
		     */
		    Point.prototype.scale = function (sx, sy, origin) {
		        if (origin === void 0) { origin = new Point(); }
		        var ref = Point.create(origin);
		        this.x = ref.x + sx * (this.x - ref.x);
		        this.y = ref.y + sy * (this.y - ref.y);
		        return this;
		    };
		    /**
		     * Chooses the point closest to this point from among `points`. If `points`
		     * is an empty array, `null` is returned.
		     */
		    Point.prototype.closest = function (points) {
		        var _this = this;
		        if (points.length === 1) {
		            return Point.create(points[0]);
		        }
		        var ret = null;
		        var min = Infinity;
		        points.forEach(function (p) {
		            var dist = _this.squaredDistance(p);
		            if (dist < min) {
		                ret = p;
		                min = dist;
		            }
		        });
		        return ret ? Point.create(ret) : null;
		    };
		    /**
		     * Returns the distance between the point and another point `p`.
		     */
		    Point.prototype.distance = function (p) {
		        return Math.sqrt(this.squaredDistance(p));
		    };
		    /**
		     * Returns the squared distance between the point and another point `p`.
		     *
		     * Useful for distance comparisons in which real distance is not necessary
		     * (saves one `Math.sqrt()` operation).
		     */
		    Point.prototype.squaredDistance = function (p) {
		        var ref = Point.create(p);
		        var dx = this.x - ref.x;
		        var dy = this.y - ref.y;
		        return dx * dx + dy * dy;
		    };
		    Point.prototype.manhattanDistance = function (p) {
		        var ref = Point.create(p);
		        return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);
		    };
		    /**
		     * Returns the magnitude of the point vector.
		     *
		     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
		     */
		    Point.prototype.magnitude = function () {
		        return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
		    };
		    /**
		     * Returns the angle(in degrees) between vector from this point to `p` and
		     * the x-axis.
		     */
		    Point.prototype.theta = function (p) {
		        if (p === void 0) { p = new Point(); }
		        var ref = Point.create(p);
		        var y = -(ref.y - this.y); // invert the y-axis.
		        var x = ref.x - this.x;
		        var rad = Math.atan2(y, x);
		        // Correction for III. and IV. quadrant.
		        if (rad < 0) {
		            rad = 2 * Math.PI + rad;
		        }
		        return (180 * rad) / Math.PI;
		    };
		    /**
		     * Returns the angle(in degrees) between vector from this point to `p1` and
		     * the vector from this point to `p2`.
		     *
		     * The ordering of points `p1` and `p2` is important.
		     *
		     * The function returns a value between `0` and `180` when the angle (in the
		     * direction from `p1` to `p2`) is clockwise, and a value between `180` and
		     * `360` when the angle is counterclockwise.
		     *
		     * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
		     */
		    Point.prototype.angleBetween = function (p1, p2) {
		        if (this.equals(p1) || this.equals(p2)) {
		            return NaN;
		        }
		        var angle = this.theta(p2) - this.theta(p1);
		        if (angle < 0) {
		            angle += 360;
		        }
		        return angle;
		    };
		    /**
		     * Returns the angle(in degrees) between the line from `(0,0)` and this point
		     * and the line from `(0,0)` to `p`.
		     *
		     * The function returns a value between `0` and `180` when the angle (in the
		     * direction from this point to `p`) is clockwise, and a value between `180`
		     * and `360` when the angle is counterclockwise. Returns `NaN` if called from
		     * point `(0,0)` or if `p` is `(0,0)`.
		     */
		    Point.prototype.vectorAngle = function (p) {
		        var zero = new Point(0, 0);
		        return zero.angleBetween(this, p);
		    };
		    /**
		     * Converts rectangular to polar coordinates.
		     */
		    Point.prototype.toPolar = function (origin) {
		        this.update(Point.toPolar(this, origin));
		        return this;
		    };
		    /**
		     * Returns the change in angle(in degrees) that is the result of moving the
		     * point from its previous position to its current position.
		     *
		     * More specifically, this function computes the angle between the line from
		     * the ref point to the previous position of this point(i.e. current position
		     * `-dx`, `-dy`) and the line from the `ref` point to the current position of
		     * this point.
		     *
		     * The function returns a positive value between `0` and `180` when the angle
		     * (in the direction from previous position of this point to its current
		     * position) is clockwise, and a negative value between `0` and `-180` when
		     * the angle is counterclockwise.
		     *
		     * The function returns `0` if the previous and current positions of this
		     * point are the same (i.e. both `dx` and `dy` are `0`).
		     */
		    Point.prototype.changeInAngle = function (dx, dy, ref) {
		        if (ref === void 0) { ref = new Point(); }
		        // Revert the translation and measure the change in angle around x-axis.
		        return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);
		    };
		    /**
		     * If the point lies outside the rectangle `rect`, adjust the point so that
		     * it becomes the nearest point on the boundary of `rect`.
		     */
		    Point.prototype.adhereToRect = function (rect) {
		        if (!util.containsPoint(rect, this)) {
		            this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);
		            this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);
		        }
		        return this;
		    };
		    /**
		     * Returns the bearing(cardinal direction) between me and the given point.
		     *
		     * @see https://en.wikipedia.org/wiki/Cardinal_direction
		     */
		    Point.prototype.bearing = function (p) {
		        var ref = Point.create(p);
		        var lat1 = angle_1.Angle.toRad(this.y);
		        var lat2 = angle_1.Angle.toRad(ref.y);
		        var lon1 = this.x;
		        var lon2 = ref.x;
		        var dLon = angle_1.Angle.toRad(lon2 - lon1);
		        var y = Math.sin(dLon) * Math.cos(lat2);
		        var x = Math.cos(lat1) * Math.sin(lat2) -
		            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
		        var brng = angle_1.Angle.toDeg(Math.atan2(y, x));
		        var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
		        var index = brng - 22.5;
		        if (index < 0) {
		            index += 360;
		        }
		        index = parseInt((index / 45), 10);
		        return bearings[index];
		    };
		    /**
		     * Returns the cross product of the vector from me to `p1` and the vector
		     * from me to `p2`.
		     *
		     * The left-hand rule is used because the coordinate system is left-handed.
		     */
		    Point.prototype.cross = function (p1, p2) {
		        if (p1 != null && p2 != null) {
		            var a = Point.create(p1);
		            var b = Point.create(p2);
		            return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
		        }
		        return NaN;
		    };
		    /**
		     * Returns the dot product of this point with given other point.
		     */
		    Point.prototype.dot = function (p) {
		        var ref = Point.create(p);
		        return this.x * ref.x + this.y * ref.y;
		    };
		    Point.prototype.diff = function (dx, dy) {
		        if (typeof dx === 'number') {
		            return new Point(this.x - dx, this.y - dy);
		        }
		        var p = Point.create(dx);
		        return new Point(this.x - p.x, this.y - p.y);
		    };
		    /**
		     * Returns an interpolation between me and point `p` for a parametert in
		     * the closed interval `[0, 1]`.
		     */
		    Point.prototype.lerp = function (p, t) {
		        var ref = Point.create(p);
		        return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);
		    };
		    /**
		     * Normalize the point vector, scale the line segment between `(0, 0)`
		     * and the point in order for it to have the given length. If length is
		     * not specified, it is considered to be `1`; in that case, a unit vector
		     * is computed.
		     */
		    Point.prototype.normalize = function (length) {
		        if (length === void 0) { length = 1; }
		        var scale = length / this.magnitude();
		        return this.scale(scale, scale);
		    };
		    /**
		     * Moves this point along the line starting from `ref` to this point by a
		     * certain `distance`.
		     */
		    Point.prototype.move = function (ref, distance) {
		        var p = Point.create(ref);
		        var rad = angle_1.Angle.toRad(p.theta(this));
		        return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
		    };
		    /**
		     * Returns a point that is the reflection of me with the center of inversion
		     * in `ref` point.
		     */
		    Point.prototype.reflection = function (ref) {
		        return Point.create(ref).move(this, this.distance(ref));
		    };
		    Point.prototype.snapToGrid = function (gx, gy) {
		        this.x = util.snapToGrid(this.x, gx);
		        this.y = util.snapToGrid(this.y, gy == null ? gx : gy);
		        return this;
		    };
		    Point.prototype.equals = function (p) {
		        var ref = Point.create(p);
		        return ref != null && ref.x === this.x && ref.y === this.y;
		    };
		    Point.prototype.clone = function () {
		        return Point.clone(this);
		    };
		    /**
		     * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
		     */
		    Point.prototype.toJSON = function () {
		        return Point.toJSON(this);
		    };
		    Point.prototype.serialize = function () {
		        return this.x + " " + this.y;
		    };
		    return Point;
		}(geometry_1.Geometry));
		exports.Point = Point;
		(function (Point) {
		    Point.toStringTag = "X6.Geometry." + Point.name;
		    function isPoint(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Point) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var point = instance;
		        if ((tag == null || tag === Point.toStringTag) &&
		            typeof point.x === 'number' &&
		            typeof point.y === 'number' &&
		            typeof point.toPolar === 'function') {
		            return true;
		        }
		        return false;
		    }
		    Point.isPoint = isPoint;
		})(Point = exports.Point || (exports.Point = {}));
		exports.Point = Point;
		(function (Point) {
		    function isPointLike(p) {
		        return (p != null &&
		            typeof p === 'object' &&
		            typeof p.x === 'number' &&
		            typeof p.y === 'number');
		    }
		    Point.isPointLike = isPointLike;
		    function isPointData(p) {
		        return (p != null &&
		            Array.isArray(p) &&
		            p.length === 2 &&
		            typeof p[0] === 'number' &&
		            typeof p[1] === 'number');
		    }
		    Point.isPointData = isPointData;
		})(Point = exports.Point || (exports.Point = {}));
		exports.Point = Point;
		(function (Point) {
		    function create(x, y) {
		        if (x == null || typeof x === 'number') {
		            return new Point(x, y);
		        }
		        return clone(x);
		    }
		    Point.create = create;
		    function clone(p) {
		        if (Point.isPoint(p)) {
		            return new Point(p.x, p.y);
		        }
		        if (Array.isArray(p)) {
		            return new Point(p[0], p[1]);
		        }
		        return new Point(p.x, p.y);
		    }
		    Point.clone = clone;
		    function toJSON(p) {
		        if (Point.isPoint(p)) {
		            return { x: p.x, y: p.y };
		        }
		        if (Array.isArray(p)) {
		            return { x: p[0], y: p[1] };
		        }
		        return { x: p.x, y: p.y };
		    }
		    Point.toJSON = toJSON;
		    /**
		     * Returns a new Point object from the given polar coordinates.
		     * @see http://en.wikipedia.org/wiki/Polar_coordinate_system
		     */
		    function fromPolar(r, rad, origin) {
		        if (origin === void 0) { origin = new Point(); }
		        var x = Math.abs(r * Math.cos(rad));
		        var y = Math.abs(r * Math.sin(rad));
		        var org = clone(origin);
		        var deg = angle_1.Angle.normalize(angle_1.Angle.toDeg(rad));
		        if (deg < 90) {
		            y = -y;
		        }
		        else if (deg < 180) {
		            x = -x;
		            y = -y;
		        }
		        else if (deg < 270) {
		            x = -x;
		        }
		        return new Point(org.x + x, org.y + y);
		    }
		    Point.fromPolar = fromPolar;
		    /**
		     * Converts rectangular to polar coordinates.
		     */
		    function toPolar(point, origin) {
		        if (origin === void 0) { origin = new Point(); }
		        var p = clone(point);
		        var o = clone(origin);
		        var dx = p.x - o.x;
		        var dy = p.y - o.y;
		        return new Point(Math.sqrt(dx * dx + dy * dy), // r
		        angle_1.Angle.toRad(o.theta(p)));
		    }
		    Point.toPolar = toPolar;
		    function equals(p1, p2) {
		        if (p1 === p2) {
		            return true;
		        }
		        if (p1 != null && p2 != null) {
		            return p1.x === p2.x && p1.y === p2.y;
		        }
		        return false;
		    }
		    Point.equals = equals;
		    function equalPoints(p1, p2) {
		        if ((p1 == null && p2 != null) ||
		            (p1 != null && p2 == null) ||
		            (p1 != null && p2 != null && p1.length !== p2.length)) {
		            return false;
		        }
		        if (p1 != null && p2 != null) {
		            for (var i = 0, ii = p1.length; i < ii; i += 1) {
		                if (!equals(p1[i], p2[i])) {
		                    return false;
		                }
		            }
		        }
		        return true;
		    }
		    Point.equalPoints = equalPoints;
		    /**
		     * Returns a point with random coordinates that fall within the range
		     * `[x1, x2]` and `[y1, y2]`.
		     */
		    function random(x1, x2, y1, y2) {
		        return new Point(util.random(x1, x2), util.random(y1, y2));
		    }
		    Point.random = random;
		    function rotate(point, angle, center) {
		        var rad = angle_1.Angle.toRad(angle_1.Angle.normalize(-angle));
		        var sin = Math.sin(rad);
		        var cos = Math.cos(rad);
		        return rotateEx(point, cos, sin, center);
		    }
		    Point.rotate = rotate;
		    function rotateEx(point, cos, sin, center) {
		        if (center === void 0) { center = new Point(); }
		        var source = clone(point);
		        var origin = clone(center);
		        var dx = source.x - origin.x;
		        var dy = source.y - origin.y;
		        var x1 = dx * cos - dy * sin;
		        var y1 = dy * cos + dx * sin;
		        return new Point(x1 + origin.x, y1 + origin.y);
		    }
		    Point.rotateEx = rotateEx;
		})(Point = exports.Point || (exports.Point = {}));
		exports.Point = Point;
		
	} (point));
	return point;
}

var line = {};

var rectangle = {};

var hasRequiredRectangle;

function requireRectangle () {
	if (hasRequiredRectangle) return rectangle;
	hasRequiredRectangle = 1;
	(function (exports) {
		"use strict";
		var __extends = (rectangle && rectangle.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		var __createBinding = (rectangle && rectangle.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (rectangle && rectangle.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (rectangle && rectangle.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Rectangle = void 0;
		var util = __importStar(requireUtil$4());
		var angle_1 = requireAngle();
		var line_1 = requireLine();
		var point_1 = requirePoint();
		var geometry_1 = requireGeometry$1();
		var Rectangle = /** @class */ (function (_super) {
		    __extends(Rectangle, _super);
		    function Rectangle(x, y, width, height) {
		        var _this = _super.call(this) || this;
		        _this.x = x == null ? 0 : x;
		        _this.y = y == null ? 0 : y;
		        _this.width = width == null ? 0 : width;
		        _this.height = height == null ? 0 : height;
		        return _this;
		    }
		    Object.defineProperty(Rectangle.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Rectangle.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "left", {
		        get: function () {
		            return this.x;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "top", {
		        get: function () {
		            return this.y;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "right", {
		        get: function () {
		            return this.x + this.width;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "bottom", {
		        get: function () {
		            return this.y + this.height;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "origin", {
		        get: function () {
		            return new point_1.Point(this.x, this.y);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "topLeft", {
		        get: function () {
		            return new point_1.Point(this.x, this.y);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "topCenter", {
		        get: function () {
		            return new point_1.Point(this.x + this.width / 2, this.y);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "topRight", {
		        get: function () {
		            return new point_1.Point(this.x + this.width, this.y);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "center", {
		        get: function () {
		            return new point_1.Point(this.x + this.width / 2, this.y + this.height / 2);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "bottomLeft", {
		        get: function () {
		            return new point_1.Point(this.x, this.y + this.height);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "bottomCenter", {
		        get: function () {
		            return new point_1.Point(this.x + this.width / 2, this.y + this.height);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "bottomRight", {
		        get: function () {
		            return new point_1.Point(this.x + this.width, this.y + this.height);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "corner", {
		        get: function () {
		            return new point_1.Point(this.x + this.width, this.y + this.height);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "rightMiddle", {
		        get: function () {
		            return new point_1.Point(this.x + this.width, this.y + this.height / 2);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "leftMiddle", {
		        get: function () {
		            return new point_1.Point(this.x, this.y + this.height / 2);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "topLine", {
		        get: function () {
		            return new line_1.Line(this.topLeft, this.topRight);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "rightLine", {
		        get: function () {
		            return new line_1.Line(this.topRight, this.bottomRight);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "bottomLine", {
		        get: function () {
		            return new line_1.Line(this.bottomLeft, this.bottomRight);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Rectangle.prototype, "leftLine", {
		        get: function () {
		            return new line_1.Line(this.topLeft, this.bottomLeft);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Rectangle.prototype.getOrigin = function () {
		        return this.origin;
		    };
		    Rectangle.prototype.getTopLeft = function () {
		        return this.topLeft;
		    };
		    Rectangle.prototype.getTopCenter = function () {
		        return this.topCenter;
		    };
		    Rectangle.prototype.getTopRight = function () {
		        return this.topRight;
		    };
		    Rectangle.prototype.getCenter = function () {
		        return this.center;
		    };
		    Rectangle.prototype.getCenterX = function () {
		        return this.x + this.width / 2;
		    };
		    Rectangle.prototype.getCenterY = function () {
		        return this.y + this.height / 2;
		    };
		    Rectangle.prototype.getBottomLeft = function () {
		        return this.bottomLeft;
		    };
		    Rectangle.prototype.getBottomCenter = function () {
		        return this.bottomCenter;
		    };
		    Rectangle.prototype.getBottomRight = function () {
		        return this.bottomRight;
		    };
		    Rectangle.prototype.getCorner = function () {
		        return this.corner;
		    };
		    Rectangle.prototype.getRightMiddle = function () {
		        return this.rightMiddle;
		    };
		    Rectangle.prototype.getLeftMiddle = function () {
		        return this.leftMiddle;
		    };
		    Rectangle.prototype.getTopLine = function () {
		        return this.topLine;
		    };
		    Rectangle.prototype.getRightLine = function () {
		        return this.rightLine;
		    };
		    Rectangle.prototype.getBottomLine = function () {
		        return this.bottomLine;
		    };
		    Rectangle.prototype.getLeftLine = function () {
		        return this.leftLine;
		    };
		    /**
		     * Returns a rectangle that is the bounding box of the rectangle.
		     *
		     * If `angle` is specified, the bounding box calculation will take into
		     * account the rotation of the rectangle by angle degrees around its center.
		     */
		    Rectangle.prototype.bbox = function (angle) {
		        if (!angle) {
		            return this.clone();
		        }
		        var rad = angle_1.Angle.toRad(angle);
		        var st = Math.abs(Math.sin(rad));
		        var ct = Math.abs(Math.cos(rad));
		        var w = this.width * ct + this.height * st;
		        var h = this.width * st + this.height * ct;
		        return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
		    };
		    Rectangle.prototype.round = function (precision) {
		        if (precision === void 0) { precision = 0; }
		        this.x = util.round(this.x, precision);
		        this.y = util.round(this.y, precision);
		        this.width = util.round(this.width, precision);
		        this.height = util.round(this.height, precision);
		        return this;
		    };
		    Rectangle.prototype.add = function (x, y, width, height) {
		        var rect = Rectangle.create(x, y, width, height);
		        var minX = Math.min(this.x, rect.x);
		        var minY = Math.min(this.y, rect.y);
		        var maxX = Math.max(this.x + this.width, rect.x + rect.width);
		        var maxY = Math.max(this.y + this.height, rect.y + rect.height);
		        this.x = minX;
		        this.y = minY;
		        this.width = maxX - minX;
		        this.height = maxY - minY;
		        return this;
		    };
		    Rectangle.prototype.update = function (x, y, width, height) {
		        var rect = Rectangle.create(x, y, width, height);
		        this.x = rect.x;
		        this.y = rect.y;
		        this.width = rect.width;
		        this.height = rect.height;
		        return this;
		    };
		    Rectangle.prototype.inflate = function (dx, dy) {
		        var w = dx;
		        var h = dy != null ? dy : dx;
		        this.x -= w;
		        this.y -= h;
		        this.width += 2 * w;
		        this.height += 2 * h;
		        return this;
		    };
		    Rectangle.prototype.snapToGrid = function (gx, gy) {
		        var origin = this.origin.snapToGrid(gx, gy);
		        var corner = this.corner.snapToGrid(gx, gy);
		        this.x = origin.x;
		        this.y = origin.y;
		        this.width = corner.x - origin.x;
		        this.height = corner.y - origin.y;
		        return this;
		    };
		    Rectangle.prototype.translate = function (tx, ty) {
		        var p = point_1.Point.create(tx, ty);
		        this.x += p.x;
		        this.y += p.y;
		        return this;
		    };
		    Rectangle.prototype.scale = function (sx, sy, origin) {
		        if (origin === void 0) { origin = new point_1.Point(); }
		        var pos = this.origin.scale(sx, sy, origin);
		        this.x = pos.x;
		        this.y = pos.y;
		        this.width *= sx;
		        this.height *= sy;
		        return this;
		    };
		    Rectangle.prototype.rotate = function (degree, center) {
		        if (center === void 0) { center = this.getCenter(); }
		        if (degree !== 0) {
		            var rad = angle_1.Angle.toRad(degree);
		            var cos = Math.cos(rad);
		            var sin = Math.sin(rad);
		            var p1 = this.getOrigin();
		            var p2 = this.getTopRight();
		            var p3 = this.getBottomRight();
		            var p4 = this.getBottomLeft();
		            p1 = point_1.Point.rotateEx(p1, cos, sin, center);
		            p2 = point_1.Point.rotateEx(p2, cos, sin, center);
		            p3 = point_1.Point.rotateEx(p3, cos, sin, center);
		            p4 = point_1.Point.rotateEx(p4, cos, sin, center);
		            var rect = new Rectangle(p1.x, p1.y, 0, 0);
		            rect.add(p2.x, p2.y, 0, 0);
		            rect.add(p3.x, p3.y, 0, 0);
		            rect.add(p4.x, p4.y, 0, 0);
		            this.update(rect);
		        }
		        return this;
		    };
		    Rectangle.prototype.rotate90 = function () {
		        var t = (this.width - this.height) / 2;
		        this.x += t;
		        this.y -= t;
		        var tmp = this.width;
		        this.width = this.height;
		        this.height = tmp;
		        return this;
		    };
		    /**
		     * Translates the rectangle by `rect.x` and `rect.y` and expand it by
		     * `rect.width` and `rect.height`.
		     */
		    Rectangle.prototype.moveAndExpand = function (rect) {
		        var ref = Rectangle.clone(rect);
		        this.x += ref.x || 0;
		        this.y += ref.y || 0;
		        this.width += ref.width || 0;
		        this.height += ref.height || 0;
		        return this;
		    };
		    /**
		     * Returns an object where `sx` and `sy` give the maximum scaling that can be
		     * applied to the rectangle so that it would still fit into `limit`. If
		     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
		     * scaled around its center.
		     */
		    Rectangle.prototype.getMaxScaleToFit = function (limit, origin) {
		        if (origin === void 0) { origin = this.center; }
		        var rect = Rectangle.clone(limit);
		        var ox = origin.x;
		        var oy = origin.y;
		        // Find the maximal possible scale for all corners, so when the scale
		        // is applied the point is still inside the rectangle.
		        var sx1 = Infinity;
		        var sx2 = Infinity;
		        var sx3 = Infinity;
		        var sx4 = Infinity;
		        var sy1 = Infinity;
		        var sy2 = Infinity;
		        var sy3 = Infinity;
		        var sy4 = Infinity;
		        // Top Left
		        var p1 = rect.topLeft;
		        if (p1.x < ox) {
		            sx1 = (this.x - ox) / (p1.x - ox);
		        }
		        if (p1.y < oy) {
		            sy1 = (this.y - oy) / (p1.y - oy);
		        }
		        // Bottom Right
		        var p2 = rect.bottomRight;
		        if (p2.x > ox) {
		            sx2 = (this.x + this.width - ox) / (p2.x - ox);
		        }
		        if (p2.y > oy) {
		            sy2 = (this.y + this.height - oy) / (p2.y - oy);
		        }
		        // Top Right
		        var p3 = rect.topRight;
		        if (p3.x > ox) {
		            sx3 = (this.x + this.width - ox) / (p3.x - ox);
		        }
		        if (p3.y < oy) {
		            sy3 = (this.y - oy) / (p3.y - oy);
		        }
		        // Bottom Left
		        var p4 = rect.bottomLeft;
		        if (p4.x < ox) {
		            sx4 = (this.x - ox) / (p4.x - ox);
		        }
		        if (p4.y > oy) {
		            sy4 = (this.y + this.height - oy) / (p4.y - oy);
		        }
		        return {
		            sx: Math.min(sx1, sx2, sx3, sx4),
		            sy: Math.min(sy1, sy2, sy3, sy4),
		        };
		    };
		    /**
		     * Returns a number that specifies the maximum scaling that can be applied to
		     * the rectangle along both axes so that it would still fit into `limit`. If
		     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
		     * scaled around its center.
		     */
		    Rectangle.prototype.getMaxUniformScaleToFit = function (limit, origin) {
		        if (origin === void 0) { origin = this.center; }
		        var scale = this.getMaxScaleToFit(limit, origin);
		        return Math.min(scale.sx, scale.sy);
		    };
		    Rectangle.prototype.containsPoint = function (x, y) {
		        return util.containsPoint(this, point_1.Point.create(x, y));
		    };
		    Rectangle.prototype.containsRect = function (x, y, width, height) {
		        var b = Rectangle.create(x, y, width, height);
		        var x1 = this.x;
		        var y1 = this.y;
		        var w1 = this.width;
		        var h1 = this.height;
		        var x2 = b.x;
		        var y2 = b.y;
		        var w2 = b.width;
		        var h2 = b.height;
		        // one of the dimensions is 0
		        if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
		            return false;
		        }
		        return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
		    };
		    /**
		     * Returns an array of the intersection points of the rectangle and the line.
		     * Return `null` if no intersection exists.
		     */
		    Rectangle.prototype.intersectsWithLine = function (line) {
		        var rectLines = [
		            this.topLine,
		            this.rightLine,
		            this.bottomLine,
		            this.leftLine,
		        ];
		        var points = [];
		        var dedupeArr = [];
		        rectLines.forEach(function (l) {
		            var p = line.intersectsWithLine(l);
		            if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
		                points.push(p);
		                dedupeArr.push(p.toString());
		            }
		        });
		        return points.length > 0 ? points : null;
		    };
		    /**
		     * Returns the point on the boundary of the rectangle that is the intersection
		     * of the rectangle with a line starting in the center the rectangle ending in
		     * the point `p`.
		     *
		     * If `angle` is specified, the intersection will take into account the
		     * rotation of the rectangle by `angle` degrees around its center.
		     */
		    Rectangle.prototype.intersectsWithLineFromCenterToPoint = function (p, angle) {
		        var ref = point_1.Point.clone(p);
		        var center = this.center;
		        var result = null;
		        if (angle != null && angle !== 0) {
		            ref.rotate(angle, center);
		        }
		        var sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
		        var connector = new line_1.Line(center, ref);
		        for (var i = sides.length - 1; i >= 0; i -= 1) {
		            var intersection = sides[i].intersectsWithLine(connector);
		            if (intersection !== null) {
		                result = intersection;
		                break;
		            }
		        }
		        if (result && angle != null && angle !== 0) {
		            result.rotate(-angle, center);
		        }
		        return result;
		    };
		    Rectangle.prototype.intersectsWithRect = function (x, y, width, height) {
		        var ref = Rectangle.create(x, y, width, height);
		        // no intersection
		        if (!this.isIntersectWithRect(ref)) {
		            return null;
		        }
		        var myOrigin = this.origin;
		        var myCorner = this.corner;
		        var rOrigin = ref.origin;
		        var rCorner = ref.corner;
		        var xx = Math.max(myOrigin.x, rOrigin.x);
		        var yy = Math.max(myOrigin.y, rOrigin.y);
		        return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
		    };
		    Rectangle.prototype.isIntersectWithRect = function (x, y, width, height) {
		        var ref = Rectangle.create(x, y, width, height);
		        var myOrigin = this.origin;
		        var myCorner = this.corner;
		        var rOrigin = ref.origin;
		        var rCorner = ref.corner;
		        if (rCorner.x <= myOrigin.x ||
		            rCorner.y <= myOrigin.y ||
		            rOrigin.x >= myCorner.x ||
		            rOrigin.y >= myCorner.y) {
		            return false;
		        }
		        return true;
		    };
		    /**
		     * Normalize the rectangle, i.e. make it so that it has non-negative
		     * width and height. If width is less than `0`, the function swaps left and
		     * right corners and if height is less than `0`, the top and bottom corners
		     * are swapped.
		     */
		    Rectangle.prototype.normalize = function () {
		        var newx = this.x;
		        var newy = this.y;
		        var newwidth = this.width;
		        var newheight = this.height;
		        if (this.width < 0) {
		            newx = this.x + this.width;
		            newwidth = -this.width;
		        }
		        if (this.height < 0) {
		            newy = this.y + this.height;
		            newheight = -this.height;
		        }
		        this.x = newx;
		        this.y = newy;
		        this.width = newwidth;
		        this.height = newheight;
		        return this;
		    };
		    /**
		     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
		     */
		    Rectangle.prototype.union = function (rect) {
		        var ref = Rectangle.clone(rect);
		        var myOrigin = this.origin;
		        var myCorner = this.corner;
		        var rOrigin = ref.origin;
		        var rCorner = ref.corner;
		        var originX = Math.min(myOrigin.x, rOrigin.x);
		        var originY = Math.min(myOrigin.y, rOrigin.y);
		        var cornerX = Math.max(myCorner.x, rCorner.x);
		        var cornerY = Math.max(myCorner.y, rCorner.y);
		        return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);
		    };
		    /**
		     * Returns a string ("top", "left", "right" or "bottom") denoting the side of
		     * the rectangle which is nearest to the point `p`.
		     */
		    Rectangle.prototype.getNearestSideToPoint = function (p) {
		        var ref = point_1.Point.clone(p);
		        var distLeft = ref.x - this.x;
		        var distRight = this.x + this.width - ref.x;
		        var distTop = ref.y - this.y;
		        var distBottom = this.y + this.height - ref.y;
		        var closest = distLeft;
		        var side = 'left';
		        if (distRight < closest) {
		            closest = distRight;
		            side = 'right';
		        }
		        if (distTop < closest) {
		            closest = distTop;
		            side = 'top';
		        }
		        if (distBottom < closest) {
		            side = 'bottom';
		        }
		        return side;
		    };
		    /**
		     * Returns a point on the boundary of the rectangle nearest to the point `p`.
		     */
		    Rectangle.prototype.getNearestPointToPoint = function (p) {
		        var ref = point_1.Point.clone(p);
		        if (this.containsPoint(ref)) {
		            var side = this.getNearestSideToPoint(ref);
		            switch (side) {
		                case 'right':
		                    return new point_1.Point(this.x + this.width, ref.y);
		                case 'left':
		                    return new point_1.Point(this.x, ref.y);
		                case 'bottom':
		                    return new point_1.Point(ref.x, this.y + this.height);
		                case 'top':
		                    return new point_1.Point(ref.x, this.y);
		                default:
		                    break;
		            }
		        }
		        return ref.adhereToRect(this);
		    };
		    Rectangle.prototype.equals = function (rect) {
		        return (rect != null &&
		            rect.x === this.x &&
		            rect.y === this.y &&
		            rect.width === this.width &&
		            rect.height === this.height);
		    };
		    Rectangle.prototype.clone = function () {
		        return new Rectangle(this.x, this.y, this.width, this.height);
		    };
		    Rectangle.prototype.toJSON = function () {
		        return { x: this.x, y: this.y, width: this.width, height: this.height };
		    };
		    Rectangle.prototype.serialize = function () {
		        return this.x + " " + this.y + " " + this.width + " " + this.height;
		    };
		    return Rectangle;
		}(geometry_1.Geometry));
		exports.Rectangle = Rectangle;
		(function (Rectangle) {
		    Rectangle.toStringTag = "X6.Geometry." + Rectangle.name;
		    function isRectangle(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Rectangle) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var rect = instance;
		        if ((tag == null || tag === Rectangle.toStringTag) &&
		            typeof rect.x === 'number' &&
		            typeof rect.y === 'number' &&
		            typeof rect.width === 'number' &&
		            typeof rect.height === 'number' &&
		            typeof rect.inflate === 'function' &&
		            typeof rect.moveAndExpand === 'function') {
		            return true;
		        }
		        return false;
		    }
		    Rectangle.isRectangle = isRectangle;
		})(Rectangle = exports.Rectangle || (exports.Rectangle = {}));
		exports.Rectangle = Rectangle;
		(function (Rectangle) {
		    function isRectangleLike(o) {
		        return (o != null &&
		            typeof o === 'object' &&
		            typeof o.x === 'number' &&
		            typeof o.y === 'number' &&
		            typeof o.width === 'number' &&
		            typeof o.height === 'number');
		    }
		    Rectangle.isRectangleLike = isRectangleLike;
		})(Rectangle = exports.Rectangle || (exports.Rectangle = {}));
		exports.Rectangle = Rectangle;
		(function (Rectangle) {
		    function create(x, y, width, height) {
		        if (x == null || typeof x === 'number') {
		            return new Rectangle(x, y, width, height);
		        }
		        return clone(x);
		    }
		    Rectangle.create = create;
		    function clone(rect) {
		        if (Rectangle.isRectangle(rect)) {
		            return rect.clone();
		        }
		        if (Array.isArray(rect)) {
		            return new Rectangle(rect[0], rect[1], rect[2], rect[3]);
		        }
		        return new Rectangle(rect.x, rect.y, rect.width, rect.height);
		    }
		    Rectangle.clone = clone;
		    function fromSize(size) {
		        return new Rectangle(0, 0, size.width, size.height);
		    }
		    Rectangle.fromSize = fromSize;
		    function fromPositionAndSize(pos, size) {
		        return new Rectangle(pos.x, pos.y, size.width, size.height);
		    }
		    Rectangle.fromPositionAndSize = fromPositionAndSize;
		    /**
		     * Returns a new rectangle from the given ellipse.
		     */
		    function fromEllipse(ellipse) {
		        return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);
		    }
		    Rectangle.fromEllipse = fromEllipse;
		})(Rectangle = exports.Rectangle || (exports.Rectangle = {}));
		exports.Rectangle = Rectangle;
		
	} (rectangle));
	return rectangle;
}

var hasRequiredLine;

function requireLine () {
	if (hasRequiredLine) return line;
	hasRequiredLine = 1;
	(function (exports) {
		"use strict";
		var __extends = (line && line.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Line = void 0;
		var point_1 = requirePoint();
		var geometry_1 = requireGeometry$1();
		var rectangle_1 = requireRectangle();
		var Line = /** @class */ (function (_super) {
		    __extends(Line, _super);
		    function Line(x1, y1, x2, y2) {
		        var _this = _super.call(this) || this;
		        if (typeof x1 === 'number' && typeof y1 === 'number') {
		            _this.start = new point_1.Point(x1, y1);
		            _this.end = new point_1.Point(x2, y2);
		        }
		        else {
		            _this.start = point_1.Point.create(x1);
		            _this.end = point_1.Point.create(y1);
		        }
		        return _this;
		    }
		    Object.defineProperty(Line.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Line.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Line.prototype, "center", {
		        get: function () {
		            return new point_1.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Line.prototype.getCenter = function () {
		        return this.center;
		    };
		    /**
		     * Rounds the line to the given `precision`.
		     */
		    Line.prototype.round = function (precision) {
		        if (precision === void 0) { precision = 0; }
		        this.start.round(precision);
		        this.end.round(precision);
		        return this;
		    };
		    Line.prototype.translate = function (tx, ty) {
		        if (typeof tx === 'number') {
		            this.start.translate(tx, ty);
		            this.end.translate(tx, ty);
		        }
		        else {
		            this.start.translate(tx);
		            this.end.translate(tx);
		        }
		        return this;
		    };
		    /**
		     * Rotate the line by `angle` around `origin`.
		     */
		    Line.prototype.rotate = function (angle, origin) {
		        this.start.rotate(angle, origin);
		        this.end.rotate(angle, origin);
		        return this;
		    };
		    /**
		     * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
		     * specified, the line is scaled around `0,0`.
		     */
		    Line.prototype.scale = function (sx, sy, origin) {
		        this.start.scale(sx, sy, origin);
		        this.end.scale(sx, sy, origin);
		        return this;
		    };
		    /**
		     * Returns the length of the line.
		     */
		    Line.prototype.length = function () {
		        return Math.sqrt(this.squaredLength());
		    };
		    /**
		     * Useful for distance comparisons in which real length is not necessary
		     * (saves one `Math.sqrt()` operation).
		     */
		    Line.prototype.squaredLength = function () {
		        var dx = this.start.x - this.end.x;
		        var dy = this.start.y - this.end.y;
		        return dx * dx + dy * dy;
		    };
		    /**
		     * Scale the line so that it has the requested length. The start point of
		     * the line is preserved.
		     */
		    Line.prototype.setLength = function (length) {
		        var total = this.length();
		        if (!total) {
		            return this;
		        }
		        var scale = length / total;
		        return this.scale(scale, scale, this.start);
		    };
		    Line.prototype.parallel = function (distance) {
		        var line = this.clone();
		        if (!line.isDifferentiable()) {
		            return line;
		        }
		        var start = line.start, end = line.end;
		        var eRef = start.clone().rotate(270, end);
		        var sRef = end.clone().rotate(90, start);
		        start.move(sRef, distance);
		        end.move(eRef, distance);
		        return line;
		    };
		    /**
		     * Returns the vector of the line with length equal to length of the line.
		     */
		    Line.prototype.vector = function () {
		        return new point_1.Point(this.end.x - this.start.x, this.end.y - this.start.y);
		    };
		    /**
		     * Returns the angle of incline of the line.
		     *
		     * The function returns `NaN` if the start and end endpoints of the line
		     * both lie at the same coordinates(it is impossible to determine the angle
		     * of incline of a line that appears to be a point). The
		     * `line.isDifferentiable()` function may be used in advance to determine
		     * whether the angle of incline can be computed for a given line.
		     */
		    Line.prototype.angle = function () {
		        var horizontal = new point_1.Point(this.start.x + 1, this.start.y);
		        return this.start.angleBetween(this.end, horizontal);
		    };
		    /**
		     * Returns a rectangle that is the bounding box of the line.
		     */
		    Line.prototype.bbox = function () {
		        var left = Math.min(this.start.x, this.end.x);
		        var top = Math.min(this.start.y, this.end.y);
		        var right = Math.max(this.start.x, this.end.x);
		        var bottom = Math.max(this.start.y, this.end.y);
		        return new rectangle_1.Rectangle(left, top, right - left, bottom - top);
		    };
		    /**
		     * Returns the bearing (cardinal direction) of the line.
		     *
		     * The return value is one of the following strings:
		     * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
		     *
		     * The function returns 'N' if the two endpoints of the line are coincident.
		     */
		    Line.prototype.bearing = function () {
		        return this.start.bearing(this.end);
		    };
		    /**
		     * Returns the point on the line that lies closest to point `p`.
		     */
		    Line.prototype.closestPoint = function (p) {
		        return this.pointAt(this.closestPointNormalizedLength(p));
		    };
		    /**
		     * Returns the length of the line up to the point that lies closest to point `p`.
		     */
		    Line.prototype.closestPointLength = function (p) {
		        return this.closestPointNormalizedLength(p) * this.length();
		    };
		    /**
		     * Returns a line that is tangent to the line at the point that lies closest
		     * to point `p`.
		     */
		    Line.prototype.closestPointTangent = function (p) {
		        return this.tangentAt(this.closestPointNormalizedLength(p));
		    };
		    /**
		     * Returns the normalized length (distance from the start of the line / total
		     * line length) of the line up to the point that lies closest to point.
		     */
		    Line.prototype.closestPointNormalizedLength = function (p) {
		        var product = this.vector().dot(new Line(this.start, p).vector());
		        var normalized = Math.min(1, Math.max(0, product / this.squaredLength()));
		        // normalized returns `NaN` if this line has zero length
		        if (Number.isNaN(normalized)) {
		            return 0;
		        }
		        return normalized;
		    };
		    /**
		     * Returns a point on the line that lies `rate` (normalized length) away from
		     * the beginning of the line.
		     */
		    Line.prototype.pointAt = function (ratio) {
		        var start = this.start;
		        var end = this.end;
		        if (ratio <= 0) {
		            return start.clone();
		        }
		        if (ratio >= 1) {
		            return end.clone();
		        }
		        return start.lerp(end, ratio);
		    };
		    /**
		     * Returns a point on the line that lies length away from the beginning of
		     * the line.
		     */
		    Line.prototype.pointAtLength = function (length) {
		        var start = this.start;
		        var end = this.end;
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false; // start calculation from end point
		            length = -length; // eslint-disable-line
		        }
		        var total = this.length();
		        if (length >= total) {
		            return fromStart ? end.clone() : start.clone();
		        }
		        var rate = (fromStart ? length : total - length) / total;
		        return this.pointAt(rate);
		    };
		    /**
		     * Divides the line into two lines at the point that lies `rate` (normalized
		     * length) away from the beginning of the line.
		     */
		    Line.prototype.divideAt = function (ratio) {
		        var dividerPoint = this.pointAt(ratio);
		        return [
		            new Line(this.start, dividerPoint),
		            new Line(dividerPoint, this.end),
		        ];
		    };
		    /**
		     * Divides the line into two lines at the point that lies length away from
		     * the beginning of the line.
		     */
		    Line.prototype.divideAtLength = function (length) {
		        var dividerPoint = this.pointAtLength(length);
		        return [
		            new Line(this.start, dividerPoint),
		            new Line(dividerPoint, this.end),
		        ];
		    };
		    /**
		     * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
		     */
		    Line.prototype.containsPoint = function (p) {
		        var start = this.start;
		        var end = this.end;
		        // cross product of 0 indicates that this line and
		        // the vector to `p` are collinear.
		        if (start.cross(p, end) !== 0) {
		            return false;
		        }
		        var length = this.length();
		        if (new Line(start, p).length() > length) {
		            return false;
		        }
		        if (new Line(p, end).length() > length) {
		            return false;
		        }
		        return true;
		    };
		    Line.prototype.intersect = function (shape, options) {
		        var ret = shape.intersectsWithLine(this, options);
		        if (ret) {
		            return Array.isArray(ret) ? ret : [ret];
		        }
		        return null;
		    };
		    /**
		     * Returns the intersection point of the line with another line. Returns
		     * `null` if no intersection exists.
		     */
		    Line.prototype.intersectsWithLine = function (line) {
		        var pt1Dir = new point_1.Point(this.end.x - this.start.x, this.end.y - this.start.y);
		        var pt2Dir = new point_1.Point(line.end.x - line.start.x, line.end.y - line.start.y);
		        var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
		        var deltaPt = new point_1.Point(line.start.x - this.start.x, line.start.y - this.start.y);
		        var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
		        var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
		        if (det === 0 || alpha * det < 0 || beta * det < 0) {
		            return null;
		        }
		        if (det > 0) {
		            if (alpha > det || beta > det) {
		                return null;
		            }
		        }
		        else if (alpha < det || beta < det) {
		            return null;
		        }
		        return new point_1.Point(this.start.x + (alpha * pt1Dir.x) / det, this.start.y + (alpha * pt1Dir.y) / det);
		    };
		    /**
		     * Returns `true` if a tangent line can be found for the line.
		     *
		     * Tangents cannot be found if both of the line endpoints are coincident
		     * (the line appears to be a point).
		     */
		    Line.prototype.isDifferentiable = function () {
		        return !this.start.equals(this.end);
		    };
		    /**
		     * Returns the perpendicular distance between the line and point. The
		     * distance is positive if the point lies to the right of the line, negative
		     * if the point lies to the left of the line, and `0` if the point lies on
		     * the line.
		     */
		    Line.prototype.pointOffset = function (p) {
		        var ref = point_1.Point.clone(p);
		        var start = this.start;
		        var end = this.end;
		        var determinant = (end.x - start.x) * (ref.y - start.y) -
		            (end.y - start.y) * (ref.x - start.x);
		        return determinant / this.length();
		    };
		    Line.prototype.pointSquaredDistance = function (x, y) {
		        var p = point_1.Point.create(x, y);
		        return this.closestPoint(p).squaredDistance(p);
		    };
		    Line.prototype.pointDistance = function (x, y) {
		        var p = point_1.Point.create(x, y);
		        return this.closestPoint(p).distance(p);
		    };
		    /**
		     * Returns a line tangent to the line at point that lies `rate` (normalized
		     * length) away from the beginning of the line.
		     */
		    Line.prototype.tangentAt = function (ratio) {
		        if (!this.isDifferentiable()) {
		            return null;
		        }
		        var start = this.start;
		        var end = this.end;
		        var tangentStart = this.pointAt(ratio);
		        var tangentLine = new Line(start, end);
		        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
		        return tangentLine;
		    };
		    /**
		     * Returns a line tangent to the line at point that lies `length` away from
		     * the beginning of the line.
		     */
		    Line.prototype.tangentAtLength = function (length) {
		        if (!this.isDifferentiable()) {
		            return null;
		        }
		        var start = this.start;
		        var end = this.end;
		        var tangentStart = this.pointAtLength(length);
		        var tangentLine = new Line(start, end);
		        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
		        return tangentLine;
		    };
		    Line.prototype.relativeCcw = function (x, y) {
		        var ref = point_1.Point.create(x, y);
		        var dx1 = ref.x - this.start.x;
		        var dy1 = ref.y - this.start.y;
		        var dx2 = this.end.x - this.start.x;
		        var dy2 = this.end.y - this.start.y;
		        var ccw = dx1 * dy2 - dy1 * dx2;
		        if (ccw === 0) {
		            ccw = dx1 * dx2 + dy1 * dy2;
		            if (ccw > 0.0) {
		                dx1 -= dx2;
		                dy1 -= dy2;
		                ccw = dx1 * dx2 + dy1 * dy2;
		                if (ccw < 0.0) {
		                    ccw = 0.0;
		                }
		            }
		        }
		        return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;
		    };
		    /**
		     * Return `true` if the line equals the other line.
		     */
		    Line.prototype.equals = function (l) {
		        return (l != null &&
		            this.start.x === l.start.x &&
		            this.start.y === l.start.y &&
		            this.end.x === l.end.x &&
		            this.end.y === l.end.y);
		    };
		    /**
		     * Returns another line which is a clone of the line.
		     */
		    Line.prototype.clone = function () {
		        return new Line(this.start, this.end);
		    };
		    Line.prototype.toJSON = function () {
		        return { start: this.start.toJSON(), end: this.end.toJSON() };
		    };
		    Line.prototype.serialize = function () {
		        return [this.start.serialize(), this.end.serialize()].join(' ');
		    };
		    return Line;
		}(geometry_1.Geometry));
		exports.Line = Line;
		(function (Line) {
		    Line.toStringTag = "X6.Geometry." + Line.name;
		    function isLine(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Line) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var line = instance;
		        try {
		            if ((tag == null || tag === Line.toStringTag) &&
		                point_1.Point.isPoint(line.start) &&
		                point_1.Point.isPoint(line.end) &&
		                typeof line.vector === 'function' &&
		                typeof line.bearing === 'function' &&
		                typeof line.parallel === 'function' &&
		                typeof line.intersect === 'function') {
		                return true;
		            }
		        }
		        catch (e) {
		            return false;
		        }
		        return false;
		    }
		    Line.isLine = isLine;
		})(Line = exports.Line || (exports.Line = {}));
		exports.Line = Line;
		
	} (line));
	return line;
}

var ellipse = {};

var hasRequiredEllipse;

function requireEllipse () {
	if (hasRequiredEllipse) return ellipse;
	hasRequiredEllipse = 1;
	(function (exports) {
		"use strict";
		var __extends = (ellipse && ellipse.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Ellipse = void 0;
		var point_1 = requirePoint();
		var rectangle_1 = requireRectangle();
		var geometry_1 = requireGeometry$1();
		var Ellipse = /** @class */ (function (_super) {
		    __extends(Ellipse, _super);
		    function Ellipse(x, y, a, b) {
		        var _this = _super.call(this) || this;
		        _this.x = x == null ? 0 : x;
		        _this.y = y == null ? 0 : y;
		        _this.a = a == null ? 0 : a;
		        _this.b = b == null ? 0 : b;
		        return _this;
		    }
		    Object.defineProperty(Ellipse.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Ellipse.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Ellipse.prototype, "center", {
		        get: function () {
		            return new point_1.Point(this.x, this.y);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    /**
		     * Returns a rectangle that is the bounding box of the ellipse.
		     */
		    Ellipse.prototype.bbox = function () {
		        return rectangle_1.Rectangle.fromEllipse(this);
		    };
		    /**
		     * Returns a point that is the center of the ellipse.
		     */
		    Ellipse.prototype.getCenter = function () {
		        return this.center;
		    };
		    Ellipse.prototype.inflate = function (dx, dy) {
		        var w = dx;
		        var h = dy != null ? dy : dx;
		        this.a += 2 * w;
		        this.b += 2 * h;
		        return this;
		    };
		    Ellipse.prototype.normalizedDistance = function (x, y) {
		        var ref = point_1.Point.create(x, y);
		        var dx = ref.x - this.x;
		        var dy = ref.y - this.y;
		        var a = this.a;
		        var b = this.b;
		        return (dx * dx) / (a * a) + (dy * dy) / (b * b);
		    };
		    Ellipse.prototype.containsPoint = function (x, y) {
		        return this.normalizedDistance(x, y) <= 1;
		    };
		    /**
		     * Returns an array of the intersection points of the ellipse and the line.
		     * Returns `null` if no intersection exists.
		     */
		    Ellipse.prototype.intersectsWithLine = function (line) {
		        var intersections = [];
		        var rx = this.a;
		        var ry = this.b;
		        var a1 = line.start;
		        var a2 = line.end;
		        var dir = line.vector();
		        var diff = a1.diff(new point_1.Point(this.x, this.y));
		        var mDir = new point_1.Point(dir.x / (rx * rx), dir.y / (ry * ry));
		        var mDiff = new point_1.Point(diff.x / (rx * rx), diff.y / (ry * ry));
		        var a = dir.dot(mDir);
		        var b = dir.dot(mDiff);
		        var c = diff.dot(mDiff) - 1.0;
		        var d = b * b - a * c;
		        if (d < 0) {
		            return null;
		        }
		        if (d > 0) {
		            var root = Math.sqrt(d);
		            var ta = (-b - root) / a;
		            var tb = (-b + root) / a;
		            if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {
		                // outside
		                return null;
		            }
		            if (ta >= 0 && ta <= 1) {
		                intersections.push(a1.lerp(a2, ta));
		            }
		            if (tb >= 0 && tb <= 1) {
		                intersections.push(a1.lerp(a2, tb));
		            }
		        }
		        else {
		            var t = -b / a;
		            if (t >= 0 && t <= 1) {
		                intersections.push(a1.lerp(a2, t));
		            }
		            else {
		                // outside
		                return null;
		            }
		        }
		        return intersections;
		    };
		    /**
		     * Returns the point on the boundary of the ellipse that is the
		     * intersection of the ellipse with a line starting in the center
		     * of the ellipse ending in the point `p`.
		     *
		     * If angle is specified, the intersection will take into account
		     * the rotation of the ellipse by angle degrees around its center.
		     */
		    Ellipse.prototype.intersectsWithLineFromCenterToPoint = function (p, angle) {
		        if (angle === void 0) { angle = 0; }
		        var ref = point_1.Point.clone(p);
		        if (angle) {
		            ref.rotate(angle, this.getCenter());
		        }
		        var dx = ref.x - this.x;
		        var dy = ref.y - this.y;
		        var result;
		        if (dx === 0) {
		            result = this.bbox().getNearestPointToPoint(ref);
		            if (angle) {
		                return result.rotate(-angle, this.getCenter());
		            }
		            return result;
		        }
		        var m = dy / dx;
		        var mSquared = m * m;
		        var aSquared = this.a * this.a;
		        var bSquared = this.b * this.b;
		        var x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
		        x = dx < 0 ? -x : x;
		        var y = m * x;
		        result = new point_1.Point(this.x + x, this.y + y);
		        if (angle) {
		            return result.rotate(-angle, this.getCenter());
		        }
		        return result;
		    };
		    /**
		     * Returns the angle between the x-axis and the tangent from a point. It is
		     * valid for points lying on the ellipse boundary only.
		     */
		    Ellipse.prototype.tangentTheta = function (p) {
		        var ref = point_1.Point.clone(p);
		        var x0 = ref.x;
		        var y0 = ref.y;
		        var a = this.a;
		        var b = this.b;
		        var center = this.bbox().center;
		        var cx = center.x;
		        var cy = center.y;
		        var refPointDelta = 30;
		        var q1 = x0 > center.x + a / 2;
		        var q3 = x0 < center.x - a / 2;
		        var x;
		        var y;
		        if (q1 || q3) {
		            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
		            x =
		                (a * a) / (x0 - cx) -
		                    (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +
		                    cx;
		        }
		        else {
		            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
		            y =
		                (b * b) / (y0 - cy) -
		                    (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +
		                    cy;
		        }
		        return new point_1.Point(x, y).theta(ref);
		    };
		    Ellipse.prototype.scale = function (sx, sy) {
		        this.a *= sx;
		        this.b *= sy;
		        return this;
		    };
		    Ellipse.prototype.rotate = function (angle, origin) {
		        var rect = rectangle_1.Rectangle.fromEllipse(this);
		        rect.rotate(angle, origin);
		        var ellipse = Ellipse.fromRect(rect);
		        this.a = ellipse.a;
		        this.b = ellipse.b;
		        this.x = ellipse.x;
		        this.y = ellipse.y;
		        return this;
		    };
		    Ellipse.prototype.translate = function (dx, dy) {
		        var p = point_1.Point.create(dx, dy);
		        this.x += p.x;
		        this.y += p.y;
		        return this;
		    };
		    Ellipse.prototype.equals = function (ellipse) {
		        return (ellipse != null &&
		            ellipse.x === this.x &&
		            ellipse.y === this.y &&
		            ellipse.a === this.a &&
		            ellipse.b === this.b);
		    };
		    Ellipse.prototype.clone = function () {
		        return new Ellipse(this.x, this.y, this.a, this.b);
		    };
		    Ellipse.prototype.toJSON = function () {
		        return { x: this.x, y: this.y, a: this.a, b: this.b };
		    };
		    Ellipse.prototype.serialize = function () {
		        return this.x + " " + this.y + " " + this.a + " " + this.b;
		    };
		    return Ellipse;
		}(geometry_1.Geometry));
		exports.Ellipse = Ellipse;
		(function (Ellipse) {
		    Ellipse.toStringTag = "X6.Geometry." + Ellipse.name;
		    function isEllipse(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Ellipse) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var ellipse = instance;
		        if ((tag == null || tag === Ellipse.toStringTag) &&
		            typeof ellipse.x === 'number' &&
		            typeof ellipse.y === 'number' &&
		            typeof ellipse.a === 'number' &&
		            typeof ellipse.b === 'number' &&
		            typeof ellipse.inflate === 'function' &&
		            typeof ellipse.normalizedDistance === 'function') {
		            return true;
		        }
		        return false;
		    }
		    Ellipse.isEllipse = isEllipse;
		})(Ellipse = exports.Ellipse || (exports.Ellipse = {}));
		exports.Ellipse = Ellipse;
		(function (Ellipse) {
		    function create(x, y, a, b) {
		        if (x == null || typeof x === 'number') {
		            return new Ellipse(x, y, a, b);
		        }
		        return parse(x);
		    }
		    Ellipse.create = create;
		    function parse(e) {
		        if (Ellipse.isEllipse(e)) {
		            return e.clone();
		        }
		        if (Array.isArray(e)) {
		            return new Ellipse(e[0], e[1], e[2], e[3]);
		        }
		        return new Ellipse(e.x, e.y, e.a, e.b);
		    }
		    Ellipse.parse = parse;
		    function fromRect(rect) {
		        var center = rect.center;
		        return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);
		    }
		    Ellipse.fromRect = fromRect;
		})(Ellipse = exports.Ellipse || (exports.Ellipse = {}));
		exports.Ellipse = Ellipse;
		
	} (ellipse));
	return ellipse;
}

var path$2 = {};

var path$1 = {};

var curve = {};

var polyline = {};

var hasRequiredPolyline;

function requirePolyline () {
	if (hasRequiredPolyline) return polyline;
	hasRequiredPolyline = 1;
	(function (exports) {
		"use strict";
		var __extends = (polyline && polyline.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Polyline = void 0;
		var point_1 = requirePoint();
		var rectangle_1 = requireRectangle();
		var line_1 = requireLine();
		var geometry_1 = requireGeometry$1();
		var Polyline = /** @class */ (function (_super) {
		    __extends(Polyline, _super);
		    function Polyline(points) {
		        var _this = _super.call(this) || this;
		        if (points != null) {
		            if (typeof points === 'string') {
		                return Polyline.parse(points);
		            }
		            _this.points = points.map(function (p) { return point_1.Point.create(p); });
		        }
		        else {
		            _this.points = [];
		        }
		        return _this;
		    }
		    Object.defineProperty(Polyline.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Polyline.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Polyline.prototype, "start", {
		        get: function () {
		            if (this.points.length === 0) {
		                return null;
		            }
		            return this.points[0];
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Polyline.prototype, "end", {
		        get: function () {
		            if (this.points.length === 0) {
		                return null;
		            }
		            return this.points[this.points.length - 1];
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Polyline.prototype.scale = function (sx, sy, origin) {
		        if (origin === void 0) { origin = new point_1.Point(); }
		        this.points.forEach(function (p) { return p.scale(sx, sy, origin); });
		        return this;
		    };
		    Polyline.prototype.rotate = function (angle, origin) {
		        this.points.forEach(function (p) { return p.rotate(angle, origin); });
		        return this;
		    };
		    Polyline.prototype.translate = function (dx, dy) {
		        var t = point_1.Point.create(dx, dy);
		        this.points.forEach(function (p) { return p.translate(t.x, t.y); });
		        return this;
		    };
		    Polyline.prototype.bbox = function () {
		        if (this.points.length === 0) {
		            return new rectangle_1.Rectangle();
		        }
		        var x1 = Infinity;
		        var x2 = -Infinity;
		        var y1 = Infinity;
		        var y2 = -Infinity;
		        var points = this.points;
		        for (var i = 0, ii = points.length; i < ii; i += 1) {
		            var point = points[i];
		            var x = point.x;
		            var y = point.y;
		            if (x < x1)
		                x1 = x;
		            if (x > x2)
		                x2 = x;
		            if (y < y1)
		                y1 = y;
		            if (y > y2)
		                y2 = y;
		        }
		        return new rectangle_1.Rectangle(x1, y1, x2 - x1, y2 - y1);
		    };
		    Polyline.prototype.closestPoint = function (p) {
		        var cpLength = this.closestPointLength(p);
		        return this.pointAtLength(cpLength);
		    };
		    Polyline.prototype.closestPointLength = function (p) {
		        var points = this.points;
		        var count = points.length;
		        if (count === 0 || count === 1) {
		            return 0;
		        }
		        var length = 0;
		        var cpLength = 0;
		        var minSqrDistance = Infinity;
		        for (var i = 0, ii = count - 1; i < ii; i += 1) {
		            var line = new line_1.Line(points[i], points[i + 1]);
		            var lineLength = line.length();
		            var cpNormalizedLength = line.closestPointNormalizedLength(p);
		            var cp = line.pointAt(cpNormalizedLength);
		            var sqrDistance = cp.squaredDistance(p);
		            if (sqrDistance < minSqrDistance) {
		                minSqrDistance = sqrDistance;
		                cpLength = length + cpNormalizedLength * lineLength;
		            }
		            length += lineLength;
		        }
		        return cpLength;
		    };
		    Polyline.prototype.closestPointNormalizedLength = function (p) {
		        var cpLength = this.closestPointLength(p);
		        if (cpLength === 0) {
		            return 0;
		        }
		        var length = this.length();
		        if (length === 0) {
		            return 0;
		        }
		        return cpLength / length;
		    };
		    Polyline.prototype.closestPointTangent = function (p) {
		        var cpLength = this.closestPointLength(p);
		        return this.tangentAtLength(cpLength);
		    };
		    Polyline.prototype.containsPoint = function (p) {
		        if (this.points.length === 0) {
		            return false;
		        }
		        var ref = point_1.Point.clone(p);
		        var x = ref.x;
		        var y = ref.y;
		        var points = this.points;
		        var count = points.length;
		        var startIndex = count - 1;
		        var intersectionCount = 0;
		        for (var endIndex = 0; endIndex < count; endIndex += 1) {
		            var start = points[startIndex];
		            var end = points[endIndex];
		            if (ref.equals(start)) {
		                return true;
		            }
		            var segment = new line_1.Line(start, end);
		            if (segment.containsPoint(p)) {
		                return true;
		            }
		            // do we have an intersection?
		            if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {
		                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
		                // (when `y === start.y === end.y`)
		                // this conditional branch IS entered when `segment` touches `ray` at only one point
		                // (e.g. when `y === start.y !== end.y`)
		                // since this branch is entered again for the following segment, the two touches cancel out
		                var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
		                if (xDifference >= 0) {
		                    // segment lies at least partially to the right of `p`
		                    var rayEnd = new point_1.Point(x + xDifference, y); // right
		                    var ray = new line_1.Line(p, rayEnd);
		                    if (segment.intersectsWithLine(ray)) {
		                        // an intersection was detected to the right of `p`
		                        intersectionCount += 1;
		                    }
		                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)
		            }
		            // move to check the next polyline segment
		            startIndex = endIndex;
		        }
		        // returns `true` for odd numbers of intersections (even-odd algorithm)
		        return intersectionCount % 2 === 1;
		    };
		    Polyline.prototype.intersectsWithLine = function (line) {
		        var intersections = [];
		        for (var i = 0, n = this.points.length - 1; i < n; i += 1) {
		            var a = this.points[i];
		            var b = this.points[i + 1];
		            var int = line.intersectsWithLine(new line_1.Line(a, b));
		            if (int) {
		                intersections.push(int);
		            }
		        }
		        return intersections.length > 0 ? intersections : null;
		    };
		    Polyline.prototype.isDifferentiable = function () {
		        for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {
		            var a = this.points[i];
		            var b = this.points[i + 1];
		            var line = new line_1.Line(a, b);
		            if (line.isDifferentiable()) {
		                return true;
		            }
		        }
		        return false;
		    };
		    Polyline.prototype.length = function () {
		        var len = 0;
		        for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {
		            var a = this.points[i];
		            var b = this.points[i + 1];
		            len += a.distance(b);
		        }
		        return len;
		    };
		    Polyline.prototype.pointAt = function (ratio) {
		        var points = this.points;
		        var count = points.length;
		        if (count === 0) {
		            return null;
		        }
		        if (count === 1) {
		            return points[0].clone();
		        }
		        if (ratio <= 0) {
		            return points[0].clone();
		        }
		        if (ratio >= 1) {
		            return points[count - 1].clone();
		        }
		        var total = this.length();
		        var length = total * ratio;
		        return this.pointAtLength(length);
		    };
		    Polyline.prototype.pointAtLength = function (length) {
		        var points = this.points;
		        var count = points.length;
		        if (count === 0) {
		            return null;
		        }
		        if (count === 1) {
		            return points[0].clone();
		        }
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false;
		            length = -length; // eslint-disable-line
		        }
		        var tmp = 0;
		        for (var i = 0, ii = count - 1; i < ii; i += 1) {
		            var index = fromStart ? i : ii - 1 - i;
		            var a = points[index];
		            var b = points[index + 1];
		            var l = new line_1.Line(a, b);
		            var d = a.distance(b);
		            if (length <= tmp + d) {
		                return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));
		            }
		            tmp += d;
		        }
		        var lastPoint = fromStart ? points[count - 1] : points[0];
		        return lastPoint.clone();
		    };
		    Polyline.prototype.tangentAt = function (ratio) {
		        var points = this.points;
		        var count = points.length;
		        if (count === 0 || count === 1) {
		            return null;
		        }
		        if (ratio < 0) {
		            ratio = 0; // eslint-disable-line
		        }
		        if (ratio > 1) {
		            ratio = 1; // eslint-disable-line
		        }
		        var total = this.length();
		        var length = total * ratio;
		        return this.tangentAtLength(length);
		    };
		    Polyline.prototype.tangentAtLength = function (length) {
		        var points = this.points;
		        var count = points.length;
		        if (count === 0 || count === 1) {
		            return null;
		        }
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false;
		            length = -length; // eslint-disable-line
		        }
		        var lastValidLine;
		        var tmp = 0;
		        for (var i = 0, ii = count - 1; i < ii; i += 1) {
		            var index = fromStart ? i : ii - 1 - i;
		            var a = points[index];
		            var b = points[index + 1];
		            var l = new line_1.Line(a, b);
		            var d = a.distance(b);
		            if (l.isDifferentiable()) {
		                // has a tangent line (line length is not 0)
		                if (length <= tmp + d) {
		                    return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));
		                }
		                lastValidLine = l;
		            }
		            tmp += d;
		        }
		        if (lastValidLine) {
		            var ratio = fromStart ? 1 : 0;
		            return lastValidLine.tangentAt(ratio);
		        }
		        return null;
		    };
		    Polyline.prototype.simplify = function (
		    // TODO: Accept startIndex and endIndex to specify where to start and end simplification
		    options) {
		        if (options === void 0) { options = {}; }
		        var points = this.points;
		        // we need at least 3 points
		        if (points.length < 3) {
		            return this;
		        }
		        var threshold = options.threshold || 0;
		        // start at the beginning of the polyline and go forward
		        var currentIndex = 0;
		        // we need at least one intermediate point (3 points) in every iteration
		        // as soon as that stops being true, we know we reached the end of the polyline
		        while (points[currentIndex + 2]) {
		            var firstIndex = currentIndex;
		            var middleIndex = currentIndex + 1;
		            var lastIndex = currentIndex + 2;
		            var firstPoint = points[firstIndex];
		            var middlePoint = points[middleIndex];
		            var lastPoint = points[lastIndex];
		            var chord = new line_1.Line(firstPoint, lastPoint); // = connection between first and last point
		            var closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point
		            var closestPointDistance = closestPoint.distance(middlePoint);
		            if (closestPointDistance <= threshold) {
		                // middle point is close enough to the chord = simplify
		                // 1) remove middle point:
		                points.splice(middleIndex, 1);
		                // 2) in next iteration, investigate the newly-created triplet of points
		                //    - do not change `currentIndex`
		                //    = (first point stays, point after removed point becomes middle point)
		            }
		            else {
		                // middle point is far from the chord
		                // 1) preserve middle point
		                // 2) in next iteration, move `currentIndex` by one step:
		                currentIndex += 1;
		                //    = (point after first point becomes first point)
		            }
		        }
		        // `points` array was modified in-place
		        return this;
		    };
		    Polyline.prototype.toHull = function () {
		        var points = this.points;
		        var count = points.length;
		        if (count === 0) {
		            return new Polyline();
		        }
		        // Step 1: find the starting point -- point with
		        // the lowest y (if equality, highest x).
		        var startPoint = points[0];
		        for (var i = 1; i < count; i += 1) {
		            if (points[i].y < startPoint.y) {
		                startPoint = points[i];
		            }
		            else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
		                startPoint = points[i];
		            }
		        }
		        // Step 2: sort the list of points by angle between line
		        // from start point to current point and the x-axis (theta).
		        // Step 2a: create the point records = [point, originalIndex, angle]
		        var sortedRecords = [];
		        for (var i = 0; i < count; i += 1) {
		            var angle = startPoint.theta(points[i]);
		            if (angle === 0) {
		                // Give highest angle to start point.
		                // The start point will end up at end of sorted list.
		                // The start point will end up at beginning of hull points list.
		                angle = 360;
		            }
		            sortedRecords.push([points[i], i, angle]);
		        }
		        // Step 2b: sort the list in place
		        sortedRecords.sort(function (record1, record2) {
		            var ret = record1[2] - record2[2];
		            if (ret === 0) {
		                ret = record2[1] - record1[1];
		            }
		            return ret;
		        });
		        // Step 2c: duplicate start record from the top of
		        // the stack to the bottom of the stack.
		        if (sortedRecords.length > 2) {
		            var startPoint_1 = sortedRecords[sortedRecords.length - 1];
		            sortedRecords.unshift(startPoint_1);
		        }
		        // Step 3
		        // ------
		        // Step 3a: go through sorted points in order and find those with
		        // right turns, and we want to get our results in clockwise order.
		        // Dictionary of points with left turns - cannot be on the hull.
		        var insidePoints = {};
		        // Stack of records with right turns - hull point candidates.
		        var hullRecords = [];
		        var getKey = function (record) {
		            return record[0].toString() + "@" + record[1];
		        };
		        while (sortedRecords.length !== 0) {
		            var currentRecord = sortedRecords.pop();
		            var currentPoint = currentRecord[0];
		            // Check if point has already been discarded.
		            if (insidePoints[getKey(currentRecord)]) {
		                continue;
		            }
		            var correctTurnFound = false;
		            while (!correctTurnFound) {
		                if (hullRecords.length < 2) {
		                    // Not enough points for comparison, just add current point.
		                    hullRecords.push(currentRecord);
		                    correctTurnFound = true;
		                }
		                else {
		                    var lastHullRecord = hullRecords.pop();
		                    var lastHullPoint = lastHullRecord[0];
		                    var secondLastHullRecord = hullRecords.pop();
		                    var secondLastHullPoint = secondLastHullRecord[0];
		                    var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
		                    if (crossProduct < 0) {
		                        // Found a right turn.
		                        hullRecords.push(secondLastHullRecord);
		                        hullRecords.push(lastHullRecord);
		                        hullRecords.push(currentRecord);
		                        correctTurnFound = true;
		                    }
		                    else if (crossProduct === 0) {
		                        // the three points are collinear
		                        // three options:
		                        // there may be a 180 or 0 degree angle at lastHullPoint
		                        // or two of the three points are coincident
		                        // we have to take rounding errors into account
		                        var THRESHOLD = 1e-10;
		                        var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
		                        if (Math.abs(angleBetween - 180) < THRESHOLD) {
		                            // rouding around 180 to 180
		                            // if the cross product is 0 because the angle is 180 degrees
		                            // discard last hull point (add to insidePoints)
		                            // insidePoints.unshift(lastHullPoint);
		                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
		                            // reenter second-to-last hull point (will be last at next iter)
		                            hullRecords.push(secondLastHullRecord);
		                            // do not do anything with current point
		                            // correct turn not found
		                        }
		                        else if (lastHullPoint.equals(currentPoint) ||
		                            secondLastHullPoint.equals(lastHullPoint)) {
		                            // if the cross product is 0 because two points are the same
		                            // discard last hull point (add to insidePoints)
		                            // insidePoints.unshift(lastHullPoint);
		                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
		                            // reenter second-to-last hull point (will be last at next iter)
		                            hullRecords.push(secondLastHullRecord);
		                            // do not do anything with current point
		                            // correct turn not found
		                        }
		                        else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {
		                            // rounding around 0 and 360 to 0
		                            // if the cross product is 0 because the angle is 0 degrees
		                            // remove last hull point from hull BUT do not discard it
		                            // reenter second-to-last hull point (will be last at next iter)
		                            hullRecords.push(secondLastHullRecord);
		                            // put last hull point back into the sorted point records list
		                            sortedRecords.push(lastHullRecord);
		                            // we are switching the order of the 0deg and 180deg points
		                            // correct turn not found
		                        }
		                    }
		                    else {
		                        // found a left turn
		                        // discard last hull point (add to insidePoints)
		                        // insidePoints.unshift(lastHullPoint);
		                        insidePoints[getKey(lastHullRecord)] = lastHullPoint;
		                        // reenter second-to-last hull point (will be last at next iter of loop)
		                        hullRecords.push(secondLastHullRecord);
		                        // do not do anything with current point
		                        // correct turn not found
		                    }
		                }
		            }
		        }
		        // At this point, hullPointRecords contains the output points in clockwise order
		        // the points start with lowest-y,highest-x startPoint, and end at the same point
		        // Step 3b: remove duplicated startPointRecord from the end of the array
		        if (hullRecords.length > 2) {
		            hullRecords.pop();
		        }
		        // Step 4: find the lowest originalIndex record and put it at the beginning of hull
		        var lowestHullIndex; // the lowest originalIndex on the hull
		        var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex
		        for (var i = 0, n = hullRecords.length; i < n; i += 1) {
		            var currentHullIndex = hullRecords[i][1];
		            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
		                lowestHullIndex = currentHullIndex;
		                indexOfLowestHullIndexRecord = i;
		            }
		        }
		        var hullPointRecordsReordered = [];
		        if (indexOfLowestHullIndexRecord > 0) {
		            var newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
		            var newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
		            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
		        }
		        else {
		            hullPointRecordsReordered = hullRecords;
		        }
		        var hullPoints = [];
		        for (var i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {
		            hullPoints.push(hullPointRecordsReordered[i][0]);
		        }
		        return new Polyline(hullPoints);
		    };
		    Polyline.prototype.equals = function (p) {
		        var _this = this;
		        if (p == null) {
		            return false;
		        }
		        if (p.points.length !== this.points.length) {
		            return false;
		        }
		        return p.points.every(function (a, i) { return a.equals(_this.points[i]); });
		    };
		    Polyline.prototype.clone = function () {
		        return new Polyline(this.points.map(function (p) { return p.clone(); }));
		    };
		    Polyline.prototype.toJSON = function () {
		        return this.points.map(function (p) { return p.toJSON(); });
		    };
		    Polyline.prototype.serialize = function () {
		        return this.points.map(function (p) { return p.x + ", " + p.y; }).join(' ');
		    };
		    return Polyline;
		}(geometry_1.Geometry));
		exports.Polyline = Polyline;
		(function (Polyline) {
		    Polyline.toStringTag = "X6.Geometry." + Polyline.name;
		    function isPolyline(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Polyline) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var polyline = instance;
		        if ((tag == null || tag === Polyline.toStringTag) &&
		            typeof polyline.toHull === 'function' &&
		            typeof polyline.simplify === 'function') {
		            return true;
		        }
		        return false;
		    }
		    Polyline.isPolyline = isPolyline;
		})(Polyline = exports.Polyline || (exports.Polyline = {}));
		exports.Polyline = Polyline;
		(function (Polyline) {
		    function parse(svgString) {
		        var str = svgString.trim();
		        if (str === '') {
		            return new Polyline();
		        }
		        var points = [];
		        var coords = str.split(/\s*,\s*|\s+/);
		        for (var i = 0, ii = coords.length; i < ii; i += 2) {
		            points.push({ x: +coords[i], y: +coords[i + 1] });
		        }
		        return new Polyline(points);
		    }
		    Polyline.parse = parse;
		})(Polyline = exports.Polyline || (exports.Polyline = {}));
		exports.Polyline = Polyline;
		
	} (polyline));
	return polyline;
}

var hasRequiredCurve;

function requireCurve () {
	if (hasRequiredCurve) return curve;
	hasRequiredCurve = 1;
	(function (exports) {
		"use strict";
		var __extends = (curve && curve.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Curve = void 0;
		var point_1 = requirePoint();
		var line_1 = requireLine();
		var rectangle_1 = requireRectangle();
		var polyline_1 = requirePolyline();
		var geometry_1 = requireGeometry$1();
		var Curve = /** @class */ (function (_super) {
		    __extends(Curve, _super);
		    function Curve(start, controlPoint1, controlPoint2, end) {
		        var _this = _super.call(this) || this;
		        _this.PRECISION = 3;
		        _this.start = point_1.Point.create(start);
		        _this.controlPoint1 = point_1.Point.create(controlPoint1);
		        _this.controlPoint2 = point_1.Point.create(controlPoint2);
		        _this.end = point_1.Point.create(end);
		        return _this;
		    }
		    Object.defineProperty(Curve.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Curve.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Curve.prototype.bbox = function () {
		        var start = this.start;
		        var controlPoint1 = this.controlPoint1;
		        var controlPoint2 = this.controlPoint2;
		        var end = this.end;
		        var x0 = start.x;
		        var y0 = start.y;
		        var x1 = controlPoint1.x;
		        var y1 = controlPoint1.y;
		        var x2 = controlPoint2.x;
		        var y2 = controlPoint2.y;
		        var x3 = end.x;
		        var y3 = end.y;
		        var points = []; // local extremes
		        var tvalues = []; // t values of local extremes
		        var bounds = [[], []];
		        var a;
		        var b;
		        var c;
		        var t;
		        var t1;
		        var t2;
		        var b2ac;
		        var sqrtb2ac;
		        for (var i = 0; i < 2; i += 1) {
		            if (i === 0) {
		                b = 6 * x0 - 12 * x1 + 6 * x2;
		                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
		                c = 3 * x1 - 3 * x0;
		            }
		            else {
		                b = 6 * y0 - 12 * y1 + 6 * y2;
		                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
		                c = 3 * y1 - 3 * y0;
		            }
		            if (Math.abs(a) < 1e-12) {
		                if (Math.abs(b) < 1e-12) {
		                    continue;
		                }
		                t = -c / b;
		                if (t > 0 && t < 1)
		                    tvalues.push(t);
		                continue;
		            }
		            b2ac = b * b - 4 * c * a;
		            sqrtb2ac = Math.sqrt(b2ac);
		            if (b2ac < 0)
		                continue;
		            t1 = (-b + sqrtb2ac) / (2 * a);
		            if (t1 > 0 && t1 < 1)
		                tvalues.push(t1);
		            t2 = (-b - sqrtb2ac) / (2 * a);
		            if (t2 > 0 && t2 < 1)
		                tvalues.push(t2);
		        }
		        var x;
		        var y;
		        var mt;
		        var j = tvalues.length;
		        var jlen = j;
		        while (j) {
		            j -= 1;
		            t = tvalues[j];
		            mt = 1 - t;
		            x =
		                mt * mt * mt * x0 +
		                    3 * mt * mt * t * x1 +
		                    3 * mt * t * t * x2 +
		                    t * t * t * x3;
		            bounds[0][j] = x;
		            y =
		                mt * mt * mt * y0 +
		                    3 * mt * mt * t * y1 +
		                    3 * mt * t * t * y2 +
		                    t * t * t * y3;
		            bounds[1][j] = y;
		            points[j] = { X: x, Y: y };
		        }
		        tvalues[jlen] = 0;
		        tvalues[jlen + 1] = 1;
		        points[jlen] = { X: x0, Y: y0 };
		        points[jlen + 1] = { X: x3, Y: y3 };
		        bounds[0][jlen] = x0;
		        bounds[1][jlen] = y0;
		        bounds[0][jlen + 1] = x3;
		        bounds[1][jlen + 1] = y3;
		        tvalues.length = jlen + 2;
		        bounds[0].length = jlen + 2;
		        bounds[1].length = jlen + 2;
		        points.length = jlen + 2;
		        var left = Math.min.apply(null, bounds[0]);
		        var top = Math.min.apply(null, bounds[1]);
		        var right = Math.max.apply(null, bounds[0]);
		        var bottom = Math.max.apply(null, bounds[1]);
		        return new rectangle_1.Rectangle(left, top, right - left, bottom - top);
		    };
		    Curve.prototype.closestPoint = function (p, options) {
		        if (options === void 0) { options = {}; }
		        return this.pointAtT(this.closestPointT(p, options));
		    };
		    Curve.prototype.closestPointLength = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var opts = this.getOptions(options);
		        return this.lengthAtT(this.closestPointT(p, opts), opts);
		    };
		    Curve.prototype.closestPointNormalizedLength = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var opts = this.getOptions(options);
		        var cpLength = this.closestPointLength(p, opts);
		        if (!cpLength) {
		            return 0;
		        }
		        var length = this.length(opts);
		        if (length === 0) {
		            return 0;
		        }
		        return cpLength / length;
		    };
		    Curve.prototype.closestPointT = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var precision = this.getPrecision(options);
		        var subdivisions = this.getDivisions(options);
		        var precisionRatio = Math.pow(10, -precision); // eslint-disable-line
		        var investigatedSubdivision = null;
		        var investigatedSubdivisionStartT = 0;
		        var investigatedSubdivisionEndT = 0;
		        var distFromStart = 0;
		        var distFromEnd = 0;
		        var chordLength = 0;
		        var minSumDist = null;
		        var count = subdivisions.length;
		        var piece = count > 0 ? 1 / count : 0;
		        subdivisions.forEach(function (division, i) {
		            var startDist = division.start.distance(p);
		            var endDist = division.end.distance(p);
		            var sumDist = startDist + endDist;
		            if (minSumDist == null || sumDist < minSumDist) {
		                investigatedSubdivision = division;
		                investigatedSubdivisionStartT = i * piece;
		                investigatedSubdivisionEndT = (i + 1) * piece;
		                distFromStart = startDist;
		                distFromEnd = endDist;
		                minSumDist = sumDist;
		                chordLength = division.endpointDistance();
		            }
		        });
		        // Recursively divide investigated subdivision, until distance between
		        // baselinePoint and closest path endpoint is within `10^(-precision)`,
		        // then return the closest endpoint of that final subdivision.
		        // eslint-disable-next-line
		        while (true) {
		            // check if we have reached at least one required observed precision
		            // - calculated as: the difference in distances from point to start and end divided by the distance
		            // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
		            // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
		            // - this criterion works well for points lying far away from the curve
		            var startPrecisionRatio = distFromStart
		                ? Math.abs(distFromStart - distFromEnd) / distFromStart
		                : 0;
		            var endPrecisionRatio = distFromEnd != null
		                ? Math.abs(distFromStart - distFromEnd) / distFromEnd
		                : 0;
		            var hasRequiredPrecision = startPrecisionRatio < precisionRatio ||
		                endPrecisionRatio < precisionRatio;
		            // check if we have reached at least one required minimal distance
		            // - calculated as: the subdivision chord length multiplied by precisionRatio
		            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
		            // - this is a backup criterion that works well for points lying "almost at" the curve
		            var hasMiniStartDistance = distFromStart
		                ? distFromStart < chordLength * precisionRatio
		                : true;
		            var hasMiniEndDistance = distFromEnd
		                ? distFromEnd < chordLength * precisionRatio
		                : true;
		            var hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;
		            if (hasRequiredPrecision || hasMiniDistance) {
		                return distFromStart <= distFromEnd
		                    ? investigatedSubdivisionStartT
		                    : investigatedSubdivisionEndT;
		            }
		            // otherwise, set up for next iteration
		            var divided = investigatedSubdivision.divide(0.5);
		            piece /= 2;
		            var startDist1 = divided[0].start.distance(p);
		            var endDist1 = divided[0].end.distance(p);
		            var sumDist1 = startDist1 + endDist1;
		            var startDist2 = divided[1].start.distance(p);
		            var endDist2 = divided[1].end.distance(p);
		            var sumDist2 = startDist2 + endDist2;
		            if (sumDist1 <= sumDist2) {
		                investigatedSubdivision = divided[0];
		                investigatedSubdivisionEndT -= piece;
		                distFromStart = startDist1;
		                distFromEnd = endDist1;
		            }
		            else {
		                investigatedSubdivision = divided[1];
		                investigatedSubdivisionStartT += piece;
		                distFromStart = startDist2;
		                distFromEnd = endDist2;
		            }
		        }
		    };
		    Curve.prototype.closestPointTangent = function (p, options) {
		        if (options === void 0) { options = {}; }
		        return this.tangentAtT(this.closestPointT(p, options));
		    };
		    Curve.prototype.containsPoint = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var polyline = this.toPolyline(options);
		        return polyline.containsPoint(p);
		    };
		    Curve.prototype.divideAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (ratio <= 0) {
		            return this.divideAtT(0);
		        }
		        if (ratio >= 1) {
		            return this.divideAtT(1);
		        }
		        var t = this.tAt(ratio, options);
		        return this.divideAtT(t);
		    };
		    Curve.prototype.divideAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        var t = this.tAtLength(length, options);
		        return this.divideAtT(t);
		    };
		    Curve.prototype.divide = function (t) {
		        return this.divideAtT(t);
		    };
		    Curve.prototype.divideAtT = function (t) {
		        var start = this.start;
		        var controlPoint1 = this.controlPoint1;
		        var controlPoint2 = this.controlPoint2;
		        var end = this.end;
		        if (t <= 0) {
		            return [
		                new Curve(start, start, start, start),
		                new Curve(start, controlPoint1, controlPoint2, end),
		            ];
		        }
		        if (t >= 1) {
		            return [
		                new Curve(start, controlPoint1, controlPoint2, end),
		                new Curve(end, end, end, end),
		            ];
		        }
		        var dividerPoints = this.getSkeletonPoints(t);
		        var startControl1 = dividerPoints.startControlPoint1;
		        var startControl2 = dividerPoints.startControlPoint2;
		        var divider = dividerPoints.divider;
		        var dividerControl1 = dividerPoints.dividerControlPoint1;
		        var dividerControl2 = dividerPoints.dividerControlPoint2;
		        return [
		            new Curve(start, startControl1, startControl2, divider),
		            new Curve(divider, dividerControl1, dividerControl2, end),
		        ];
		    };
		    Curve.prototype.endpointDistance = function () {
		        return this.start.distance(this.end);
		    };
		    Curve.prototype.getSkeletonPoints = function (t) {
		        var start = this.start;
		        var control1 = this.controlPoint1;
		        var control2 = this.controlPoint2;
		        var end = this.end;
		        // shortcuts for `t` values that are out of range
		        if (t <= 0) {
		            return {
		                startControlPoint1: start.clone(),
		                startControlPoint2: start.clone(),
		                divider: start.clone(),
		                dividerControlPoint1: control1.clone(),
		                dividerControlPoint2: control2.clone(),
		            };
		        }
		        if (t >= 1) {
		            return {
		                startControlPoint1: control1.clone(),
		                startControlPoint2: control2.clone(),
		                divider: end.clone(),
		                dividerControlPoint1: end.clone(),
		                dividerControlPoint2: end.clone(),
		            };
		        }
		        var midpoint1 = new line_1.Line(start, control1).pointAt(t);
		        var midpoint2 = new line_1.Line(control1, control2).pointAt(t);
		        var midpoint3 = new line_1.Line(control2, end).pointAt(t);
		        var subControl1 = new line_1.Line(midpoint1, midpoint2).pointAt(t);
		        var subControl2 = new line_1.Line(midpoint2, midpoint3).pointAt(t);
		        var divideLine = new line_1.Line(subControl1, subControl2).pointAt(t);
		        return {
		            startControlPoint1: midpoint1,
		            startControlPoint2: subControl1,
		            divider: divideLine,
		            dividerControlPoint1: subControl2,
		            dividerControlPoint2: midpoint3,
		        };
		    };
		    Curve.prototype.getSubdivisions = function (options) {
		        if (options === void 0) { options = {}; }
		        var precision = this.getPrecision(options);
		        var subdivisions = [
		            new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),
		        ];
		        if (precision === 0) {
		            return subdivisions;
		        }
		        var previousLength = this.endpointDistance();
		        var precisionRatio = Math.pow(10, -precision); // eslint-disable-line
		        // Recursively divide curve at `t = 0.5`, until the difference between
		        // observed length at subsequent iterations is lower than precision.
		        var iteration = 0;
		        var _loop_1 = function () {
		            iteration += 1;
		            var divisions = [];
		            subdivisions.forEach(function (c) {
		                // dividing at t = 0.5 (not at middle length!)
		                var divided = c.divide(0.5);
		                divisions.push(divided[0], divided[1]);
		            });
		            // measure new length
		            var length_1 = divisions.reduce(function (memo, c) { return memo + c.endpointDistance(); }, 0);
		            // check if we have reached required observed precision
		            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
		            // not a problem for further iterations because cubic curves cannot have more than two local extrema
		            // (i.e. cubic curves cannot intersect the baseline more than once)
		            // therefore two subsequent iterations cannot produce sampling with equal length
		            var ratio = length_1 !== 0 ? (length_1 - previousLength) / length_1 : 0;
		            if (iteration > 1 && ratio < precisionRatio) {
		                return { value: divisions };
		            }
		            subdivisions = divisions;
		            previousLength = length_1;
		        };
		        // eslint-disable-next-line
		        while (true) {
		            var state_1 = _loop_1();
		            if (typeof state_1 === "object")
		                return state_1.value;
		        }
		    };
		    Curve.prototype.length = function (options) {
		        if (options === void 0) { options = {}; }
		        var divisions = this.getDivisions(options);
		        return divisions.reduce(function (memo, c) {
		            return memo + c.endpointDistance();
		        }, 0);
		    };
		    Curve.prototype.lengthAtT = function (t, options) {
		        if (options === void 0) { options = {}; }
		        if (t <= 0) {
		            return 0;
		        }
		        var precision = options.precision === undefined ? this.PRECISION : options.precision;
		        var subCurve = this.divide(t)[0];
		        return subCurve.length({ precision: precision });
		    };
		    Curve.prototype.pointAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (ratio <= 0) {
		            return this.start.clone();
		        }
		        if (ratio >= 1) {
		            return this.end.clone();
		        }
		        var t = this.tAt(ratio, options);
		        return this.pointAtT(t);
		    };
		    Curve.prototype.pointAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        var t = this.tAtLength(length, options);
		        return this.pointAtT(t);
		    };
		    Curve.prototype.pointAtT = function (t) {
		        if (t <= 0) {
		            return this.start.clone();
		        }
		        if (t >= 1) {
		            return this.end.clone();
		        }
		        return this.getSkeletonPoints(t).divider;
		    };
		    Curve.prototype.isDifferentiable = function () {
		        var start = this.start;
		        var control1 = this.controlPoint1;
		        var control2 = this.controlPoint2;
		        var end = this.end;
		        return !(start.equals(control1) &&
		            control1.equals(control2) &&
		            control2.equals(end));
		    };
		    Curve.prototype.tangentAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (!this.isDifferentiable())
		            return null;
		        if (ratio < 0) {
		            ratio = 0; // eslint-disable-line
		        }
		        else if (ratio > 1) {
		            ratio = 1; // eslint-disable-line
		        }
		        var t = this.tAt(ratio, options);
		        return this.tangentAtT(t);
		    };
		    Curve.prototype.tangentAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        if (!this.isDifferentiable()) {
		            return null;
		        }
		        var t = this.tAtLength(length, options);
		        return this.tangentAtT(t);
		    };
		    Curve.prototype.tangentAtT = function (t) {
		        if (!this.isDifferentiable()) {
		            return null;
		        }
		        if (t < 0) {
		            t = 0; // eslint-disable-line
		        }
		        if (t > 1) {
		            t = 1; // eslint-disable-line
		        }
		        var skeletonPoints = this.getSkeletonPoints(t);
		        var p1 = skeletonPoints.startControlPoint2;
		        var p2 = skeletonPoints.dividerControlPoint1;
		        var tangentStart = skeletonPoints.divider;
		        var tangentLine = new line_1.Line(p1, p2);
		        // move so that tangent line starts at the point requested
		        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
		        return tangentLine;
		    };
		    Curve.prototype.getPrecision = function (options) {
		        if (options === void 0) { options = {}; }
		        return options.precision == null ? this.PRECISION : options.precision;
		    };
		    Curve.prototype.getDivisions = function (options) {
		        if (options === void 0) { options = {}; }
		        if (options.subdivisions != null) {
		            return options.subdivisions;
		        }
		        var precision = this.getPrecision(options);
		        return this.getSubdivisions({ precision: precision });
		    };
		    Curve.prototype.getOptions = function (options) {
		        if (options === void 0) { options = {}; }
		        var precision = this.getPrecision(options);
		        var subdivisions = this.getDivisions(options);
		        return { precision: precision, subdivisions: subdivisions };
		    };
		    Curve.prototype.tAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (ratio <= 0) {
		            return 0;
		        }
		        if (ratio >= 1) {
		            return 1;
		        }
		        var opts = this.getOptions(options);
		        var total = this.length(opts);
		        var length = total * ratio;
		        return this.tAtLength(length, opts);
		    };
		    Curve.prototype.tAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false;
		            length = -length; // eslint-disable-line
		        }
		        var precision = this.getPrecision(options);
		        var subdivisions = this.getDivisions(options);
		        var opts = { precision: precision, subdivisions: subdivisions };
		        var investigatedSubdivision = null;
		        var investigatedSubdivisionStartT;
		        var investigatedSubdivisionEndT;
		        var baselinePointDistFromStart = 0;
		        var baselinePointDistFromEnd = 0;
		        var memo = 0;
		        var count = subdivisions.length;
		        var piece = count > 0 ? 1 / count : 0;
		        for (var i = 0; i < count; i += 1) {
		            var index = fromStart ? i : count - 1 - i;
		            var division = subdivisions[i];
		            var dist = division.endpointDistance();
		            if (length <= memo + dist) {
		                investigatedSubdivision = division;
		                investigatedSubdivisionStartT = index * piece;
		                investigatedSubdivisionEndT = (index + 1) * piece;
		                baselinePointDistFromStart = fromStart
		                    ? length - memo
		                    : dist + memo - length;
		                baselinePointDistFromEnd = fromStart
		                    ? dist + memo - length
		                    : length - memo;
		                break;
		            }
		            memo += dist;
		        }
		        if (investigatedSubdivision == null) {
		            return fromStart ? 1 : 0;
		        }
		        // note that precision affects what length is recorded
		        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
		        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1
		        var total = this.length(opts);
		        var precisionRatio = Math.pow(10, -precision); // eslint-disable-line
		        // recursively divide investigated subdivision:
		        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
		        // then return the closest endpoint of that final subdivision
		        // eslint-disable-next-line
		        while (true) {
		            var ratio = void 0;
		            ratio = total !== 0 ? baselinePointDistFromStart / total : 0;
		            if (ratio < precisionRatio) {
		                return investigatedSubdivisionStartT;
		            }
		            ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;
		            if (ratio < precisionRatio) {
		                return investigatedSubdivisionEndT;
		            }
		            // otherwise, set up for next iteration
		            var newBaselinePointDistFromStart = void 0;
		            var newBaselinePointDistFromEnd = void 0;
		            var divided = investigatedSubdivision.divide(0.5);
		            piece /= 2;
		            var baseline1Length = divided[0].endpointDistance();
		            var baseline2Length = divided[1].endpointDistance();
		            if (baselinePointDistFromStart <= baseline1Length) {
		                investigatedSubdivision = divided[0];
		                investigatedSubdivisionEndT -= piece;
		                newBaselinePointDistFromStart = baselinePointDistFromStart;
		                newBaselinePointDistFromEnd =
		                    baseline1Length - newBaselinePointDistFromStart;
		            }
		            else {
		                investigatedSubdivision = divided[1];
		                investigatedSubdivisionStartT += piece;
		                newBaselinePointDistFromStart =
		                    baselinePointDistFromStart - baseline1Length;
		                newBaselinePointDistFromEnd =
		                    baseline2Length - newBaselinePointDistFromStart;
		            }
		            baselinePointDistFromStart = newBaselinePointDistFromStart;
		            baselinePointDistFromEnd = newBaselinePointDistFromEnd;
		        }
		    };
		    Curve.prototype.toPoints = function (options) {
		        if (options === void 0) { options = {}; }
		        var subdivisions = this.getDivisions(options);
		        var points = [subdivisions[0].start.clone()];
		        subdivisions.forEach(function (c) { return points.push(c.end.clone()); });
		        return points;
		    };
		    Curve.prototype.toPolyline = function (options) {
		        if (options === void 0) { options = {}; }
		        return new polyline_1.Polyline(this.toPoints(options));
		    };
		    Curve.prototype.scale = function (sx, sy, origin) {
		        this.start.scale(sx, sy, origin);
		        this.controlPoint1.scale(sx, sy, origin);
		        this.controlPoint2.scale(sx, sy, origin);
		        this.end.scale(sx, sy, origin);
		        return this;
		    };
		    Curve.prototype.rotate = function (angle, origin) {
		        this.start.rotate(angle, origin);
		        this.controlPoint1.rotate(angle, origin);
		        this.controlPoint2.rotate(angle, origin);
		        this.end.rotate(angle, origin);
		        return this;
		    };
		    Curve.prototype.translate = function (tx, ty) {
		        if (typeof tx === 'number') {
		            this.start.translate(tx, ty);
		            this.controlPoint1.translate(tx, ty);
		            this.controlPoint2.translate(tx, ty);
		            this.end.translate(tx, ty);
		        }
		        else {
		            this.start.translate(tx);
		            this.controlPoint1.translate(tx);
		            this.controlPoint2.translate(tx);
		            this.end.translate(tx);
		        }
		        return this;
		    };
		    Curve.prototype.equals = function (c) {
		        return (c != null &&
		            this.start.equals(c.start) &&
		            this.controlPoint1.equals(c.controlPoint1) &&
		            this.controlPoint2.equals(c.controlPoint2) &&
		            this.end.equals(c.end));
		    };
		    Curve.prototype.clone = function () {
		        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
		    };
		    Curve.prototype.toJSON = function () {
		        return {
		            start: this.start.toJSON(),
		            controlPoint1: this.controlPoint1.toJSON(),
		            controlPoint2: this.controlPoint2.toJSON(),
		            end: this.end.toJSON(),
		        };
		    };
		    Curve.prototype.serialize = function () {
		        return [
		            this.start.serialize(),
		            this.controlPoint1.serialize(),
		            this.controlPoint2.serialize(),
		            this.end.serialize(),
		        ].join(' ');
		    };
		    return Curve;
		}(geometry_1.Geometry));
		exports.Curve = Curve;
		(function (Curve) {
		    Curve.toStringTag = "X6.Geometry." + Curve.name;
		    function isCurve(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Curve) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var curve = instance;
		        try {
		            if ((tag == null || tag === Curve.toStringTag) &&
		                point_1.Point.isPoint(curve.start) &&
		                point_1.Point.isPoint(curve.controlPoint1) &&
		                point_1.Point.isPoint(curve.controlPoint2) &&
		                point_1.Point.isPoint(curve.end) &&
		                typeof curve.toPoints === 'function' &&
		                typeof curve.toPolyline === 'function') {
		                return true;
		            }
		        }
		        catch (e) {
		            return false;
		        }
		        return false;
		    }
		    Curve.isCurve = isCurve;
		})(Curve = exports.Curve || (exports.Curve = {}));
		exports.Curve = Curve;
		(function (Curve) {
		    function getFirstControlPoints(rhs) {
		        var n = rhs.length;
		        var x = []; // `x` is a solution vector.
		        var tmp = [];
		        var b = 2.0;
		        x[0] = rhs[0] / b;
		        // Decomposition and forward substitution.
		        for (var i = 1; i < n; i += 1) {
		            tmp[i] = 1 / b;
		            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
		            x[i] = (rhs[i] - x[i - 1]) / b;
		        }
		        for (var i = 1; i < n; i += 1) {
		            // Backsubstitution.
		            x[n - i - 1] -= tmp[n - i] * x[n - i];
		        }
		        return x;
		    }
		    function getCurveControlPoints(points) {
		        var knots = points.map(function (p) { return point_1.Point.clone(p); });
		        var firstControlPoints = [];
		        var secondControlPoints = [];
		        var n = knots.length - 1;
		        // Special case: Bezier curve should be a straight line.
		        if (n === 1) {
		            // 3P1 = 2P0 + P3
		            firstControlPoints[0] = new point_1.Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
		            // P2 = 2P1  P0
		            secondControlPoints[0] = new point_1.Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
		            return [firstControlPoints, secondControlPoints];
		        }
		        // Calculate first Bezier control points.
		        // Right hand side vector.
		        var rhs = [];
		        // Set right hand side X values.
		        for (var i = 1; i < n - 1; i += 1) {
		            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
		        }
		        rhs[0] = knots[0].x + 2 * knots[1].x;
		        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;
		        // Get first control points X-values.
		        var x = getFirstControlPoints(rhs);
		        // Set right hand side Y values.
		        for (var i = 1; i < n - 1; i += 1) {
		            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
		        }
		        rhs[0] = knots[0].y + 2 * knots[1].y;
		        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;
		        // Get first control points Y-values.
		        var y = getFirstControlPoints(rhs);
		        // Fill output arrays.
		        for (var i = 0; i < n; i += 1) {
		            // First control point.
		            firstControlPoints.push(new point_1.Point(x[i], y[i]));
		            // Second control point.
		            if (i < n - 1) {
		                secondControlPoints.push(new point_1.Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
		            }
		            else {
		                secondControlPoints.push(new point_1.Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
		            }
		        }
		        return [firstControlPoints, secondControlPoints];
		    }
		    function throughPoints(points) {
		        if (points == null || (Array.isArray(points) && points.length < 2)) {
		            throw new Error('At least 2 points are required');
		        }
		        var controlPoints = getCurveControlPoints(points);
		        var curves = [];
		        for (var i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
		            var controlPoint1 = new point_1.Point(controlPoints[0][i].x, controlPoints[0][i].y);
		            var controlPoint2 = new point_1.Point(controlPoints[1][i].x, controlPoints[1][i].y);
		            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
		        }
		        return curves;
		    }
		    Curve.throughPoints = throughPoints;
		})(Curve = exports.Curve || (exports.Curve = {}));
		exports.Curve = Curve;
		
	} (curve));
	return curve;
}

var close = {};

var lineto = {};

var segment = {};

var hasRequiredSegment;

function requireSegment () {
	if (hasRequiredSegment) return segment;
	hasRequiredSegment = 1;
	"use strict";
	var __extends = (segment && segment.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(segment, "__esModule", { value: true });
	segment.Segment = void 0;
	var geometry_1 = requireGeometry$1();
	var Segment = /** @class */ (function (_super) {
	    __extends(Segment, _super);
	    function Segment() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.isVisible = true;
	        _this.isSegment = true;
	        _this.isSubpathStart = false;
	        return _this;
	    }
	    Object.defineProperty(Segment.prototype, "end", {
	        get: function () {
	            return this.endPoint;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Segment.prototype, "start", {
	        get: function () {
	            if (this.previousSegment == null) {
	                throw new Error('Missing previous segment. (This segment cannot be the ' +
	                    'first segment of a path, or segment has not yet been ' +
	                    'added to a path.)');
	            }
	            return this.previousSegment.end;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Segment.prototype.closestPointT = function (p, options) {
	        if (this.closestPointNormalizedLength) {
	            return this.closestPointNormalizedLength(p);
	        }
	        throw new Error('Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.');
	    };
	    // eslint-disable-next-line
	    Segment.prototype.lengthAtT = function (t, options) {
	        if (t <= 0) {
	            return 0;
	        }
	        var length = this.length();
	        if (t >= 1) {
	            return length;
	        }
	        return length * t;
	    };
	    Segment.prototype.divideAtT = function (t) {
	        if (this.divideAt) {
	            return this.divideAt(t);
	        }
	        throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.');
	    };
	    Segment.prototype.pointAtT = function (t) {
	        if (this.pointAt) {
	            return this.pointAt(t);
	        }
	        throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.');
	    };
	    Segment.prototype.tangentAtT = function (t) {
	        if (this.tangentAt) {
	            return this.tangentAt(t);
	        }
	        throw new Error('Neither `tangentAtT` nor `tangentAt` method is implemented.');
	    };
	    return Segment;
	}(geometry_1.Geometry));
	segment.Segment = Segment;
	
	return segment;
}

var hasRequiredLineto;

function requireLineto () {
	if (hasRequiredLineto) return lineto;
	hasRequiredLineto = 1;
	(function (exports) {
		"use strict";
		var __extends = (lineto && lineto.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.LineTo = void 0;
		var line_1 = requireLine();
		var point_1 = requirePoint();
		var segment_1 = requireSegment();
		var LineTo = /** @class */ (function (_super) {
		    __extends(LineTo, _super);
		    function LineTo(x, y) {
		        var _this = _super.call(this) || this;
		        if (line_1.Line.isLine(x)) {
		            _this.endPoint = x.end.clone().round(2);
		        }
		        else {
		            _this.endPoint = point_1.Point.create(x, y).round(2);
		        }
		        return _this;
		    }
		    Object.defineProperty(LineTo.prototype, "type", {
		        get: function () {
		            return 'L';
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(LineTo.prototype, "line", {
		        get: function () {
		            return new line_1.Line(this.start, this.end);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    LineTo.prototype.bbox = function () {
		        return this.line.bbox();
		    };
		    LineTo.prototype.closestPoint = function (p) {
		        return this.line.closestPoint(p);
		    };
		    LineTo.prototype.closestPointLength = function (p) {
		        return this.line.closestPointLength(p);
		    };
		    LineTo.prototype.closestPointNormalizedLength = function (p) {
		        return this.line.closestPointNormalizedLength(p);
		    };
		    LineTo.prototype.closestPointTangent = function (p) {
		        return this.line.closestPointTangent(p);
		    };
		    LineTo.prototype.length = function () {
		        return this.line.length();
		    };
		    LineTo.prototype.divideAt = function (ratio) {
		        var divided = this.line.divideAt(ratio);
		        return [new LineTo(divided[0]), new LineTo(divided[1])];
		    };
		    LineTo.prototype.divideAtLength = function (length) {
		        var divided = this.line.divideAtLength(length);
		        return [new LineTo(divided[0]), new LineTo(divided[1])];
		    };
		    LineTo.prototype.getSubdivisions = function () {
		        return [];
		    };
		    LineTo.prototype.pointAt = function (ratio) {
		        return this.line.pointAt(ratio);
		    };
		    LineTo.prototype.pointAtLength = function (length) {
		        return this.line.pointAtLength(length);
		    };
		    LineTo.prototype.tangentAt = function (ratio) {
		        return this.line.tangentAt(ratio);
		    };
		    LineTo.prototype.tangentAtLength = function (length) {
		        return this.line.tangentAtLength(length);
		    };
		    LineTo.prototype.isDifferentiable = function () {
		        if (this.previousSegment == null) {
		            return false;
		        }
		        return !this.start.equals(this.end);
		    };
		    LineTo.prototype.clone = function () {
		        return new LineTo(this.end);
		    };
		    LineTo.prototype.scale = function (sx, sy, origin) {
		        this.end.scale(sx, sy, origin);
		        return this;
		    };
		    LineTo.prototype.rotate = function (angle, origin) {
		        this.end.rotate(angle, origin);
		        return this;
		    };
		    LineTo.prototype.translate = function (tx, ty) {
		        if (typeof tx === 'number') {
		            this.end.translate(tx, ty);
		        }
		        else {
		            this.end.translate(tx);
		        }
		        return this;
		    };
		    LineTo.prototype.equals = function (s) {
		        return (this.type === s.type &&
		            this.start.equals(s.start) &&
		            this.end.equals(s.end));
		    };
		    LineTo.prototype.toJSON = function () {
		        return {
		            type: this.type,
		            start: this.start.toJSON(),
		            end: this.end.toJSON(),
		        };
		    };
		    LineTo.prototype.serialize = function () {
		        var end = this.end;
		        return this.type + " " + end.x + " " + end.y;
		    };
		    return LineTo;
		}(segment_1.Segment));
		exports.LineTo = LineTo;
		(function (LineTo) {
		    function create() {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var len = args.length;
		        var arg0 = args[0];
		        // line provided
		        if (line_1.Line.isLine(arg0)) {
		            return new LineTo(arg0);
		        }
		        // points provided
		        if (point_1.Point.isPointLike(arg0)) {
		            if (len === 1) {
		                return new LineTo(arg0);
		            }
		            // poly-line segment
		            return args.map(function (arg) { return new LineTo(arg); });
		        }
		        // coordinates provided
		        if (len === 2) {
		            return new LineTo(+args[0], +args[1]);
		        }
		        // poly-line segment
		        var segments = [];
		        for (var i = 0; i < len; i += 2) {
		            var x = +args[i];
		            var y = +args[i + 1];
		            segments.push(new LineTo(x, y));
		        }
		        return segments;
		    }
		    LineTo.create = create;
		})(LineTo = exports.LineTo || (exports.LineTo = {}));
		exports.LineTo = LineTo;
		
	} (lineto));
	return lineto;
}

var hasRequiredClose;

function requireClose () {
	if (hasRequiredClose) return close;
	hasRequiredClose = 1;
	(function (exports) {
		"use strict";
		var __extends = (close && close.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Close = void 0;
		var line_1 = requireLine();
		var lineto_1 = requireLineto();
		var segment_1 = requireSegment();
		var Close = /** @class */ (function (_super) {
		    __extends(Close, _super);
		    function Close() {
		        return _super !== null && _super.apply(this, arguments) || this;
		    }
		    Object.defineProperty(Close.prototype, "end", {
		        get: function () {
		            if (!this.subpathStartSegment) {
		                throw new Error('Missing subpath start segment. (This segment needs a subpath ' +
		                    'start segment (e.g. MoveTo), or segment has not yet been added' +
		                    ' to a path.)');
		            }
		            return this.subpathStartSegment.end;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Close.prototype, "type", {
		        get: function () {
		            return 'Z';
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Close.prototype, "line", {
		        get: function () {
		            return new line_1.Line(this.start, this.end);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Close.prototype.bbox = function () {
		        return this.line.bbox();
		    };
		    Close.prototype.closestPoint = function (p) {
		        return this.line.closestPoint(p);
		    };
		    Close.prototype.closestPointLength = function (p) {
		        return this.line.closestPointLength(p);
		    };
		    Close.prototype.closestPointNormalizedLength = function (p) {
		        return this.line.closestPointNormalizedLength(p);
		    };
		    Close.prototype.closestPointTangent = function (p) {
		        return this.line.closestPointTangent(p);
		    };
		    Close.prototype.length = function () {
		        return this.line.length();
		    };
		    Close.prototype.divideAt = function (ratio) {
		        var divided = this.line.divideAt(ratio);
		        return [
		            // do not actually cut into the segment, first divided part can stay as Z
		            divided[1].isDifferentiable() ? new lineto_1.LineTo(divided[0]) : this.clone(),
		            new lineto_1.LineTo(divided[1]),
		        ];
		    };
		    Close.prototype.divideAtLength = function (length) {
		        var divided = this.line.divideAtLength(length);
		        return [
		            divided[1].isDifferentiable() ? new lineto_1.LineTo(divided[0]) : this.clone(),
		            new lineto_1.LineTo(divided[1]),
		        ];
		    };
		    Close.prototype.getSubdivisions = function () {
		        return [];
		    };
		    Close.prototype.pointAt = function (ratio) {
		        return this.line.pointAt(ratio);
		    };
		    Close.prototype.pointAtLength = function (length) {
		        return this.line.pointAtLength(length);
		    };
		    Close.prototype.tangentAt = function (ratio) {
		        return this.line.tangentAt(ratio);
		    };
		    Close.prototype.tangentAtLength = function (length) {
		        return this.line.tangentAtLength(length);
		    };
		    Close.prototype.isDifferentiable = function () {
		        if (!this.previousSegment || !this.subpathStartSegment) {
		            return false;
		        }
		        return !this.start.equals(this.end);
		    };
		    Close.prototype.scale = function () {
		        return this;
		    };
		    Close.prototype.rotate = function () {
		        return this;
		    };
		    Close.prototype.translate = function () {
		        return this;
		    };
		    Close.prototype.equals = function (s) {
		        return (this.type === s.type &&
		            this.start.equals(s.start) &&
		            this.end.equals(s.end));
		    };
		    Close.prototype.clone = function () {
		        return new Close();
		    };
		    Close.prototype.toJSON = function () {
		        return {
		            type: this.type,
		            start: this.start.toJSON(),
		            end: this.end.toJSON(),
		        };
		    };
		    Close.prototype.serialize = function () {
		        return this.type;
		    };
		    return Close;
		}(segment_1.Segment));
		exports.Close = Close;
		(function (Close) {
		    function create() {
		        return new Close();
		    }
		    Close.create = create;
		})(Close = exports.Close || (exports.Close = {}));
		exports.Close = Close;
		
	} (close));
	return close;
}

var moveto = {};

var hasRequiredMoveto;

function requireMoveto () {
	if (hasRequiredMoveto) return moveto;
	hasRequiredMoveto = 1;
	(function (exports) {
		"use strict";
		var __extends = (moveto && moveto.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MoveTo = void 0;
		var line_1 = requireLine();
		var curve_1 = requireCurve();
		var point_1 = requirePoint();
		var lineto_1 = requireLineto();
		var segment_1 = requireSegment();
		var MoveTo = /** @class */ (function (_super) {
		    __extends(MoveTo, _super);
		    function MoveTo(x, y) {
		        var _this = _super.call(this) || this;
		        _this.isVisible = false;
		        _this.isSubpathStart = true;
		        if (line_1.Line.isLine(x) || curve_1.Curve.isCurve(x)) {
		            _this.endPoint = x.end.clone().round(2);
		        }
		        else {
		            _this.endPoint = point_1.Point.create(x, y).round(2);
		        }
		        return _this;
		    }
		    Object.defineProperty(MoveTo.prototype, "start", {
		        get: function () {
		            throw new Error('Illegal access. Moveto segments should not need a start property.');
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(MoveTo.prototype, "type", {
		        get: function () {
		            return 'M';
		        },
		        enumerable: false,
		        configurable: true
		    });
		    MoveTo.prototype.bbox = function () {
		        return null;
		    };
		    MoveTo.prototype.closestPoint = function () {
		        return this.end.clone();
		    };
		    MoveTo.prototype.closestPointLength = function () {
		        return 0;
		    };
		    MoveTo.prototype.closestPointNormalizedLength = function () {
		        return 0;
		    };
		    MoveTo.prototype.closestPointT = function () {
		        return 1;
		    };
		    MoveTo.prototype.closestPointTangent = function () {
		        return null;
		    };
		    MoveTo.prototype.length = function () {
		        return 0;
		    };
		    MoveTo.prototype.lengthAtT = function () {
		        return 0;
		    };
		    MoveTo.prototype.divideAt = function () {
		        return [this.clone(), this.clone()];
		    };
		    MoveTo.prototype.divideAtLength = function () {
		        return [this.clone(), this.clone()];
		    };
		    MoveTo.prototype.getSubdivisions = function () {
		        return [];
		    };
		    MoveTo.prototype.pointAt = function () {
		        return this.end.clone();
		    };
		    MoveTo.prototype.pointAtLength = function () {
		        return this.end.clone();
		    };
		    MoveTo.prototype.pointAtT = function () {
		        return this.end.clone();
		    };
		    MoveTo.prototype.tangentAt = function () {
		        return null;
		    };
		    MoveTo.prototype.tangentAtLength = function () {
		        return null;
		    };
		    MoveTo.prototype.tangentAtT = function () {
		        return null;
		    };
		    MoveTo.prototype.isDifferentiable = function () {
		        return false;
		    };
		    MoveTo.prototype.scale = function (sx, sy, origin) {
		        this.end.scale(sx, sy, origin);
		        return this;
		    };
		    MoveTo.prototype.rotate = function (angle, origin) {
		        this.end.rotate(angle, origin);
		        return this;
		    };
		    MoveTo.prototype.translate = function (tx, ty) {
		        if (typeof tx === 'number') {
		            this.end.translate(tx, ty);
		        }
		        else {
		            this.end.translate(tx);
		        }
		        return this;
		    };
		    MoveTo.prototype.clone = function () {
		        return new MoveTo(this.end);
		    };
		    MoveTo.prototype.equals = function (s) {
		        return this.type === s.type && this.end.equals(s.end);
		    };
		    MoveTo.prototype.toJSON = function () {
		        return {
		            type: this.type,
		            end: this.end.toJSON(),
		        };
		    };
		    MoveTo.prototype.serialize = function () {
		        var end = this.end;
		        return this.type + " " + end.x + " " + end.y;
		    };
		    return MoveTo;
		}(segment_1.Segment));
		exports.MoveTo = MoveTo;
		(function (MoveTo) {
		    function create() {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var len = args.length;
		        var arg0 = args[0];
		        // line provided
		        if (line_1.Line.isLine(arg0)) {
		            return new MoveTo(arg0);
		        }
		        // curve provided
		        if (curve_1.Curve.isCurve(arg0)) {
		            return new MoveTo(arg0);
		        }
		        // points provided
		        if (point_1.Point.isPointLike(arg0)) {
		            if (len === 1) {
		                return new MoveTo(arg0);
		            }
		            // this is a moveto-with-subsequent-poly-line segment
		            var segments_1 = [];
		            // points come one by one
		            for (var i = 0; i < len; i += 1) {
		                if (i === 0) {
		                    segments_1.push(new MoveTo(args[i]));
		                }
		                else {
		                    segments_1.push(new lineto_1.LineTo(args[i]));
		                }
		            }
		            return segments_1;
		        }
		        // coordinates provided
		        if (len === 2) {
		            return new MoveTo(+args[0], +args[1]);
		        }
		        // this is a moveto-with-subsequent-poly-line segment
		        var segments = [];
		        for (var i = 0; i < len; i += 2) {
		            var x = +args[i];
		            var y = +args[i + 1];
		            if (i === 0) {
		                segments.push(new MoveTo(x, y));
		            }
		            else {
		                segments.push(new lineto_1.LineTo(x, y));
		            }
		        }
		        return segments;
		    }
		    MoveTo.create = create;
		})(MoveTo = exports.MoveTo || (exports.MoveTo = {}));
		exports.MoveTo = MoveTo;
		
	} (moveto));
	return moveto;
}

var curveto = {};

var hasRequiredCurveto;

function requireCurveto () {
	if (hasRequiredCurveto) return curveto;
	hasRequiredCurveto = 1;
	(function (exports) {
		"use strict";
		var __extends = (curveto && curveto.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CurveTo = void 0;
		var curve_1 = requireCurve();
		var point_1 = requirePoint();
		var segment_1 = requireSegment();
		var CurveTo = /** @class */ (function (_super) {
		    __extends(CurveTo, _super);
		    function CurveTo(arg0, arg1, arg2, arg3, arg4, arg5) {
		        var _this = _super.call(this) || this;
		        if (curve_1.Curve.isCurve(arg0)) {
		            _this.controlPoint1 = arg0.controlPoint1.clone().round(2);
		            _this.controlPoint2 = arg0.controlPoint2.clone().round(2);
		            _this.endPoint = arg0.end.clone().round(2);
		        }
		        else if (typeof arg0 === 'number') {
		            _this.controlPoint1 = new point_1.Point(arg0, arg1).round(2);
		            _this.controlPoint2 = new point_1.Point(arg2, arg3).round(2);
		            _this.endPoint = new point_1.Point(arg4, arg5).round(2);
		        }
		        else {
		            _this.controlPoint1 = point_1.Point.create(arg0).round(2);
		            _this.controlPoint2 = point_1.Point.create(arg1).round(2);
		            _this.endPoint = point_1.Point.create(arg2).round(2);
		        }
		        return _this;
		    }
		    Object.defineProperty(CurveTo.prototype, "type", {
		        get: function () {
		            return 'C';
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(CurveTo.prototype, "curve", {
		        get: function () {
		            return new curve_1.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
		        },
		        enumerable: false,
		        configurable: true
		    });
		    CurveTo.prototype.bbox = function () {
		        return this.curve.bbox();
		    };
		    CurveTo.prototype.closestPoint = function (p) {
		        return this.curve.closestPoint(p);
		    };
		    CurveTo.prototype.closestPointLength = function (p) {
		        return this.curve.closestPointLength(p);
		    };
		    CurveTo.prototype.closestPointNormalizedLength = function (p) {
		        return this.curve.closestPointNormalizedLength(p);
		    };
		    CurveTo.prototype.closestPointTangent = function (p) {
		        return this.curve.closestPointTangent(p);
		    };
		    CurveTo.prototype.length = function () {
		        return this.curve.length();
		    };
		    CurveTo.prototype.divideAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        // TODO: fix options
		        var divided = this.curve.divideAt(ratio, options);
		        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
		    };
		    CurveTo.prototype.divideAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        // TODO: fix options
		        var divided = this.curve.divideAtLength(length, options);
		        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
		    };
		    CurveTo.prototype.divideAtT = function (t) {
		        var divided = this.curve.divideAtT(t);
		        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
		    };
		    CurveTo.prototype.getSubdivisions = function () {
		        return [];
		    };
		    CurveTo.prototype.pointAt = function (ratio) {
		        return this.curve.pointAt(ratio);
		    };
		    CurveTo.prototype.pointAtLength = function (length) {
		        return this.curve.pointAtLength(length);
		    };
		    CurveTo.prototype.tangentAt = function (ratio) {
		        return this.curve.tangentAt(ratio);
		    };
		    CurveTo.prototype.tangentAtLength = function (length) {
		        return this.curve.tangentAtLength(length);
		    };
		    CurveTo.prototype.isDifferentiable = function () {
		        if (!this.previousSegment) {
		            return false;
		        }
		        var start = this.start;
		        var control1 = this.controlPoint1;
		        var control2 = this.controlPoint2;
		        var end = this.end;
		        return !(start.equals(control1) &&
		            control1.equals(control2) &&
		            control2.equals(end));
		    };
		    CurveTo.prototype.scale = function (sx, sy, origin) {
		        this.controlPoint1.scale(sx, sy, origin);
		        this.controlPoint2.scale(sx, sy, origin);
		        this.end.scale(sx, sy, origin);
		        return this;
		    };
		    CurveTo.prototype.rotate = function (angle, origin) {
		        this.controlPoint1.rotate(angle, origin);
		        this.controlPoint2.rotate(angle, origin);
		        this.end.rotate(angle, origin);
		        return this;
		    };
		    CurveTo.prototype.translate = function (tx, ty) {
		        if (typeof tx === 'number') {
		            this.controlPoint1.translate(tx, ty);
		            this.controlPoint2.translate(tx, ty);
		            this.end.translate(tx, ty);
		        }
		        else {
		            this.controlPoint1.translate(tx);
		            this.controlPoint2.translate(tx);
		            this.end.translate(tx);
		        }
		        return this;
		    };
		    CurveTo.prototype.equals = function (s) {
		        return (this.start.equals(s.start) &&
		            this.end.equals(s.end) &&
		            this.controlPoint1.equals(s.controlPoint1) &&
		            this.controlPoint2.equals(s.controlPoint2));
		    };
		    CurveTo.prototype.clone = function () {
		        return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);
		    };
		    CurveTo.prototype.toJSON = function () {
		        return {
		            type: this.type,
		            start: this.start.toJSON(),
		            controlPoint1: this.controlPoint1.toJSON(),
		            controlPoint2: this.controlPoint2.toJSON(),
		            end: this.end.toJSON(),
		        };
		    };
		    CurveTo.prototype.serialize = function () {
		        var c1 = this.controlPoint1;
		        var c2 = this.controlPoint2;
		        var end = this.end;
		        return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');
		    };
		    return CurveTo;
		}(segment_1.Segment));
		exports.CurveTo = CurveTo;
		(function (CurveTo) {
		    function create() {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var len = args.length;
		        var arg0 = args[0];
		        // curve provided
		        if (curve_1.Curve.isCurve(arg0)) {
		            return new CurveTo(arg0);
		        }
		        // points provided
		        if (point_1.Point.isPointLike(arg0)) {
		            if (len === 3) {
		                return new CurveTo(args[0], args[1], args[2]);
		            }
		            // this is a poly-bezier segment
		            var segments_1 = [];
		            for (var i = 0; i < len; i += 3) {
		                segments_1.push(new CurveTo(args[i], args[i + 1], args[i + 2]));
		            }
		            return segments_1;
		        }
		        // coordinates provided
		        if (len === 6) {
		            return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);
		        }
		        // this is a poly-bezier segment
		        var segments = [];
		        for (var i = 0; i < len; i += 6) {
		            segments.push(new CurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));
		        }
		        return segments;
		    }
		    CurveTo.create = create;
		})(CurveTo = exports.CurveTo || (exports.CurveTo = {}));
		exports.CurveTo = CurveTo;
		
	} (curveto));
	return curveto;
}

var normalize = {};

var hasRequiredNormalize;

function requireNormalize () {
	if (hasRequiredNormalize) return normalize;
	hasRequiredNormalize = 1;
	"use strict";
	var __spreadArray = (normalize && normalize.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(normalize, "__esModule", { value: true });
	normalize.normalizePathData = void 0;
	var util_1 = requireUtil$4();
	function rotate(x, y, rad) {
	    return {
	        x: x * Math.cos(rad) - y * Math.sin(rad),
	        y: x * Math.sin(rad) + y * Math.cos(rad),
	    };
	}
	function q2c(x1, y1, ax, ay, x2, y2) {
	    var v13 = 1 / 3;
	    var v23 = 2 / 3;
	    return [
	        v13 * x1 + v23 * ax,
	        v13 * y1 + v23 * ay,
	        v13 * x2 + v23 * ax,
	        v13 * y2 + v23 * ay,
	        x2,
	        y2,
	    ];
	}
	function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
	    // for more information of where this math came from visit:
	    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	    var v120 = (Math.PI * 120) / 180;
	    var rad = (Math.PI / 180) * (+angle || 0);
	    var res = [];
	    var xy;
	    var f1;
	    var f2;
	    var cx;
	    var cy;
	    if (!recursive) {
	        xy = rotate(x1, y1, -rad);
	        x1 = xy.x; // eslint-disable-line
	        y1 = xy.y; // eslint-disable-line
	        xy = rotate(x2, y2, -rad);
	        x2 = xy.x; // eslint-disable-line
	        y2 = xy.y; // eslint-disable-line
	        var x = (x1 - x2) / 2;
	        var y = (y1 - y2) / 2;
	        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
	        if (h > 1) {
	            h = Math.sqrt(h);
	            rx = h * rx; // eslint-disable-line
	            ry = h * ry; // eslint-disable-line
	        }
	        var rx2 = rx * rx;
	        var ry2 = ry * ry;
	        var k = (largeArcFlag === sweepFlag ? -1 : 1) *
	            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
	        cx = (k * rx * y) / ry + (x1 + x2) / 2;
	        cy = (k * -ry * x) / rx + (y1 + y2) / 2;
	        f1 = Math.asin((y1 - cy) / ry);
	        f2 = Math.asin((y2 - cy) / ry);
	        f1 = x1 < cx ? Math.PI - f1 : f1;
	        f2 = x2 < cx ? Math.PI - f2 : f2;
	        if (f1 < 0) {
	            f1 = Math.PI * 2 + f1;
	        }
	        if (f2 < 0) {
	            f2 = Math.PI * 2 + f2;
	        }
	        if (sweepFlag && f1 > f2) {
	            f1 -= Math.PI * 2;
	        }
	        if (!sweepFlag && f2 > f1) {
	            f2 -= Math.PI * 2;
	        }
	    }
	    else {
	        f1 = recursive[0];
	        f2 = recursive[1];
	        cx = recursive[2];
	        cy = recursive[3];
	    }
	    var df = f2 - f1;
	    if (Math.abs(df) > v120) {
	        var f2old = f2;
	        var x2old = x2;
	        var y2old = y2;
	        f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1);
	        x2 = cx + rx * Math.cos(f2); // eslint-disable-line
	        y2 = cy + ry * Math.sin(f2); // eslint-disable-line
	        res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [
	            f2,
	            f2old,
	            cx,
	            cy,
	        ]);
	    }
	    df = f2 - f1;
	    var c1 = Math.cos(f1);
	    var s1 = Math.sin(f1);
	    var c2 = Math.cos(f2);
	    var s2 = Math.sin(f2);
	    var t = Math.tan(df / 4);
	    var hx = (4 / 3) * (rx * t);
	    var hy = (4 / 3) * (ry * t);
	    var m1 = [x1, y1];
	    var m2 = [x1 + hx * s1, y1 - hy * c1];
	    var m3 = [x2 + hx * s2, y2 - hy * c2];
	    var m4 = [x2, y2];
	    m2[0] = 2 * m1[0] - m2[0];
	    m2[1] = 2 * m1[1] - m2[1];
	    if (recursive) {
	        return [m2, m3, m4].concat(res);
	    }
	    {
	        res = [m2, m3, m4].concat(res).join().split(',');
	        var newres = [];
	        var ii = res.length;
	        for (var i = 0; i < ii; i += 1) {
	            newres[i] =
	                i % 2
	                    ? rotate(+res[i - 1], +res[i], rad).y
	                    : rotate(+res[i], +res[i + 1], rad).x;
	        }
	        return newres;
	    }
	}
	function parse(pathData) {
	    if (!pathData) {
	        return null;
	    }
	    var spaces = '\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029';
	    // https://regexper.com/#%28%5Ba-z%5D%29%5B%5Cs%2C%5D*%28%28-%3F%5Cd*%5C.%3F%5C%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*%29%2B%29
	    var segmentReg = new RegExp("([a-z])[" + spaces + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + spaces + "]*,?[" + spaces + "]*)+)", // eslint-disable-line
	    'ig');
	    // https://regexper.com/#%28-%3F%5Cd*%5C.%3F%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%29%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*
	    var commandParamReg = new RegExp(
	    // eslint-disable-next-line
	    "(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + spaces + "]*,?[" + spaces + "]*", 'ig');
	    var paramsCount = {
	        a: 7,
	        c: 6,
	        h: 1,
	        l: 2,
	        m: 2,
	        q: 4,
	        s: 4,
	        t: 2,
	        v: 1,
	        z: 0,
	    };
	    var segmetns = [];
	    pathData.replace(segmentReg, function (input, cmd, args) {
	        var params = [];
	        var command = cmd.toLowerCase();
	        args.replace(commandParamReg, function (a, b) {
	            if (b) {
	                params.push(+b);
	            }
	            return a;
	        });
	        if (command === 'm' && params.length > 2) {
	            segmetns.push(__spreadArray([cmd], params.splice(0, 2), true));
	            command = 'l';
	            cmd = cmd === 'm' ? 'l' : 'L'; // eslint-disable-line
	        }
	        var count = paramsCount[command];
	        while (params.length >= count) {
	            segmetns.push(__spreadArray([cmd], params.splice(0, count), true));
	            if (!count) {
	                break;
	            }
	        }
	        return input;
	    });
	    return segmetns;
	}
	function abs(pathString) {
	    var pathArray = parse(pathString);
	    // if invalid string, return 'M 0 0'
	    if (!pathArray || !pathArray.length) {
	        return [['M', 0, 0]];
	    }
	    var x = 0;
	    var y = 0;
	    var mx = 0;
	    var my = 0;
	    var segments = [];
	    for (var i = 0, ii = pathArray.length; i < ii; i += 1) {
	        var r = [];
	        segments.push(r);
	        var segment = pathArray[i];
	        var command = segment[0];
	        if (command !== command.toUpperCase()) {
	            r[0] = command.toUpperCase();
	            switch (r[0]) {
	                case 'A':
	                    r[1] = segment[1];
	                    r[2] = segment[2];
	                    r[3] = segment[3];
	                    r[4] = segment[4];
	                    r[5] = segment[5];
	                    r[6] = +segment[6] + x;
	                    r[7] = +segment[7] + y;
	                    break;
	                case 'V':
	                    r[1] = +segment[1] + y;
	                    break;
	                case 'H':
	                    r[1] = +segment[1] + x;
	                    break;
	                case 'M':
	                    mx = +segment[1] + x;
	                    my = +segment[2] + y;
	                    for (var j = 1, jj = segment.length; j < jj; j += 1) {
	                        r[j] = +segment[j] + (j % 2 ? x : y);
	                    }
	                    break;
	                default:
	                    for (var j = 1, jj = segment.length; j < jj; j += 1) {
	                        r[j] = +segment[j] + (j % 2 ? x : y);
	                    }
	                    break;
	            }
	        }
	        else {
	            for (var j = 0, jj = segment.length; j < jj; j += 1) {
	                r[j] = segment[j];
	            }
	        }
	        switch (r[0]) {
	            case 'Z':
	                x = +mx;
	                y = +my;
	                break;
	            case 'H':
	                x = r[1];
	                break;
	            case 'V':
	                y = r[1];
	                break;
	            case 'M':
	                mx = r[r.length - 2];
	                my = r[r.length - 1];
	                x = r[r.length - 2];
	                y = r[r.length - 1];
	                break;
	            default:
	                x = r[r.length - 2];
	                y = r[r.length - 1];
	                break;
	        }
	    }
	    return segments;
	}
	function normalize$1(path) {
	    var pathArray = abs(path);
	    var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
	    function processPath(path, d, pcom) {
	        var nx;
	        var ny;
	        if (!path) {
	            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
	        }
	        if (!(path[0] in { T: 1, Q: 1 })) {
	            d.qx = null;
	            d.qy = null;
	        }
	        switch (path[0]) {
	            case 'M':
	                d.X = path[1];
	                d.Y = path[2];
	                break;
	            case 'A':
	                if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
	                    // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
	                    // "If either rx or ry is 0, then this arc is treated as a
	                    // straight line segment (a "lineto") joining the endpoints."
	                    return ['L', path[6], path[7]];
	                }
	                return ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
	            case 'S':
	                if (pcom === 'C' || pcom === 'S') {
	                    // In 'S' case we have to take into account, if the previous command is C/S.
	                    nx = d.x * 2 - d.bx; // And reflect the previous
	                    ny = d.y * 2 - d.by; // command's control point relative to the current point.
	                }
	                else {
	                    // or some else or nothing
	                    nx = d.x;
	                    ny = d.y;
	                }
	                return ['C', nx, ny].concat(path.slice(1));
	            case 'T':
	                if (pcom === 'Q' || pcom === 'T') {
	                    // In 'T' case we have to take into account, if the previous command is Q/T.
	                    d.qx = d.x * 2 - d.qx; // And make a reflection similar
	                    d.qy = d.y * 2 - d.qy; // to case 'S'.
	                }
	                else {
	                    // or something else or nothing
	                    d.qx = d.x;
	                    d.qy = d.y;
	                }
	                return ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
	            case 'Q':
	                d.qx = path[1];
	                d.qy = path[2];
	                return ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
	            case 'H':
	                return ['L'].concat(path[1], d.y);
	            case 'V':
	                return ['L'].concat(d.x, path[1]);
	            case 'L':
	                break;
	            case 'Z':
	                break;
	            default:
	                break;
	        }
	        return path;
	    }
	    function fixArc(pp, i) {
	        if (pp[i].length > 7) {
	            pp[i].shift();
	            var pi = pp[i];
	            while (pi.length) {
	                // if created multiple 'C's, their original seg is saved
	                commands[i] = 'A';
	                i += 1; // eslint-disable-line
	                pp.splice(i, 0, ['C'].concat(pi.splice(0, 6)));
	            }
	            pp.splice(i, 1);
	            ii = pathArray.length;
	        }
	    }
	    var commands = []; // path commands of original path p
	    var prevCommand = ''; // holder for previous path command of original path
	    var ii = pathArray.length;
	    for (var i = 0; i < ii; i += 1) {
	        var command = ''; // temporary holder for original path command
	        if (pathArray[i]) {
	            command = pathArray[i][0]; // save current path command
	        }
	        if (command !== 'C') {
	            // C is not saved yet, because it may be result of conversion
	            commands[i] = command; // Save current path command
	            if (i > 0) {
	                prevCommand = commands[i - 1]; // Get previous path command pcom
	            }
	        }
	        // Previous path command is inputted to processPath
	        pathArray[i] = processPath(pathArray[i], attrs, prevCommand);
	        if (commands[i] !== 'A' && command === 'C') {
	            commands[i] = 'C'; // 'A' is the only command
	        }
	        // which may produce multiple 'C's
	        // so we have to make sure that 'C' is also 'C' in original path
	        fixArc(pathArray, i); // fixArc adds also the right amount of 'A's to pcoms
	        var seg = pathArray[i];
	        var seglen = seg.length;
	        attrs.x = seg[seglen - 2];
	        attrs.y = seg[seglen - 1];
	        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
	        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
	    }
	    // make sure normalized path data string starts with an M segment
	    if (!pathArray[0][0] || pathArray[0][0] !== 'M') {
	        pathArray.unshift(['M', 0, 0]);
	    }
	    return pathArray;
	}
	/**
	 * Converts provided SVG path data string into a normalized path data string.
	 *
	 * The normalization uses a restricted subset of path commands; all segments
	 * are translated into lineto, curveto, moveto, and closepath segments.
	 *
	 * Relative path commands are changed into their absolute counterparts,
	 * and chaining of coordinates is disallowed.
	 *
	 * The function will always return a valid path data string; if an input
	 * string cannot be normalized, 'M 0 0' is returned.
	 */
	function normalizePathData(pathData) {
	    return normalize$1(pathData)
	        .map(function (segment) {
	        return segment.map(function (item) { return (typeof item === 'string' ? item : (0, util_1.round)(item, 2)); });
	    })
	        .join(',')
	        .split(',')
	        .join(' ');
	}
	normalize.normalizePathData = normalizePathData;
	
	return normalize;
}

var util$2 = {};

var hasRequiredUtil$3;

function requireUtil$3 () {
	if (hasRequiredUtil$3) return util$2;
	hasRequiredUtil$3 = 1;
	"use strict";
	Object.defineProperty(util$2, "__esModule", { value: true });
	util$2.drawArc = util$2.arcToCurves = util$2.drawPoints = util$2.isValid = void 0;
	var point_1 = requirePoint();
	var regexSupportedData = new RegExp("^[\\s\\dLMCZz,.]*$");
	function isValid(data) {
	    if (typeof data !== 'string') {
	        return false;
	    }
	    return regexSupportedData.test(data);
	}
	util$2.isValid = isValid;
	/**
	 * Returns the remainder of division of `n` by `m`. You should use this
	 * instead of the built-in operation as the built-in operation does not
	 * properly handle negative numbers.
	 */
	function mod(n, m) {
	    return ((n % m) + m) % m;
	}
	function draw(points, round, initialMove, close, exclude) {
	    var data = [];
	    var end = points[points.length - 1];
	    var rounded = round != null && round > 0;
	    var arcSize = round || 0;
	    // Adds virtual waypoint in the center between start and end point
	    if (close && rounded) {
	        points = points.slice(); // eslint-disable-line
	        var p0 = points[0];
	        var wp = new point_1.Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);
	        points.splice(0, 0, wp);
	    }
	    var pt = points[0];
	    var i = 1;
	    // Draws the line segments
	    if (initialMove) {
	        data.push('M', pt.x, pt.y);
	    }
	    else {
	        data.push('L', pt.x, pt.y);
	    }
	    while (i < (close ? points.length : points.length - 1)) {
	        var tmp = points[mod(i, points.length)];
	        var dx = pt.x - tmp.x;
	        var dy = pt.y - tmp.y;
	        if (rounded &&
	            (dx !== 0 || dy !== 0) &&
	            (exclude == null || exclude.indexOf(i - 1) < 0)) {
	            // Draws a line from the last point to the current
	            // point with a spacing of size off the current point
	            // into direction of the last point
	            var dist = Math.sqrt(dx * dx + dy * dy);
	            var nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;
	            var ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;
	            var x1 = tmp.x + nx1;
	            var y1 = tmp.y + ny1;
	            data.push('L', x1, y1);
	            // Draws a curve from the last point to the current
	            // point with a spacing of size off the current point
	            // into direction of the next point
	            var next = points[mod(i + 1, points.length)];
	            // Uses next non-overlapping point
	            while (i < points.length - 2 &&
	                Math.round(next.x - tmp.x) === 0 &&
	                Math.round(next.y - tmp.y) === 0) {
	                next = points[mod(i + 2, points.length)];
	                i += 1;
	            }
	            dx = next.x - tmp.x;
	            dy = next.y - tmp.y;
	            dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
	            var nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;
	            var ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;
	            var x2 = tmp.x + nx2;
	            var y2 = tmp.y + ny2;
	            data.push('Q', tmp.x, tmp.y, x2, y2);
	            tmp = new point_1.Point(x2, y2);
	        }
	        else {
	            data.push('L', tmp.x, tmp.y);
	        }
	        pt = tmp;
	        i += 1;
	    }
	    if (close) {
	        data.push('Z');
	    }
	    else {
	        data.push('L', end.x, end.y);
	    }
	    return data.map(function (v) { return (typeof v === 'string' ? v : +v.toFixed(3)); }).join(' ');
	}
	function drawPoints(points, options) {
	    if (options === void 0) { options = {}; }
	    var pts = [];
	    if (points && points.length) {
	        points.forEach(function (p) {
	            if (Array.isArray(p)) {
	                pts.push({ x: p[0], y: p[1] });
	            }
	            else {
	                pts.push({ x: p.x, y: p.y });
	            }
	        });
	    }
	    return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);
	}
	util$2.drawPoints = drawPoints;
	/**
	 * Converts the given arc to a series of curves.
	 */
	function arcToCurves(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) {
	    if (angle === void 0) { angle = 0; }
	    if (largeArcFlag === void 0) { largeArcFlag = 0; }
	    if (sweepFlag === void 0) { sweepFlag = 0; }
	    if (r1 === 0 || r2 === 0) {
	        return [];
	    }
	    x -= x0; // eslint-disable-line
	    y -= y0; // eslint-disable-line
	    r1 = Math.abs(r1); // eslint-disable-line
	    r2 = Math.abs(r2); // eslint-disable-line
	    var ctx = -x / 2;
	    var cty = -y / 2;
	    var cpsi = Math.cos((angle * Math.PI) / 180);
	    var spsi = Math.sin((angle * Math.PI) / 180);
	    var rxd = cpsi * ctx + spsi * cty;
	    var ryd = -1 * spsi * ctx + cpsi * cty;
	    var rxdd = rxd * rxd;
	    var rydd = ryd * ryd;
	    var r1x = r1 * r1;
	    var r2y = r2 * r2;
	    var lamda = rxdd / r1x + rydd / r2y;
	    var sds;
	    if (lamda > 1) {
	        r1 = Math.sqrt(lamda) * r1; // eslint-disable-line
	        r2 = Math.sqrt(lamda) * r2; // eslint-disable-line
	        sds = 0;
	    }
	    else {
	        var seif = 1;
	        if (largeArcFlag === sweepFlag) {
	            seif = -1;
	        }
	        sds =
	            seif *
	                Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
	    }
	    var txd = (sds * r1 * ryd) / r2;
	    var tyd = (-1 * sds * r2 * rxd) / r1;
	    var tx = cpsi * txd - spsi * tyd + x / 2;
	    var ty = spsi * txd + cpsi * tyd + y / 2;
	    var rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
	    var s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
	    rad =
	        Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -
	            Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
	    var dr = rad >= 0 ? rad : 2 * Math.PI + rad;
	    if (sweepFlag === 0 && dr > 0) {
	        dr -= 2 * Math.PI;
	    }
	    else if (sweepFlag !== 0 && dr < 0) {
	        dr += 2 * Math.PI;
	    }
	    var sse = (dr * 2) / Math.PI;
	    var seg = Math.ceil(sse < 0 ? -1 * sse : sse);
	    var segr = dr / seg;
	    var t = ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2);
	    var cpsir1 = cpsi * r1;
	    var cpsir2 = cpsi * r2;
	    var spsir1 = spsi * r1;
	    var spsir2 = spsi * r2;
	    var mc = Math.cos(s1);
	    var ms = Math.sin(s1);
	    var x2 = -t * (cpsir1 * ms + spsir2 * mc);
	    var y2 = -t * (spsir1 * ms - cpsir2 * mc);
	    var x3 = 0;
	    var y3 = 0;
	    var result = [];
	    for (var n = 0; n < seg; n += 1) {
	        s1 += segr;
	        mc = Math.cos(s1);
	        ms = Math.sin(s1);
	        x3 = cpsir1 * mc - spsir2 * ms + tx;
	        y3 = spsir1 * mc + cpsir2 * ms + ty;
	        var dx = -t * (cpsir1 * ms + spsir2 * mc);
	        var dy = -t * (spsir1 * ms - cpsir2 * mc);
	        // CurveTo updates x0, y0 so need to restore it
	        var index = n * 6;
	        result[index] = Number(x2 + x0);
	        result[index + 1] = Number(y2 + y0);
	        result[index + 2] = Number(x3 - dx + x0);
	        result[index + 3] = Number(y3 - dy + y0);
	        result[index + 4] = Number(x3 + x0);
	        result[index + 5] = Number(y3 + y0);
	        x2 = x3 + dx;
	        y2 = y3 + dy;
	    }
	    return result.map(function (num) { return +num.toFixed(2); });
	}
	util$2.arcToCurves = arcToCurves;
	function drawArc(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY) {
	    if (xAxisRotation === void 0) { xAxisRotation = 0; }
	    if (largeArcFlag === void 0) { largeArcFlag = 0; }
	    if (sweepFlag === void 0) { sweepFlag = 0; }
	    var data = [];
	    var points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);
	    if (points != null) {
	        for (var i = 0, ii = points.length; i < ii; i += 6) {
	            data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
	        }
	    }
	    return data.join(' ');
	}
	util$2.drawArc = drawArc;
	
	return util$2;
}

var hasRequiredPath$2;

function requirePath$2 () {
	if (hasRequiredPath$2) return path$1;
	hasRequiredPath$2 = 1;
	(function (exports) {
		"use strict";
		var __extends = (path$1 && path$1.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		var __createBinding = (path$1 && path$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (path$1 && path$1.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (path$1 && path$1.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __spreadArray = (path$1 && path$1.__spreadArray) || function (to, from, pack) {
		    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
		        if (ar || !(i in from)) {
		            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
		            ar[i] = from[i];
		        }
		    }
		    return to.concat(ar || Array.prototype.slice.call(from));
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Path = void 0;
		var util_1 = requireUtil$4();
		var line_1 = requireLine();
		var point_1 = requirePoint();
		var curve_1 = requireCurve();
		var polyline_1 = requirePolyline();
		var rectangle_1 = requireRectangle();
		var geometry_1 = requireGeometry$1();
		var close_1 = requireClose();
		var lineto_1 = requireLineto();
		var moveto_1 = requireMoveto();
		var curveto_1 = requireCurveto();
		var normalize_1 = requireNormalize();
		var Util = __importStar(requireUtil$3());
		var Path = /** @class */ (function (_super) {
		    __extends(Path, _super);
		    function Path(args) {
		        var _this = _super.call(this) || this;
		        _this.PRECISION = 3;
		        _this.segments = [];
		        if (Array.isArray(args)) {
		            if (line_1.Line.isLine(args[0]) || curve_1.Curve.isCurve(args[0])) {
		                var previousObj_1 = null;
		                var arr = args;
		                arr.forEach(function (o, i) {
		                    if (i === 0) {
		                        _this.appendSegment(Path.createSegment('M', o.start));
		                    }
		                    if (previousObj_1 != null && !previousObj_1.end.equals(o.start)) {
		                        _this.appendSegment(Path.createSegment('M', o.start));
		                    }
		                    if (line_1.Line.isLine(o)) {
		                        _this.appendSegment(Path.createSegment('L', o.end));
		                    }
		                    else if (curve_1.Curve.isCurve(o)) {
		                        _this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));
		                    }
		                    previousObj_1 = o;
		                });
		            }
		            else {
		                var arr = args;
		                arr.forEach(function (s) {
		                    if (s.isSegment) {
		                        _this.appendSegment(s);
		                    }
		                });
		            }
		        }
		        else if (args != null) {
		            if (line_1.Line.isLine(args)) {
		                _this.appendSegment(Path.createSegment('M', args.start));
		                _this.appendSegment(Path.createSegment('L', args.end));
		            }
		            else if (curve_1.Curve.isCurve(args)) {
		                _this.appendSegment(Path.createSegment('M', args.start));
		                _this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));
		            }
		            else if (polyline_1.Polyline.isPolyline(args)) {
		                if (args.points && args.points.length) {
		                    args.points.forEach(function (point, index) {
		                        var segment = index === 0
		                            ? Path.createSegment('M', point)
		                            : Path.createSegment('L', point);
		                        _this.appendSegment(segment);
		                    });
		                }
		            }
		            else if (args.isSegment) {
		                _this.appendSegment(args);
		            }
		        }
		        return _this;
		    }
		    Object.defineProperty(Path.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Path.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Path.prototype, "start", {
		        get: function () {
		            var segments = this.segments;
		            var count = segments.length;
		            if (count === 0) {
		                return null;
		            }
		            for (var i = 0; i < count; i += 1) {
		                var segment = segments[i];
		                if (segment.isVisible) {
		                    return segment.start;
		                }
		            }
		            // if no visible segment, return last segment end point
		            return segments[count - 1].end;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Path.prototype, "end", {
		        get: function () {
		            var segments = this.segments;
		            var count = segments.length;
		            if (count === 0) {
		                return null;
		            }
		            for (var i = count - 1; i >= 0; i -= 1) {
		                var segment = segments[i];
		                if (segment.isVisible) {
		                    return segment.end;
		                }
		            }
		            // if no visible segment, return last segment end point
		            return segments[count - 1].end;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Path.prototype.moveTo = function () {
		        var _a;
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        return this.appendSegment((_a = moveto_1.MoveTo.create).call.apply(_a, __spreadArray([null], args, false)));
		    };
		    Path.prototype.lineTo = function () {
		        var _a;
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        return this.appendSegment((_a = lineto_1.LineTo.create).call.apply(_a, __spreadArray([null], args, false)));
		    };
		    Path.prototype.curveTo = function () {
		        var _a;
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        return this.appendSegment((_a = curveto_1.CurveTo.create).call.apply(_a, __spreadArray([null], args, false)));
		    };
		    Path.prototype.arcTo = function (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {
		        var start = this.end || new point_1.Point();
		        var points = typeof endX === 'number'
		            ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY)
		            : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);
		        if (points != null) {
		            for (var i = 0, ii = points.length; i < ii; i += 6) {
		                this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
		            }
		        }
		        return this;
		    };
		    Path.prototype.quadTo = function (x1, y1, x, y) {
		        var start = this.end || new point_1.Point();
		        var data = ['M', start.x, start.y];
		        if (typeof x1 === 'number') {
		            data.push('Q', x1, y1, x, y);
		        }
		        else {
		            var p = y1;
		            data.push("Q", x1.x, x1.y, p.x, p.y);
		        }
		        var path = Path.parse(data.join(' '));
		        this.appendSegment(path.segments.slice(1));
		        return this;
		    };
		    Path.prototype.close = function () {
		        return this.appendSegment(close_1.Close.create());
		    };
		    Path.prototype.drawPoints = function (points, options) {
		        if (options === void 0) { options = {}; }
		        var raw = Util.drawPoints(points, options);
		        var sub = Path.parse(raw);
		        if (sub && sub.segments) {
		            this.appendSegment(sub.segments);
		        }
		    };
		    Path.prototype.bbox = function () {
		        var segments = this.segments;
		        var count = segments.length;
		        if (count === 0) {
		            return null;
		        }
		        var bbox;
		        for (var i = 0; i < count; i += 1) {
		            var segment = segments[i];
		            if (segment.isVisible) {
		                var segmentBBox = segment.bbox();
		                if (segmentBBox != null) {
		                    bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
		                }
		            }
		        }
		        if (bbox != null) {
		            return bbox;
		        }
		        // if the path has only invisible elements, return end point of last segment
		        var lastSegment = segments[count - 1];
		        return new rectangle_1.Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
		    };
		    Path.prototype.appendSegment = function (seg) {
		        var count = this.segments.length;
		        var previousSegment = count !== 0 ? this.segments[count - 1] : null;
		        var currentSegment;
		        var nextSegment = null;
		        if (Array.isArray(seg)) {
		            for (var i = 0, ii = seg.length; i < ii; i += 1) {
		                var segment = seg[i];
		                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
		                this.segments.push(currentSegment);
		                previousSegment = currentSegment;
		            }
		        }
		        else if (seg != null && seg.isSegment) {
		            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
		            this.segments.push(currentSegment);
		        }
		        return this;
		    };
		    Path.prototype.insertSegment = function (index, seg) {
		        var count = this.segments.length;
		        if (index < 0) {
		            index = count + index + 1; // eslint-disable-line
		        }
		        if (index > count || index < 0) {
		            throw new Error('Index out of range.');
		        }
		        var currentSegment;
		        var previousSegment = null;
		        var nextSegment = null;
		        if (count !== 0) {
		            if (index >= 1) {
		                previousSegment = this.segments[index - 1];
		                nextSegment = previousSegment.nextSegment;
		            }
		            else {
		                previousSegment = null;
		                nextSegment = this.segments[0];
		            }
		        }
		        if (!Array.isArray(seg)) {
		            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
		            this.segments.splice(index, 0, currentSegment);
		        }
		        else {
		            for (var i = 0, ii = seg.length; i < ii; i += 1) {
		                var segment = seg[i];
		                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
		                this.segments.splice(index + i, 0, currentSegment);
		                previousSegment = currentSegment;
		            }
		        }
		        return this;
		    };
		    Path.prototype.removeSegment = function (index) {
		        var idx = this.fixIndex(index);
		        var removedSegment = this.segments.splice(idx, 1)[0];
		        var previousSegment = removedSegment.previousSegment;
		        var nextSegment = removedSegment.nextSegment;
		        // link the previous and next segments together (if present)
		        if (previousSegment) {
		            previousSegment.nextSegment = nextSegment;
		        }
		        if (nextSegment) {
		            nextSegment.previousSegment = previousSegment;
		        }
		        if (removedSegment.isSubpathStart && nextSegment) {
		            this.updateSubpathStartSegment(nextSegment);
		        }
		        return removedSegment;
		    };
		    Path.prototype.replaceSegment = function (index, seg) {
		        var idx = this.fixIndex(index);
		        var currentSegment;
		        var replacedSegment = this.segments[idx];
		        var previousSegment = replacedSegment.previousSegment;
		        var nextSegment = replacedSegment.nextSegment;
		        var updateSubpathStart = replacedSegment.isSubpathStart;
		        if (!Array.isArray(seg)) {
		            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
		            this.segments.splice(idx, 1, currentSegment);
		            if (updateSubpathStart && currentSegment.isSubpathStart) {
		                // already updated by `prepareSegment`
		                updateSubpathStart = false;
		            }
		        }
		        else {
		            this.segments.splice(index, 1);
		            for (var i = 0, ii = seg.length; i < ii; i += 1) {
		                var segment = seg[i];
		                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
		                this.segments.splice(index + i, 0, currentSegment);
		                previousSegment = currentSegment;
		                if (updateSubpathStart && currentSegment.isSubpathStart) {
		                    updateSubpathStart = false;
		                }
		            }
		        }
		        if (updateSubpathStart && nextSegment) {
		            this.updateSubpathStartSegment(nextSegment);
		        }
		    };
		    Path.prototype.getSegment = function (index) {
		        var idx = this.fixIndex(index);
		        return this.segments[idx];
		    };
		    Path.prototype.fixIndex = function (index) {
		        var length = this.segments.length;
		        if (length === 0) {
		            throw new Error('Path has no segments.');
		        }
		        var i = index;
		        while (i < 0) {
		            i = length + i;
		        }
		        if (i >= length || i < 0) {
		            throw new Error('Index out of range.');
		        }
		        return i;
		    };
		    Path.prototype.segmentAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        var index = this.segmentIndexAt(ratio, options);
		        if (!index) {
		            return null;
		        }
		        return this.getSegment(index);
		    };
		    Path.prototype.segmentAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        var index = this.segmentIndexAtLength(length, options);
		        if (!index)
		            return null;
		        return this.getSegment(index);
		    };
		    Path.prototype.segmentIndexAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        var rate = (0, util_1.clamp)(ratio, 0, 1);
		        var opt = this.getOptions(options);
		        var len = this.length(opt);
		        var length = len * rate;
		        return this.segmentIndexAtLength(length, opt);
		    };
		    Path.prototype.segmentIndexAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        var count = this.segments.length;
		        if (count === 0) {
		            return null;
		        }
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false;
		            length = -length; // eslint-disable-line
		        }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var memo = 0;
		        var lastVisibleIndex = null;
		        for (var i = 0; i < count; i += 1) {
		            var index = fromStart ? i : count - 1 - i;
		            var segment = this.segments[index];
		            var subdivisions = segmentSubdivisions[index];
		            var len = segment.length({ precision: precision, subdivisions: subdivisions });
		            if (segment.isVisible) {
		                if (length <= memo + len) {
		                    return index;
		                }
		                lastVisibleIndex = index;
		            }
		            memo += len;
		        }
		        // If length requested is higher than the length of the path, return
		        // last visible segment index. If no visible segment, return null.
		        return lastVisibleIndex;
		    };
		    Path.prototype.getSegmentSubdivisions = function (options) {
		        if (options === void 0) { options = {}; }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = [];
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var segment = this.segments[i];
		            var subdivisions = segment.getSubdivisions({ precision: precision });
		            segmentSubdivisions.push(subdivisions);
		        }
		        return segmentSubdivisions;
		    };
		    Path.prototype.updateSubpathStartSegment = function (segment) {
		        var previous = segment.previousSegment;
		        var current = segment;
		        while (current && !current.isSubpathStart) {
		            // assign previous segment's subpath start segment to this segment
		            if (previous != null) {
		                current.subpathStartSegment = previous.subpathStartSegment;
		            }
		            else {
		                current.subpathStartSegment = null;
		            }
		            previous = current;
		            current = current.nextSegment;
		        }
		    };
		    Path.prototype.prepareSegment = function (segment, previousSegment, nextSegment) {
		        segment.previousSegment = previousSegment;
		        segment.nextSegment = nextSegment;
		        if (previousSegment != null) {
		            previousSegment.nextSegment = segment;
		        }
		        if (nextSegment != null) {
		            nextSegment.previousSegment = segment;
		        }
		        var updateSubpathStart = segment;
		        if (segment.isSubpathStart) {
		            // move to
		            segment.subpathStartSegment = segment;
		            updateSubpathStart = nextSegment;
		        }
		        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments
		        if (updateSubpathStart != null) {
		            this.updateSubpathStartSegment(updateSubpathStart);
		        }
		        return segment;
		    };
		    Path.prototype.closestPoint = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var t = this.closestPointT(p, options);
		        if (!t) {
		            return null;
		        }
		        return this.pointAtT(t);
		    };
		    Path.prototype.closestPointLength = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var opts = this.getOptions(options);
		        var t = this.closestPointT(p, opts);
		        if (!t) {
		            return 0;
		        }
		        return this.lengthAtT(t, opts);
		    };
		    Path.prototype.closestPointNormalizedLength = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var opts = this.getOptions(options);
		        var cpLength = this.closestPointLength(p, opts);
		        if (cpLength === 0) {
		            return 0;
		        }
		        var length = this.length(opts);
		        if (length === 0) {
		            return 0;
		        }
		        return cpLength / length;
		    };
		    Path.prototype.closestPointT = function (p, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var closestPointT;
		        var minSquaredDistance = Infinity;
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var segment = this.segments[i];
		            var subdivisions = segmentSubdivisions[i];
		            if (segment.isVisible) {
		                var segmentClosestPointT = segment.closestPointT(p, {
		                    precision: precision,
		                    subdivisions: subdivisions,
		                });
		                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
		                var squaredDistance = (0, util_1.squaredLength)(segmentClosestPoint, p);
		                if (squaredDistance < minSquaredDistance) {
		                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };
		                    minSquaredDistance = squaredDistance;
		                }
		            }
		        }
		        if (closestPointT) {
		            return closestPointT;
		        }
		        return { segmentIndex: this.segments.length - 1, value: 1 };
		    };
		    Path.prototype.closestPointTangent = function (p, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var closestPointTangent;
		        var minSquaredDistance = Infinity;
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var segment = this.segments[i];
		            var subdivisions = segmentSubdivisions[i];
		            if (segment.isDifferentiable()) {
		                var segmentClosestPointT = segment.closestPointT(p, {
		                    precision: precision,
		                    subdivisions: subdivisions,
		                });
		                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
		                var squaredDistance = (0, util_1.squaredLength)(segmentClosestPoint, p);
		                if (squaredDistance < minSquaredDistance) {
		                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);
		                    minSquaredDistance = squaredDistance;
		                }
		            }
		        }
		        if (closestPointTangent) {
		            return closestPointTangent;
		        }
		        return null;
		    };
		    Path.prototype.containsPoint = function (p, options) {
		        if (options === void 0) { options = {}; }
		        var polylines = this.toPolylines(options);
		        if (!polylines) {
		            return false;
		        }
		        var numIntersections = 0;
		        for (var i = 0, ii = polylines.length; i < ii; i += 1) {
		            var polyline = polylines[i];
		            if (polyline.containsPoint(p)) {
		                numIntersections += 1;
		            }
		        }
		        // returns `true` for odd numbers of intersections (even-odd algorithm)
		        return numIntersections % 2 === 1;
		    };
		    Path.prototype.pointAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        if (ratio <= 0) {
		            return this.start.clone();
		        }
		        if (ratio >= 1) {
		            return this.end.clone();
		        }
		        var opts = this.getOptions(options);
		        var pathLength = this.length(opts);
		        var length = pathLength * ratio;
		        return this.pointAtLength(length, opts);
		    };
		    Path.prototype.pointAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        if (length === 0) {
		            return this.start.clone();
		        }
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false;
		            length = -length; // eslint-disable-line
		        }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var lastVisibleSegment;
		        var memo = 0;
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var index = fromStart ? i : ii - 1 - i;
		            var segment = this.segments[index];
		            var subdivisions = segmentSubdivisions[index];
		            var d = segment.length({
		                precision: precision,
		                subdivisions: subdivisions,
		            });
		            if (segment.isVisible) {
		                if (length <= memo + d) {
		                    return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {
		                        precision: precision,
		                        subdivisions: subdivisions,
		                    });
		                }
		                lastVisibleSegment = segment;
		            }
		            memo += d;
		        }
		        // if length requested is higher than the length of the path,
		        // return last visible segment endpoint
		        if (lastVisibleSegment) {
		            return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
		        }
		        // if no visible segment, return last segment end point
		        var lastSegment = this.segments[this.segments.length - 1];
		        return lastSegment.end.clone();
		    };
		    Path.prototype.pointAtT = function (t) {
		        var segments = this.segments;
		        var numSegments = segments.length;
		        if (numSegments === 0)
		            return null; // if segments is an empty array
		        var segmentIndex = t.segmentIndex;
		        if (segmentIndex < 0)
		            return segments[0].pointAtT(0);
		        if (segmentIndex >= numSegments) {
		            return segments[numSegments - 1].pointAtT(1);
		        }
		        var tValue = (0, util_1.clamp)(t.value, 0, 1);
		        return segments[segmentIndex].pointAtT(tValue);
		    };
		    Path.prototype.divideAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        var rate = (0, util_1.clamp)(ratio, 0, 1);
		        var opts = this.getOptions(options);
		        var len = this.length(opts);
		        var length = len * rate;
		        return this.divideAtLength(length, opts);
		    };
		    Path.prototype.divideAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false;
		            length = -length; // eslint-disable-line
		        }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var memo = 0;
		        var divided;
		        var dividedSegmentIndex;
		        var lastValidSegment;
		        var lastValidSegmentIndex;
		        var t;
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var index_1 = fromStart ? i : ii - 1 - i;
		            var segment = this.getSegment(index_1);
		            var subdivisions = segmentSubdivisions[index_1];
		            var opts = { precision: precision, subdivisions: subdivisions };
		            var len = segment.length(opts);
		            if (segment.isDifferentiable()) {
		                lastValidSegment = segment;
		                lastValidSegmentIndex = index_1;
		                if (length <= memo + len) {
		                    dividedSegmentIndex = index_1;
		                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);
		                    break;
		                }
		            }
		            memo += len;
		        }
		        if (!lastValidSegment) {
		            return null;
		        }
		        if (!divided) {
		            dividedSegmentIndex = lastValidSegmentIndex;
		            t = fromStart ? 1 : 0;
		            divided = lastValidSegment.divideAtT(t);
		        }
		        // create a copy of this path and replace the identified segment with its two divided parts:
		        var pathCopy = this.clone();
		        var index = dividedSegmentIndex;
		        pathCopy.replaceSegment(index, divided);
		        var divisionStartIndex = index;
		        var divisionMidIndex = index + 1;
		        var divisionEndIndex = index + 2;
		        // do not insert the part if it looks like a point
		        if (!divided[0].isDifferentiable()) {
		            pathCopy.removeSegment(divisionStartIndex);
		            divisionMidIndex -= 1;
		            divisionEndIndex -= 1;
		        }
		        // insert a Moveto segment to ensure secondPath will be valid:
		        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
		        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));
		        divisionEndIndex += 1;
		        // do not insert the part if it looks like a point
		        if (!divided[1].isDifferentiable()) {
		            pathCopy.removeSegment(divisionEndIndex - 1);
		            divisionEndIndex -= 1;
		        }
		        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:
		        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
		        for (var i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {
		            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
		            var segment = pathCopy.getSegment(i);
		            if (segment.type === 'Z' &&
		                !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
		                // pathCopy segment's subpathStartSegment is different from original segment's one
		                // convert this Closepath segment to a Lineto and replace it in pathCopy
		                var convertedSegment = Path.createSegment('L', originalSegment.end);
		                pathCopy.replaceSegment(i, convertedSegment);
		            }
		        }
		        // distribute pathCopy segments into two paths and return those:
		        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));
		        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));
		        return [firstPath, secondPath];
		    };
		    Path.prototype.intersectsWithLine = function (line, options) {
		        if (options === void 0) { options = {}; }
		        var polylines = this.toPolylines(options);
		        if (polylines == null) {
		            return null;
		        }
		        var intersections = null;
		        for (var i = 0, ii = polylines.length; i < ii; i += 1) {
		            var polyline = polylines[i];
		            var intersection = line.intersect(polyline);
		            if (intersection) {
		                if (intersections == null) {
		                    intersections = [];
		                }
		                if (Array.isArray(intersection)) {
		                    intersections.push.apply(intersections, intersection);
		                }
		                else {
		                    intersections.push(intersection);
		                }
		            }
		        }
		        return intersections;
		    };
		    Path.prototype.isDifferentiable = function () {
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var segment = this.segments[i];
		            if (segment.isDifferentiable()) {
		                return true;
		            }
		        }
		        return false;
		    };
		    Path.prototype.isValid = function () {
		        var segments = this.segments;
		        var isValid = segments.length === 0 || segments[0].type === 'M';
		        return isValid;
		    };
		    Path.prototype.length = function (options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return 0;
		        }
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var length = 0;
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var segment = this.segments[i];
		            var subdivisions = segmentSubdivisions[i];
		            length += segment.length({ subdivisions: subdivisions });
		        }
		        return length;
		    };
		    Path.prototype.lengthAtT = function (t, options) {
		        if (options === void 0) { options = {}; }
		        var count = this.segments.length;
		        if (count === 0) {
		            return 0;
		        }
		        var segmentIndex = t.segmentIndex;
		        if (segmentIndex < 0) {
		            return 0;
		        }
		        var tValue = (0, util_1.clamp)(t.value, 0, 1);
		        if (segmentIndex >= count) {
		            segmentIndex = count - 1;
		            tValue = 1;
		        }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var length = 0;
		        for (var i = 0; i < segmentIndex; i += 1) {
		            var segment_1 = this.segments[i];
		            var subdivisions_1 = segmentSubdivisions[i];
		            length += segment_1.length({ precision: precision, subdivisions: subdivisions_1 });
		        }
		        var segment = this.segments[segmentIndex];
		        var subdivisions = segmentSubdivisions[segmentIndex];
		        length += segment.lengthAtT(tValue, { precision: precision, subdivisions: subdivisions });
		        return length;
		    };
		    Path.prototype.tangentAt = function (ratio, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        var rate = (0, util_1.clamp)(ratio, 0, 1);
		        var opts = this.getOptions(options);
		        var len = this.length(opts);
		        var length = len * rate;
		        return this.tangentAtLength(length, opts);
		    };
		    Path.prototype.tangentAtLength = function (length, options) {
		        if (options === void 0) { options = {}; }
		        if (this.segments.length === 0) {
		            return null;
		        }
		        var fromStart = true;
		        if (length < 0) {
		            fromStart = false;
		            length = -length; // eslint-disable-line
		        }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var lastValidSegment;
		        var memo = 0;
		        for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
		            var index = fromStart ? i : ii - 1 - i;
		            var segment = this.segments[index];
		            var subdivisions = segmentSubdivisions[index];
		            var len = segment.length({ precision: precision, subdivisions: subdivisions });
		            if (segment.isDifferentiable()) {
		                if (length <= memo + len) {
		                    return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {
		                        precision: precision,
		                        subdivisions: subdivisions,
		                    });
		                }
		                lastValidSegment = segment;
		            }
		            memo += len;
		        }
		        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment
		        if (lastValidSegment) {
		            var t = fromStart ? 1 : 0;
		            return lastValidSegment.tangentAtT(t);
		        }
		        // if no valid segment, return null
		        return null;
		    };
		    Path.prototype.tangentAtT = function (t) {
		        var count = this.segments.length;
		        if (count === 0) {
		            return null;
		        }
		        var segmentIndex = t.segmentIndex;
		        if (segmentIndex < 0) {
		            return this.segments[0].tangentAtT(0);
		        }
		        if (segmentIndex >= count) {
		            return this.segments[count - 1].tangentAtT(1);
		        }
		        var tValue = (0, util_1.clamp)(t.value, 0, 1);
		        return this.segments[segmentIndex].tangentAtT(tValue);
		    };
		    Path.prototype.getPrecision = function (options) {
		        if (options === void 0) { options = {}; }
		        return options.precision == null ? this.PRECISION : options.precision;
		    };
		    Path.prototype.getSubdivisions = function (options) {
		        if (options === void 0) { options = {}; }
		        if (options.segmentSubdivisions == null) {
		            var precision = this.getPrecision(options);
		            return this.getSegmentSubdivisions({ precision: precision });
		        }
		        return options.segmentSubdivisions;
		    };
		    Path.prototype.getOptions = function (options) {
		        if (options === void 0) { options = {}; }
		        var precision = this.getPrecision(options);
		        var segmentSubdivisions = this.getSubdivisions(options);
		        return { precision: precision, segmentSubdivisions: segmentSubdivisions };
		    };
		    Path.prototype.toPoints = function (options) {
		        if (options === void 0) { options = {}; }
		        var segments = this.segments;
		        var count = segments.length;
		        if (count === 0) {
		            return null;
		        }
		        var segmentSubdivisions = this.getSubdivisions(options);
		        var points = [];
		        var partialPoints = [];
		        for (var i = 0; i < count; i += 1) {
		            var segment = segments[i];
		            if (segment.isVisible) {
		                var divisions = segmentSubdivisions[i];
		                if (divisions.length > 0) {
		                    // eslint-disable-next-line no-loop-func
		                    divisions.forEach(function (c) { return partialPoints.push(c.start); });
		                }
		                else {
		                    partialPoints.push(segment.start);
		                }
		            }
		            else if (partialPoints.length > 0) {
		                partialPoints.push(segments[i - 1].end);
		                points.push(partialPoints);
		                partialPoints = [];
		            }
		        }
		        if (partialPoints.length > 0) {
		            partialPoints.push(this.end);
		            points.push(partialPoints);
		        }
		        return points;
		    };
		    Path.prototype.toPolylines = function (options) {
		        if (options === void 0) { options = {}; }
		        var points = this.toPoints(options);
		        if (!points) {
		            return null;
		        }
		        return points.map(function (arr) { return new polyline_1.Polyline(arr); });
		    };
		    Path.prototype.scale = function (sx, sy, origin) {
		        this.segments.forEach(function (s) { return s.scale(sx, sy, origin); });
		        return this;
		    };
		    Path.prototype.rotate = function (angle, origin) {
		        this.segments.forEach(function (segment) { return segment.rotate(angle, origin); });
		        return this;
		    };
		    Path.prototype.translate = function (tx, ty) {
		        if (typeof tx === 'number') {
		            this.segments.forEach(function (s) { return s.translate(tx, ty); });
		        }
		        else {
		            this.segments.forEach(function (s) { return s.translate(tx); });
		        }
		        return this;
		    };
		    Path.prototype.clone = function () {
		        var path = new Path();
		        this.segments.forEach(function (s) { return path.appendSegment(s.clone()); });
		        return path;
		    };
		    Path.prototype.equals = function (p) {
		        if (p == null) {
		            return false;
		        }
		        var segments = this.segments;
		        var otherSegments = p.segments;
		        var count = segments.length;
		        if (otherSegments.length !== count) {
		            return false;
		        }
		        for (var i = 0; i < count; i += 1) {
		            var a = segments[i];
		            var b = otherSegments[i];
		            if (a.type !== b.type || !a.equals(b)) {
		                return false;
		            }
		        }
		        return true;
		    };
		    Path.prototype.toJSON = function () {
		        return this.segments.map(function (s) { return s.toJSON(); });
		    };
		    Path.prototype.serialize = function () {
		        if (!this.isValid()) {
		            throw new Error('Invalid path segments.');
		        }
		        return this.segments.map(function (s) { return s.serialize(); }).join(' ');
		    };
		    Path.prototype.toString = function () {
		        return this.serialize();
		    };
		    return Path;
		}(geometry_1.Geometry));
		exports.Path = Path;
		(function (Path) {
		    Path.toStringTag = "X6.Geometry." + Path.name;
		    function isPath(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Path) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var path = instance;
		        if ((tag == null || tag === Path.toStringTag) &&
		            Array.isArray(path.segments) &&
		            typeof path.moveTo === 'function' &&
		            typeof path.lineTo === 'function' &&
		            typeof path.curveTo === 'function') {
		            return true;
		        }
		        return false;
		    }
		    Path.isPath = isPath;
		})(Path = exports.Path || (exports.Path = {}));
		exports.Path = Path;
		(function (Path) {
		    function parse(pathData) {
		        if (!pathData) {
		            return new Path();
		        }
		        var path = new Path();
		        var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
		        var commands = Path.normalize(pathData).match(commandRe);
		        if (commands != null) {
		            for (var i = 0, ii = commands.length; i < ii; i += 1) {
		                var command = commands[i];
		                var argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
		                // args = [type, coordinate1, coordinate2...]
		                var args = command.match(argRe);
		                if (args != null) {
		                    var type = args[0];
		                    var coords = args.slice(1).map(function (a) { return +a; });
		                    var segment = createSegment.call.apply(createSegment, __spreadArray([null, type], coords, false));
		                    path.appendSegment(segment);
		                }
		            }
		        }
		        return path;
		    }
		    Path.parse = parse;
		    function createSegment(type) {
		        var _a, _b, _c;
		        var args = [];
		        for (var _i = 1; _i < arguments.length; _i++) {
		            args[_i - 1] = arguments[_i];
		        }
		        if (type === 'M') {
		            return (_a = moveto_1.MoveTo.create).call.apply(_a, __spreadArray([null], args, false));
		        }
		        if (type === 'L') {
		            return (_b = lineto_1.LineTo.create).call.apply(_b, __spreadArray([null], args, false));
		        }
		        if (type === 'C') {
		            return (_c = curveto_1.CurveTo.create).call.apply(_c, __spreadArray([null], args, false));
		        }
		        if (type === 'z' || type === 'Z') {
		            return close_1.Close.create();
		        }
		        throw new Error("Invalid path segment type \"" + type + "\"");
		    }
		    Path.createSegment = createSegment;
		})(Path = exports.Path || (exports.Path = {}));
		exports.Path = Path;
		(function (Path) {
		    Path.normalize = normalize_1.normalizePathData;
		    Path.isValid = Util.isValid;
		    Path.drawArc = Util.drawArc;
		    Path.drawPoints = Util.drawPoints;
		    Path.arcToCurves = Util.arcToCurves;
		})(Path = exports.Path || (exports.Path = {}));
		exports.Path = Path;
		
	} (path$1));
	return path$1;
}

var hasRequiredPath$1;

function requirePath$1 () {
	if (hasRequiredPath$1) return path$2;
	hasRequiredPath$1 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (path$2 && path$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (path$2 && path$2.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requirePath$2(), exports);
		__exportStar(requireSegment(), exports);
		
	} (path$2));
	return path$2;
}

var hasRequiredGeometry;

function requireGeometry () {
	if (hasRequiredGeometry) return geometry$1;
	hasRequiredGeometry = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (geometry$1 && geometry$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (geometry$1 && geometry$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireAngle(), exports);
		__exportStar(requirePoint(), exports);
		__exportStar(requireLine(), exports);
		__exportStar(requireEllipse(), exports);
		__exportStar(requireRectangle(), exports);
		__exportStar(requirePath$1(), exports);
		__exportStar(requireCurve(), exports);
		__exportStar(requirePolyline(), exports);
		
	} (geometry$1));
	return geometry$1;
}

var hasRequiredVector$1;

function requireVector$1 () {
	if (hasRequiredVector$1) return vector$1;
	hasRequiredVector$1 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (vector$1 && vector$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (vector$1 && vector$1.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (vector$1 && vector$1.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Vector = void 0;
		var geometry_1 = requireGeometry();
		var Dom = __importStar(requireCore());
		var Vector = /** @class */ (function () {
		    function Vector(elem, attrs, children) {
		        if (!elem) {
		            throw new TypeError('Invalid element to create vector');
		        }
		        var node;
		        if (Vector.isVector(elem)) {
		            node = elem.node;
		        }
		        else if (typeof elem === 'string') {
		            if (elem.toLowerCase() === 'svg') {
		                node = Dom.createSvgDocument();
		            }
		            else if (elem[0] === '<') {
		                var doc = Dom.createSvgDocument(elem);
		                // only import the first child
		                node = document.importNode(doc.firstChild, true);
		            }
		            else {
		                node = document.createElementNS(Dom.ns.svg, elem);
		            }
		        }
		        else {
		            node = elem;
		        }
		        this.node = node;
		        if (attrs) {
		            this.setAttributes(attrs);
		        }
		        if (children) {
		            this.append(children);
		        }
		    }
		    Object.defineProperty(Vector.prototype, Symbol.toStringTag, {
		        get: function () {
		            return Vector.toStringTag;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Vector.prototype, "type", {
		        get: function () {
		            return this.node.nodeName;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Object.defineProperty(Vector.prototype, "id", {
		        get: function () {
		            return this.node.id;
		        },
		        set: function (id) {
		            this.node.id = id;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    Vector.prototype.transform = function (matrix, options) {
		        if (matrix == null) {
		            return Dom.transform(this.node);
		        }
		        Dom.transform(this.node, matrix, options);
		        return this;
		    };
		    Vector.prototype.translate = function (tx, ty, options) {
		        if (ty === void 0) { ty = 0; }
		        if (options === void 0) { options = {}; }
		        if (tx == null) {
		            return Dom.translate(this.node);
		        }
		        Dom.translate(this.node, tx, ty, options);
		        return this;
		    };
		    Vector.prototype.rotate = function (angle, cx, cy, options) {
		        if (options === void 0) { options = {}; }
		        if (angle == null) {
		            return Dom.rotate(this.node);
		        }
		        Dom.rotate(this.node, angle, cx, cy, options);
		        return this;
		    };
		    Vector.prototype.scale = function (sx, sy) {
		        if (sx == null) {
		            return Dom.scale(this.node);
		        }
		        Dom.scale(this.node, sx, sy);
		        return this;
		    };
		    /**
		     * Returns an SVGMatrix that specifies the transformation necessary
		     * to convert this coordinate system into `target` coordinate system.
		     */
		    Vector.prototype.getTransformToElement = function (target) {
		        var ref = Vector.toNode(target);
		        return Dom.getTransformToElement(this.node, ref);
		    };
		    Vector.prototype.removeAttribute = function (name) {
		        Dom.removeAttribute(this.node, name);
		        return this;
		    };
		    Vector.prototype.getAttribute = function (name) {
		        return Dom.getAttribute(this.node, name);
		    };
		    Vector.prototype.setAttribute = function (name, value) {
		        Dom.setAttribute(this.node, name, value);
		        return this;
		    };
		    Vector.prototype.setAttributes = function (attrs) {
		        Dom.setAttributes(this.node, attrs);
		        return this;
		    };
		    Vector.prototype.attr = function (name, value) {
		        if (name == null) {
		            return Dom.attr(this.node);
		        }
		        if (typeof name === 'string' && value === undefined) {
		            return Dom.attr(this.node, name);
		        }
		        if (typeof name === 'object') {
		            Dom.attr(this.node, name);
		        }
		        else {
		            Dom.attr(this.node, name, value);
		        }
		        return this;
		    };
		    Vector.prototype.svg = function () {
		        return this.node instanceof SVGSVGElement
		            ? this
		            : Vector.create(this.node.ownerSVGElement);
		    };
		    Vector.prototype.defs = function () {
		        var context = this.svg() || this;
		        var defsNode = context.node.getElementsByTagName('defs')[0];
		        if (defsNode) {
		            return Vector.create(defsNode);
		        }
		        return Vector.create('defs').appendTo(context);
		    };
		    Vector.prototype.text = function (content, options) {
		        if (options === void 0) { options = {}; }
		        Dom.text(this.node, content, options);
		        return this;
		    };
		    Vector.prototype.tagName = function () {
		        return Dom.tagName(this.node);
		    };
		    Vector.prototype.clone = function () {
		        return Vector.create(this.node.cloneNode(true));
		    };
		    Vector.prototype.remove = function () {
		        Dom.remove(this.node);
		        return this;
		    };
		    Vector.prototype.empty = function () {
		        Dom.empty(this.node);
		        return this;
		    };
		    Vector.prototype.append = function (elems) {
		        Dom.append(this.node, Vector.toNodes(elems));
		        return this;
		    };
		    Vector.prototype.appendTo = function (target) {
		        Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);
		        return this;
		    };
		    Vector.prototype.prepend = function (elems) {
		        Dom.prepend(this.node, Vector.toNodes(elems));
		        return this;
		    };
		    Vector.prototype.before = function (elems) {
		        Dom.before(this.node, Vector.toNodes(elems));
		        return this;
		    };
		    Vector.prototype.replace = function (elem) {
		        if (this.node.parentNode) {
		            this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);
		        }
		        return Vector.create(elem);
		    };
		    Vector.prototype.first = function () {
		        return this.node.firstChild
		            ? Vector.create(this.node.firstChild)
		            : null;
		    };
		    Vector.prototype.last = function () {
		        return this.node.lastChild
		            ? Vector.create(this.node.lastChild)
		            : null;
		    };
		    Vector.prototype.get = function (index) {
		        var child = this.node.childNodes[index];
		        return child ? Vector.create(child) : null;
		    };
		    Vector.prototype.indexOf = function (elem) {
		        var children = Array.prototype.slice.call(this.node.childNodes);
		        return children.indexOf(Vector.toNode(elem));
		    };
		    Vector.prototype.find = function (selector) {
		        var vels = [];
		        var nodes = Dom.find(this.node, selector);
		        if (nodes) {
		            for (var i = 0, ii = nodes.length; i < ii; i += 1) {
		                vels.push(Vector.create(nodes[i]));
		            }
		        }
		        return vels;
		    };
		    Vector.prototype.findOne = function (selector) {
		        var found = Dom.findOne(this.node, selector);
		        return found ? Vector.create(found) : null;
		    };
		    Vector.prototype.findParentByClass = function (className, terminator) {
		        var node = Dom.findParentByClass(this.node, className, terminator);
		        return node ? Vector.create(node) : null;
		    };
		    Vector.prototype.matches = function (selector) {
		        var node = this.node;
		        var matches = this.node.matches;
		        var matcher = node.matches ||
		            node.matchesSelector ||
		            node.msMatchesSelector ||
		            node.mozMatchesSelector ||
		            node.webkitMatchesSelector ||
		            node.oMatchesSelector ||
		            null;
		        return matcher && matcher.call(node, selector);
		    };
		    Vector.prototype.contains = function (child) {
		        return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);
		    };
		    Vector.prototype.wrap = function (node) {
		        var vel = Vector.create(node);
		        var parentNode = this.node.parentNode;
		        if (parentNode != null) {
		            parentNode.insertBefore(vel.node, this.node);
		        }
		        return vel.append(this);
		    };
		    Vector.prototype.parent = function (type) {
		        var parent = this; // eslint-disable-line @typescript-eslint/no-this-alias
		        // check for parent
		        if (parent.node.parentNode == null) {
		            return null;
		        }
		        // get parent element
		        parent = Vector.create(parent.node.parentNode);
		        if (type == null) {
		            return parent;
		        }
		        // loop trough ancestors if type is given
		        do {
		            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {
		                return parent;
		            }
		        } while ((parent = Vector.create(parent.node.parentNode)));
		        return parent;
		    };
		    Vector.prototype.children = function () {
		        var children = this.node.childNodes;
		        var vels = [];
		        for (var i = 0; i < children.length; i += 1) {
		            var currentChild = children[i];
		            if (currentChild.nodeType === 1) {
		                vels.push(Vector.create(children[i]));
		            }
		        }
		        return vels;
		    };
		    Vector.prototype.eachChild = function (fn, deep) {
		        var children = this.children();
		        for (var i = 0, l = children.length; i < l; i += 1) {
		            fn.call(children[i], children[i], i, children);
		            if (deep) {
		                children[i].eachChild(fn, deep);
		            }
		        }
		        return this;
		    };
		    Vector.prototype.index = function () {
		        return Dom.index(this.node);
		    };
		    Vector.prototype.hasClass = function (className) {
		        return Dom.hasClass(this.node, className);
		    };
		    Vector.prototype.addClass = function (className) {
		        Dom.addClass(this.node, className);
		        return this;
		    };
		    Vector.prototype.removeClass = function (className) {
		        Dom.removeClass(this.node, className);
		        return this;
		    };
		    Vector.prototype.toggleClass = function (className, stateVal) {
		        Dom.toggleClass(this.node, className, stateVal);
		        return this;
		    };
		    Vector.prototype.toLocalPoint = function (x, y) {
		        return Dom.toLocalPoint(this.node, x, y);
		    };
		    Vector.prototype.toGeometryShape = function () {
		        return Dom.toGeometryShape(this.node);
		    };
		    Vector.prototype.translateCenterToPoint = function (p) {
		        var bbox = this.getBBox({ target: this.svg() });
		        var center = bbox.getCenter();
		        this.translate(p.x - center.x, p.y - center.y);
		        return this;
		    };
		    Vector.prototype.translateAndAutoOrient = function (position, reference, target) {
		        Dom.translateAndAutoOrient(this.node, position, reference, target);
		        return this;
		    };
		    Vector.prototype.animate = function (options) {
		        return Dom.animate(this.node, options);
		    };
		    Vector.prototype.animateTransform = function (options) {
		        return Dom.animateTransform(this.node, options);
		    };
		    Vector.prototype.animateAlongPath = function (options, path) {
		        return Dom.animateAlongPath(this.node, options, path);
		    };
		    /**
		     * Normalize this element's d attribute. SVGPathElements without
		     * a path data attribute obtain a value of 'M 0 0'.
		     */
		    Vector.prototype.normalizePath = function () {
		        var tagName = this.tagName();
		        if (tagName === 'path') {
		            this.attr('d', geometry_1.Path.normalize(this.attr('d')));
		        }
		        return this;
		    };
		    /**
		     * Returns the bounding box of the element after transformations are applied.
		     * If `withoutTransformations` is `true`, transformations of the element
		     * will not be considered when computing the bounding box. If `target` is
		     * specified, bounding box will be computed relatively to the target element.
		     */
		    Vector.prototype.bbox = function (withoutTransformations, target) {
		        return Dom.bbox(this.node, withoutTransformations, target);
		    };
		    Vector.prototype.getBBox = function (options) {
		        if (options === void 0) { options = {}; }
		        return Dom.getBBox(this.node, {
		            recursive: options.recursive,
		            target: options.target ? Vector.toNode(options.target) : null,
		        });
		    };
		    /**
		     * Samples the underlying SVG element (it currently works only on
		     * paths - where it is most useful anyway). Returns an array of objects
		     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
		     * objects represent a point on the path. This basically creates a discrete
		     * representation of the path (which is possible a curve). The sampling
		     * interval defines the accuracy of the sampling. In other words, we travel
		     * from the beginning of the path to the end by interval distance (on the
		     * path, not between the resulting points) and collect the discrete points
		     * on the path. This is very useful in many situations. For example, SVG
		     * does not provide a built-in mechanism to find intersections between two
		     * paths. Using sampling, we can just generate bunch of points for each of
		     * the path and find the closest ones from each set.
		     */
		    Vector.prototype.sample = function (interval) {
		        if (interval === void 0) { interval = 1; }
		        if (this.node instanceof SVGPathElement) {
		            return Dom.sample(this.node, interval);
		        }
		        return [];
		    };
		    Vector.prototype.toPath = function () {
		        return Vector.create(Dom.toPath(this.node));
		    };
		    Vector.prototype.toPathData = function () {
		        return Dom.toPathData(this.node);
		    };
		    return Vector;
		}());
		exports.Vector = Vector;
		(function (Vector) {
		    Vector.toStringTag = "X6." + Vector.name;
		    function isVector(instance) {
		        if (instance == null) {
		            return false;
		        }
		        if (instance instanceof Vector) {
		            return true;
		        }
		        var tag = instance[Symbol.toStringTag];
		        var vector = instance;
		        if ((tag == null || tag === Vector.toStringTag) &&
		            vector.node instanceof SVGElement &&
		            typeof vector.animate === 'function' &&
		            typeof vector.sample === 'function' &&
		            typeof vector.normalizePath === 'function' &&
		            typeof vector.toPath === 'function') {
		            return true;
		        }
		        return false;
		    }
		    Vector.isVector = isVector;
		    function create(elem, attrs, children) {
		        return new Vector(elem, attrs, children);
		    }
		    Vector.create = create;
		    function createVectors(markup) {
		        if (markup[0] === '<') {
		            var svgDoc = Dom.createSvgDocument(markup);
		            var vels = [];
		            for (var i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
		                var childNode = svgDoc.childNodes[i];
		                vels.push(create(document.importNode(childNode, true)));
		            }
		            return vels;
		        }
		        return [create(markup)];
		    }
		    Vector.createVectors = createVectors;
		    function toNode(elem) {
		        if (isVector(elem)) {
		            return elem.node;
		        }
		        return elem;
		    }
		    Vector.toNode = toNode;
		    function toNodes(elems) {
		        if (Array.isArray(elems)) {
		            return elems.map(function (elem) { return toNode(elem); });
		        }
		        return [toNode(elems)];
		    }
		    Vector.toNodes = toNodes;
		})(Vector = exports.Vector || (exports.Vector = {}));
		exports.Vector = Vector;
		
	} (vector$1));
	return vector$1;
}

var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text;
	hasRequiredText = 1;
	"use strict";
	/* eslint-disable no-control-regex */
	var __spreadArray = (text && text.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(text, "__esModule", { value: true });
	text.breakText = text.text = void 0;
	var number_1 = requireNumber();
	var text_1 = requireText$1();
	var attr_1 = requireAttr();
	var vector_1 = requireVector$1();
	var elem_1 = requireElem();
	var platform_1 = requirePlatform();
	function createTextPathNode(attrs, elem) {
	    var vel = vector_1.Vector.create(elem);
	    var textPath = vector_1.Vector.create('textPath');
	    var d = attrs.d;
	    if (d && attrs['xlink:href'] === undefined) {
	        var path = vector_1.Vector.create('path').attr('d', d).appendTo(vel.defs());
	        textPath.attr('xlink:href', "#" + path.id);
	    }
	    if (typeof attrs === 'object') {
	        textPath.attr(attrs);
	    }
	    return textPath.node;
	}
	function annotateTextLine(lineNode, lineAnnotations, options) {
	    var eol = options.eol;
	    var baseSize = options.baseSize;
	    var lineHeight = options.lineHeight;
	    var maxFontSize = 0;
	    var tspanNode;
	    var fontMetrics = {};
	    var lastJ = lineAnnotations.length - 1;
	    for (var j = 0; j <= lastJ; j += 1) {
	        var annotation = lineAnnotations[j];
	        var fontSize = null;
	        if (typeof annotation === 'object') {
	            var annotationAttrs = annotation.attrs;
	            var vTSpan = vector_1.Vector.create('tspan', annotationAttrs);
	            tspanNode = vTSpan.node;
	            var t = annotation.t;
	            if (eol && j === lastJ) {
	                t += eol;
	            }
	            tspanNode.textContent = t;
	            // Per annotation className
	            var annotationClass = annotationAttrs.class;
	            if (annotationClass) {
	                vTSpan.addClass(annotationClass);
	            }
	            // set the list of indices of all the applied annotations
	            // in the `annotations` attribute. This list is a comma
	            // separated list of indices.
	            if (options.includeAnnotationIndices) {
	                vTSpan.attr('annotations', annotation.annotations.join(','));
	            }
	            // Check for max font size
	            fontSize = parseFloat(annotationAttrs['font-size']);
	            if (fontSize === undefined)
	                fontSize = baseSize;
	            if (fontSize && fontSize > maxFontSize)
	                maxFontSize = fontSize;
	        }
	        else {
	            if (eol && j === lastJ) {
	                annotation += eol;
	            }
	            tspanNode = document.createTextNode(annotation || ' ');
	            if (baseSize && baseSize > maxFontSize) {
	                maxFontSize = baseSize;
	            }
	        }
	        lineNode.appendChild(tspanNode);
	    }
	    if (maxFontSize) {
	        fontMetrics.maxFontSize = maxFontSize;
	    }
	    if (lineHeight) {
	        fontMetrics.lineHeight = lineHeight;
	    }
	    else if (maxFontSize) {
	        fontMetrics.lineHeight = maxFontSize * 1.2;
	    }
	    return fontMetrics;
	}
	var emRegex = /em$/;
	function emToPx(em, fontSize) {
	    var numerical = parseFloat(em);
	    if (emRegex.test(em)) {
	        return numerical * fontSize;
	    }
	    return numerical;
	}
	function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
	    if (!Array.isArray(linesMetrics)) {
	        return 0;
	    }
	    var n = linesMetrics.length;
	    if (!n)
	        return 0;
	    var lineMetrics = linesMetrics[0];
	    var flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
	    var rLineHeights = 0;
	    var lineHeightPx = emToPx(lineHeight, baseSizePx);
	    for (var i = 1; i < n; i += 1) {
	        lineMetrics = linesMetrics[i];
	        var iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
	        rLineHeights += iLineHeight;
	    }
	    var llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
	    var dy;
	    switch (alignment) {
	        case 'middle':
	            dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
	            break;
	        case 'bottom':
	            dy = -(0.25 * llMaxFont) - rLineHeights;
	            break;
	        default:
	        case 'top':
	            dy = 0.8 * flMaxFont;
	            break;
	    }
	    return dy;
	}
	function text$1(elem, content, options) {
	    if (options === void 0) { options = {}; }
	    content = text_1.Text.sanitize(content); // eslint-disable-line
	    var eol = options.eol;
	    var textPath = options.textPath;
	    var verticalAnchor = options.textVerticalAnchor;
	    var namedVerticalAnchor = verticalAnchor === 'middle' ||
	        verticalAnchor === 'bottom' ||
	        verticalAnchor === 'top';
	    // Horizontal shift applied to all the lines but the first.
	    var x = options.x;
	    if (x === undefined) {
	        x = elem.getAttribute('x') || 0;
	    }
	    // Annotations
	    var iai = options.includeAnnotationIndices;
	    var annotations = options.annotations;
	    if (annotations && !Array.isArray(annotations)) {
	        annotations = [annotations];
	    }
	    // Shift all the <tspan> but first by one line (`1em`)
	    var defaultLineHeight = options.lineHeight;
	    var autoLineHeight = defaultLineHeight === 'auto';
	    var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
	    (0, elem_1.empty)(elem);
	    (0, attr_1.attr)(elem, {
	        // Preserve spaces, do not consecutive spaces to get collapsed to one.
	        'xml:space': 'preserve',
	        // An empty text gets rendered into the DOM in webkit-based browsers.
	        // In order to unify this behaviour across all browsers
	        // we rather hide the text element when it's empty.
	        display: content || options.displayEmpty ? null : 'none',
	    });
	    // Set default font-size if none
	    var strFontSize = (0, attr_1.attr)(elem, 'font-size');
	    var fontSize = parseFloat(strFontSize);
	    if (!fontSize) {
	        fontSize = 16;
	        if ((namedVerticalAnchor || annotations) && !strFontSize) {
	            (0, attr_1.attr)(elem, 'font-size', "" + fontSize);
	        }
	    }
	    var containerNode;
	    if (textPath) {
	        // Now all the `<tspan>`s will be inside the `<textPath>`.
	        if (typeof textPath === 'string') {
	            textPath = { d: textPath };
	        }
	        containerNode = createTextPathNode(textPath, elem);
	    }
	    else {
	        containerNode = document.createDocumentFragment();
	    }
	    var dy;
	    var offset = 0;
	    var annotatedY;
	    var lines = content.split('\n');
	    var linesMetrics = [];
	    var lastI = lines.length - 1;
	    for (var i = 0; i <= lastI; i += 1) {
	        dy = lineHeight;
	        var lineClassName = 'v-line';
	        var lineNode = (0, elem_1.createSvgElement)('tspan');
	        var lineMetrics = void 0;
	        var line = lines[i];
	        if (line) {
	            if (annotations) {
	                // Find the *compacted* annotations for this line.
	                var lineAnnotations = text_1.Text.annotate(line, annotations, {
	                    offset: -offset,
	                    includeAnnotationIndices: iai,
	                });
	                lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
	                    eol: i !== lastI && eol,
	                    baseSize: fontSize,
	                    lineHeight: autoLineHeight ? null : lineHeight,
	                    includeAnnotationIndices: iai,
	                });
	                // Get the line height based on the biggest font size
	                // in the annotations for this line.
	                var iLineHeight = lineMetrics.lineHeight;
	                if (iLineHeight && autoLineHeight && i !== 0) {
	                    dy = iLineHeight;
	                }
	                if (i === 0) {
	                    annotatedY = lineMetrics.maxFontSize * 0.8;
	                }
	            }
	            else {
	                if (eol && i !== lastI) {
	                    line += eol;
	                }
	                lineNode.textContent = line;
	            }
	        }
	        else {
	            // Make sure the textContent is never empty. If it is, add a dummy
	            // character and make it invisible, making the following lines correctly
	            // relatively positioned. `dy=1em` won't work with empty lines otherwise.
	            lineNode.textContent = '-';
	            lineClassName += ' v-empty-line';
	            var lineNodeStyle = lineNode.style;
	            lineNodeStyle.fillOpacity = 0;
	            lineNodeStyle.strokeOpacity = 0;
	            if (annotations) {
	                lineMetrics = {};
	            }
	        }
	        if (lineMetrics) {
	            linesMetrics.push(lineMetrics);
	        }
	        if (i > 0) {
	            lineNode.setAttribute('dy', dy);
	        }
	        // Firefox requires 'x' to be set on the first line
	        if (i > 0 || textPath) {
	            lineNode.setAttribute('x', x);
	        }
	        lineNode.className.baseVal = lineClassName;
	        containerNode.appendChild(lineNode);
	        offset += line.length + 1; // + 1 = newline character.
	    }
	    // Y Alignment calculation
	    if (namedVerticalAnchor) {
	        if (annotations) {
	            dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
	        }
	        else if (verticalAnchor === 'top') {
	            // A shortcut for top alignment. It does not depend on font-size nor line-height
	            dy = '0.8em';
	        }
	        else {
	            var rh = void 0; // remaining height
	            if (lastI > 0) {
	                rh = parseFloat(lineHeight) || 1;
	                rh *= lastI;
	                if (!emRegex.test(lineHeight))
	                    rh /= fontSize;
	            }
	            else {
	                // Single-line text
	                rh = 0;
	            }
	            switch (verticalAnchor) {
	                case 'middle':
	                    dy = 0.3 - rh / 2 + "em";
	                    break;
	                case 'bottom':
	                    dy = -rh - 0.3 + "em";
	                    break;
	                default:
	                    break;
	            }
	        }
	    }
	    else if (verticalAnchor === 0) {
	        dy = '0em';
	    }
	    else if (verticalAnchor) {
	        dy = verticalAnchor;
	    }
	    else {
	        // No vertical anchor is defined
	        dy = 0;
	        // Backwards compatibility - we change the `y` attribute instead of `dy`.
	        if (elem.getAttribute('y') == null) {
	            elem.setAttribute('y', "" + (annotatedY || '0.8em'));
	        }
	    }
	    var firstLine = containerNode.firstChild;
	    firstLine.setAttribute('dy', dy);
	    elem.appendChild(containerNode);
	}
	text.text = text$1;
	function splitText(text, separator, eol, hyphen) {
	    var words = [];
	    var separators = [];
	    if (separator != null) {
	        var parts = text.split(separator);
	        words.push.apply(words, parts);
	        if (typeof separator === 'string') {
	            for (var i = 0, l = parts.length - 1; i < l; i += 1) {
	                separators.push(separator);
	            }
	        }
	        else {
	            var seps = text.match(new RegExp(separator, 'g'));
	            for (var i = 0, l = parts.length - 1; i < l; i += 1) {
	                separators.push(seps ? seps[i] : '');
	            }
	        }
	    }
	    else {
	        var word = '';
	        for (var i = 0, l = text.length; i < l; i += 1) {
	            var char = text[i];
	            if (char === ' ') {
	                words.push(word);
	                separators.push(' ');
	                word = '';
	            }
	            else if (char.match(/[^\x00-\xff]/)) {
	                // split double byte character
	                if (word.length) {
	                    words.push(word);
	                    separators.push('');
	                }
	                words.push(char);
	                separators.push('');
	                word = '';
	            }
	            else {
	                word += char;
	            }
	        }
	        if (word.length) {
	            words.push(word);
	        }
	    }
	    // end-of-line
	    for (var i = 0; i < words.length; i += 1) {
	        var word = words[i];
	        if (word.indexOf(eol) >= 0 && word.length > 1) {
	            var parts = word.split(eol);
	            for (var j = 0, k = parts.length - 1; j < k; j += 1) {
	                parts.splice(2 * j + 1, 0, eol);
	            }
	            var valids = parts.filter(function (part) { return part !== ''; });
	            words.splice.apply(words, __spreadArray([i, 1], valids, false));
	            var seps = valids.map(function () { return ''; });
	            seps.pop();
	            separators.splice.apply(separators, __spreadArray([i, 0], seps, false));
	        }
	    }
	    // hyphen
	    for (var i = 0; i < words.length; i += 1) {
	        var word = words[i];
	        var index = word.search(hyphen);
	        if (index > 0 && index < word.length - 1) {
	            words.splice(i, 1, word.substring(0, index + 1), word.substring(index + 1));
	            separators.splice(i, 0, '');
	        }
	    }
	    return { words: words, separators: separators };
	}
	function breakText(text, size, styles, options) {
	    if (styles === void 0) { styles = {}; }
	    if (options === void 0) { options = {}; }
	    var width = size.width;
	    var height = size.height;
	    var svgDocument = options.svgDocument || (0, elem_1.createSvgElement)('svg');
	    var telem = (0, elem_1.createSvgElement)('text');
	    var tspan = (0, elem_1.createSvgElement)('tspan');
	    var tnode = document.createTextNode('');
	    (0, attr_1.attr)(telem, styles);
	    telem.appendChild(tspan);
	    // Prevent flickering
	    telem.style.opacity = '0';
	    // Prevent FF from throwing an uncaught exception when `getBBox()`
	    // called on element that is not in the render tree (is not measurable).
	    // <tspan>.getComputedTextLength() returns always 0 in this case.
	    // Note that the `textElement` resp. `textSpan` can become hidden
	    // when it's appended to the DOM and a `display: none` CSS stylesheet
	    // rule gets applied.
	    telem.style.display = 'block';
	    tspan.style.display = 'block';
	    tspan.appendChild(tnode);
	    svgDocument.appendChild(telem);
	    var shouldAppend = svgDocument.parentNode == null;
	    if (shouldAppend) {
	        document.body.appendChild(svgDocument);
	    }
	    var eol = options.eol || '\n';
	    var separator = options.separator || ' ';
	    var hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\w\d]/;
	    var breakWord = options.breakWord !== false;
	    var full = [];
	    var lineSeprators = {};
	    var lines = [];
	    var partIndex;
	    // let hyphenIndex
	    var lineHeight;
	    var currentSeparator;
	    var _a = splitText(text, options.separator, eol, hyphen), words = _a.words, separators = _a.separators;
	    for (var wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {
	        var word = words[wordIndex];
	        // empty word
	        if (!word) {
	            continue;
	        }
	        // end of line
	        if (word === eol) {
	            full[lineIndex] = true;
	            // start a new line
	            lineIndex += 1;
	            lines[lineIndex] = '';
	            continue;
	        }
	        if (lines[lineIndex] != null) {
	            currentSeparator = separators[wordIndex - 1] || '';
	            tnode.data = "" + lines[lineIndex] + currentSeparator + word;
	        }
	        else {
	            tnode.data = word;
	        }
	        if (tspan.getComputedTextLength() <= width) {
	            // update line
	            lines[lineIndex] = tnode.data;
	            lineSeprators[lineIndex] = separators[wordIndex];
	            // when is partitioning, put rest of the word onto next line
	            if (partIndex) {
	                full[lineIndex] = true;
	                lineIndex += 1;
	                partIndex = 0;
	            }
	        }
	        else {
	            if (breakWord) {
	                // word is too long to put in one line or is partitioning
	                if (!lines[lineIndex] || partIndex) {
	                    var isPartition = !!partIndex;
	                    var isCharacter = word.length === 1;
	                    partIndex = word.length - 1;
	                    if (isPartition || isCharacter) {
	                        // word has only one character.
	                        if (isCharacter) {
	                            if (!lines[lineIndex]) {
	                                // can't fit this text within our rect
	                                lines = [];
	                                break;
	                            }
	                            // partitioning didn't help on the non-empty line
	                            // try again, but this time start with a new line
	                            // cancel partitions created
	                            words.splice(wordIndex, 2, word + words[wordIndex + 1]);
	                            separators.splice(wordIndex + 1, 1);
	                            full[lineIndex] = true;
	                            lineIndex += 1;
	                            wordCount -= 1;
	                            wordIndex -= 1;
	                            continue;
	                        }
	                        // update the partitioning words
	                        words[wordIndex] = word.substring(0, partIndex);
	                        words[wordIndex + 1] =
	                            word.substring(partIndex) + words[wordIndex + 1];
	                    }
	                    else {
	                        // partitioning the long word into two words
	                        words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));
	                        separators.splice(wordIndex, 0, '');
	                        wordCount += 1;
	                        // if the previous line is not full
	                        if (lineIndex && !full[lineIndex - 1]) {
	                            lineIndex -= 1;
	                        }
	                    }
	                    wordIndex -= 1;
	                    continue;
	                }
	            }
	            else if (!lines[lineIndex]) {
	                lines[lineIndex] = word;
	                full[lineIndex] = true;
	                lineIndex += 1;
	                continue;
	            }
	            lineIndex += 1;
	            wordIndex -= 1;
	        }
	        // check whether the height of the entire text exceeds the rect height
	        if (height != null) {
	            // ensure line height
	            if (lineHeight == null) {
	                var heightValue 
	                // use the same defaults as in V.prototype.text
	                = void 0;
	                // use the same defaults as in V.prototype.text
	                if (styles.lineHeight === 'auto') {
	                    heightValue = { value: 1.5, unit: 'em' };
	                }
	                else {
	                    heightValue = number_1.NumberExt.parseCssNumeric(styles.lineHeight, [
	                        'em',
	                    ]) || {
	                        value: 1,
	                        unit: 'em',
	                    };
	                }
	                lineHeight = heightValue.value;
	                if (heightValue.unit === 'em') {
	                    if (platform_1.Platform.IS_FIREFOX) {
	                        lineHeight *= tspan.getBBox().height;
	                    }
	                    else {
	                        lineHeight *= telem.getBBox().height;
	                    }
	                }
	            }
	            if (lineHeight * lines.length > height) {
	                // remove overflowing lines
	                var lastLineIndex = Math.floor(height / lineHeight) - 1;
	                var lastLine = lines[lastLineIndex];
	                var overflowLine = lines[lastLineIndex + 1];
	                lines.splice(lastLineIndex + 1);
	                if (lastLine == null) {
	                    break;
	                }
	                // add ellipsis
	                var ellipsis = options.ellipsis;
	                if (!ellipsis) {
	                    break;
	                }
	                if (typeof ellipsis !== 'string') {
	                    ellipsis = '\u2026';
	                }
	                var fullLastLine = lastLine;
	                if (overflowLine && breakWord) {
	                    fullLastLine += currentSeparator + overflowLine;
	                }
	                var lastCharIndex = fullLastLine.length;
	                var fixedLastLine = void 0;
	                var lastChar = void 0;
	                do {
	                    lastChar = fullLastLine[lastCharIndex];
	                    fixedLastLine = fullLastLine.substring(0, lastCharIndex);
	                    if (!lastChar) {
	                        fixedLastLine += lineSeprators[lastLineIndex];
	                    }
	                    else if (lastChar.match(separator)) {
	                        fixedLastLine += lastChar;
	                    }
	                    fixedLastLine += ellipsis;
	                    tnode.data = fixedLastLine;
	                    if (tspan.getComputedTextLength() <= width) {
	                        lines[lastLineIndex] = fixedLastLine;
	                        break;
	                    }
	                    lastCharIndex -= 1;
	                } while (lastCharIndex >= 0);
	                break;
	            }
	        }
	    }
	    if (shouldAppend) {
	        (0, elem_1.remove)(svgDocument);
	    }
	    else {
	        (0, elem_1.remove)(telem);
	    }
	    return lines.join(eol);
	}
	text.breakText = breakText;
	
	return text;
}

var path = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createSlicePathData = exports.toPathData = exports.toPath = exports.rectToPathData = exports.rectangleToPathData = exports.ellipseToPathData = exports.circleToPathData = exports.getPointsFromSvgElement = exports.polylineToPathData = exports.polygonToPathData = exports.lineToPathData = exports.sample = exports.KAPPA = void 0;
		var attr_1 = requireAttr();
		var elem_1 = requireElem();
		exports.KAPPA = 0.551784;
		function getNumbericAttribute(elem, attr, defaultValue) {
		    if (defaultValue === void 0) { defaultValue = NaN; }
		    var v = elem.getAttribute(attr);
		    if (v == null) {
		        return defaultValue;
		    }
		    var n = parseFloat(v);
		    return Number.isNaN(n) ? defaultValue : n;
		}
		function sample(elem, interval) {
		    if (interval === void 0) { interval = 1; }
		    var length = elem.getTotalLength();
		    var samples = [];
		    var distance = 0;
		    var sample;
		    while (distance < length) {
		        sample = elem.getPointAtLength(distance);
		        samples.push({ distance: distance, x: sample.x, y: sample.y });
		        distance += interval;
		    }
		    return samples;
		}
		exports.sample = sample;
		function lineToPathData(line) {
		    return [
		        'M',
		        getNumbericAttribute(line, 'x1'),
		        getNumbericAttribute(line, 'y1'),
		        'L',
		        getNumbericAttribute(line, 'x2'),
		        getNumbericAttribute(line, 'y2'),
		    ].join(' ');
		}
		exports.lineToPathData = lineToPathData;
		function polygonToPathData(polygon) {
		    var points = getPointsFromSvgElement(polygon);
		    if (points.length === 0) {
		        return null;
		    }
		    return svgPointsToPath(points) + " Z";
		}
		exports.polygonToPathData = polygonToPathData;
		function polylineToPathData(polyline) {
		    var points = getPointsFromSvgElement(polyline);
		    if (points.length === 0) {
		        return null;
		    }
		    return svgPointsToPath(points);
		}
		exports.polylineToPathData = polylineToPathData;
		function svgPointsToPath(points) {
		    var arr = points.map(function (p) { return p.x + " " + p.y; });
		    return "M " + arr.join(' L');
		}
		function getPointsFromSvgElement(elem) {
		    var points = [];
		    var nodePoints = elem.points;
		    if (nodePoints) {
		        for (var i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
		            points.push(nodePoints.getItem(i));
		        }
		    }
		    return points;
		}
		exports.getPointsFromSvgElement = getPointsFromSvgElement;
		function circleToPathData(circle) {
		    var cx = getNumbericAttribute(circle, 'cx', 0);
		    var cy = getNumbericAttribute(circle, 'cy', 0);
		    var r = getNumbericAttribute(circle, 'r');
		    var cd = r * exports.KAPPA; // Control distance.
		    return [
		        'M',
		        cx,
		        cy - r,
		        'C',
		        cx + cd,
		        cy - r,
		        cx + r,
		        cy - cd,
		        cx + r,
		        cy,
		        'C',
		        cx + r,
		        cy + cd,
		        cx + cd,
		        cy + r,
		        cx,
		        cy + r,
		        'C',
		        cx - cd,
		        cy + r,
		        cx - r,
		        cy + cd,
		        cx - r,
		        cy,
		        'C',
		        cx - r,
		        cy - cd,
		        cx - cd,
		        cy - r,
		        cx,
		        cy - r,
		        'Z',
		    ].join(' ');
		}
		exports.circleToPathData = circleToPathData;
		function ellipseToPathData(ellipse) {
		    var cx = getNumbericAttribute(ellipse, 'cx', 0);
		    var cy = getNumbericAttribute(ellipse, 'cy', 0);
		    var rx = getNumbericAttribute(ellipse, 'rx');
		    var ry = getNumbericAttribute(ellipse, 'ry') || rx;
		    var cdx = rx * exports.KAPPA; // Control distance x.
		    var cdy = ry * exports.KAPPA; // Control distance y.
		    var d = [
		        'M',
		        cx,
		        cy - ry,
		        'C',
		        cx + cdx,
		        cy - ry,
		        cx + rx,
		        cy - cdy,
		        cx + rx,
		        cy,
		        'C',
		        cx + rx,
		        cy + cdy,
		        cx + cdx,
		        cy + ry,
		        cx,
		        cy + ry,
		        'C',
		        cx - cdx,
		        cy + ry,
		        cx - rx,
		        cy + cdy,
		        cx - rx,
		        cy,
		        'C',
		        cx - rx,
		        cy - cdy,
		        cx - cdx,
		        cy - ry,
		        cx,
		        cy - ry,
		        'Z',
		    ].join(' ');
		    return d;
		}
		exports.ellipseToPathData = ellipseToPathData;
		function rectangleToPathData(rect) {
		    return rectToPathData({
		        x: getNumbericAttribute(rect, 'x', 0),
		        y: getNumbericAttribute(rect, 'y', 0),
		        width: getNumbericAttribute(rect, 'width', 0),
		        height: getNumbericAttribute(rect, 'height', 0),
		        rx: getNumbericAttribute(rect, 'rx', 0),
		        ry: getNumbericAttribute(rect, 'ry', 0),
		    });
		}
		exports.rectangleToPathData = rectangleToPathData;
		function rectToPathData(r) {
		    var d;
		    var x = r.x;
		    var y = r.y;
		    var width = r.width;
		    var height = r.height;
		    var topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);
		    var bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);
		    var topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);
		    var bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);
		    if (topRx || bottomRx || topRy || bottomRy) {
		        d = [
		            'M',
		            x,
		            y + topRy,
		            'v',
		            height - topRy - bottomRy,
		            'a',
		            bottomRx,
		            bottomRy,
		            0,
		            0,
		            0,
		            bottomRx,
		            bottomRy,
		            'h',
		            width - 2 * bottomRx,
		            'a',
		            bottomRx,
		            bottomRy,
		            0,
		            0,
		            0,
		            bottomRx,
		            -bottomRy,
		            'v',
		            -(height - bottomRy - topRy),
		            'a',
		            topRx,
		            topRy,
		            0,
		            0,
		            0,
		            -topRx,
		            -topRy,
		            'h',
		            -(width - 2 * topRx),
		            'a',
		            topRx,
		            topRy,
		            0,
		            0,
		            0,
		            -topRx,
		            topRy,
		            'Z',
		        ];
		    }
		    else {
		        d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];
		    }
		    return d.join(' ');
		}
		exports.rectToPathData = rectToPathData;
		function toPath(elem) {
		    var path = (0, elem_1.createSvgElement)('path');
		    (0, attr_1.attr)(path, (0, attr_1.attr)(elem));
		    var d = toPathData(elem);
		    if (d) {
		        path.setAttribute('d', d);
		    }
		    return path;
		}
		exports.toPath = toPath;
		function toPathData(elem) {
		    var tagName = elem.tagName.toLowerCase();
		    switch (tagName) {
		        case 'path':
		            return elem.getAttribute('d');
		        case 'line':
		            return lineToPathData(elem);
		        case 'polygon':
		            return polygonToPathData(elem);
		        case 'polyline':
		            return polylineToPathData(elem);
		        case 'ellipse':
		            return ellipseToPathData(elem);
		        case 'circle':
		            return circleToPathData(elem);
		        case 'rect':
		            return rectangleToPathData(elem);
		        default:
		            break;
		    }
		    throw new Error("\"" + tagName + "\" cannot be converted to svg path element.");
		}
		exports.toPathData = toPathData;
		// Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js
		function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {
		    var svgArcMax = 2 * Math.PI - 1e-6;
		    var r0 = innerRadius;
		    var r1 = outerRadius;
		    var a0 = startAngle;
		    var a1 = endAngle;
		    if (a1 < a0) {
		        var tmp = a0;
		        a0 = a1;
		        a1 = tmp;
		    }
		    var da = a1 - a0;
		    var df = da < Math.PI ? '0' : '1';
		    var c0 = Math.cos(a0);
		    var s0 = Math.sin(a0);
		    var c1 = Math.cos(a1);
		    var s1 = Math.sin(a1);
		    return da >= svgArcMax
		        ? r0
		            ? // eslint-disable-next-line
		                "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z"
		            : // eslint-disable-next-line
		                "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z"
		        : r0
		            ? // eslint-disable-next-line
		                "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z"
		            : // eslint-disable-next-line
		                "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" +
		                    "Z";
		}
		exports.createSlicePathData = createSlicePathData;
		
	} (path));
	return path;
}

var geom = {};

var matrix = {};

var hasRequiredMatrix;

function requireMatrix () {
	if (hasRequiredMatrix) return matrix;
	hasRequiredMatrix = 1;
	"use strict";
	Object.defineProperty(matrix, "__esModule", { value: true });
	matrix.transformRectangle = matrix.transformPolyline = matrix.transformLine = matrix.transformPoint = matrix.matrixToTranslation = matrix.matrixToRotation = matrix.matrixToScale = matrix.decomposeMatrix = matrix.parseTransformString = matrix.matrixToTransformString = matrix.transformStringToMatrix = matrix.createSVGTransform = matrix.createSVGMatrix = matrix.createSVGPoint = void 0;
	var geometry_1 = requireGeometry();
	var elem_1 = requireElem();
	var svgDocument = (0, elem_1.createSvgElement)('svg');
	var transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
	var transformSeparatorRegex = /[ ,]+/;
	var transformationListRegex = /^(\w+)\((.*)\)/;
	/**
	 * Returns a SVG point object initialized with the `x` and `y` coordinates.
	 * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint
	 */
	function createSVGPoint(x, y) {
	    var p = svgDocument.createSVGPoint();
	    p.x = x;
	    p.y = y;
	    return p;
	}
	matrix.createSVGPoint = createSVGPoint;
	/**
	 * Returns the SVG transformation matrix initialized with the given matrix.
	 *
	 * The given matrix is an object of the form:
	 * {
	 *   a: number
	 *   b: number
	 *   c: number
	 *   d: number
	 *   e: number
	 *   f: number
	 * }
	 *
	 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
	 */
	function createSVGMatrix(matrix) {
	    var mat = svgDocument.createSVGMatrix();
	    if (matrix != null) {
	        var source = matrix;
	        var target = mat;
	        // eslint-disable-next-line
	        for (var key in source) {
	            target[key] = source[key];
	        }
	    }
	    return mat;
	}
	matrix.createSVGMatrix = createSVGMatrix;
	/**
	 * Returns a SVG transform object.
	 * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform
	 */
	function createSVGTransform(matrix) {
	    if (matrix != null) {
	        if (!(matrix instanceof DOMMatrix)) {
	            matrix = createSVGMatrix(matrix); // eslint-disable-line
	        }
	        return svgDocument.createSVGTransformFromMatrix(matrix);
	    }
	    return svgDocument.createSVGTransform();
	}
	matrix.createSVGTransform = createSVGTransform;
	/**
	 * Returns the SVG transformation matrix built from the `transformString`.
	 *
	 * E.g. 'translate(10,10) scale(2,2)' will result in matrix:
	 * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`
	 */
	function transformStringToMatrix(transform) {
	    var mat = createSVGMatrix();
	    var matches = transform != null && transform.match(transformRegex);
	    if (!matches) {
	        return mat;
	    }
	    for (var i = 0, n = matches.length; i < n; i += 1) {
	        var transformationString = matches[i];
	        var transformationMatch = transformationString.match(transformationListRegex);
	        if (transformationMatch) {
	            var sx = void 0;
	            var sy = void 0;
	            var tx = void 0;
	            var ty = void 0;
	            var angle = void 0;
	            var ctm = createSVGMatrix();
	            var args = transformationMatch[2].split(transformSeparatorRegex);
	            switch (transformationMatch[1].toLowerCase()) {
	                case 'scale':
	                    sx = parseFloat(args[0]);
	                    sy = args[1] === undefined ? sx : parseFloat(args[1]);
	                    ctm = ctm.scaleNonUniform(sx, sy);
	                    break;
	                case 'translate':
	                    tx = parseFloat(args[0]);
	                    ty = parseFloat(args[1]);
	                    ctm = ctm.translate(tx, ty);
	                    break;
	                case 'rotate':
	                    angle = parseFloat(args[0]);
	                    tx = parseFloat(args[1]) || 0;
	                    ty = parseFloat(args[2]) || 0;
	                    if (tx !== 0 || ty !== 0) {
	                        ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
	                    }
	                    else {
	                        ctm = ctm.rotate(angle);
	                    }
	                    break;
	                case 'skewx':
	                    angle = parseFloat(args[0]);
	                    ctm = ctm.skewX(angle);
	                    break;
	                case 'skewy':
	                    angle = parseFloat(args[0]);
	                    ctm = ctm.skewY(angle);
	                    break;
	                case 'matrix':
	                    ctm.a = parseFloat(args[0]);
	                    ctm.b = parseFloat(args[1]);
	                    ctm.c = parseFloat(args[2]);
	                    ctm.d = parseFloat(args[3]);
	                    ctm.e = parseFloat(args[4]);
	                    ctm.f = parseFloat(args[5]);
	                    break;
	                default:
	                    continue;
	            }
	            mat = mat.multiply(ctm);
	        }
	    }
	    return mat;
	}
	matrix.transformStringToMatrix = transformStringToMatrix;
	function matrixToTransformString(matrix) {
	    var m = matrix || {};
	    var a = m.a != null ? m.a : 1;
	    var b = m.b != null ? m.b : 0;
	    var c = m.c != null ? m.c : 0;
	    var d = m.d != null ? m.d : 1;
	    var e = m.e != null ? m.e : 0;
	    var f = m.f != null ? m.f : 0;
	    return "matrix(" + a + "," + b + "," + c + "," + d + "," + e + "," + f + ")";
	}
	matrix.matrixToTransformString = matrixToTransformString;
	function parseTransformString(transform) {
	    var translation;
	    var rotation;
	    var scale;
	    if (transform) {
	        var separator = transformSeparatorRegex;
	        // Allow reading transform string with a single matrix
	        if (transform.trim().indexOf('matrix') >= 0) {
	            var matrix = transformStringToMatrix(transform);
	            var decomposedMatrix = decomposeMatrix(matrix);
	            translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
	            rotation = [decomposedMatrix.rotation];
	            scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
	            var transformations = [];
	            if (translation[0] !== 0 || translation[1] !== 0) {
	                transformations.push("translate(" + translation.join(',') + ")");
	            }
	            if (scale[0] !== 1 || scale[1] !== 1) {
	                transformations.push("scale(" + scale.join(',') + ")");
	            }
	            if (rotation[0] !== 0) {
	                transformations.push("rotate(" + rotation[0] + ")");
	            }
	            transform = transformations.join(' '); // eslint-disable-line
	        }
	        else {
	            var translateMatch = transform.match(/translate\((.*?)\)/);
	            if (translateMatch) {
	                translation = translateMatch[1].split(separator);
	            }
	            var rotateMatch = transform.match(/rotate\((.*?)\)/);
	            if (rotateMatch) {
	                rotation = rotateMatch[1].split(separator);
	            }
	            var scaleMatch = transform.match(/scale\((.*?)\)/);
	            if (scaleMatch) {
	                scale = scaleMatch[1].split(separator);
	            }
	        }
	    }
	    var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
	    return {
	        raw: transform || '',
	        translation: {
	            tx: translation && translation[0]
	                ? parseInt(translation[0], 10)
	                : 0,
	            ty: translation && translation[1]
	                ? parseInt(translation[1], 10)
	                : 0,
	        },
	        rotation: {
	            angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
	            cx: rotation && rotation[1]
	                ? parseInt(rotation[1], 10)
	                : undefined,
	            cy: rotation && rotation[2]
	                ? parseInt(rotation[2], 10)
	                : undefined,
	        },
	        scale: {
	            sx: sx,
	            sy: scale && scale[1] ? parseFloat(scale[1]) : sx,
	        },
	    };
	}
	matrix.parseTransformString = parseTransformString;
	function deltaTransformPoint(matrix, point) {
	    var dx = point.x * matrix.a + point.y * matrix.c + 0;
	    var dy = point.x * matrix.b + point.y * matrix.d + 0;
	    return { x: dx, y: dy };
	}
	/**
	 * Decomposes the SVG transformation matrix into separate transformations.
	 *
	 * Returns an object of the form:
	 * {
	 *   translateX: number
	 *   translateY: number
	 *   scaleX: number
	 *   scaleY: number
	 *   skewX: number
	 *   skewY: number
	 *   rotation: number
	 * }
	 *
	 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
	 */
	function decomposeMatrix(matrix) {
	    // @see https://gist.github.com/2052247
	    var px = deltaTransformPoint(matrix, { x: 0, y: 1 });
	    var py = deltaTransformPoint(matrix, { x: 1, y: 0 });
	    var skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90;
	    var skewY = (180 / Math.PI) * Math.atan2(py.y, py.x);
	    return {
	        skewX: skewX,
	        skewY: skewY,
	        translateX: matrix.e,
	        translateY: matrix.f,
	        scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
	        scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
	        rotation: skewX,
	    };
	}
	matrix.decomposeMatrix = decomposeMatrix;
	function matrixToScale(matrix) {
	    var a;
	    var b;
	    var c;
	    var d;
	    if (matrix) {
	        a = matrix.a == null ? 1 : matrix.a;
	        d = matrix.d == null ? 1 : matrix.d;
	        b = matrix.b;
	        c = matrix.c;
	    }
	    else {
	        a = d = 1;
	    }
	    return {
	        sx: b ? Math.sqrt(a * a + b * b) : a,
	        sy: c ? Math.sqrt(c * c + d * d) : d,
	    };
	}
	matrix.matrixToScale = matrixToScale;
	function matrixToRotation(matrix) {
	    var p = { x: 0, y: 1 };
	    if (matrix) {
	        p = deltaTransformPoint(matrix, p);
	    }
	    return {
	        angle: geometry_1.Angle.normalize(geometry_1.Angle.toDeg(Math.atan2(p.y, p.x)) - 90),
	    };
	}
	matrix.matrixToRotation = matrixToRotation;
	function matrixToTranslation(matrix) {
	    return {
	        tx: (matrix && matrix.e) || 0,
	        ty: (matrix && matrix.f) || 0,
	    };
	}
	matrix.matrixToTranslation = matrixToTranslation;
	/**
	 * Transforms point by an SVG transformation represented by `matrix`.
	 */
	function transformPoint(point, matrix) {
	    var ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);
	    return new geometry_1.Point(ret.x, ret.y);
	}
	matrix.transformPoint = transformPoint;
	/**
	 * Transforms line by an SVG transformation represented by `matrix`.
	 */
	function transformLine(line, matrix) {
	    return new geometry_1.Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));
	}
	matrix.transformLine = transformLine;
	/**
	 * Transforms polyline by an SVG transformation represented by `matrix`.
	 */
	function transformPolyline(polyline, matrix) {
	    var points = polyline instanceof geometry_1.Polyline ? polyline.points : polyline;
	    if (!Array.isArray(points)) {
	        points = [];
	    }
	    return new geometry_1.Polyline(points.map(function (p) { return transformPoint(p, matrix); }));
	}
	matrix.transformPolyline = transformPolyline;
	function transformRectangle(rect, matrix) {
	    var p = svgDocument.createSVGPoint();
	    p.x = rect.x;
	    p.y = rect.y;
	    var corner1 = p.matrixTransform(matrix);
	    p.x = rect.x + rect.width;
	    p.y = rect.y;
	    var corner2 = p.matrixTransform(matrix);
	    p.x = rect.x + rect.width;
	    p.y = rect.y + rect.height;
	    var corner3 = p.matrixTransform(matrix);
	    p.x = rect.x;
	    p.y = rect.y + rect.height;
	    var corner4 = p.matrixTransform(matrix);
	    var minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
	    var maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
	    var minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
	    var maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
	    return new geometry_1.Rectangle(minX, minY, maxX - minX, maxY - minY);
	}
	matrix.transformRectangle = transformRectangle;
	
	return matrix;
}

var hasRequiredGeom;

function requireGeom () {
	if (hasRequiredGeom) return geom;
	hasRequiredGeom = 1;
	"use strict";
	var __rest = (geom && geom.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	Object.defineProperty(geom, "__esModule", { value: true });
	geom.getBoundingOffsetRect = geom.animateAlongPath = geom.animateTransform = geom.animate = geom.getIntersection = geom.toGeometryShape = geom.toLocalPoint = geom.getTransformToElement = geom.getMatrixByElementAttr = geom.getBBoxByElementAttr = geom.getBBox = geom.bbox = void 0;
	var geometry_1 = requireGeometry();
	var attr_1 = requireAttr();
	var path_1 = requirePath();
	var elem_1 = requireElem();
	var style_1 = requireStyle();
	var matrix_1 = requireMatrix();
	/**
	 * Returns the bounding box of the element after transformations are
	 * applied. If `withoutTransformations` is `true`, transformations of
	 * the element will not be considered when computing the bounding box.
	 * If `target` is specified, bounding box will be computed relatively
	 * to the `target` element.
	 */
	function bbox(elem, withoutTransformations, target) {
	    var box;
	    var ownerSVGElement = elem.ownerSVGElement;
	    // If the element is not in the live DOM, it does not have a bounding
	    // box defined and so fall back to 'zero' dimension element.
	    if (!ownerSVGElement) {
	        return new geometry_1.Rectangle(0, 0, 0, 0);
	    }
	    try {
	        box = elem.getBBox();
	    }
	    catch (e) {
	        // Fallback for IE.
	        box = {
	            x: elem.clientLeft,
	            y: elem.clientTop,
	            width: elem.clientWidth,
	            height: elem.clientHeight,
	        };
	    }
	    if (withoutTransformations) {
	        return geometry_1.Rectangle.create(box);
	    }
	    var matrix = getTransformToElement(elem, target || ownerSVGElement);
	    return (0, matrix_1.transformRectangle)(box, matrix);
	}
	geom.bbox = bbox;
	/**
	 * Returns the bounding box of the element after transformations are
	 * applied. Unlike `bbox()`, this function fixes a browser implementation
	 * bug to return the correct bounding box if this elemenent is a group of
	 * svg elements (if `options.recursive` is specified).
	 */
	function getBBox(elem, options) {
	    if (options === void 0) { options = {}; }
	    var outputBBox;
	    var ownerSVGElement = elem.ownerSVGElement;
	    // If the element is not in the live DOM, it does not have a bounding box
	    // defined and so fall back to 'zero' dimension element.
	    // If the element is not an SVGGraphicsElement, we could not measure the
	    // bounding box either
	    if (!ownerSVGElement || !(0, elem_1.isSVGGraphicsElement)(elem)) {
	        if ((0, elem_1.isHTMLElement)(elem)) {
	            // If the element is a HTMLElement, return the position relative to the body
	            var _a = getBoundingOffsetRect(elem), left = _a.left, top_1 = _a.top, width = _a.width, height = _a.height;
	            return new geometry_1.Rectangle(left, top_1, width, height);
	        }
	        return new geometry_1.Rectangle(0, 0, 0, 0);
	    }
	    var target = options.target;
	    var recursive = options.recursive;
	    if (!recursive) {
	        try {
	            outputBBox = elem.getBBox();
	        }
	        catch (e) {
	            outputBBox = {
	                x: elem.clientLeft,
	                y: elem.clientTop,
	                width: elem.clientWidth,
	                height: elem.clientHeight,
	            };
	        }
	        if (!target) {
	            return geometry_1.Rectangle.create(outputBBox);
	        }
	        // transform like target
	        var matrix = getTransformToElement(elem, target);
	        return (0, matrix_1.transformRectangle)(outputBBox, matrix);
	    }
	    // recursive
	    {
	        var children = elem.childNodes;
	        var n = children.length;
	        if (n === 0) {
	            return getBBox(elem, { target: target });
	        }
	        if (!target) {
	            target = elem; // eslint-disable-line
	        }
	        for (var i = 0; i < n; i += 1) {
	            var child = children[i];
	            var childBBox = void 0;
	            if (child.childNodes.length === 0) {
	                childBBox = getBBox(child, { target: target });
	            }
	            else {
	                // if child is a group element, enter it with a recursive call
	                childBBox = getBBox(child, { target: target, recursive: true });
	            }
	            if (!outputBBox) {
	                outputBBox = childBBox;
	            }
	            else {
	                outputBBox = outputBBox.union(childBBox);
	            }
	        }
	        return outputBBox;
	    }
	}
	geom.getBBox = getBBox;
	// BBox is calculated by the attribute on the node
	function getBBoxByElementAttr(elem) {
	    var node = elem;
	    var tagName = node ? node.tagName.toLowerCase() : '';
	    // find shape node
	    while (tagName === 'g') {
	        node = node.firstElementChild;
	        tagName = node ? node.tagName.toLowerCase() : '';
	    }
	    var attr = function (name) {
	        var s = node.getAttribute(name);
	        var v = s ? parseFloat(s) : 0;
	        return Number.isNaN(v) ? 0 : v;
	    };
	    var r;
	    var bbox;
	    switch (tagName) {
	        case 'rect':
	            bbox = new geometry_1.Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));
	            break;
	        case 'circle':
	            r = attr('r');
	            bbox = new geometry_1.Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r);
	            break;
	        default:
	            break;
	    }
	    return bbox;
	}
	geom.getBBoxByElementAttr = getBBoxByElementAttr;
	// Matrix is calculated by the transform attribute on the node
	function getMatrixByElementAttr(elem, target) {
	    var matrix = (0, matrix_1.createSVGMatrix)();
	    if ((0, elem_1.isSVGGraphicsElement)(target) && (0, elem_1.isSVGGraphicsElement)(elem)) {
	        var node = elem;
	        var matrixList = [];
	        while (node && node !== target) {
	            var transform = node.getAttribute('transform') || null;
	            var nodeMatrix = (0, matrix_1.transformStringToMatrix)(transform);
	            matrixList.push(nodeMatrix);
	            node = node.parentNode;
	        }
	        matrixList.reverse().forEach(function (m) {
	            matrix = matrix.multiply(m);
	        });
	    }
	    return matrix;
	}
	geom.getMatrixByElementAttr = getMatrixByElementAttr;
	/**
	 * Returns an DOMMatrix that specifies the transformation necessary
	 * to convert `elem` coordinate system into `target` coordinate system.
	 */
	function getTransformToElement(elem, target) {
	    if ((0, elem_1.isSVGGraphicsElement)(target) && (0, elem_1.isSVGGraphicsElement)(elem)) {
	        var targetCTM = target.getScreenCTM();
	        var nodeCTM = elem.getScreenCTM();
	        if (targetCTM && nodeCTM) {
	            return targetCTM.inverse().multiply(nodeCTM);
	        }
	    }
	    // Could not get actual transformation matrix
	    return (0, matrix_1.createSVGMatrix)();
	}
	geom.getTransformToElement = getTransformToElement;
	/**
	 * Converts a global point with coordinates `x` and `y` into the
	 * coordinate space of the element.
	 */
	function toLocalPoint(elem, x, y) {
	    var svg = elem instanceof SVGSVGElement
	        ? elem
	        : elem.ownerSVGElement;
	    var p = svg.createSVGPoint();
	    p.x = x;
	    p.y = y;
	    try {
	        var ctm = svg.getScreenCTM();
	        var globalPoint = p.matrixTransform(ctm.inverse());
	        var globalToLocalMatrix = getTransformToElement(elem, svg).inverse();
	        return globalPoint.matrixTransform(globalToLocalMatrix);
	    }
	    catch (e) {
	        return p;
	    }
	}
	geom.toLocalPoint = toLocalPoint;
	/**
	 * Convert the SVGElement to an equivalent geometric shape. The element's
	 * transformations are not taken into account.
	 *
	 * SVGRectElement      => Rectangle
	 *
	 * SVGLineElement      => Line
	 *
	 * SVGCircleElement    => Ellipse
	 *
	 * SVGEllipseElement   => Ellipse
	 *
	 * SVGPolygonElement   => Polyline
	 *
	 * SVGPolylineElement  => Polyline
	 *
	 * SVGPathElement      => Path
	 *
	 * others              => Rectangle
	 */
	function toGeometryShape(elem) {
	    var attr = function (name) {
	        var s = elem.getAttribute(name);
	        var v = s ? parseFloat(s) : 0;
	        return Number.isNaN(v) ? 0 : v;
	    };
	    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
	        case 'rect':
	            return new geometry_1.Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));
	        case 'circle':
	            return new geometry_1.Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));
	        case 'ellipse':
	            return new geometry_1.Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));
	        case 'polyline': {
	            var points = (0, path_1.getPointsFromSvgElement)(elem);
	            return new geometry_1.Polyline(points);
	        }
	        case 'polygon': {
	            var points = (0, path_1.getPointsFromSvgElement)(elem);
	            if (points.length > 1) {
	                points.push(points[0]);
	            }
	            return new geometry_1.Polyline(points);
	        }
	        case 'path': {
	            var d = elem.getAttribute('d');
	            if (!geometry_1.Path.isValid(d)) {
	                d = geometry_1.Path.normalize(d);
	            }
	            return geometry_1.Path.parse(d);
	        }
	        case 'line': {
	            return new geometry_1.Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));
	        }
	        default:
	            break;
	    }
	    // Anything else is a rectangle
	    return getBBox(elem);
	}
	geom.toGeometryShape = toGeometryShape;
	function getIntersection(elem, ref, target) {
	    var svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
	    target = target || svg; // eslint-disable-line
	    var bbox = getBBox(target);
	    var center = bbox.getCenter();
	    if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {
	        return null;
	    }
	    var spot = null;
	    var tagName = elem.tagName.toLowerCase();
	    // Little speed up optimization for `<rect>` element. We do not do convert
	    // to path element and sampling but directly calculate the intersection
	    // through a transformed geometrical rectangle.
	    if (tagName === 'rect') {
	        var gRect = new geometry_1.Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0'));
	        // Get the rect transformation matrix with regards to the SVG document.
	        var rectMatrix = getTransformToElement(elem, target);
	        var rectMatrixComponents = (0, matrix_1.decomposeMatrix)(rectMatrix);
	        // Rotate the rectangle back so that we can use
	        // `intersectsWithLineFromCenterToPoint()`.
	        var reseted = svg.createSVGTransform();
	        reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);
	        var rect = (0, matrix_1.transformRectangle)(gRect, reseted.matrix.multiply(rectMatrix));
	        spot = geometry_1.Rectangle.create(rect).intersectsWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
	    }
	    else if (tagName === 'path' ||
	        tagName === 'polygon' ||
	        tagName === 'polyline' ||
	        tagName === 'circle' ||
	        tagName === 'ellipse') {
	        var pathNode = tagName === 'path' ? elem : (0, path_1.toPath)(elem);
	        var samples = (0, path_1.sample)(pathNode);
	        var minDistance = Infinity;
	        var closestSamples = [];
	        for (var i = 0, ii = samples.length; i < ii; i += 1) {
	            var sample_1 = samples[i];
	            // Convert the sample point in the local coordinate system
	            // to the global coordinate system.
	            var gp = (0, matrix_1.createSVGPoint)(sample_1.x, sample_1.y);
	            gp = gp.matrixTransform(getTransformToElement(elem, target));
	            var ggp = geometry_1.Point.create(gp);
	            var centerDistance = ggp.distance(center);
	            // Penalize a higher distance to the reference point by 10%.
	            // This gives better results. This is due to
	            // inaccuracies introduced by rounding errors and getPointAtLength() returns.
	            var refDistance = ggp.distance(ref) * 1.1;
	            var distance = centerDistance + refDistance;
	            if (distance < minDistance) {
	                minDistance = distance;
	                closestSamples = [{ sample: sample_1, refDistance: refDistance }];
	            }
	            else if (distance < minDistance + 1) {
	                closestSamples.push({ sample: sample_1, refDistance: refDistance });
	            }
	        }
	        closestSamples.sort(function (a, b) { return a.refDistance - b.refDistance; });
	        if (closestSamples[0]) {
	            spot = geometry_1.Point.create(closestSamples[0].sample);
	        }
	    }
	    return spot;
	}
	geom.getIntersection = getIntersection;
	function animate(elem, options) {
	    return createAnimation(elem, options, 'animate');
	}
	geom.animate = animate;
	function animateTransform(elem, options) {
	    return createAnimation(elem, options, 'animateTransform');
	}
	geom.animateTransform = animateTransform;
	function createAnimation(elem, options, type) {
	    // @see
	    // https://www.w3.org/TR/SVG11/animate.html#AnimateElement
	    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement
	    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement
	    var animate = (0, elem_1.createSvgElement)(type);
	    elem.appendChild(animate);
	    try {
	        return setupAnimation(animate, options);
	    }
	    catch (error) {
	        // pass
	    }
	    return function () { };
	}
	function setupAnimation(animate, options) {
	    var start = options.start, complete = options.complete, repeat = options.repeat, attrs = __rest(options, ["start", "complete", "repeat"]);
	    (0, attr_1.attr)(animate, attrs);
	    start && animate.addEventListener('beginEvent', start);
	    complete && animate.addEventListener('endEvent', complete);
	    repeat && animate.addEventListener('repeatEvent', repeat);
	    var ani = animate;
	    setTimeout(function () {
	        ani.beginElement();
	    });
	    return function () { return ani.endElement(); };
	}
	/**
	 * Animate the element along the path SVG element (or Vector object).
	 * `attrs` contain Animation Timing attributes describing the animation.
	 */
	function animateAlongPath(elem, options, path) {
	    var id = (0, elem_1.ensureId)(path);
	    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement
	    var animate = (0, elem_1.createSvgElement)('animateMotion');
	    var mpath = (0, elem_1.createSvgElement)('mpath');
	    (0, attr_1.attr)(mpath, { 'xlink:href': "#" + id });
	    animate.appendChild(mpath);
	    elem.appendChild(animate);
	    try {
	        return setupAnimation(animate, options);
	    }
	    catch (e) {
	        // Fallback for IE 9.
	        if (document.documentElement.getAttribute('smiling') === 'fake') {
	            // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)
	            var ani = animate;
	            ani.animators = [];
	            var win = window;
	            var animationID = ani.getAttribute('id');
	            if (animationID) {
	                win.id2anim[animationID] = ani;
	            }
	            var targets = win.getTargets(ani);
	            for (var i = 0, ii = targets.length; i < ii; i += 1) {
	                var target = targets[i];
	                var animator = new win.Animator(ani, target, i);
	                win.animators.push(animator);
	                ani.animators[i] = animator;
	                animator.register();
	            }
	        }
	    }
	    return function () { };
	}
	geom.animateAlongPath = animateAlongPath;
	function getBoundingOffsetRect(elem) {
	    var left = 0;
	    var top = 0;
	    var width = 0;
	    var height = 0;
	    if (elem) {
	        var current = elem;
	        while (current) {
	            left += current.offsetLeft;
	            top += current.offsetTop;
	            current = current.offsetParent;
	            if (current) {
	                left += parseInt((0, style_1.getComputedStyle)(current, 'borderLeft'), 10);
	                top += parseInt((0, style_1.getComputedStyle)(current, 'borderTop'), 10);
	            }
	        }
	        width = elem.offsetWidth;
	        height = elem.offsetHeight;
	    }
	    return { left: left, top: top, width: width, height: height };
	}
	geom.getBoundingOffsetRect = getBoundingOffsetRect;
	
	return geom;
}

var transform = {};

var hasRequiredTransform;

function requireTransform () {
	if (hasRequiredTransform) return transform;
	hasRequiredTransform = 1;
	"use strict";
	Object.defineProperty(transform, "__esModule", { value: true });
	transform.translateAndAutoOrient = transform.scale = transform.rotate = transform.translate = transform.transform = void 0;
	var geometry_1 = requireGeometry();
	var attr_1 = requireAttr();
	var geom_1 = requireGeom();
	var matrix_1 = requireMatrix();
	function transform$1(elem, matrix, options) {
	    if (options === void 0) { options = {}; }
	    if (matrix == null) {
	        return (0, matrix_1.transformStringToMatrix)((0, attr_1.attr)(elem, 'transform'));
	    }
	    if (options.absolute) {
	        elem.setAttribute('transform', (0, matrix_1.matrixToTransformString)(matrix));
	        return;
	    }
	    var transformList = elem.transform;
	    var svgTransform = (0, matrix_1.createSVGTransform)(matrix);
	    transformList.baseVal.appendItem(svgTransform);
	}
	transform.transform = transform$1;
	function translate(elem, tx, ty, options) {
	    if (ty === void 0) { ty = 0; }
	    if (options === void 0) { options = {}; }
	    var transformAttr = (0, attr_1.attr)(elem, 'transform');
	    var transform = (0, matrix_1.parseTransformString)(transformAttr);
	    if (tx == null) {
	        return transform.translation;
	    }
	    transformAttr = transform.raw;
	    transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
	    var newTx = options.absolute ? tx : transform.translation.tx + tx;
	    var newTy = options.absolute ? ty : transform.translation.ty + ty;
	    var newTranslate = "translate(" + newTx + "," + newTy + ")";
	    // Note that `translate()` is always the first transformation. This is
	    // usually the desired case.
	    elem.setAttribute('transform', (newTranslate + " " + transformAttr).trim());
	}
	transform.translate = translate;
	function rotate(elem, angle, cx, cy, options) {
	    if (options === void 0) { options = {}; }
	    var transformAttr = (0, attr_1.attr)(elem, 'transform');
	    var transform = (0, matrix_1.parseTransformString)(transformAttr);
	    if (angle == null) {
	        return transform.rotation;
	    }
	    transformAttr = transform.raw;
	    transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
	    angle %= 360; // eslint-disable-line
	    var newAngle = options.absolute ? angle : transform.rotation.angle + angle;
	    var newOrigin = cx != null && cy != null ? "," + cx + "," + cy : '';
	    var newRotate = "rotate(" + newAngle + newOrigin + ")";
	    elem.setAttribute('transform', (transformAttr + " " + newRotate).trim());
	}
	transform.rotate = rotate;
	function scale(elem, sx, sy) {
	    var transformAttr = (0, attr_1.attr)(elem, 'transform');
	    var transform = (0, matrix_1.parseTransformString)(transformAttr);
	    if (sx == null) {
	        return transform.scale;
	    }
	    sy = sy == null ? sx : sy; // eslint-disable-line
	    transformAttr = transform.raw;
	    transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
	    var newScale = "scale(" + sx + "," + sy + ")";
	    elem.setAttribute('transform', (transformAttr + " " + newScale).trim());
	}
	transform.scale = scale;
	function translateAndAutoOrient(elem, position, reference, target) {
	    var pos = geometry_1.Point.create(position);
	    var ref = geometry_1.Point.create(reference);
	    if (!target) {
	        var svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
	        target = svg; // eslint-disable-line
	    }
	    // Clean-up previously set transformations except the scale.
	    // If we didn't clean up the previous transformations then they'd
	    // add up with the old ones. Scale is an exception as it doesn't
	    // add up, consider: `this.scale(2).scale(2).scale(2)`. The result
	    // is that the element is scaled by the factor 2, not 8.
	    var s = scale(elem);
	    elem.setAttribute('transform', '');
	    var bbox = (0, geom_1.getBBox)(elem, { target: target }).scale(s.sx, s.sy);
	    // 1. Translate to origin.
	    var translateToOrigin = (0, matrix_1.createSVGTransform)();
	    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);
	    // 2. Rotate around origin.
	    var rotateAroundOrigin = (0, matrix_1.createSVGTransform)();
	    var angle = pos.angleBetween(ref, pos.clone().translate(1, 0));
	    if (angle)
	        rotateAroundOrigin.setRotate(angle, 0, 0);
	    // 3. Translate to the `position` + the offset (half my width)
	    //    towards the `reference` point.
	    var translateFromOrigin = (0, matrix_1.createSVGTransform)();
	    var finalPosition = pos.clone().move(ref, bbox.width / 2);
	    translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);
	    // 4. Get the current transformation matrix of this node
	    var ctm = (0, geom_1.getTransformToElement)(elem, target);
	    // 5. Apply transformations and the scale
	    var transform = (0, matrix_1.createSVGTransform)();
	    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
	    elem.setAttribute('transform', (0, matrix_1.matrixToTransformString)(transform.matrix));
	}
	transform.translateAndAutoOrient = translateAndAutoOrient;
	
	return transform;
}

var mousewheel = {};

var hasRequiredMousewheel;

function requireMousewheel () {
	if (hasRequiredMousewheel) return mousewheel;
	hasRequiredMousewheel = 1;
	"use strict";
	var __importDefault = (mousewheel && mousewheel.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(mousewheel, "__esModule", { value: true });
	mousewheel.MouseWheelHandle = void 0;
	var jquery_1 = __importDefault(requireJquery());
	var platform_1 = requirePlatform();
	var MouseWheelHandle = /** @class */ (function () {
	    function MouseWheelHandle(target, onWheelCallback, onWheelGuard) {
	        this.animationFrameId = 0;
	        this.deltaX = 0;
	        this.deltaY = 0;
	        this.eventName = platform_1.Platform.isEventSupported('wheel')
	            ? 'wheel'
	            : 'mousewheel';
	        this.target = target;
	        this.onWheelCallback = onWheelCallback;
	        this.onWheelGuard = onWheelGuard;
	        this.onWheel = this.onWheel.bind(this);
	        this.didWheel = this.didWheel.bind(this);
	    }
	    MouseWheelHandle.prototype.enable = function () {
	        if (platform_1.Platform.SUPPORT_PASSIVE) {
	            this.target.addEventListener(this.eventName, this.onWheel, {
	                passive: false,
	            });
	        }
	        else {
	            (0, jquery_1.default)(this.target).on('mousewheel', this.onWheel);
	        }
	    };
	    MouseWheelHandle.prototype.disable = function () {
	        if (platform_1.Platform.SUPPORT_PASSIVE) {
	            this.target.removeEventListener(this.eventName, this.onWheel);
	        }
	        else {
	            (0, jquery_1.default)(this.target).off('mousewheel');
	        }
	    };
	    MouseWheelHandle.prototype.onWheel = function (e) {
	        var _this = this;
	        if (this.onWheelGuard != null && !this.onWheelGuard(e)) {
	            return;
	        }
	        this.deltaX += e.deltaX;
	        this.deltaY += e.deltaY;
	        e.preventDefault();
	        var changed;
	        if (this.deltaX !== 0 || this.deltaY !== 0) {
	            e.stopPropagation();
	            changed = true;
	        }
	        if (changed === true && this.animationFrameId === 0) {
	            this.animationFrameId = requestAnimationFrame(function () {
	                _this.didWheel(e);
	            });
	        }
	    };
	    MouseWheelHandle.prototype.didWheel = function (e) {
	        this.animationFrameId = 0;
	        this.onWheelCallback(e, this.deltaX, this.deltaY);
	        this.deltaX = 0;
	        this.deltaY = 0;
	    };
	    return MouseWheelHandle;
	}());
	mousewheel.MouseWheelHandle = MouseWheelHandle;
	
	return mousewheel;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (core && core.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (core && core.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireAf(), exports);
		__exportStar(requireAttr(), exports);
		__exportStar(requireElem(), exports);
		__exportStar(require_class(), exports);
		__exportStar(requireStyle(), exports);
		__exportStar(requirePrefix(), exports);
		__exportStar(requireSelection(), exports);
		// svg
		// ---
		__exportStar(requireText(), exports);
		__exportStar(requirePath(), exports);
		__exportStar(requireGeom(), exports);
		__exportStar(requireMatrix(), exports);
		__exportStar(requireTransform(), exports);
		__exportStar(requireMousewheel(), exports);
		
	} (core));
	return core;
}

var vector = {};

var hasRequiredVector;

function requireVector () {
	if (hasRequiredVector) return vector;
	hasRequiredVector = 1;
	"use strict";
	Object.defineProperty(vector, "__esModule", { value: true });
	vector.createVectors = vector.createVector = vector.isVector = void 0;
	var vector_1 = requireVector$1();
	/**
	 * **Deprecation Notice:** `Dom.isVector` is deprecated and will be moved in next
	 * major release. Use `Vector.isVector()` instead.
	 *
	 * @deprecated
	 */
	vector.isVector = vector_1.Vector.isVector;
	/**
	 * **Deprecation Notice:** `Dom.createVector` is deprecated and will be moved
	 * in next major release. Use `Vector.create()` instead.
	 *
	 * @deprecated
	 */
	vector.createVector = vector_1.Vector.create;
	/**
	 * **Deprecation Notice:** `Dom.createVectors` is deprecated and will be moved
	 * in next major release. Use `Vector.createVectors()` instead.
	 *
	 * @deprecated
	 */
	vector.createVectors = vector_1.Vector.createVectors;
	
	return vector;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main;
	hasRequiredMain = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (main && main.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main && main.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireCore(), exports);
		__exportStar(requireVector(), exports);
		
	} (main));
	return main;
}

var hasRequiredDom;

function requireDom () {
	if (hasRequiredDom) return dom;
	hasRequiredDom = 1;
	"use strict";
	var __createBinding = (dom && dom.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dom && dom.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dom && dom.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(dom, "__esModule", { value: true });
	dom.Dom = void 0;
	var Dom = __importStar(requireMain());
	dom.Dom = Dom;
	
	return dom;
}

var sizeSensor = {};

var sensors = {};

var object = {};

var util$1 = {};

var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$1;
	hasRequiredUtil$2 = 1;
	"use strict";
	Object.defineProperty(util$1, "__esModule", { value: true });
	util$1.debounce = void 0;
	function debounce(fn, delay) {
	    var _this = this;
	    if (delay === void 0) { delay = 60; }
	    var timer = null;
	    return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (timer) {
	            clearTimeout(timer);
	        }
	        timer = window.setTimeout(function () {
	            fn.apply(_this, args);
	        }, delay);
	    };
	}
	util$1.debounce = debounce;
	
	return util$1;
}

var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;
	"use strict";
	Object.defineProperty(object, "__esModule", { value: true });
	object.createSensor = void 0;
	var util_1 = requireUtil$2();
	function createSensor(element) {
	    var sensor = null;
	    var listeners = [];
	    var create = function () {
	        if (getComputedStyle(element).position === 'static') {
	            var style = element.style;
	            style.position = 'relative';
	        }
	        var obj = document.createElement('object');
	        obj.onload = function () {
	            obj.contentDocument.defaultView.addEventListener('resize', trigger);
	            trigger();
	        };
	        obj.style.display = 'block';
	        obj.style.position = 'absolute';
	        obj.style.top = '0';
	        obj.style.left = '0';
	        obj.style.height = '100%';
	        obj.style.width = '100%';
	        obj.style.overflow = 'hidden';
	        obj.style.pointerEvents = 'none';
	        obj.style.zIndex = '-1';
	        obj.style.opacity = '0';
	        obj.setAttribute('tabindex', '-1');
	        obj.type = 'text/html';
	        element.appendChild(obj);
	        // for ie, should set data attribute delay, or will be white screen
	        obj.data = 'about:blank';
	        return obj;
	    };
	    var trigger = (0, util_1.debounce)(function () {
	        listeners.forEach(function (listener) { return listener(element); });
	    });
	    var bind = function (listener) {
	        if (!sensor) {
	            sensor = create();
	        }
	        if (listeners.indexOf(listener) === -1) {
	            listeners.push(listener);
	        }
	    };
	    var destroy = function () {
	        if (sensor && sensor.parentNode) {
	            if (sensor.contentDocument) {
	                sensor.contentDocument.defaultView.removeEventListener('resize', trigger);
	            }
	            sensor.parentNode.removeChild(sensor);
	            sensor = null;
	            listeners = [];
	        }
	    };
	    var unbind = function (listener) {
	        var idx = listeners.indexOf(listener);
	        if (idx !== -1) {
	            listeners.splice(idx, 1);
	        }
	        // no listener, and sensor is exist then destroy the sensor
	        if (listeners.length === 0 && sensor) {
	            destroy();
	        }
	    };
	    return {
	        element: element,
	        bind: bind,
	        destroy: destroy,
	        unbind: unbind,
	    };
	}
	object.createSensor = createSensor;
	
	return object;
}

var observer = {};

var hasRequiredObserver;

function requireObserver () {
	if (hasRequiredObserver) return observer;
	hasRequiredObserver = 1;
	"use strict";
	Object.defineProperty(observer, "__esModule", { value: true });
	observer.createSensor = void 0;
	var util_1 = requireUtil$2();
	function createSensor(element) {
	    var sensor = null;
	    var listeners = [];
	    var trigger = (0, util_1.debounce)(function () {
	        listeners.forEach(function (listener) {
	            listener(element);
	        });
	    });
	    var create = function () {
	        var s = new ResizeObserver(trigger);
	        s.observe(element);
	        trigger();
	        return s;
	    };
	    var bind = function (listener) {
	        if (!sensor) {
	            sensor = create();
	        }
	        if (listeners.indexOf(listener) === -1) {
	            listeners.push(listener);
	        }
	    };
	    var destroy = function () {
	        if (sensor) {
	            sensor.disconnect();
	            listeners = [];
	            sensor = null;
	        }
	    };
	    var unbind = function (listener) {
	        var idx = listeners.indexOf(listener);
	        if (idx !== -1) {
	            listeners.splice(idx, 1);
	        }
	        // no listener, and sensor is exist then destroy the sensor
	        if (listeners.length === 0 && sensor) {
	            destroy();
	        }
	    };
	    return {
	        element: element,
	        bind: bind,
	        destroy: destroy,
	        unbind: unbind,
	    };
	}
	observer.createSensor = createSensor;
	
	return observer;
}

var hasRequiredSensors;

function requireSensors () {
	if (hasRequiredSensors) return sensors;
	hasRequiredSensors = 1;
	"use strict";
	Object.defineProperty(sensors, "__esModule", { value: true });
	sensors.createSensor = void 0;
	var object_1 = requireObject();
	var observer_1 = requireObserver();
	sensors.createSensor = typeof ResizeObserver !== 'undefined'
	    ? observer_1.createSensor
	    : object_1.createSensor;
	
	return sensors;
}

var hasRequiredSizeSensor;

function requireSizeSensor () {
	if (hasRequiredSizeSensor) return sizeSensor;
	hasRequiredSizeSensor = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SizeSensor = void 0;
		var sensors_1 = requireSensors();
		var SizeSensor;
		(function (SizeSensor) {
		    var cache = new WeakMap();
		    function get(element) {
		        var sensor = cache.get(element);
		        if (sensor) {
		            return sensor;
		        }
		        sensor = (0, sensors_1.createSensor)(element);
		        cache.set(element, sensor);
		        return sensor;
		    }
		    function remove(sensor) {
		        sensor.destroy();
		        cache.delete(sensor.element);
		    }
		    SizeSensor.bind = function (element, cb) {
		        var sensor = get(element);
		        sensor.bind(cb);
		        return function () { return sensor.unbind(cb); };
		    };
		    SizeSensor.clear = function (element) {
		        var sensor = get(element);
		        remove(sensor);
		    };
		})(SizeSensor = exports.SizeSensor || (exports.SizeSensor = {}));
		
	} (sizeSensor));
	return sizeSensor;
}

var scheduler = {};

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return scheduler;
	hasRequiredScheduler = 1;
	(function (exports) {
		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Scheduler = void 0;
		var Scheduler;
		(function (Scheduler) {
		    var queue = [];
		    var threshold = 1000 / 60;
		    var unit = [];
		    var deadline = 0;
		    var getTime = function () { return performance.now(); };
		    var peek = function (queue) { return queue[0]; };
		    var schedule = function (cb) { return unit.push(cb) === 1 && postMessage(); };
		    var postMessage = (function () {
		        var cb = function () { var _a, _b; return (_b = (_a = unit.splice(0, unit.length))[0]) === null || _b === void 0 ? void 0 : _b.call(_a); };
		        if (typeof MessageChannel !== 'undefined') {
		            var _a = new MessageChannel(), port1 = _a.port1, port2_1 = _a.port2;
		            port1.onmessage = cb;
		            return function () { return port2_1.postMessage(null); };
		        }
		        return function () { return setTimeout(cb); };
		    })();
		    var flushTask = function () {
		        deadline = getTime() + threshold;
		        var job = peek(queue);
		        while (job && !Scheduler.shouldYield()) {
		            var callback = job.callback, data = job.data;
		            job.callback = null;
		            var next = callback && callback(data);
		            if (next) {
		                job.callback = next;
		            }
		            else {
		                queue.shift();
		            }
		            job = peek(queue);
		        }
		        job && schedule(flushTask);
		    };
		    Scheduler.scheduleTask = function (callback, data) {
		        var task = {
		            callback: callback,
		            data: data,
		        };
		        queue.push(task);
		        schedule(flushTask);
		    };
		    Scheduler.shouldYield = function () {
		        var _a, _b;
		        return (((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline);
		    };
		})(Scheduler = exports.Scheduler || (exports.Scheduler = {}));
		
	} (scheduler));
	return scheduler;
}

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$4;
	hasRequiredUtil$1 = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (util$4 && util$4.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (util$4 && util$4.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importDefault = (util$4 && util$4.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.JQuery = void 0;
		var jquery_1 = __importDefault(requireJquery());
		exports.JQuery = jquery_1.default;
		requirePolyfill();
		__exportStar(requireLang(), exports);
		__exportStar(requireArray(), exports);
		__exportStar(requireObject$1(), exports);
		__exportStar(requireString(), exports);
		__exportStar(requireNumber(), exports);
		__exportStar(require_function(), exports);
		__exportStar(requirePlatform(), exports);
		__exportStar(requireText$1(), exports);
		__exportStar(requireJson(), exports);
		__exportStar(requireDatauri(), exports);
		__exportStar(requireUnit(), exports);
		__exportStar(requireDom(), exports);
		__exportStar(requireVector$1(), exports);
		__exportStar(requireSizeSensor(), exports);
		__exportStar(requireScheduler(), exports);
		
	} (util$4));
	return util$4;
}

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util$5;
	hasRequiredUtil = 1;
	"use strict";
	var __assign = (util$5 && util$5.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(util$5, "__esModule", { value: true });
	util$5.toResult = util$5.normalizePoint = void 0;
	var util_1 = requireUtil$1();
	var geometry_1 = requireGeometry();
	function normalizePoint(bbox, args) {
	    if (args === void 0) { args = {}; }
	    return new geometry_1.Point(util_1.NumberExt.normalizePercentage(args.x, bbox.width), util_1.NumberExt.normalizePercentage(args.y, bbox.height));
	}
	util$5.normalizePoint = normalizePoint;
	function toResult(point, angle, rawArgs) {
	    return __assign({ angle: angle, position: point.toJSON() }, rawArgs);
	}
	util$5.toResult = toResult;
	
	return util$5;
}

var utilExports = requireUtil();
var util = /*@__PURE__*/getDefaultExportFromCjs(utilExports);

Graph.registerPortLayout('dynamicOut', (portsPositionArgs, elemBBox) => {
    return portsPositionArgs.map((_, index) => {
        const portCount = portsPositionArgs.length;
        const ratio = (index + 0.5) / portCount;
        const p1 = portCount <= 3 ? elemBBox.getTopRight() : elemBBox.getBottomLeft();
        const p2 = portCount <= 3 ? elemBBox.getBottomRight() : elemBBox.getBottomRight();
        const line = new Line(p1, p2);
        const p = line.pointAt(ratio);
        return utilExports.toResult(p.round(), 0, {});
    });
});
Graph.registerPortLayout('dynamicIn', (portsPositionArgs, elemBBox) => {
    return portsPositionArgs.map((_, index) => {
        const portCount = portsPositionArgs.length;
        const ratio = (index + 0.5) / portCount;
        const p1 = portCount <= 3 ? elemBBox.getTopLeft() : elemBBox.getTopLeft();
        const p2 = portCount <= 3 ? elemBBox.getBottomLeft() : elemBBox.getTopRight();
        const line = new Line(p1, p2);
        const p = line.pointAt(ratio);
        return utilExports.toResult(p.round(), 0, {});
    });
});
Graph.registerConnector('elsa-connector', (s, e) => {
    const offset = 0;
    const deltaY = Math.abs(e.y - s.y);
    const control = Math.floor((deltaY / 3) * 2);
    const v1 = { x: s.x, y: s.y + offset + control };
    const v2 = { x: e.x, y: e.y - offset - control };
    return Path$2.normalize(`M ${s.x} ${s.y}
       L ${s.x} ${s.y + offset}
       C ${v1.x} ${v1.y} ${v2.x} ${v2.y} ${e.x} ${e.y - offset}
       L ${e.x} ${e.y}
      `);
}, true);
Graph.registerEdge('elsa-edge', {
    inherit: 'edge',
    attrs: {
        line: {
            stroke: '#C2C8D5',
            strokeWidth: 1,
            targetMarker: null
        },
    },
}, true);

class ActivityNodeShape extends HTML {
    get component() {
        return this.store.get('component');
    }
    set component(value) {
        this.store.set('component', value);
    }
    set activity(value) {
        this.store.set('activity', value);
    }
    get activity() {
        return this.store.get('activity');
    }
    get activityDescriptor() {
        return this.store.get('activityDescriptor');
    }
    set activityDescriptor(value) {
        this.store.set('activityDescriptor', value);
    }
    get displayContext() {
        return this.store.get('displayContext');
    }
    set displayContext(value) {
        this.store.set('displayContext', value);
    }
    init() {
        super.init();
        this.updateSize();
    }
    setup() {
        const self = this;
        super.setup();
        this.on('change:component', this.updateSize, this);
        this.on('change:activity', this.updateSize, this);
        this.html = {
            render() {
                return self.createHtml();
            },
            shouldComponentUpdate(node) {
                return node.hasChanged('component') || node.hasChanged('activity');
            },
        };
    }
    updateSize() {
        const wrapper = document.createElement('div');
        wrapper.className = 'w-full flex items-center pl-10 pr-2 py-2 absolute';
        wrapper.style.left = '-1000px';
        wrapper.style.top = '-1000px';
        wrapper.innerHTML = this.createHtml();
        document.body.append(wrapper);
        // Wait for activity element to be completely rendered.
        // When using custom elements, they are rendered after they are mounted. Before then, they have a 0 width and height.
        const tryUpdateSize = () => {
            const activityElement = wrapper.getElementsByTagName('elsa-default-activity-template')[0];
            const activityElementRect = activityElement.getBoundingClientRect();
            // If the custom element has no width or height yet, it means it has not yet rendered.
            if (activityElementRect.width == 0 || activityElementRect.height == 0) {
                // Request an animation frame and call ourselves back immediately after.
                window.requestAnimationFrame(tryUpdateSize);
                return;
            }
            const rect = wrapper.firstElementChild.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            // Update size of the activity node.
            this.prop({ size: { width, height } });
            // Remove the temporary element (used only to calculate its size).
            wrapper.remove();
        };
        // Begin try to get our element size.
        tryUpdateSize();
    }
    createHtml() {
        const component = this.component;
        return `<elsa-default-activity-template
       class="activity elsa-inline-block elsa-rounded elsa-bg-white elsa-text-left elsa-text-black elsa-text-lg elsa-select-none elsa-max-w-md elsa-shadow-sm elsa-relative">
        ${component}</elsa-default-activity-template>`;
    }
}
ActivityNodeShape.config({
    ports: {
        items: [
            {
                group: 'out',
            },
            {
                group: 'in',
            },
        ],
        groups: {
            in: {
                position: 'dynamicIn',
                attrs: {
                    circle: {
                        r: 6,
                        magnet: true,
                        stroke: '#3c82f6',
                        strokeWidth: 2,
                        fill: '#fff',
                    },
                    text: {
                        fontSize: 12,
                        fill: '#888',
                    },
                },
                label: {
                    position: {
                        name: 'outside',
                    },
                },
            },
            out: {
                position: 'dynamicOut',
                attrs: {
                    circle: {
                        r: 6,
                        magnet: true,
                        stroke: '#fff',
                        strokeWidth: 2,
                        fill: '#3c82f6',
                    },
                    text: {
                        fontSize: 12,
                        fill: '#888',
                    },
                },
                label: {
                    position: {
                        name: 'outside',
                    },
                },
            },
        },
    },
    portMarkup: [
        {
            tagName: 'circle',
            selector: 'portBody',
        },
    ],
});
Graph.registerNode('activity', ActivityNodeShape, true);

let _cursorX = 0;
let _cursorY = 0;
addEventListener("mousemove", e => {
    _cursorX = e.clientX;
    _cursorY = e.clientY;
});
function createGraph(container, interacting, disableEvents, enableEvents, disableEdit = false) {
    const graph = new Graph({
        container: container,
        interacting: interacting,
        embedding: {
            enabled: false,
        },
        grid: {
            type: 'mesh',
            size: 20,
            visible: true,
            args: {
                color: '#e0e0e0'
            }
        },
        height: 5000,
        width: 5000,
        // Keep disabled for now until we find that performance degrades significantly when adding too many nodes.
        // When we do enable async rendering, we need to take care of the selection rectangle after pasting nodes, which would be calculated too early (before rendering completed).
        async: false,
        autoResize: true,
        keyboard: {
            enabled: true,
            global: false,
        },
        clipboard: {
            enabled: true,
            useLocalStorage: true,
        },
        selecting: {
            enabled: true,
            showNodeSelectionBox: false,
            rubberband: !disableEdit
        },
        scroller: {
            enabled: true,
            pannable: true,
            pageVisible: true,
            pageBreak: false,
            padding: 0,
            modifiers: ['ctrl', 'meta'],
        },
        connecting: {
            allowBlank: false,
            allowMulti: !disableEdit,
            allowLoop: !disableEdit,
            allowNode: !disableEdit,
            allowEdge: false,
            allowPort: !disableEdit,
            highlight: !disableEdit,
            router: {
                name: 'manhattan',
                args: {
                    padding: 10,
                    startDirections: ['right', 'bottom'],
                    endDirections: ['left'],
                },
            },
            //connector: 'elsa-connector',
            connector: {
                name: 'rounded',
                args: {
                    radius: 10
                },
            },
            snap: {
                radius: 10,
            },
            validateMagnet({ magnet }) {
                return magnet.getAttribute('port-group') !== 'in';
            },
            validateConnection({ sourceView, targetView, sourceMagnet, targetMagnet }) {
                // if (!sourceMagnet || sourceMagnet.getAttribute('port-group') === 'in') {
                //   return false
                // }
                if (!targetMagnet || targetMagnet.getAttribute('port-group') !== 'in') {
                    return false;
                }
                const portId = sourceMagnet.getAttribute('port');
                const node = sourceView.cell;
                const port = node.getPort(portId);
                return !(port && port.connected);
                // if (sourceView) {
                //   const node = sourceView.cell;
                //   if (node instanceof ActivityNodeShape) {
                //     const portId = targetMagnet.getAttribute('port');
                //     const usedOutPorts = node.getUsedOutPorts(graph);
                //     if (usedOutPorts.find((port) => port && port.id === portId)) {
                //       return false
                //     }
                //   }
                // }
                return true;
            },
            createEdge() {
                return graph.createEdge({
                    shape: 'elsa-edge',
                    zIndex: -1,
                });
            }
        },
        onPortRendered(args) {
        },
        highlighting: {
            magnetAdsorbed: {
                name: 'stroke',
                args: {
                    attrs: {
                        fill: '#5F95FF',
                        stroke: '#5F95FF',
                    },
                },
            },
        },
        mousewheel: {
            enabled: true,
            modifiers: ['ctrl', 'meta'],
            zoomAtMousePosition: true,
            minScale: 0.5,
            maxScale: 3,
        },
        history: {
            enabled: !disableEdit,
            beforeAddCommand: (e, args) => {
                if (args.key == 'tools')
                    return false;
                const supportedEvents = ['cell:added', 'cell:removed', 'cell:change:*', 'edge:change:*'];
                return supportedEvents.indexOf(e) >= 0;
            },
        },
    });
    addGraphEvents(graph, disableEvents, enableEvents, disableEdit);
    return graph;
}
;
function addGraphEvents(graph, disableEvents, enableEvents, disableEdit) {
    if (!disableEdit) {
        graph.on('node:mousedown', ({ node }) => {
            node.toFront();
        });
        graph.on('edge:mouseenter', ({ edge }) => {
            edge.addTools([
                'source-arrowhead',
                'target-arrowhead',
                {
                    name: 'button-remove',
                    args: {
                        distance: -30,
                    },
                },
            ]);
        });
        graph.on('edge:mouseleave', ({ edge }) => {
            edge.removeTools();
        });
        graph.on('edge:removed', ({ edge }) => {
        });
        function copyGraphCells(graph, cells) {
            if (cells.length) {
                graph.copy(cells);
            }
            const cellsJson = localStorage.getItem("x6.clipboard.cells");
            navigator.clipboard.writeText(cellsJson);
        }
        graph.bindKey(['meta+c', 'ctrl+c'], () => {
            const cells = graph.getSelectedCells();
            copyGraphCells(graph, cells);
            return false;
        });
        graph.bindKey(['meta+x', 'ctrl+x'], () => {
            const cells = graph.getSelectedCells();
            if (cells.length) {
                graph.cut(cells);
            }
            const cellsJson = localStorage.getItem("x6.clipboard.cells");
            navigator.clipboard.writeText(cellsJson);
            return false;
        });
        graph.bindKey(['meta+v', 'ctrl+v'], async () => {
            var cellsJson = await navigator.clipboard.readText();
            if (cellsJson) {
                disableEvents();
                let cells = [];
                try {
                    cells = Model.fromJSON(JSON.parse(cellsJson));
                    if (!(cells === null || cells === void 0 ? void 0 : cells.length)) {
                        console.log("No cells to paste");
                        return;
                    }
                    cells.forEach((cell) => {
                        cell.model = null;
                        cell.removeProp('zIndex');
                        cell.translate(0, 0);
                    });
                    graph.addCell(cells);
                    copyGraphCells(graph, cells); // So it would generate new cell ids to the cells in the clipboard
                    var activityIdsMap = cells.filter(x => !!x.activity).reduce(function (map, x) {
                        map[x.activity.activityId] = x.id;
                        return map;
                    }, {});
                    const nodePositions = cells.filter(x => !!x.activity).map(x => x.position({ relative: false }));
                    const minX = Math.min(...nodePositions.map(x => x.x));
                    const minY = Math.min(...nodePositions.map(x => x.y));
                    graph.disableHistory();
                    for (const cell of cells) {
                        if (cell.activity) {
                            cell.activity.activityId = cell.id;
                            // Move the cells where the cursor is located
                            const cellPosition = cell.position({ relative: false });
                            const point = graph.pageToLocal(_cursorX, _cursorY);
                            const newX = point.x + cellPosition.x - minX;
                            const newY = point.y + cellPosition.y - minY;
                            cell.position(newX, newY);
                            cell.activity.x = Math.round(newX);
                            cell.activity.y = Math.round(newY);
                        }
                        else if (cell.data) {
                            cell.data.sourceId = activityIdsMap[cell.data.sourceId] || cell.data.sourceId;
                            cell.data.targetId = activityIdsMap[cell.data.targetId] || cell.data.targetId;
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
                graph.enableHistory();
                await enableEvents(true);
                graph.cleanSelection();
                if (cells.length) {
                    graph.select(cells);
                }
            }
            return false;
        });
        //undo redo
        graph.bindKey(['meta+z', 'ctrl+z'], () => {
            if (graph.history.canUndo()) {
                graph.history.undo();
            }
            return false;
        });
        graph.bindKey(['meta+y', 'ctrl+y'], () => {
            if (graph.history.canRedo()) {
                graph.history.redo();
            }
            return false;
        });
        //delete
        graph.bindKey('del', () => {
            const cells = graph.getSelectedCells();
            if (cells.length) {
                graph.removeCells(cells);
            }
        });
    }
    // select all;
    graph.bindKey(['meta+a', 'ctrl+a'], () => {
        const nodes = graph.getNodes();
        if (nodes) {
            graph.select(nodes);
        }
    });
    // zoom
    graph.bindKey(['ctrl+1', 'meta+1'], () => {
        const zoom = graph.zoom();
        if (zoom < 1.5) {
            graph.zoom(0.1);
        }
    });
    graph.bindKey(['ctrl+2', 'meta+2'], () => {
        const zoom = graph.zoom();
        if (zoom > 0.5) {
            graph.zoom(-0.1);
        }
    });
}
function removeGraphEvents(graph) {
    graph.off('node:mousedown');
    graph.off('edge:mouseenter');
    graph.off('edge:mouseleave');
    graph.off('edge:removed');
    graph.unbindKey(['meta+c', 'ctrl+c']);
    graph.unbindKey(['meta+x', 'ctrl+x']);
    graph.unbindKey(['meta+v', 'ctrl+v']);
    graph.unbindKey(['meta+z', 'ctrl+z']);
    graph.unbindKey(['meta+y', 'ctrl+y']);
    graph.unbindKey('del');
    graph.unbindKey(['meta+a', 'ctrl+a']);
    graph.unbindKey(['ctrl+1', 'meta+1']);
    graph.unbindKey(['ctrl+2', 'meta+2']);
}
Graph.registerNode('activity', ActivityNodeShape, true);

var dagreExports = requireDagre();
var dagre = /*@__PURE__*/getDefaultExportFromCjs(dagreExports);

const x6DesignerCss = ":host{display:block}.workflow-canvas{background-color:#fbfbfb;width:100%;height:calc(100vh - 64px);box-sizing:border-box}.outcome{background-color:#fbfbfb}.start-btn{display:flex;top:1rem;width:100%;justify-content:center;pointer-events:none}.start-btn>*{pointer-events:initial}.layout-btn{display:flex;left:1rem;bottom:2rem}.elsa-workflow-wrapper{width:100%;height:calc(100vh - 64px);overflow:hidden}.workflow-canvas .x6-graph-scroller{position:relative;width:100% !important;height:100% !important}.x6-port-out .x6-port-label{opacity:0;transition:opacity 0.2s ease-in}.x6-port-out:hover .x6-port-label{opacity:1}.context-menu-button-container button{position:relative}.context-menu-button-container button:before{content:'';position:absolute;width:44px;height:44px;cursor:pointer}.x6-node-selected elsa-default-activity-template:after{content:'';width:calc(100% + 8px);height:calc(100% + 8px);top:-4px;left:-4px;position:absolute;border:2px dashed #feb663}";

const ElsaWorkflowDesigner = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.workflowChanged = createEvent(this, "workflow-changed", 7);
        this.activitySelected = createEvent(this, "activitySelected", 7);
        this.activityDeselected = createEvent(this, "activityDeselected", 7);
        this.activityContextMenuButtonClicked = createEvent(this, "activityContextMenuButtonClicked", 7);
        this.connectionContextMenuButtonClicked = createEvent(this, "connectionContextMenuButtonClicked", 7);
        this.activityContextMenuButtonTestClicked = createEvent(this, "activityContextMenuButtonTestClicked", 7);
        this.activityDeleted = createEvent(this, "activityDeleted", 7);
        this.addingActivity = false;
        this.selectedActivities = {};
        this.ignoreCopyPasteActivities = false;
        this.silent = false;
        this.ignoreNextNodeSelect = false;
        this.activityDisplayContexts = null;
        this.workflowSaveTimer = null;
        this.edgeUpdateTimer = null;
        this.model = {
            activities: [],
            connections: [],
            persistenceBehavior: WorkflowPersistenceBehavior.WorkflowBurst
        };
        this.selectedActivityIds = [];
        this.mode = WorkflowDesignerMode.Edit;
        this.layoutDirection = LayoutDirection.TopBottom;
        this.activityContextMenuState = {
            shown: false,
            x: 0,
            y: 0,
            activity: null,
            selectedActivities: {}
        };
        this.connectionContextMenuState = {
            shown: false,
            x: 0,
            y: 0,
            activity: null,
        };
        this.activityContextMenuTestState = {
            shown: false,
            x: 0,
            y: 0,
            activity: null,
        };
        this.createAndInitializeGraph = async () => {
            const graph = this.graph = createGraph(this.container, {}, this.disableEvents, this.enableEvents, this.mode !== WorkflowDesignerMode.Edit);
            graph.on('blank:click', this.onGraphClick);
            graph.on('node:selected', this.onNodeSelected);
            graph.on('node:unselected', this.onNodeUnselected);
            graph.on('node:contextmenu', this.onNodeContextMenu);
            graph.on('edge:connected', this.onEdgeConnected);
            graph.on('node:moved', this.onNodeMoved);
            graph.on('node:removed', this.updateModelFromGraph);
            graph.on('node:change:*', this.updateModelFromGraph);
            graph.on('node:added', this.updateModelFromGraph);
            graph.on('edge:added', this.updateModelFromGraph);
            graph.on('edge:removed', this.updateModelFromGraph);
            graph.on('edge:connected', this.updateModelFromGraph);
            await this.updateLayout();
        };
        this.disableEvents = () => this.silent = true;
        this.enableEvents = (emitWorkflowChanged) => {
            this.silent = false;
            if (emitWorkflowChanged === true) {
                this.updateModelFromGraph();
            }
        };
        this.getOutcomes = (activity, definition) => {
            let outcomes = [];
            const displayContext = this.activityDisplayContexts[activity.activityId];
            if (!!definition) {
                const lambda = displayContext.outcomes || definition.outcomes;
                if (lambda instanceof Array) {
                    outcomes = lambda;
                }
                else {
                    const value = eval(lambda);
                    if (value instanceof Array)
                        outcomes = value;
                    else if (value instanceof Function) {
                        try {
                            outcomes = value({ activity, definition, state: activity.state });
                        }
                        catch (e) {
                            console.warn(e);
                            outcomes = [];
                        }
                    }
                }
            }
            return !!outcomes ? outcomes : [];
        };
        this.onNodeMoved = async (e) => {
            const node = e.node;
            const activity = node.activity;
            const nodePosition = node.position({ relative: false });
            activity.x = Math.round(nodePosition.x);
            activity.y = Math.round(nodePosition.y);
            if (node.id !== activity.activityId)
                activity.activityId = node.id;
            this.updateActivityInternal(activity);
        };
        this.onNodeSelected = async (e) => {
            if (this.ignoreNextNodeSelect) {
                this.ignoreNextNodeSelect = false;
                return;
            }
            const node = e.node;
            const activity = node.activity;
            this.selectedActivities[activity.activityId] = activity;
            this.activitySelected.emit(activity);
        };
        this.onNodeUnselected = async (e) => {
            const node = e.node;
            const activity = node.activity;
            if (!!this.selectedActivities[activity.activityId]) {
                this.activityDeselected.emit(this.selectedActivities[activity.activityId]);
                delete this.selectedActivities[activity.activityId];
            }
        };
        this.onNodeContextMenu = (e) => {
            e.e.preventDefault();
            const node = e.node;
            if (this.mode == WorkflowDesignerMode.Edit || this.mode == WorkflowDesignerMode.Instance) {
                this.handleContextMenuChange({
                    x: e.e.clientX,
                    y: e.e.clientY,
                    shown: true,
                    activity: node.activity,
                    selectedActivities: this.selectedActivities
                });
            }
        };
        this.onGraphClick = async () => {
            for (const key in this.selectedActivities) {
                this.activityDeselected.emit(this.selectedActivities[key]);
            }
            this.selectedActivities = {};
        };
        this.onEdgeConnected = async (e) => {
            const edge = e.edge;
            let workflowModel = Object.assign({}, this.workflowModel);
            const sourceNode = edge.getSourceNode();
            const targetId = edge.getTargetCellId();
            const sourcePort = edge.getSourcePortId();
            edge.data = this.addConnection(sourceNode.id, targetId, sourcePort);
            if (!this.enableMultipleConnectionsFromSingleSource) {
                const existingConnection = workflowModel.connections.find(x => x.sourceId === sourceNode.id && x.targetId == targetId);
                if (!existingConnection) {
                    // Add created connection to list.
                    const newConnection = {
                        sourceId: sourceNode.id,
                        targetId: targetId,
                        outcome: sourcePort
                    };
                    edge.data = newConnection;
                    edge.insertLabel(sourcePort);
                    workflowModel.connections = [...workflowModel.connections, newConnection];
                    this.updateWorkflowModel(workflowModel);
                }
            }
        };
        this.createGraphNode = (item) => {
            const desciptors = state.activityDescriptors;
            const descriptor = desciptors.find(x => x.type == item.type);
            const outcomes = this.mode === WorkflowDesignerMode.Blueprint ? item.outcomes : this.getOutcomes(item, descriptor);
            let ports = [{ group: 'in', id: v4(), attrs: {} }];
            outcomes.forEach(outcome => ports.push({
                id: outcome,
                group: 'out',
                attrs: {
                    text: {
                        text: outcome
                    }
                }
            }));
            const node = {
                id: item.activityId,
                shape: 'activity',
                x: item.x || 0,
                y: item.y || 0,
                type: item.type,
                activity: item,
                ports: {
                    items: ports
                },
                component: this.renderActivity(item)
            };
            return node;
        };
        this.getEdgeStep = (sourceId, targetId) => {
            // The purpose of this function is to prevent connections from overlapping because of their target nodes being on the same height
            const targetNode = this.workflowModel.activities.find(x => x.activityId === targetId);
            const siblingEdges = this.workflowModel.connections.filter(x => x.sourceId === sourceId);
            const siblingActivities = siblingEdges.map(x => this.workflowModel.activities.find(a => a.activityId === x.targetId)).filter(x => !!x);
            let xStep = 10;
            let yStep = 10;
            if (targetNode) {
                const sameYNodes = siblingActivities
                    .filter(x => Math.abs(x.y - targetNode.y) < 20)
                    .sort((a, b) => a.x > b.x ? 1 : -1);
                const sameXNodes = siblingActivities
                    .filter(x => Math.abs(x.x - targetNode.x) < 20)
                    .sort((a, b) => a.y > b.y ? 1 : -1);
                if (sameYNodes.length > 1) {
                    yStep += sameYNodes.findIndex(x => x.activityId == targetNode.activityId) * 32;
                }
                if (sameXNodes.length > 1) {
                    xStep += sameXNodes.findIndex(x => x.activityId == targetNode.activityId) * 32;
                }
            }
            return Math.max(xStep, yStep);
        };
        this.createEdge = (connection) => {
            return {
                shape: 'elsa-edge',
                zIndex: -1,
                data: connection,
                source: connection.sourceId,
                sourcePort: connection.outcome,
                target: connection.targetId,
                targetPort: connection.targetPort,
                outcome: connection.outcome,
                router: this.createEdgeRouter(connection.sourceId, connection.targetId),
                labels: [{
                        attrs: {
                            label: { text: connection.outcome }
                        },
                    }],
            };
        };
        this.createEdgeRouter = (sourceId, targetId) => {
            const sourceNode = this.activityDisplayContexts[sourceId];
            return {
                name: 'manhattan',
                args: {
                    padding: 10,
                    step: this.getEdgeStep(sourceId, targetId),
                    startDirections: ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.outcomes.length) > 3) ? ['bottom'] : ['right'],
                    endDirections: ['left']
                },
            };
        };
        this.updateModelFromGraph = (e) => {
            if (this.silent) {
                return;
            }
            this.updateGraphEdgeViews();
            const graph = this.graph;
            const graphModel = graph.toJSON();
            const activities = graphModel.cells.filter(x => x.shape == 'activity').map(x => x.activity);
            const connections = graphModel.cells
                .map(x => ((e === null || e === void 0 ? void 0 : e.edge) && e.edge.data && x.id == e.edge.id) ? this.createEdge(e.edge.data) : x)
                .filter(x => x.shape == 'elsa-edge' && !!x.data).map(x => x.data);
            const workflowModel = {
                activities,
                connections,
                persistenceBehavior: WorkflowPersistenceBehavior.WorkflowBurst
            };
            this.updateWorkflowModel(workflowModel);
        };
        this.updateGraphEdgeViews = () => {
            // This updates the connection routing between nodes, when one node gets moved for example
            this.disableEvents();
            if (this.edgeUpdateTimer) {
                clearTimeout(this.edgeUpdateTimer);
            }
            this.edgeUpdateTimer = setTimeout(() => {
                this.edgeUpdateTimer = null;
                this.graph.disableHistory();
                const edges = this.graph.getCells().filter(x => x.shape == 'elsa-edge');
                for (const edge of edges) {
                    edge.router = this.createEdgeRouter(edge.source.cell, edge.target.cell);
                    this.graph.findViewByCell(edge.id).update();
                }
                this.graph.enableHistory();
            }, 10);
            this.enableEvents(false);
        };
        this.updateGraph = async () => {
            const activities = this.workflowModel.activities;
            const connections = this.workflowModel.connections;
            const edges = [];
            for (const model of activities)
                this.activityDisplayContexts[model.activityId] = await this.getActivityDisplayContext(model);
            // Create an X6 node for each activity.
            const nodes = activities.map(activity => this.createGraphNode(activity));
            // Create X6 edges for each connection in the flowchart.
            for (const connection of connections) {
                const edge = this.createEdge(connection);
                edges.push(edge);
            }
            const model = { nodes, edges };
            // Freeze then unfreeze prevents an error from occurring when importing JSON a second time (e.g. after loading a new workflow.
            this.graph.freeze();
            this.graph.fromJSON(model, { silent: false });
            this.graph.unfreeze();
        };
        this.findActivityById = (id) => this.workflowModel.activities.find(x => x.activityId === id);
        this.onWorkflowImported = args => {
            this.workflowModel = args;
            this.updateGraph();
            if (this.isAutoLayoutRequired) {
                setTimeout(() => {
                    this.applyAutoLayout();
                }, 1);
            }
            this.graph.scrollToContent();
        };
        this.onActivityPicked = async (args) => {
            const activityDescriptor = args;
            const activityModel = this.newActivity(activityDescriptor);
            const connectFromRoot = !this.parentActivityOutcome || this.parentActivityOutcome == '';
            const sourceId = connectFromRoot ? null : this.parentActivityId;
            const targetId = connectFromRoot ? this.parentActivityId : null;
            this.addActivity(activityModel, sourceId, targetId, this.parentActivityOutcome);
        };
        this.onUpdateActivityExternal = args => {
            const activityModel = args;
            if (this.addingActivity) {
                console.debug(`adding activity with ID ${activityModel.activityId}`);
                const connectFromRoot = !this.parentActivityOutcome || this.parentActivityOutcome == '';
                const sourceId = connectFromRoot ? null : this.parentActivityId;
                const targetId = connectFromRoot ? this.parentActivityId : null;
                this.addActivity(activityModel, sourceId, targetId, this.parentActivityOutcome);
                this.addingActivity = false;
            }
            else {
                console.debug(`updating activity with ID ${activityModel.activityId}`);
                this.updateActivityExternal(activityModel);
            }
        };
    }
    handleActivityContextMenuChanged(newValue) {
        this.activityContextMenuState = newValue;
    }
    handleConnectionContextMenuChanged(newValue) {
        this.connectionContextMenuState = newValue;
    }
    handleActivityContextMenuTestChanged(newValue) {
        this.activityContextMenuTestState = newValue;
    }
    handleActivityContextMenuButtonChanged(newValue) {
        if (this.mode !== WorkflowDesignerMode.Edit) {
            this.graph.resetSelection();
            this.graph.disableRubberband();
            this.graph.disableHistory();
            removeGraphEvents(this.graph);
        }
        else {
            this.graph.enableRubberband();
            this.graph.enableHistory();
            addGraphEvents(this.graph, this.disableEvents, this.enableEvents, false);
        }
        setTimeout(() => this.updateGraph(), 1);
    }
    handleModelChanged(newValue) {
        if (this.model !== newValue) {
            this.updateWorkflowModel(newValue, false);
            setTimeout(() => this.updateGraph(), 1);
        }
    }
    async removeActivity(activity) {
        const cell = this.graph.getCells().find(x => x.id === activity.activityId);
        if (cell) {
            this.graph.removeCell(cell);
        }
    }
    async removeSelectedActivities() {
        const cells = this.graph.getCells().filter(x => this.selectedActivityIds.includes(x.id));
        this.graph.removeCells(cells);
    }
    async showActivityEditor(activity, animate) {
        await this.showActivityEditorInternal(activity, animate);
    }
    async updateLayout() {
        const width = this.el.clientWidth;
        const height = this.el.clientHeight;
        this.graph.resize(width, height);
        this.graph.updateBackground();
    }
    async componentDidLoad() {
        await this.createAndInitializeGraph();
        // Below fixes issues, that arise when navigating from another page to this one - the graph not being fully loaded in the DOM at the correct time
        const containerObserver = new ResizeObserver(() => {
            if (this.container.clientHeight > 0) {
                this.onContainerLoaded();
                containerObserver.unobserve(this.container);
            }
        });
        containerObserver.observe(this.container);
    }
    onContainerLoaded() {
        if (this.isAutoLayoutRequired) {
            setTimeout(() => this.applyAutoLayout(), 100);
        }
        this.updateGraph();
        if (this.workflowModel.activities.length) {
            setTimeout(() => this.graph.scrollToContent(), 10);
        }
    }
    applyAutoLayout() {
        const graph = new dagre.graphlib.Graph();
        graph.setGraph({ rankdir: "TB", nodesep: 30, ranksep: 180 });
        graph.setDefaultEdgeLabel(() => ({}));
        this.workflowModel.activities.forEach(activity => {
            const activityElement = document.querySelectorAll("g[data-cell-id=\"" + activity.activityId + "\"]")[0].getBoundingClientRect();
            graph.setNode(activity.activityId, {
                label: activity.activityId,
                width: Math.max(220, activityElement.width),
                height: Math.max(64, activityElement.height)
            });
        });
        this.workflowModel.connections.forEach(connection => {
            graph.setEdge(connection.sourceId, connection.targetId);
        });
        dagre.layout(graph);
        this.disableEvents();
        this.graph.batchUpdate(() => {
            this.workflowModel.activities.forEach(activity => {
                const node = graph.node(activity.activityId);
                const cell = this.graph.getCellById(activity.activityId);
                cell.setProp('position', { x: node.x, y: node.y });
                activity.x = Math.round(node.x);
                activity.y = Math.round(node.y);
                cell.activity = activity;
            });
        });
        this.graph.scrollToContent();
        this.enableEvents(true);
        setTimeout(() => this.updateGraphEdgeViews(), 100);
        console.log("Auto-layout applied");
    }
    ;
    connectedCallback() {
        eventBus.on(EventTypes.WorkflowImported, this.onWorkflowImported);
        eventBus.on(EventTypes.ActivityPicked, this.onActivityPicked);
        eventBus.on(EventTypes.UpdateActivity, this.onUpdateActivityExternal);
        //eventBus.on(EventTypes.PasteActivity, this.onPasteActivity);
        // eventBus.on(EventTypes.HideModalDialog, this.onCopyPasteActivityEnabled);
        // eventBus.on(EventTypes.ShowWorkflowSettings, this.onCopyPasteActivityDisabled);
        eventBus.on(EventTypes.TestActivityMessageReceived, this.updateGraph);
    }
    disconnectedCallback() {
        eventBus.detach(EventTypes.WorkflowImported, this.onWorkflowImported);
        eventBus.detach(EventTypes.ActivityPicked, this.onActivityPicked);
        eventBus.detach(EventTypes.UpdateActivity, this.onUpdateActivityExternal);
        //eventBus.detach(EventTypes.PasteActivity, this.onPasteActivity);
        // eventBus.detach(EventTypes.HideModalDialog, this.onCopyPasteActivityEnabled);
        // eventBus.detach(EventTypes.ShowWorkflowSettings, this.onCopyPasteActivityDisabled);
        eventBus.detach(EventTypes.TestActivityMessageReceived, this.updateGraph);
    }
    componentWillLoad() {
        this.workflowModel = this.model;
    }
    async componentWillRender() {
        if (!!this.activityDisplayContexts)
            return;
        const activityModels = this.workflowModel.activities;
        const displayContexts = {};
        for (const model of activityModels)
            displayContexts[model.activityId] = await this.getActivityDisplayContext(model);
        this.activityDisplayContexts = displayContexts;
    }
    get isAutoLayoutRequired() {
        if (this.workflowModel.activities.length < 2) {
            return false;
        }
        return this.workflowModel.activities.findIndex(x => !!x.x || !!x.y) === -1;
    }
    handleContextMenuChange(state) {
        this.ignoreCopyPasteActivities = true;
        this.activityContextMenuState = state;
        this.activityContextMenuButtonClicked.emit(state);
    }
    handleConnectionContextMenuChange(state) {
        this.connectionContextMenuState = state;
        this.connectionContextMenuButtonClicked.emit(state);
    }
    handleContextMenuTestChange(state) {
        this.ignoreCopyPasteActivities = true;
        this.activityContextMenuTestState = state;
        this.activityContextMenuButtonTestClicked.emit(state);
    }
    async onAddActivity(e) {
        e.preventDefault();
        if (this.mode !== WorkflowDesignerMode.Test)
            await this.showActivityPicker();
    }
    async getActivityDisplayContext(activityModel) {
        const activityDescriptors = state.activityDescriptors;
        let descriptor = activityDescriptors.find(x => x.type == activityModel.type);
        if (!descriptor)
            descriptor = this.createNotFoundActivityDescriptor(activityModel);
        const displayContext = {
            activityModel: activityModel,
            activityDescriptor: descriptor,
            outcomes: [...activityModel.outcomes]
        };
        await eventBus.emit(EventTypes.ActivityDesignDisplaying, this, displayContext);
        //Remove duplicates
        displayContext.outcomes = displayContext.outcomes.filter(function (item, pos) {
            return displayContext.outcomes.indexOf(item) == pos;
        });
        return displayContext;
    }
    createNotFoundActivityDescriptor(activityModel) {
        return {
            outcomes: ['Done'],
            inputProperties: [],
            type: `(Not Found) ${activityModel.type}`,
            outputProperties: [],
            displayName: `(Not Found) ${activityModel.displayName || activityModel.name || activityModel.type}`,
            traits: ActivityTraits.Action,
            description: `(Not Found) ${activityModel.description}`,
            category: 'Not Found',
            browsable: false,
            customAttributes: {}
        };
    }
    async showActivityEditorInternal(activity, animate) {
        await eventBus.emit(EventTypes.ActivityEditor.Show, this, activity, animate);
    }
    updateWorkflowModel(model, emitEvent = true) {
        if (emitEvent && this.mode !== WorkflowDesignerMode.Edit) {
            this.updateGraph();
            return;
        }
        this.workflowModel = model;
        if (emitEvent) {
            //Debounce the emitting of change event and saving of workflow
            if (this.workflowSaveTimer) {
                clearTimeout(this.workflowSaveTimer);
            }
            this.workflowSaveTimer = setTimeout(() => {
                this.workflowChanged.emit(this.workflowModel);
            }, 200);
        }
    }
    removeActivityInternal(activity, model) {
        let workflowModel = model || Object.assign({}, this.workflowModel);
        const incomingConnections = getInboundConnections(workflowModel, activity.activityId);
        const outgoingConnections = getOutboundConnections(workflowModel, activity.activityId);
        // Remove activity (will also remove its connections).
        workflowModel = removeActivity(workflowModel, activity.activityId);
        // For each incoming activity, try to connect it to an outgoing activity based on outcome.
        if (outgoingConnections.length > 0 && incomingConnections.length > 0) {
            for (const incomingConnection of incomingConnections) {
                const incomingActivity = findActivity(workflowModel, incomingConnection.sourceId);
                let outgoingConnection = outgoingConnections.find(x => x.outcome === incomingConnection.outcome);
                // If not matching outcome was found, pick the first one. The user will have to manually reconnect to the desired outcome.
                if (!outgoingConnection)
                    outgoingConnection = outgoingConnections[0];
                if (!!outgoingConnection)
                    workflowModel = addConnection(workflowModel, {
                        sourceId: incomingActivity.activityId,
                        targetId: outgoingConnection.targetId,
                        outcome: incomingConnection.outcome
                    });
            }
        }
        delete this.selectedActivities[activity.activityId];
        if (!model) {
            this.updateWorkflowModel(workflowModel);
        }
        return workflowModel;
    }
    newActivity(activityDescriptor) {
        const graphRect = this.el.getBoundingClientRect();
        const point = this.graph.pageToLocal(graphRect.left + 64, graphRect.top + 64);
        const activity = {
            activityId: v4(),
            type: activityDescriptor.type,
            outcomes: activityDescriptor.outcomes,
            displayName: activityDescriptor.displayName,
            properties: [],
            propertyStorageProviders: {},
            x: Math.round(point.x),
            y: Math.round(point.y)
        };
        for (const property of activityDescriptor.inputProperties) {
            activity.properties[property.name] = {
                syntax: '',
                expression: '',
            };
        }
        return activity;
    }
    async addActivity(activity, sourceActivityId, targetActivityId, outcome) {
        outcome = outcome || 'Done';
        const workflowModel = Object.assign(Object.assign({}, this.workflowModel), { activities: [...this.workflowModel.activities, activity] });
        if (targetActivityId) {
            const existingConnection = workflowModel.connections.find(x => x.targetId == targetActivityId && x.outcome == outcome);
            if (existingConnection) {
                workflowModel.connections = workflowModel.connections.filter(x => x != existingConnection);
                const replacementConnection = Object.assign(Object.assign({}, existingConnection), { sourceId: activity.activityId });
                workflowModel.connections.push(replacementConnection);
            }
            else {
                workflowModel.connections.push({ sourceId: activity.activityId, targetId: targetActivityId, outcome: outcome });
            }
        }
        if (sourceActivityId != null) {
            const existingConnection = workflowModel.connections.find(x => x.sourceId == sourceActivityId && x.outcome == outcome);
            if (existingConnection != null) {
                // Remove the existing connection
                workflowModel.connections = workflowModel.connections.filter(x => x != existingConnection);
                // Create a new outbound connection between the source and the added activity.
                const newOutboundConnection = {
                    sourceId: existingConnection.sourceId,
                    targetId: activity.activityId,
                    outcome: existingConnection.outcome
                };
                workflowModel.connections.push(newOutboundConnection);
                // Create a new outbound activity between the added activity and the target of the source activity.
                const connection = {
                    sourceId: activity.activityId,
                    targetId: existingConnection.targetId,
                    outcome: activity.outcomes[0]
                };
                workflowModel.connections.push(connection);
            }
            else {
                const connection = {
                    sourceId: sourceActivityId,
                    targetId: activity.activityId,
                    outcome: outcome
                };
                workflowModel.connections.push(connection);
            }
        }
        this.activityDisplayContexts[activity.activityId] = await this.getActivityDisplayContext(activity);
        this.updateWorkflowModel(workflowModel);
        var newNode = this.createGraphNode(activity);
        this.graph.addNode(newNode, { merge: true });
        this.parentActivityId = null;
        this.parentActivityOutcome = null;
        this.selectActivityNode(activity);
    }
    selectActivityNode(activity) {
        this.graph.resetSelection();
        const newCell = this.graph.getCells().find(x => x.id === activity.activityId);
        this.graph.select(newCell);
        for (const key in this.selectedActivities) {
            this.activityDeselected.emit(this.selectedActivities[key]);
        }
        this.selectedActivities = {};
        this.selectedActivities[activity.activityId] = activity;
        this.activitySelected.emit(activity);
        this.handleContextMenuChange({
            x: activity.x,
            y: activity.y,
            shown: true,
            activity: activity,
            selectedActivities: this.selectedActivities
        });
    }
    addConnection(sourceActivityId, targetActivityId, outcome) {
        const workflowModel = Object.assign({}, this.workflowModel);
        const newConnection = {
            sourceId: sourceActivityId,
            targetId: targetActivityId,
            outcome: outcome
        };
        let connections = workflowModel.connections;
        if (!this.enableMultipleConnectionsFromSingleSource)
            connections = [...workflowModel.connections.filter(x => !(x.sourceId === sourceActivityId && x.outcome === outcome))];
        workflowModel.connections = [...connections, newConnection];
        this.updateWorkflowModel(workflowModel);
        this.parentActivityId = null;
        this.parentActivityOutcome = null;
        return newConnection;
    }
    updateActivityInternal(activity) {
        let workflowModel = Object.assign({}, this.workflowModel);
        const activities = [...workflowModel.activities];
        const index = activities.findIndex(x => x.activityId === activity.activityId);
        activities[index] = activity;
        this.updateWorkflowModel(Object.assign(Object.assign({}, workflowModel), { activities: activities }));
    }
    async updateActivityExternal(activity) {
        var originalActivity = this.findActivityById(activity.activityId);
        // Do not allow external updates to change activity position, because position can only be changed internally by the graph
        activity.x = originalActivity.x;
        activity.y = originalActivity.y;
        this.graph.cleanHistory();
        this.updateActivityInternal(activity);
        this.updateGraph();
    }
    async showActivityPicker() {
        await eventBus.emit(EventTypes.ShowActivityPicker);
    }
    handleActivityStatsClick(activity) {
        if (this.mode === WorkflowDesignerMode.Test) {
            setTimeout(() => {
                const nodeEl = this.container.querySelectorAll(`div[stats-activity-id="${activity.activityId}"] button`)[0];
                nodeEl === null || nodeEl === void 0 ? void 0 : nodeEl.addEventListener("click", (evt) => {
                    this.ignoreNextNodeSelect = true;
                    evt.stopPropagation();
                    this.activityContextMenuButtonTestClicked.emit({ x: evt.clientX, y: evt.clientY, shown: true, activity: activity });
                });
            }, 1);
        }
        if (this.mode === WorkflowDesignerMode.Instance) {
            setTimeout(() => {
                const nodeEl = this.container.querySelectorAll(`div[stats-activity-id="${activity.activityId}"] button`)[0];
                nodeEl === null || nodeEl === void 0 ? void 0 : nodeEl.addEventListener("click", (evt) => {
                    this.ignoreNextNodeSelect = true;
                    evt.stopPropagation();
                    this.handleContextMenuChange({
                        x: evt.clientX,
                        y: evt.clientY,
                        shown: true,
                        activity: activity,
                        selectedActivities: this.selectedActivities
                    });
                });
            }, 1);
        }
    }
    renderActivity(activity) {
        const activityBorderColor = !!this.activityBorderColor ? this.activityBorderColor(activity) : 'gray';
        const selectedColor = !!this.activityBorderColor ? activityBorderColor : 'blue';
        const cssClass = `elsa-border-${activityBorderColor}-200 hover:elsa-border-${selectedColor}-600`;
        const typeName = activity.type;
        let activityContextMenuButton = !!this.activityContextMenuButton ? this.activityContextMenuButton(activity) : '';
        const activityDescriptors = state.activityDescriptors;
        let descriptor = activityDescriptors.find(x => x.type == activity.type);
        if (!descriptor) {
            descriptor = this.createNotFoundActivityDescriptor(activity);
        }
        const displayName = !!descriptor ? activity.displayName : `(Not Found) ${activity.displayName}`;
        const color = (descriptor.traits &= ActivityTraits.Trigger) == ActivityTraits.Trigger ? 'rose' : 'sky';
        const activityIcon = h(ActivityIcon, { color: color });
        this.handleActivityStatsClick(activity);
        return `<div class="elsa-border-2 elsa-border-solid ${cssClass}">
      <div class="elsa-p-2" style="padding-right: 2.6rem">
        <div class="elsa-flex elsa-justify-between elsa-space-x-4 mr-4">
          <div class="elsa-flex-shrink-0">
            ${activityIcon}
          </div>
          <div class="elsa-flex-1 elsa-font-medium elsa-leading-8 elsa-overflow-hidden">
            <p class="elsa-overflow-ellipsis elsa-text-base">${displayName}</p>
            ${typeName !== displayName ? `<p class="elsa-text-gray-400 elsa-text-sm">${typeName}</p>` : ''}
          </div>
          <div class="context-menu-button-container elsa-absolute elsa-z-1" stats-activity-id="${activity.activityId}" style="right: 0.5rem">
            ${activityContextMenuButton}
          </div>
        </div>
      </div>
    </div>`;
    }
    render() {
        return (h(Host, { key: '1ae1fc65eefd61aa968a644dde32c82aa79507e3' }, h("div", { key: 'a9d57bc70d683c503560483779078ee003dfd769', class: "workflow-canvas elsa-flex-1 elsa-flex" }, h("div", { key: '66281685bf2cb3aa71ac9be29872db0a79cd9f44', ref: el => (this.container = el) })), this.mode == WorkflowDesignerMode.Edit &&
            h("div", { key: '292315e6d168db4082bd26eddae96f9903b5635d', class: "start-btn elsa-absolute elsa-z-1" }, h("button", { key: '434433ef31ed73c7b23e5a2ffe75201a5f644215', type: "button", onClick: e => this.onAddActivity(e), class: "elsa-h-12 elsa-px-6 elsa-mx-3 elsa-border elsa-border-transparent elsa-text-base elsa-font-medium elsa-rounded-md elsa-text-white elsa-bg-green-600 hover:elsa-bg-green-500 focus:elsa-outline-none focus:elsa-border-green-700 focus:elsa-shadow-outline-green active:elsa-bg-green-700 elsa-transition elsa-ease-in-out elsa-duration-150 elsa-top-8" }, "Add activity")), this.mode !== WorkflowDesignerMode.Test &&
            h("div", { key: 'ec06d70aab226b03f48b4bdcc4b052258eb1fe17', class: "layout-btn elsa-absolute elsa-z-1" }, h("button", { key: 'd95b22b2503fec2b437bdcb07e5a8a296f49ec20', type: "button", onClick: e => this.applyAutoLayout(), class: "elsa-h-12 elsa-px-6 elsa-mx-3 elsa-border elsa-border-transparent elsa-text-base elsa-font-medium elsa-rounded-md elsa-text-white elsa-bg-yellow-600 hover:elsa-bg-yellow-500 focus:elsa-outline-none focus:elsa-border-yellow-50 focus:elsa-shadow-outline-green active:elsa-bg-yellow-500 elsa-transition elsa-ease-in-out elsa-duration-150 elsa-top-8" }, "Auto-layout")), this.mode == WorkflowDesignerMode.Test ?
            h("div", null, h("div", { id: "left", style: { border: `4px solid orange`, position: `absolute`, height: `calc(100vh - 64px)`, width: `4px`, top: `0`, bottom: `0`, left: `0` } }), h("div", { id: "right", style: { border: `4px solid orange`, position: `absolute`, height: `calc(100vh - 64px)`, width: `4px`, top: `0`, bottom: `0`, right: `0` } }), h("div", { id: "top", style: { border: `4px solid orange`, position: `absolute`, height: `4px`, left: `0`, right: `0`, top: `0` } }), h("div", { id: "bottom", style: { border: `4px solid orange`, position: `absolute`, height: `4px`, left: `0`, right: `0`, bottom: `0` } }))
            :
                undefined));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "activityContextMenu": ["handleActivityContextMenuChanged"],
        "connectionContextMenu": ["handleConnectionContextMenuChanged"],
        "activityContextTestMenu": ["handleActivityContextMenuTestChanged"],
        "mode": ["handleActivityContextMenuButtonChanged"],
        "model": ["handleModelChanged"]
    }; }
};
ElsaWorkflowDesigner.style = x6DesignerCss;

export { ElsaWorkflowDesigner as x6_designer };
//# sourceMappingURL=x6-designer.entry.esm.js.map
